<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="Shaocheng.Li"><meta name=description content="1. sysconfig() sysconfig() 是获取系统运行时配置信息的函数，包括内存、CPU 等。函数声明：
#include &amp;lt;unistd.h&amp;gt;long sysconf(int name); 参数 name 用于指示要获取的信息，通过返回值将结果返回。新建一个 test.c ，获取当前系统的信息：
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;unistd.h&amp;gt; #define ONE_MB (1024 * 1024)  int main() { printf(&amp;#34;The number of processors configured is :%ld\n&amp;#34;, sysconf(_SC_NPROCESSORS_CONF)); printf(&amp;#34;The number of processors currently online (available) is :%ld\n&amp;#34;, sysconf(_SC_NPROCESSORS_ONLN)); printf(&amp;#34;The pagesize: %ld\n&amp;#34;, sysconf(_SC_PAGESIZE)); printf(&amp;#34;The number of pages: %ld\n&amp;#34;, sysconf(_SC_PHYS_PAGES)); printf(&amp;#34;The number of available pages: %ld\n&amp;#34;, sysconf(_SC_AVPHYS_PAGES)); printf(&amp;#34;The memory size: %lld MB\n&amp;#34;, (long long)sysconf(_SC_PAGESIZE) * (long long)sysconf(_SC_PHYS_PAGES) / ONE_MB ); printf(&amp;#34;The number of files max opened:: %ld\n&amp;#34;, sysconf(_SC_OPEN_MAX)); printf(&amp;#34;The number of ticks per second: %ld\n&amp;#34;, sysconf(_SC_CLK_TCK)); printf(&amp;#34;The max length of host name: %ld\n&amp;#34;, sysconf(_SC_HOST_NAME_MAX)); printf(&amp;#34;The max length of login name: %ld\n&amp;#34;, sysconf(_SC_LOGIN_NAME_MAX)); return 0; } 编译后执行："><meta name=keywords content><meta name=robots content="noodp"><meta name=theme-color content="#252627"><link rel=canonical href=https://shaocheng.li/posts/2017/12/14/><title>Linux Program Tips :: Shaocheng.Li — Hello Friends</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=https://shaocheng.li/main.min.e9b3dfcc5ffe9d55eb281ecaf47cf6179d26eec497e087299934d581c987aa0b.css><link rel=stylesheet type=text/css href=https://shaocheng.li/css/custom.css><link rel=apple-touch-icon sizes=180x180 href=https://shaocheng.li/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://shaocheng.li/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://shaocheng.li/favicon-16x16.png><link rel=manifest href=https://shaocheng.li/site.webmanifest><link rel=mask-icon href=https://shaocheng.li/safari-pinned-tab.svg color=#252627><link rel="shortcut icon" href=https://shaocheng.li/favicon.ico><meta name=msapplication-TileColor content="#252627"><meta name=theme-color content="#252627"><meta itemprop=name content="Linux Program Tips"><meta itemprop=description content="1. sysconfig() sysconfig() 是获取系统运行时配置信息的函数，包括内存、CPU 等。函数声明：
#include &lt;unistd.h&gt;long sysconf(int name); 参数 name 用于指示要获取的信息，通过返回值将结果返回。新建一个 test.c ，获取当前系统的信息：
#include &lt;stdio.h&gt;#include &lt;unistd.h&gt; #define ONE_MB (1024 * 1024)  int main() { printf(&#34;The number of processors configured is :%ld\n&#34;, sysconf(_SC_NPROCESSORS_CONF)); printf(&#34;The number of processors currently online (available) is :%ld\n&#34;, sysconf(_SC_NPROCESSORS_ONLN)); printf(&#34;The pagesize: %ld\n&#34;, sysconf(_SC_PAGESIZE)); printf(&#34;The number of pages: %ld\n&#34;, sysconf(_SC_PHYS_PAGES)); printf(&#34;The number of available pages: %ld\n&#34;, sysconf(_SC_AVPHYS_PAGES)); printf(&#34;The memory size: %lld MB\n&#34;, (long long)sysconf(_SC_PAGESIZE) * (long long)sysconf(_SC_PHYS_PAGES) / ONE_MB ); printf(&#34;The number of files max opened:: %ld\n&#34;, sysconf(_SC_OPEN_MAX)); printf(&#34;The number of ticks per second: %ld\n&#34;, sysconf(_SC_CLK_TCK)); printf(&#34;The max length of host name: %ld\n&#34;, sysconf(_SC_HOST_NAME_MAX)); printf(&#34;The max length of login name: %ld\n&#34;, sysconf(_SC_LOGIN_NAME_MAX)); return 0; } 编译后执行："><meta itemprop=datePublished content="2017-12-14T08:00:00&#43;08:00"><meta itemprop=dateModified content="2017-12-14T08:00:00&#43;08:00"><meta itemprop=wordCount content="927"><meta itemprop=keywords content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://shaocheng.li"><meta name=twitter:title content="Linux Program Tips"><meta name=twitter:description content="1. sysconfig() sysconfig() 是获取系统运行时配置信息的函数，包括内存、CPU 等。函数声明：
#include &lt;unistd.h&gt;long sysconf(int name); 参数 name 用于指示要获取的信息，通过返回值将结果返回。新建一个 test.c ，获取当前系统的信息：
#include &lt;stdio.h&gt;#include &lt;unistd.h&gt; #define ONE_MB (1024 * 1024)  int main() { printf(&#34;The number of processors configured is :%ld\n&#34;, sysconf(_SC_NPROCESSORS_CONF)); printf(&#34;The number of processors currently online (available) is :%ld\n&#34;, sysconf(_SC_NPROCESSORS_ONLN)); printf(&#34;The pagesize: %ld\n&#34;, sysconf(_SC_PAGESIZE)); printf(&#34;The number of pages: %ld\n&#34;, sysconf(_SC_PHYS_PAGES)); printf(&#34;The number of available pages: %ld\n&#34;, sysconf(_SC_AVPHYS_PAGES)); printf(&#34;The memory size: %lld MB\n&#34;, (long long)sysconf(_SC_PAGESIZE) * (long long)sysconf(_SC_PHYS_PAGES) / ONE_MB ); printf(&#34;The number of files max opened:: %ld\n&#34;, sysconf(_SC_OPEN_MAX)); printf(&#34;The number of ticks per second: %ld\n&#34;, sysconf(_SC_CLK_TCK)); printf(&#34;The max length of host name: %ld\n&#34;, sysconf(_SC_HOST_NAME_MAX)); printf(&#34;The max length of login name: %ld\n&#34;, sysconf(_SC_LOGIN_NAME_MAX)); return 0; } 编译后执行："><meta property="article:published_time" content="2017-12-14 08:00:00 &#43;0800 &#43;0800"></head><body><div class=container><header class=header><span class=header__inner><a href=https://shaocheng.li/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>$ cd /home/</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=https://shaocheng.li/about/>About</a></li><li><a href=https://shaocheng.li/posts/>Posts</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41C32.4934 41 41 32.4934 41 22 41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>5 minutes</p></div><article><h1 class=post-title><a href=https://shaocheng.li/posts/2017/12/14/>Linux Program Tips</a></h1><hr><aside id=toc><div class=toc-title>Table of Contents</div><nav id=TableOfContents><ul><li><ul><li><a href=#1-sysconfig>1. sysconfig()</a></li><li><a href=#2-attribute>2. <strong>attribute</strong></a><ul><li><a href=#2-1-packed>2.1. packed</a></li><li><a href=#2-2-aligned-alignment>2.2. aligned(alignment)</a></li><li><a href=#2-3-constructor-destructor>2.3. constructor &amp; destructor</a></li><li><a href=#2-4-visibility>2.4. visibility</a></li><li><a href=#2-5-format>2.5 format</a></li></ul></li><li><a href=#3-size-t>3. size_t</a></li><li><a href=#4-container-of>4. container_of</a></li><li><a href=#5-pid-文件>5. PID 文件</a></li><li><a href=#6-debug>6. Debug</a></li></ul></li></ul></nav></aside><hr><div class=post-content><h2 id=1-sysconfig>1. sysconfig()</h2><p><code>sysconfig()</code> 是获取系统运行时配置信息的函数，包括内存、CPU 等。函数声明：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>long</span> <span style=color:#a6e22e>sysconf</span>(<span style=color:#66d9ef>int</span> name);</code></pre></div><p>参数 name 用于指示要获取的信息，通过返回值将结果返回。新建一个 test.c ，获取当前系统的信息：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define ONE_MB (1024 * 1024)
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
{
    printf(<span style=color:#e6db74>&#34;The number of processors configured is :%ld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, sysconf(_SC_NPROCESSORS_CONF));
    printf(<span style=color:#e6db74>&#34;The number of processors currently online (available) is :%ld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, sysconf(_SC_NPROCESSORS_ONLN));
    printf(<span style=color:#e6db74>&#34;The pagesize: %ld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, sysconf(_SC_PAGESIZE));
    printf(<span style=color:#e6db74>&#34;The number of pages: %ld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, sysconf(_SC_PHYS_PAGES));
    printf(<span style=color:#e6db74>&#34;The number of available pages: %ld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, sysconf(_SC_AVPHYS_PAGES));
    printf(<span style=color:#e6db74>&#34;The memory size: %lld MB</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, (<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>)sysconf(_SC_PAGESIZE) <span style=color:#f92672>*</span> (<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>)sysconf(_SC_PHYS_PAGES) <span style=color:#f92672>/</span> ONE_MB );
    printf(<span style=color:#e6db74>&#34;The number of files max opened:: %ld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, sysconf(_SC_OPEN_MAX));
    printf(<span style=color:#e6db74>&#34;The number of ticks per second: %ld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, sysconf(_SC_CLK_TCK));
    printf(<span style=color:#e6db74>&#34;The max length of host name: %ld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, sysconf(_SC_HOST_NAME_MAX));
    printf(<span style=color:#e6db74>&#34;The max length of login name: %ld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, sysconf(_SC_LOGIN_NAME_MAX));
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}</code></pre></div><p>编译后执行：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ gcc test.c
$ ./a.out
The number of processors configured is :1
The number of processors currently online <span style=color:#f92672>(</span>available<span style=color:#f92672>)</span> is :1
The pagesize: <span style=color:#ae81ff>4096</span>
The number of pages: <span style=color:#ae81ff>221303</span>
The number of available pages: <span style=color:#ae81ff>19370</span>
The memory size: <span style=color:#ae81ff>864</span> MB
The number of files max opened:: <span style=color:#ae81ff>1024</span>
The number of ticks per second: <span style=color:#ae81ff>100</span>
The max length of host name: <span style=color:#ae81ff>64</span>
The max length of login name: <span style=color:#ae81ff>256</span></code></pre></div><h2 id=2-attribute>2. <strong>attribute</strong></h2><p><code>__attribute__</code> 是 GCC 提供的一种语法，可以帮助我们在编译时对声明的函数、变量和类型做一些特殊处理或者是检查操作，提升城程序的性能。语法格式为: <code>__attribute__ ((attribute-list))</code> ，attribute-list 是指令集 , 分为三种类型：函数属性，变量属性，类型属性。<code>__attribute__</code> 应该出现在函数、变量和类型声明的 “;” 前。</p><h3 id=2-1-packed>2.1. packed</h3><p>packed 用于设置变量或者结构体成员以最小的对齐方式对齐，减少空间浪费，例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>struct</span> foo1 {
    <span style=color:#66d9ef>char</span> a;
    <span style=color:#66d9ef>int</span> b[<span style=color:#ae81ff>2</span>];
};
<span style=color:#66d9ef>struct</span> foo2 {
    <span style=color:#66d9ef>char</span> a;
    <span style=color:#66d9ef>int</span> b[<span style=color:#ae81ff>2</span>];
} __attribute__((packed));

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
{
    <span style=color:#66d9ef>int</span> s1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> foo1);
    <span style=color:#66d9ef>int</span> s2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> foo2);
    printf(<span style=color:#e6db74>&#34;s1 = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>s2 = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,s1,s2);

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}</code></pre></div><p>运行结果：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>s1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>12</span>
s2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span></code></pre></div><h3 id=2-2-aligned-alignment>2.2. aligned(alignment)</h3><p>aligned 用于指定变量或者结构体成语按照 alignment 字节大小对齐。如果对齐长度有大于 alignment 的，就按照最大对齐长度对齐。例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>struct</span> foo1 {
    <span style=color:#66d9ef>char</span> a;
    <span style=color:#66d9ef>int</span> b[<span style=color:#ae81ff>2</span>];
};
<span style=color:#66d9ef>struct</span> foo2 {
    <span style=color:#66d9ef>char</span> a;
    <span style=color:#66d9ef>int</span> b[<span style=color:#ae81ff>2</span>] __attribute__((aligned(<span style=color:#ae81ff>8</span>)));
};
    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
    {
        <span style=color:#66d9ef>int</span> s1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> foo1);
        <span style=color:#66d9ef>int</span> s2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> foo2);
        printf(<span style=color:#e6db74>&#34;s1 = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>s2 = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,s1,s2);

        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
    }</code></pre></div><p>运行结果：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>s1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>12</span>
s2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span></code></pre></div><h3 id=2-3-constructor-destructor>2.3. constructor &amp; destructor</h3><p>函数属性，设置 constructor 可以使函数在 main 方法之前执行，而设置 destructor 可以使函数在 main 方法之后执行。例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>__attribute__</span>((constructor)) fun1()
{
    printf(<span style=color:#e6db74>&#34;function 1</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
}
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>__attribute__</span>((destructor)) fun2()
{
    printf(<span style=color:#e6db74>&#34;function 2</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
{
    printf(<span style=color:#e6db74>&#34;Main</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}</code></pre></div><p>运行结果：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#66d9ef>function</span> <span style=color:#ae81ff>1</span>
Main
<span style=color:#66d9ef>function</span> <span style=color:#ae81ff>2</span></code></pre></div><h3 id=2-4-visibility>2.4. visibility</h3><p><a href=https://www.ibm.com/developerworks/cn/aix/library/au-aix-symbol-visibility/index.html target=_blank>控制符号可见性</a>，用与设置函数是否被导出，常用的有两个选项：</p><ol><li><code>__attribute__((visibility(&quot;default&quot;)))</code> ，用它定义的符号将被导出。</li><li><code>__attribute__((visibility(&quot;hidden&quot;)))</code> ，用它定义的符号将不被导出，其他对象无法调用。</li></ol><h3 id=2-5-format>2.5 format</h3><p>format 用于检查格式化字符串与可变参数 <code>...</code> 的匹配情况，防止出错。标准语法是：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>format(archetype, string<span style=color:#f92672>-</span>index, first<span style=color:#f92672>-</span>to<span style=color:#f92672>-</span>check)</code></pre></div><ul><li>archetype 用于检查格式化字符串的类型，例如 <code>printf</code> 和 <code>scanf</code> 。</li><li>string-index 表示传入函数的第几个参数是格式化字符串，从 1 开始数。</li><li>first-to-check 表示从传入函数的第几个参数开始检查，从 1 开始数。</li></ul><p>例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdarg.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
__attribute__((format(printf, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>)))
<span style=color:#66d9ef>void</span> mylog(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    (<span style=color:#66d9ef>void</span>)printf(fmt, ap);

    va_end(ap);
}

<span style=color:#66d9ef>int</span> main(<span style=color:#66d9ef>void</span>)
{
    mylog(<span style=color:#e6db74>&#34;value = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#ae81ff>8</span>);
    mylog(<span style=color:#e6db74>&#34;value = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#e6db74>&#34;hello&#34;</span>);

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}</code></pre></div><p>第二次调用 <code>mylog()</code> 时，因为传给格式化字符串的参数 <code>&quot;hello&quot;</code> 的类型不符，在编译会报错：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>~$ gcc -Wall main.c -o main
main.c: In <span style=color:#66d9ef>function</span> <span style=color:#e6db74>&#39;main&#39;</span>:
main.c:17:11: warning: format <span style=color:#e6db74>&#39;%d&#39;</span> expects argument of type <span style=color:#e6db74>&#39;int&#39;</span>, but argument <span style=color:#ae81ff>2</span> has type <span style=color:#e6db74>&#39;char *&#39;</span> <span style=color:#f92672>[</span>-Wformat<span style=color:#f92672>=]</span>
     mylog<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;value = %d\n&#34;</span>, <span style=color:#e6db74>&#34;hello&#34;</span><span style=color:#f92672>)</span>;</code></pre></div><h2 id=3-size-t>3. size_t</h2><p>size_t 是 C/C++ 标准定义的数据类型，无符号，它在不同的系统中大小是不一样的，32 位系统中通常定义为 unsigned int ，4 Byte ，64 位系统中通常定义为 unsigned long ，8 Byte 。它的含义是当前系统可操作的内存最大值，通常用于内存相关的变量，可以确保不会因为类型太小导致变量溢出，提高程序的有效性和可移植性。例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>malloc(size_t n)</code></pre></div><p>如果把 n 定义为 unsigned int ，那么在 64 位系统中就有溢出的可能性。参考<a href=http://jeremybai.github.io/blog/2014/09/10/size-t target=_blank>为什么 size_t 很重要</a> 。</p><h2 id=4-container-of>4. container_of</h2><p>container_of 是 Linux 内核定义的一个宏，在 linux/kernel.h 中声明，它的作用是通过结构体变量中某个成员的地址获得这个结构体变量的地址。定义：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define container_of(ptr, type, member) ({ \
</span><span style=color:#75715e>        const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \
</span><span style=color:#75715e>        (type *)( (char *)__mptr - offsetof(type,member) );})</span></code></pre></div><p>三个参数分别表示：</p><ul><li>ptr ：结构体成员变量 member 的地址</li><li>type ：结构体类型的名称</li><li>member ：结构体中的成员变量的名称</li></ul><p>宏定义包含两条语句：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>typeof</span>( ((type <span style=color:#f92672>*</span>)<span style=color:#ae81ff>0</span>)<span style=color:#f92672>-&gt;</span>member ) <span style=color:#f92672>*</span>__mptr <span style=color:#f92672>=</span> (ptr); </code></pre></div><p>首先将 0 转化成 type 类型的指针变量（指向的地址为 0x0 ），然后再引用 member 成员 <code>((type *)0)-&gt;member ) )</code>。注意这里的 typeof(x)，是返回 x 的数据类型，那么 <code>typeof( ((type *)0)-&gt;member )</code> 就是返回 member 成员的数据类型。那么这条语句整体就是定义了一个 member 成员的数据类型的指针 __mptr，指向 ptr ，而 ptr 就是 member 的地址。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>(type <span style=color:#f92672>*</span>)( (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)__mptr <span style=color:#f92672>-</span> offsetof(type,member) );</code></pre></div><p>这条语句中的 offsetof 的作用是获取结构体中某个成员的偏移量，那么从 __mptr 指向的地址向前 offsetof 个字节就是 member 所属结构体变量的首地址。offsetof 的原型：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define offsetof(type, member) (size_t)&amp;( ((type *)0)-&gt;member )</span></code></pre></div><p>type 表示结构体的名称，member 表示成员变量的名称。<code>(type *)0</code> 定义了一个 type 类型的指针，指向的地址是 0 ，那么成员 member 的地址就是它在结构体内的偏移量。</p><p>下面这个历程展示 container_of 和 offsetof 的用法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define offsetof(type, member) (size_t)&amp;( ((type *)0)-&gt;member )
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define container_of(ptr, type, member) ({ \
</span><span style=color:#75715e>        const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \
</span><span style=color:#75715e>        (type *)( (char *)__mptr - offsetof(type,member) );})
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> foo
{
    <span style=color:#66d9ef>char</span>  a;
    <span style=color:#66d9ef>int</span>  b;
}foo;

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
{
    size_t off_set <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    off_set <span style=color:#f92672>=</span> offsetof(foo, b);
    printf(<span style=color:#e6db74>&#34;foo-&gt;b offset: %lu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,off_set);

    foo s ;
    printf(<span style=color:#e6db74>&#34;s address : %lu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,(size_t)<span style=color:#f92672>&amp;</span>s);
    s.b <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
    foo <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> container_of(<span style=color:#f92672>&amp;</span>(s.b), foo, b);
    printf(<span style=color:#e6db74>&#34;p-&gt;b value : %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, p<span style=color:#f92672>-&gt;</span>b);
    printf(<span style=color:#e6db74>&#34;p address : %lu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, (size_t)p);
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}</code></pre></div><p>运行结果：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>foo-&gt;b offset: <span style=color:#ae81ff>4</span>
s address : <span style=color:#ae81ff>140723509298320</span>
p-&gt;b value : <span style=color:#ae81ff>10</span>
p address : <span style=color:#ae81ff>140723509298320</span></code></pre></div><h2 id=5-pid-文件>5. PID 文件</h2><p>在 Linux 系统的 /var/run/ 目录下可以看到很多 *.pid 文件，很多程序启动后都会在该目录下新建一个自己的 PID 文件，记录该进程的 PID ，方便管理进程。PID 文件的另一个作用是防止进程启动多个副本，进程启动后新建 PID 文件，然后为文件加独占的记录锁，只有获得 PID 文件写入权限（F_WRLCK）的进程才可以启动，并将自身的 PID 写入文件，锁定失败的进程启动退出。下面是一个例程：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;signal.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> run <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;

<span style=color:#75715e>//锁定一个文件，参数是文件描述符，出错返回 -1    
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lockfile</span>(<span style=color:#66d9ef>int</span> fd)
{
   <span style=color:#66d9ef>struct</span> flock lock;
   lock.l_type <span style=color:#f92672>=</span> F_WRLCK;  <span style=color:#75715e>//独占性写锁
</span><span style=color:#75715e></span>   lock.l_whence <span style=color:#f92672>=</span> SEEK_SET;  <span style=color:#75715e>//为整个文件加锁
</span><span style=color:#75715e></span>   lock.l_start <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
   lock.l_len <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
   <span style=color:#66d9ef>return</span> fcntl(fd, F_SETLK, <span style=color:#f92672>&amp;</span>lock);
}

<span style=color:#75715e>//新建 PID 文件并加锁，参数是 PID 文件的路径和当前进程的 PID ，失败返回负数
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>creat_pidfile</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>pid_file, pid_t pid)
{
    <span style=color:#66d9ef>int</span> fd <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    fd <span style=color:#f92672>=</span> open(pid_file, O_RDWR<span style=color:#f92672>|</span>O_CREAT, (S_IRUSR <span style=color:#f92672>|</span> S_IWUSR <span style=color:#f92672>|</span> S_IRGRP <span style=color:#f92672>|</span> S_IROTH));
    <span style=color:#66d9ef>if</span>(fd <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
    {
        printf(<span style=color:#e6db74>&#34;ERROR: can not open pid file %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,pid_file);
        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
    }
    <span style=color:#66d9ef>if</span>(lockfile(fd)<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span>)
    {
        <span style=color:#66d9ef>if</span>(errno<span style=color:#f92672>==</span>EACCES <span style=color:#f92672>||</span> errno<span style=color:#f92672>==</span>EAGAIN)
        {
            close(fd);
            printf(<span style=color:#e6db74>&#34;WARNING: process already run</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
        }
        printf(<span style=color:#e6db74>&#34;ERROR: can not lock pid file: %s error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, pid_file, strerror(errno));
        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>;
    }
    <span style=color:#66d9ef>if</span>(dprintf(fd, <span style=color:#e6db74>&#34;%d&#34;</span>, pid)<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span>)
    {
        close(fd);
        printf(<span style=color:#e6db74>&#34;ERROR: write pid failed</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
    }
    <span style=color:#66d9ef>return</span> fd;
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>remove_pidfile</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>pid_file, <span style=color:#66d9ef>int</span> fd)
{
    close(fd);
    remove(pid_file);
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handle_sig</span>(<span style=color:#66d9ef>int</span> signo)
{
    <span style=color:#66d9ef>if</span>( (signo<span style=color:#f92672>==</span>SIGINT)<span style=color:#f92672>|</span>(signo<span style=color:#f92672>==</span>SIGTERM) )
        run<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
{
    <span style=color:#66d9ef>int</span> fd <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>pid_file <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/var/run/test.pid&#34;</span>; 

    fd <span style=color:#f92672>=</span> creat_pidfile(pid_file,getpid());
    <span style=color:#66d9ef>if</span>(fd<span style=color:#f92672>&gt;</span><span style=color:#ae81ff>0</span>)
        close(fd);
    <span style=color:#66d9ef>else</span>
    {
        printf(<span style=color:#e6db74>&#34;create pid file error</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
    }
    
    signal(SIGINT,handle_sig);
    signal(SIGTERM,handle_sig);

    <span style=color:#66d9ef>while</span>(run)
    {
        sleep(<span style=color:#ae81ff>5</span>);
    }

    remove_pidfile(pid_file,fd);
    
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}</code></pre></div><h2 id=6-debug>6. Debug</h2><p>在源文件里声明：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#ifdef __DEBUG__
</span><span style=color:#75715e>#define DEBUG(format, ...) printr(&#34;%03d: &#34;format&#34;&#34;, __LINE__, ##__VA_ARGS__)
</span><span style=color:#75715e>#else
</span><span style=color:#75715e>#define DEBUG(format, ...)
</span><span style=color:#75715e>#endif</span></code></pre></div><p>调用 <code>DEBUG()</code> 的语法与 <code>printf()</code> 一样，编译时在 gcc 中声明 <code>-D __DEBUG__</code> 即可打开调试信息。</p></div></article><hr><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>927 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2017-12-14 00:00 &#43;0000</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://shaocheng.li/posts/2017/12/18/><span class=button__icon>←</span>
<span class=button__text>Tkinter 学习笔记</span></a></span>
<span class="button next"><a href=https://shaocheng.li/posts/2017/11/30/><span class=button__text>计算机是如何实现重启的</span>
<span class=button__icon>→</span></a></span></div></div><div id=comments class=thin><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"shaocheng-li"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2022</span>
<span><a href=https://shaocheng.li>Shaocheng.Li</a></span>
<span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span>
<span><a href=https://shaocheng.li/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"/><path d="M4 4a16 16 0 0 1 16 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div><div class=footer__inner><div class=footer__content><span>Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>Made with &#10084; by <a href=https://github.com/rhazdon>rhazdon</a></span></div></div></footer></div><script type=text/javascript src=https://shaocheng.li/bundle.min.2d5469329143160ae2456a69c3c76dc2d0a3b212b46afe291a51bd68650ed6f8697e001dab54f1c272c77ce08092a8c55e5bb4314e0ee334aab4b927ec896638.js integrity="sha512-LVRpMpFDFgriRWppw8dtwtCjshK0av4pGlG9aGUO1vhpfgAdq1TxwnLHfOCAkqjFXlu0MU4O4zSqtLkn7IlmOA=="></script></body></html>