<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="Shaocheng.Li ">
<meta name="description" content="Paho 是一个开源的 MQTT 客户端项目，提供多种语言的 MQTT 客户端实现，包括 C、C&#43;&#43;、C#、Java、Python、JavaScript 等，完全支持 MQTT v3.1 和 v3.1.1 。Paho Python Client 是它的 Python 语言版本，支持 Python 2.7 和 3.x 。更多特性可以查看 http://www.eclipse.org/paho/clients/python/ ，源码和文档在 https://github.com/eclipse/paho.mqtt.python 。
该项目提供了一个测试用的 MQTT broker ：iot.eclipse.org ，端口 1883 ，无密码。
1. 安装 在 Python 环境中用 pip install paho-mqtt 命令安装，或者下载源码：
git clone https://github.com/eclipse/paho.mqtt.python.git cd org.eclipse.paho.mqtt.python.git python setup.py install  下面是一个简单的例子，连接一个 borker ，订阅系统默认话题，获取 broker 的版本号：
import paho.mqtt.client as mqtt def on_connect(client, userdata, flags, rc): print(&amp;quot;Connected with result code &amp;quot;&#43;str(rc)) client." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="#252627" />
<link rel="canonical" href="http://exbob.github.io/posts/2017/05/paho-python-client-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" />


    <title>
        
            Paho Python Client 学习笔记 :: Shaocheng.Li  — Hello Friends
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="http://exbob.github.io/main.min.73f55a8d452be4a71b2960620b80252cf69abd84d63fe7501abf0a39b1a70a78.css">




    <link rel="apple-touch-icon" sizes="180x180" href="http://exbob.github.io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="http://exbob.github.io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="http://exbob.github.io/favicon-16x16.png">
    <link rel="manifest" href="http://exbob.github.io/site.webmanifest">
    <link rel="mask-icon" href="http://exbob.github.io/safari-pinned-tab.svg" color="#252627">
    <link rel="shortcut icon" href="http://exbob.github.io/favicon.ico">
    <meta name="msapplication-TileColor" content="#252627">
    <meta name="theme-color" content="#252627">

<meta itemprop="name" content="Paho Python Client 学习笔记">
<meta itemprop="description" content="Paho 是一个开源的 MQTT 客户端项目，提供多种语言的 MQTT 客户端实现，包括 C、C&#43;&#43;、C#、Java、Python、JavaScript 等，完全支持 MQTT v3.1 和 v3.1.1 。Paho Python Client 是它的 Python 语言版本，支持 Python 2.7 和 3.x 。更多特性可以查看 http://www.eclipse.org/paho/clients/python/ ，源码和文档在 https://github.com/eclipse/paho.mqtt.python 。
该项目提供了一个测试用的 MQTT broker ：iot.eclipse.org ，端口 1883 ，无密码。
1. 安装 在 Python 环境中用 pip install paho-mqtt 命令安装，或者下载源码：
git clone https://github.com/eclipse/paho.mqtt.python.git cd org.eclipse.paho.mqtt.python.git python setup.py install  下面是一个简单的例子，连接一个 borker ，订阅系统默认话题，获取 broker 的版本号：
import paho.mqtt.client as mqtt def on_connect(client, userdata, flags, rc): print(&quot;Connected with result code &quot;&#43;str(rc)) client.">


<meta itemprop="datePublished" content="2017-05-23T08:00:00&#43;08:00" />
<meta itemprop="dateModified" content="2017-05-23T08:00:00&#43;08:00" />
<meta itemprop="wordCount" content="719">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://exbob.github.io"/>

<meta name="twitter:title" content="Paho Python Client 学习笔记"/>
<meta name="twitter:description" content="Paho 是一个开源的 MQTT 客户端项目，提供多种语言的 MQTT 客户端实现，包括 C、C&#43;&#43;、C#、Java、Python、JavaScript 等，完全支持 MQTT v3.1 和 v3.1.1 。Paho Python Client 是它的 Python 语言版本，支持 Python 2.7 和 3.x 。更多特性可以查看 http://www.eclipse.org/paho/clients/python/ ，源码和文档在 https://github.com/eclipse/paho.mqtt.python 。
该项目提供了一个测试用的 MQTT broker ：iot.eclipse.org ，端口 1883 ，无密码。
1. 安装 在 Python 环境中用 pip install paho-mqtt 命令安装，或者下载源码：
git clone https://github.com/eclipse/paho.mqtt.python.git cd org.eclipse.paho.mqtt.python.git python setup.py install  下面是一个简单的例子，连接一个 borker ，订阅系统默认话题，获取 broker 的版本号：
import paho.mqtt.client as mqtt def on_connect(client, userdata, flags, rc): print(&quot;Connected with result code &quot;&#43;str(rc)) client."/>





    <meta property="article:published_time" content="2017-05-23 08:00:00 &#43;0800 CST" />








    </head>

    <body class="">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="http://exbob.github.io/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$ cd /home/</span>
            <span class="logo__cursor" style=""></span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="http://exbob.github.io/about/">About</a></li><li><a href="http://exbob.github.io/posts/">Posts</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>4 minutes

            

            </p>
        </div>

        <article>
            <h1 class="post-title">
                <a href="http://exbob.github.io/posts/2017/05/paho-python-client-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Paho Python Client 学习笔记</a>
            </h1>

            

            <div class="post-content">
                

<p>Paho 是一个开源的 MQTT 客户端项目，提供多种语言的 MQTT 客户端实现，包括 C、C++、C#、Java、Python、JavaScript 等，完全支持 MQTT v3.1 和 v3.1.1 。Paho Python Client 是它的 Python 语言版本，支持 Python 2.7 和 3.x 。更多特性可以查看 <a href="http://www.eclipse.org/paho/clients/python/" target="_blank">http://www.eclipse.org/paho/clients/python/</a> ，源码和文档在 <a href="https://github.com/eclipse/paho.mqtt.python" target="_blank">https://github.com/eclipse/paho.mqtt.python</a> 。</p>

<p>该项目提供了一个测试用的 MQTT broker ：<code>iot.eclipse.org</code> ，端口 1883 ，无密码。</p>

<h2 id="1-安装">1. 安装</h2>

<p>在 Python 环境中用 <code>pip install paho-mqtt</code> 命令安装，或者下载源码：</p>

<pre><code>git clone https://github.com/eclipse/paho.mqtt.python.git
cd org.eclipse.paho.mqtt.python.git
python setup.py install
</code></pre>

<p>下面是一个简单的例子，连接一个 borker ，订阅系统默认话题，获取 broker 的版本号：</p>

<pre><code>import paho.mqtt.client as mqtt

def on_connect(client, userdata, flags, rc):
    print(&quot;Connected with result code &quot;+str(rc))
    client.subscribe(&quot;$SYS/broker/version&quot;)

def on_message(client, userdata, msg):
    print(msg.topic+&quot; &quot;+str(msg.payload))

client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message

client.connect(&quot;iot.eclipse.org&quot;, 1883, 60)

client.loop_forever()
</code></pre>

<p>保存到 paho-mqtt.py 文件，执行：</p>

<pre><code>$ python paho-mqtt.py
Connected with result code 0
$SYS/broker/version mosquitto version 1.4.10
</code></pre>

<h2 id="2-编程">2. 编程</h2>

<p>paho.mqtt 包提供了三个类，Client、Publish 和 Subscribe。Publish 和 Subscribe 提供了简单的方法，一次性的发送或者接收消息，不会保持连接。Client 包含了新建客户端、连接、订阅、发送、回调函数等方法。通常的编程步骤是新建一个 Client 的实例，然后调用它提供的连接、发布和订阅等方法与 broker 通讯：</p>

<ol>
<li>新建一个 Client 实例</li>
<li>用一个 <code>connect*()</code> 函数连接 broker</li>
<li>用一个 <code>loop*()</code> 函数，维持与 broker 的连接</li>
<li>用 <code>subscribe()</code> 函数订阅一个话题，接收消息</li>
<li>用 <code>publish()</code> 函数发布消息</li>
<li>用 <code>disconnect()</code> 函数断开连接</li>
</ol>

<p>下面主要介绍 Client 提供的方法，使用前先导入：</p>

<pre><code>import paho.mqtt.client as mqtt
</code></pre>

<h3 id="2-1-初始化">2.1. 初始化</h3>

<p>新建一个 Client 实例：</p>

<pre><code>Client(client_id=&quot;&quot;, clean_session=True, userdata=None, protocol=MQTTv311, transport=&quot;tcp&quot;)
</code></pre>

<p>这是 Client 类的构造函数，参数的含义：</p>

<ul>
<li>client_id ，设置客户端的 ID ，应该是一个字符串，连接时向 broker 提交。如果为空，会随机生成一个 id ，此时，clean_session 必须设为 True 。</li>
<li>clean_session ，布尔型，如果为 True ，断开连接时，broker 会清除关于这个 client 的所有信息。如果为 False ，断开连接时，broker 会保留这个客户端的订阅信息和消息队列。</li>
<li>userdata ，用户自定义的数据，可以是任何类型，传递给回调函数。可以用 <code>user_data_set()</code> 函数更新。</li>
<li>protocol ，设置 MQTT 协议的版本，<code>MQTTv31</code> 或者 <code>MQTTv311</code> 。</li>
<li>transport ， 传输协议，默认还是 <code>tcp</code> ，可以设为 <code>websockets</code> 。</li>
</ul>

<p>构造实例：</p>

<pre><code>import paho.mqtt.client as mqtt
mqttc = mqtt.Client()
</code></pre>

<p>可以调用 <code>reinitialise()</code> 重新初始化 Client ：</p>

<pre><code>reinitialise(client_id=&quot;&quot;, clean_session=True, userdata=None)
</code></pre>

<h3 id="2-2-配置">2.2. 配置</h3>

<p>这些函数用来设置 Client 的一些特性，通常在连接 broker 之前调用。</p>

<pre><code>max_inflight_messages_set(self, inflight)
</code></pre>

<p>这个函数可以设置当 QoS&gt;0 时，最多可以存在几条动态消息（已经发送，还没有确认成功的消息）。默认是 20 ，增加这个值会占用更多的内存，但是可以提升吞吐量。</p>

<pre><code>max_queued_messages_set(self, queue_size)
</code></pre>

<p>这个函数可以设置当 QoS&gt;0 时，发送消息队列的最大值，默认是 0 ，表示无限制。当队列满时，旧消息会丢弃。</p>

<pre><code>message_retry_set(retry)
</code></pre>

<p>当 Qos&gt;0 时，如果发送消息后超过一定时间还没有收到确认报文，就要重发消息，这个函数用于设置超时时间，单位是秒。默认是 5 秒，通常不用修改。</p>

<p>配置 SSL 证书验证的函数，必须在 <code>connect*()</code> 函数之前调动。几个参数的含义：</p>

<ul>
<li>ca_certs ，指定 CA 根证书的路径。</li>
<li>certfile,keyfile ，指定客户端私钥和证书的路径。</li>
<li>cert_reqs ，设置客户端对 broker 证书的需求，默认是 ssl.CERT_REQUIRED ，表示 broker 必须提供一个证书。</li>
<li>tls_version ，设置 SSL/TLS 协议的版本，默认是 TLS v1 。</li>
<li>ciphers ，设置本次连接的加密密码，默认是 None 。</li>
</ul>

<p>设置用户名和密码：</p>

<p>username_pw_set(username, password=None)</p>

<p>设置遗嘱：</p>

<pre><code>will_set(topic, payload=None, qos=0, retain=False)
</code></pre>

<p>当这个 client 断开连接时，broker 会发布这个遗嘱消息。参数的含义：</p>

<ul>
<li>topic ，遗嘱消息的话题</li>
<li>payload ，遗嘱消息的内容，字符串类型，如果设为 None ，会发送一条长度为 0 消息。如果设置了 int 或者 float 类型的值，会当做字符串发送，如果你想发送真正的 int 或者 float 值，需要用 <code>struct.pack()</code> 生成消息。</li>
<li>qos ，遗嘱消息的安全等级</li>
<li>retain ，如果设为 True ，遗嘱消息会被设为保留消息</li>
</ul>

<p>如果参数设置错误，函数会抛出 ValueError 异常。</p>

<h3 id="2-3-连接">2.3. 连接</h3>

<p>最基本的连接方法是 <code>connect()</code> ：</p>

<pre><code>connect(host, port=1883, keepalive=60, bind_address=&quot;&quot;)
</code></pre>

<p>连接到 broker ，这是一个阻塞函数，参数的含义：</p>

<ul>
<li>host ，broker 的 hostname 或者 IP</li>
<li>port ，broker 的开放端口，默认是 1883 ，如果使能了 SSL/TLS ，端口可能是 8883</li>
<li>keepalive ，心跳间隔，单位是秒，如果 broker 和 client 在这段时间内没有任何通讯，client 会给 broker 发送一个 ping 消息</li>
<li>bind_address ，如果 client 的本地计算机有多个网络接口，可以用这个参数绑定其中的一个</li>
</ul>

<p>client 调用该函数发起连接后，如果收到 broker 发来的 CONNACK 消息，就会执行 <code>on_connect()</code> 回调函数。除此之外，还有 <code>connect_async()</code> 和 <code>connect_srv()</code> 两种函数可以连接 broker 。<code>connect_async()</code> 需要配合 <code>loop_start()</code> 函数以非阻塞的方式连接 broker。<code>connect_srv()</code> 是从 SRV DNS 获取 broker 的地址，然后再连接。</p>

<p>调用过 <code>connect*()</code> 函数之后，可以调用 <code>reconnect()</code> 用现有的参数重新连接。调用 <code>disconnect()</code> 函数可以从 broker 断开连接，断开连接后，会执行 <code>on_disconnect()</code> 回调函数。</p>

<h3 id="2-4-网络循环">2.4. 网络循环</h3>

<p>网络循环的函数有四种，它们运行在后台，处理收发的消息。最基本的是 <code>loop()</code> ：</p>

<pre><code>loop(timeout=1.0, max_packets=1)
</code></pre>

<p>这个函数会通过 <code>select()</code> 函数阻塞，直到有消息需要收发，阻塞的时间用 timeout 参数设置，不能超过心跳时间 keepalive ，否则你的 client 会定时从 broker 断开。max_packets 参数已经过时，无需设置。</p>

<p>另一个循环函数是 <code>loop_forever()</code> ，它会一直阻塞，直到 client 调用了 <code>disconnect()</code> ，并且，它会自动重连：</p>

<pre><code>loop_forever(timeout=1.0, max_packets=1, retry_first_connection=False)
</code></pre>

<p>timeout 和 max_packets 参数已经过时，无需设置。</p>

<h3 id="2-5-发布">2.5. 发布</h3>

<pre><code>publish(topic, payload=None, qos=0, retain=False)
</code></pre>

<p>向指定话题发送一条消息，参数的含义：</p>

<ul>
<li>topic ，这条消息所属的话题</li>
<li>payload ，消息内容，字符串类型，如果设为 None ，会发送一条长度为 0 消息。如果设置了 int 或者 float 类型的值，会当做字符串发送，如果你想发送真正的 int 或者 float 值，需要用 <code>struct.pack()</code> 生成消息。</li>
<li>qos ，消息的安全等级</li>
<li>retain ，如果设为 Ture ，这条消息会被设为保留消息</li>
</ul>

<p>如果参数设置错误，会抛出 ValueError 异常。消息发送成功后，会执行 <code>on_publish()</code> 回调函数。</p>

<h3 id="2-6-订阅">2.6. 订阅</h3>

<pre><code>subscribe(topic, qos=0)
</code></pre>

<p>向 broker 订阅话题，参数 topic 设置话题名称，qos 设置安全等级。如果只订阅一个话题，直接设置两个参数即可，例如：</p>

<pre><code>subscribe((&quot;my/topic&quot;, 1))
</code></pre>

<p>如果要订阅多个话题，可以将每个话题放在一个元组中，多个话题组成一个列表：</p>

<pre><code>subscribe([(&quot;my/topic&quot;, 0), (&quot;another/topic&quot;, 2)])
</code></pre>

<p>当 broker 确认订阅有效后，client 会执行 <code>on_subscribe()</code> 回调函数。如果要取消订阅某个话题，可以调用 <code>unsubscribe(topic)</code> ，参数是字符串型，如果是取消多个话题，参数应该是一个字符串列表。取消成功的话，会执行 <code>on_unsubscribe()</code> 回调函数。</p>

<h3 id="2-7-回调函数">2.7. 回调函数</h3>

<p>当 broker 对 client 的连接请求做出回应时，会调用 <code>on_connect()</code> 回调函数，可以在该函数中判断连接是否成功:</p>

<pre><code>on_connect(client, userdata, flags, rc)
</code></pre>

<p>参数 client 是当前 client 的实例，userdata 是 <code>Client()</code> 或 <code>userdata_set()</code> 设置的用户数据。flags 是 broker 发送的回应 flags ，字典类型。rc 表示连接结果，整数型，0 表示连接成功，连接失败可能的值有：</p>

<ul>
<li>1 ，错误的协议版本</li>
<li>2 ，无效的 client ID</li>
<li>3 ，服务器不可用</li>
<li>4 ，错误的用户名或密码</li>
<li>5 ，无法验证</li>
</ul>

<p>使用实例：</p>

<pre><code>def on_connect(client, userdata, flags, rc):
    print(&quot;Connection returned result: &quot;+connack_string(rc))

mqttc.on_connect = on_connect
...
</code></pre>

<p>对应的，与 broker 断开连接后，会执行 <code>on_disconnect()</code> 回调函数：</p>

<pre><code>on_disconnect(client, userdata, rc)
</code></pre>

<p>rc 表示断开连接的状态，如果是 0 ，表示是调用了 <code>disconnect()</code> 引起的断开连接，其他结果表示意外断开，比如网络中断。使用实例：</p>

<pre><code>def on_disconnect(client, userdata, rc):
    if rc != 0:
        print(&quot;Unexpected disconnection.&quot;)

mqttc.on_disconnect = on_disconnect
...
</code></pre>

<p>当 client 接收到已订阅的话题的消息时，会调用 <code>on_message()</code> 回调函数，在该函数中判断是哪个话题的消息，并处理消息内容：</p>

<pre><code>on_message(client, userdata, message)
</code></pre>

<p>参数 message 是 MQTTMessage 类的实例，这个类包含的成员有 <code>topic</code> ，<code>payload</code> ，<code>qos</code> ，<code>retain</code> 。使用实例：</p>

<pre><code>def on_message(client, userdata, message):
    print(&quot;Received message '&quot; + str(message.payload) + &quot;' on topic '&quot;
        + message.topic + &quot;' with QoS &quot; + str(message.qos))

mqttc.on_message = on_message
...
</code></pre>

<p>如果要用通配符同时处理多个话题的消息，例如用 sensors/# 匹配 sensors/temperature 和 sensors/humidity 话题，可以用 <code>message_callback_add()</code> 设置回调函数：</p>

<pre><code>message_callback_add(sub, callback)
</code></pre>

<p>参数 sub 是一个使用通配符的话题过滤器，字符串型，用 callback 参数指定回掉函数，与 <code>on_message()</code>  相同的类型。</p>

<p>如果同时设置了 <code>on_message()</code> 和 <code>message_callback_add()</code> 回调函数，会首先寻找合适的 <code>message_callback_add()</code> 定义的话题过滤器，如果没有匹配，才会调用 <code>on_message()</code> 。</p>

<h3 id="2-8-实例">2.8. 实例</h3>

<p>假设 broker 要求提供用户名、密码、证书和密钥，下面是一个简单的 client 例子：</p>

<pre><code>$ cat path-mqtt.py
#!/usr/bin/python

import paho.mqtt.client as mqtt

cafile = &quot;/etc/mosquitto/ca/ca.crt&quot;
certfile = &quot;/home/ubuntu/CA/client.crt&quot;
keyfile = &quot;/home/ubuntu/CA/client.key&quot;
user = &quot;guest&quot;
passwd = &quot;12345678&quot;
server = &quot;localhost&quot;
port = 8883

def on_connect(client, userdata, flags, rc):
    print(&quot;Connected with result code &quot;+str(rc))
    client.subscribe(&quot;$SYS/broker/version&quot;)

def on_message(client, userdata, msg):
    print(msg.topic+&quot; &quot;+str(msg.payload))

client = mqtt.Client()
client.tls_set(cafile,certfile,keyfile)
client.username_pw_set(user,passwd)
client.on_connect = on_connect
client.on_message = on_message

client.connect(server, port, 60)

client.loop_forever()
</code></pre>

<p>执行：</p>

<pre><code>$ ./path-mqtt.py
Connected with result code 0
$SYS/broker/version mosquitto version 1.4.11
</code></pre>

            </div>
        </article>

        <hr />

        <div class="post-info">

            <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>719 Words</p>

            <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2017-05-23 08:00 &#43;0800</p>
        </div>

        
            <div class="pagination">
                <div class="pagination__title">
                    <span class="pagination__title-h"></span>
                    <hr />
                </div>

                <div class="pagination__buttons">
                    
                        <span class="button previous">
                            <a href="http://exbob.github.io/posts/2017/05/linux-test-project-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                                <span class="button__icon">←</span>
                                <span class="button__text">Linux Test Project 学习笔记</span>
                            </a>
                        </span>
                    

                    
                        <span class="button next">
                            <a href="http://exbob.github.io/posts/2017/05/rsa-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/">
                                <span class="button__text">RSA 加密算法与数字证书</span>
                                <span class="button__icon">→</span>
                            </a>
                        </span>
                    
                </div>
            </div>
        

        
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2020</span>
            
                <span><a href="http://exbob.github.io">Shaocheng.Li</a></span>
            
            <span><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></span>
            <span> <a href="http://exbob.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/rhazdon">rhazdon</a></span>
        </div>
    </div>
</footer>

            
        </div>

        




<script type="text/javascript" src="http://exbob.github.io/bundle.min.2d5469329143160ae2456a69c3c76dc2d0a3b212b46afe291a51bd68650ed6f8697e001dab54f1c272c77ce08092a8c55e5bb4314e0ee334aab4b927ec896638.js" integrity="sha512-LVRpMpFDFgriRWppw8dtwtCjshK0av4pGlG9aGUO1vhpfgAdq1TxwnLHfOCAkqjFXlu0MU4O4zSqtLkn7IlmOA=="></script>



    </body>
</html>
