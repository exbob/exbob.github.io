<!doctype html><html lang=zh-cn dir=Chinese-Simplified class=scroll-smooth data-default-appearance=light data-auto-appearance=true><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="rgb(255,255,255)"><title>Linux 系统如何获取 CPU 主频 &#183; Shaocheng.Li</title>
<meta name=title content="Linux 系统如何获取 CPU 主频 &#183; Shaocheng.Li"><script type=text/javascript src=/js/appearance.min.022d0ebc3b46a335eb1c7ef79b7f2de143d7cd5156d433638592ef1ce5f8554e.js integrity="sha256-Ai0OvDtGozXrHH73m38t4UPXzVFW1DNjhZLvHOX4VU4="></script><link type=text/css rel=stylesheet href=/css/main.bundle.min.569cc57d5993584135ff38133d1f599f8f8db0303a9e886172e4b5aabb177ac6.css integrity="sha256-VpzFfVmTWEE1/zgTPR9Zn4+NsDA6nohhcuS1qrsXesY="><script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.f29ffdffd9ab4cc95250c3c7196b2d5dae8ee6ef0a4139451073f90183ae7e31.js integrity="sha256-8p/9/9mrTMlSUMPHGWstXa6O5u8KQTlFEHP5AYOufjE=" data-copy=复制 data-copied=已复制></script><meta name=description content="
      
        1.CPU 主频 #CPU 的主频是指 CPU 核心的时钟频率，它是 CPU 执行指令的最小时间单位。CPU 内部有时钟管理模块，通过外部振荡器（获取其他时钟电路）输入一个特定的频率（外频），经过内部的 PLL 电路（倍频器）锁定到一个很高的频率，再经过不同的分频，供给不同的模块和总线使用，供给 CPU 的就称为主频,就是通常所说的“主频 = 外频 x 倍频”。目前桌面 X86 CPU 的外频由主板供给，通常是 100MHz ，倍频通常是固定设置的。如果要超频，通常是在主板的 BIOS 中修改倍频因子，也有特殊情况可以增加外频。
      
    "><link rel=canonical href=https://shaocheng.li/posts/2018/08/07/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:title" content="Linux 系统如何获取 CPU 主频"><meta property="og:description" content="1.CPU 主频 #CPU 的主频是指 CPU 核心的时钟频率，它是 CPU 执行指令的最小时间单位。CPU 内部有时钟管理模块，通过外部振荡器（获取其他时钟电路）输入一个特定的频率（外频），经过内部的 PLL 电路（倍频器）锁定到一个很高的频率，再经过不同的分频，供给不同的模块和总线使用，供给 CPU 的就称为主频,就是通常所说的“主频 = 外频 x 倍频”。目前桌面 X86 CPU 的外频由主板供给，通常是 100MHz ，倍频通常是固定设置的。如果要超频，通常是在主板的 BIOS 中修改倍频因子，也有特殊情况可以增加外频。"><meta property="og:type" content="article"><meta property="og:url" content="https://shaocheng.li/posts/2018/08/07/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-08-07T08:00:00+08:00"><meta property="article:modified_time" content="2018-08-07T08:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux 系统如何获取 CPU 主频"><meta name=twitter:description content="1.CPU 主频 #CPU 的主频是指 CPU 核心的时钟频率，它是 CPU 执行指令的最小时间单位。CPU 内部有时钟管理模块，通过外部振荡器（获取其他时钟电路）输入一个特定的频率（外频），经过内部的 PLL 电路（倍频器）锁定到一个很高的频率，再经过不同的分频，供给不同的模块和总线使用，供给 CPU 的就称为主频,就是通常所说的“主频 = 外频 x 倍频”。目前桌面 X86 CPU 的外频由主板供给，通常是 100MHz ，倍频通常是固定设置的。如果要超频，通常是在主板的 BIOS 中修改倍频因子，也有特殊情况可以增加外频。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","articleSection":"Posts","name":"Linux 系统如何获取 CPU 主频","headline":"Linux 系统如何获取 CPU 主频","abstract":"1.CPU 主频 #CPU 的主频是指 CPU 核心的时钟频率，它是 CPU 执行指令的最小时间单位。CPU 内部有时钟管理模块，通过外部振荡器（获取其他时钟电路）输入一个特定的频率（外频），经过内部的 PLL 电路（倍频器）锁定到一个很高的频率，再经过不同的分频，供给不同的模块和总线使用，供给 CPU 的就称为主频,就是通常所说的“主频 = 外频 x 倍频”。目前桌面 X86 CPU 的外频由主板供给，通常是 100MHz ，倍频通常是固定设置的。如果要超频，通常是在主板的 BIOS 中修改倍频因子，也有特殊情况可以增加外频。","inLanguage":"zh-cn","url":"https:\/\/shaocheng.li\/posts\/2018\/08\/07\/","author":{"@type":"Person","name":"Shaocheng.Li"},"copyrightYear":"2018","dateCreated":"2018-08-07T08:00:00\u002b08:00","datePublished":"2018-08-07T08:00:00\u002b08:00","dateModified":"2018-08-07T08:00:00\u002b08:00","mainEntityOfPage":"true","wordCount":"1209"}</script><meta name=author content="Shaocheng.Li"><link href=https://github.com/exbob rel=me></head><body class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="font-bold pe-2 text-primary-600 dark:text-primary-400">&darr;</span>跳到主要内容</a></div><header class="py-6 font-semibold text-neutral-900 dark:text-neutral print:hidden sm:py-10"><nav class="flex items-start justify-between sm:items-center"><div class="flex flex-row items-center"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" rel=me href=/>Shaocheng.Li</a></div><ul class="flex flex-col list-none text-end sm:flex-row"><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/posts/ title=Posts><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">文章列表</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><button id=search-button-1 title="搜索 (/)">
<span class="transition-colors group-dark:hover:text-primary-400 group-hover:text-primary-600"><span class="relative inline-block align-text-bottom px-1 icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></span><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2"></span></button></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><button id=appearance-switcher-1 type=button aria-label="appearance switcher">
<span class="inline transition-colors group-dark:hover:text-primary-400 group-hover:text-primary-600 dark:hidden" title=切换为深色模式><span class="relative inline-block align-text-bottom px-1 icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2"></span>
</span><span class="hidden transition-colors group-dark:hover:text-primary-400 group-hover:text-primary-600 dark:inline" title=切换为浅色模式><span class="relative inline-block align-text-bottom px-1 icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2"></span></span></button></li></ul></nav></header><div class="relative flex flex-col grow"><main id=main-content class=grow><article><header class=max-w-prose><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">Linux 系统如何获取 CPU 主频</h1><div class="mt-8 mb-12 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime="2018-08-07 08:00:00 +0800 +0800">2018 August 7</time><span class="px-2 text-primary-500">&#183;</span><span>1209 字</span><span class="px-2 text-primary-500">&#183;</span><span title=预计阅读>6 分钟</span></div></div></header><section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row"><div class="order-first px-0 lg:order-last lg:max-w-xs lg:ps-8"><div class="toc pe-5 print:hidden lg:sticky lg:top-10"><details open class="-ms-5 mt-0 overflow-hidden rounded-lg ps-5"><summary class="-ms-5 block cursor-pointer bg-neutral-100 py-1 ps-5 text-lg font-semibold text-neutral-800 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">目录</summary><div class="-ms-5 border-s border-dotted border-neutral-300 py-2 ps-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#1cpu-主频>1.CPU 主频</a></li><li><a href=#2programmalbe-interval-timer-pit>2.Programmalbe Interval Timer (PIT)</a></li><li><a href=#3time-stamp-counter-tsc>3.Time Stamp Counter (TSC)</a></li><li><a href=#4计算主频>4.计算主频</a></li><li><a href=#5proccpuinfo>5./proc/cpuinfo</a></li><li><a href=#6bogomips>6.BogoMIPS</a></li><li><a href=#参考>参考</a></li></ul></nav></div></details></div></div><div class="min-w-0 min-h-0 max-w-prose grow"><h2 id=1cpu-主频 class="relative group">1.CPU 主频 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1cpu-%e4%b8%bb%e9%a2%91 aria-label=锚点>#</a></span></h2><p>CPU 的主频是指 CPU 核心的时钟频率，它是 CPU 执行指令的最小时间单位。CPU 内部有时钟管理模块，通过外部振荡器（获取其他时钟电路）输入一个特定的频率（外频），经过内部的 PLL 电路（倍频器）锁定到一个很高的频率，再经过不同的分频，供给不同的模块和总线使用，供给 CPU 的就称为主频,就是通常所说的“主频 = 外频 x 倍频”。目前桌面 X86 CPU 的外频由主板供给，通常是 100MHz ，倍频通常是固定设置的。如果要超频，通常是在主板的 BIOS 中修改倍频因子，也有特殊情况可以增加外频。</p><p>X86-Linux 体系有三种硬件时钟：</p><ul><li>Real Time Clock(RTC) ，实时时钟，通常位于 CMOS ，独立工作</li><li>Programmalbe Interval Timer(PIT) ，可编程的间隔定时器，通常由 8254 芯片实现</li><li>Time Stamp Counter(TSC) ，时间戳控制器，记录 CPU 时钟周期</li></ul><p>Linux 内核在计算 CPU 主频时会用到 PIT 和 TSC 。以下是在 kernel 3.4 版本中分析。</p><h2 id=2programmalbe-interval-timer-pit class="relative group">2.Programmalbe Interval Timer (PIT) <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#2programmalbe-interval-timer-pit aria-label=锚点>#</a></span></h2><p>Programmalbe Interval Timer (PIT) 是现代计算机的重要组成部分，尤其是在多任务环境中。 PIT 是用 8253/8254 芯片实现的，由于历史原因，外接的晶振频率是 1.193182 MHz ，Linux 内核里的定义在 <code>include/linux/timex.h</code> 文件：</p><pre><code>/* The clock frequency of the i8253/i8254 PIT */
#define PIT_TICK_RATE 1193182ul
</code></pre><p>8253/8254 内置三个独立的 16 位减法计数器用于分频，每个计数器有一个输出用于特定的功能，示意图如下：</p><p><figure><img class="mx-auto my-0 rounded-md" src=./pics/2018-08-07_1.png alt loading=lazy></figure></p><ol><li>Channel 0 ：PIT Channel 0 的输出连接在中断控制器上，因此它会产生 “IRQ 0”。通常在引导阶段，BIOS 将 Channel 0 设置为 65535 或 0（转换为65536），这将提供 18.2065Hz 的输出频率（每 54.9254ms 一次的中断）。 Channel 0 可能是最有用的 PIT 通道，因为它是唯一连接到 IRQ 的通道，可以用它产生定时中断。选择工作模式时，要注意 IRQ0 是由 Channel 0 输出电压的上升沿产生的。</li><li>Channel 1 ：PIT Channel 1 的输出曾被用于刷新 DRAM 或 RAM 。通常，RAM 中的每个位由一个电容器组成，该电容器保持代表该位状态的微小电荷，但是由于泄漏，这些电容器需要定期“刷新”，以便它们不会忘记自己的状态。在以后的机器上，DRAM 刷新是通过专用硬件完成的，不再使用 PIT 。在大规模集成电路中实现的现代计算机上，PIT Channel 1 不再可用。</li><li>Channel 2 ：PIT Channel 2 的输出连接在蜂鸣器上，因此输出的频率决定了蜂鸣器产生的声音的频率。这是唯一可以通过软件控制门信号的通道（通过I/O 端口 0x61 的 bit0），也可以用软件读取其输出。</li></ol><p>PIT 的 8253/8254 芯片有四个寄存器，包括三个数据寄存器和一个模式控制寄存器，它们的地址和功能描述：</p><table><thead><tr><th>I/O port</th><th>Usage</th></tr></thead><tbody><tr><td>0x40</td><td>Channel 0 data port (read/write)</td></tr><tr><td>0x41</td><td>Channel 1 data port (read/write)</td></tr><tr><td>0x42</td><td>Channel 2 data port (read/write)</td></tr><tr><td>0x43</td><td>Mode/Command register (write only, a read is ignored)</td></tr></tbody></table><p>模式控制寄存器的格式：</p><p><figure><img class="mx-auto my-0 rounded-md" src=./pics/2018-08-07_2.jpg alt loading=lazy></figure></p><p>编程方式是先在模式控制寄存器中设置计数器、读写方式和工作模式，然后向相应的计数器中写入初始值。</p><h2 id=3time-stamp-counter-tsc class="relative group">3.Time Stamp Counter (TSC) <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#3time-stamp-counter-tsc aria-label=锚点>#</a></span></h2><p>时间戳控制器 Time Stamp Counter (TSC) 是 X86 CPU 里的一个 64 位寄存器，自 Pentium 开始引入，用于记录 CPU 复位后的周期数，CPU 内部时钟每产生一个时钟周期，该寄存器就加一，也就是 CPU 主频的节拍记录器。我们可以用单位时间内 TSC 记录的时钟周期个数来推算 CPU 的实际频率，比如一秒内 TSC 的值增长了 1000 ，那么主频就是 1KHz 。在单核 CPU 上，TSC 是一个简单高效的获取高精度 CPU 时序信息的方式，但是在多核 CPU 、休眠操作系统上，这个方式无法提供准确信息，依赖 TSC 会降低软件的可移植性。在 Windows 平台上，微软反对使用 TSC 进行高精度计时，在 POSIX 系统上，程序可以使用 <code>clock_gettime()</code> 函数读取 CLOCK_MONOTONIC 时钟的值来获得类似的功能。在 Linux 的内核上，可以用启动参数 <code>notsc</code> 禁用 TSC 。</p><p>X86 CPU 提供了 RDTSC 指令来读取 TSC 的值，低 32 位存放在 EAX 寄存器，高 32 位存放在 EDX 寄存器:</p><table><thead><tr><th>指令</th><th>操作码</th><th>说明</th></tr></thead><tbody><tr><td>RDTSC</td><td>0F 31</td><td>将 TSC 的值读入 EDX:EAX</td></tr></tbody></table><p>在内核源码的 <code>arch/x86/include/asm/msr.h</code> 文件中提供了读取方法：</p><div class="highlight line-numbers"><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#ifdef CONFIG_X86_64
</span></span></span><span class=line><span class=cl><span class=cp>#define DECLARE_ARGS(val, low, high)	unsigned low, high
</span></span></span><span class=line><span class=cl><span class=cp>#define EAX_EDX_VAL(val, low, high)	((low) | ((u64)(high) &lt;&lt; 32))
</span></span></span><span class=line><span class=cl><span class=cp>#define EAX_EDX_ARGS(val, low, high)	&#34;a&#34; (low), &#34;d&#34; (high)
</span></span></span><span class=line><span class=cl><span class=cp>#define EAX_EDX_RET(val, low, high)	&#34;=a&#34; (low), &#34;=d&#34; (high)
</span></span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp>#define DECLARE_ARGS(val, low, high)	unsigned long long val
</span></span></span><span class=line><span class=cl><span class=cp>#define EAX_EDX_VAL(val, low, high)	(val)
</span></span></span><span class=line><span class=cl><span class=cp>#define EAX_EDX_ARGS(val, low, high)	&#34;A&#34; (val)
</span></span></span><span class=line><span class=cl><span class=cp>#define EAX_EDX_RET(val, low, high)	&#34;=A&#34; (val)
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=nf>__native_read_tsc</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>DECLARE_ARGS</span><span class=p>(</span><span class=n>val</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>high</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>asm</span> <span class=k>volatile</span><span class=p>(</span><span class=s>&#34;rdtsc&#34;</span> <span class=o>:</span> <span class=nf>EAX_EDX_RET</span><span class=p>(</span><span class=n>val</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>high</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>EAX_EDX_VAL</span><span class=p>(</span><span class=n>val</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>high</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>我们可以在用户空间用 C 语言内联汇编实现同样的功能：</p><div class="highlight line-numbers"><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>low</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>high</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>asm</span> <span class=k>volatile</span><span class=p>(</span><span class=s>&#34;rdtsc&#34;</span> <span class=o>:</span> <span class=s>&#34;=a&#34;</span><span class=p>(</span><span class=n>low</span><span class=p>),</span> <span class=s>&#34;=d&#34;</span><span class=p>(</span><span class=n>high</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;0x%x 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>high</span><span class=p>,</span><span class=n>low</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=4计算主频 class="relative group">4.计算主频 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#4%e8%ae%a1%e7%ae%97%e4%b8%bb%e9%a2%91 aria-label=锚点>#</a></span></h2><p>Linux 内核在初始化阶段用 TSC 来计算 CPU 主频。我们可以在 dmesg 中找到类似的信息：</p><div class="highlight line-numbers"><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ dmesg <span class=p>|</span> grep -E <span class=s2>&#34;TSC|tsc&#34;</span>
</span></span><span class=line><span class=cl>tsc: Fast TSC calibration using PIT
</span></span><span class=line><span class=cl>tsc: Detected 3192.872 MHz processor
</span></span><span class=line><span class=cl>TSC deadline timer enabled
</span></span><span class=line><span class=cl>tsc: Refined TSC clocksource calibration: 3192.747 MHz
</span></span><span class=line><span class=cl>Switched to clocksource tsc
</span></span></code></pre></div><p>前缀的 tsc 是模块的名称，有些内核可能没有这个，没有关系，我们从 <code>Detected 3192.872 MHz processor</code> 入手，这是在 <code>arch/x86/kernel/tsc.c</code> 文件的 <code>tsc_init()</code> 函数中打印的信息，属于内核的时钟子系统，它通过如下路径调用：</p><pre><code>start_kernel() -&gt; time_init() —&gt; x86_late_time_init() -&gt; tsc_init()
</code></pre><p>这个函数执行的是 TSC 模块的初始化工作，然后校准 TSC 频率，设置为 CPU 主频，判断 TSC 频率是否可靠，用 TSC 频率计算 lpj 等，我们先关注这一段：</p><div class="highlight line-numbers"><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>__read_mostly</span> <span class=n>cpu_khz</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>EXPORT_SYMBOL</span><span class=p>(</span><span class=n>cpu_khz</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>__read_mostly</span> <span class=n>tsc_khz</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>EXPORT_SYMBOL</span><span class=p>(</span><span class=n>tsc_khz</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>__init</span> <span class=nf>tsc_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>tsc_khz</span> <span class=o>=</span> <span class=n>x86_platform</span><span class=p>.</span><span class=nf>calibrate_tsc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>cpu_khz</span> <span class=o>=</span> <span class=n>tsc_khz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>tsc_khz</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>mark_tsc_unstable</span><span class=p>(</span><span class=s>&#34;could not calculate TSC khz&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>printk</span><span class=p>(</span><span class=s>&#34;Detected %lu.%03lu MHz processor.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span><span class=n>cpu_khz</span> <span class=o>/</span> <span class=mi>1000</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span><span class=n>cpu_khz</span> <span class=o>%</span> <span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>其中的 <code>x86_platform.calibrate_tsc()</code> 调用的是 <code>native_calibrate_tsc()</code> 函数，它的功能是校准 tsc ，获取 tsc 频率。首先用 PIT 快速校准 TSC ，它的原理是用 PIT 记录一段时间，再测量这段时间内 TSC 的变换量，就可以计算出主频，通过 <code>quick_pit_calibrate()</code> 函数实现：</p><div class="highlight line-numbers"><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>  读取 PIT 的 MSB ，判断 MSB 是否等于参数 val
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>int</span> <span class=nf>pit_verify_msb</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Ignore LSB */</span>
</span></span><span class=line><span class=cl>    <span class=nf>inb</span><span class=p>(</span><span class=mh>0x42</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>inb</span><span class=p>(</span><span class=mh>0x42</span><span class=p>)</span> <span class=o>==</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>  这个函数通过一个 for 循环不断的读取和判断 PIT 和 TSC ，最终用 *tscp 返回 MSB==val 时的 TSC 的值，*deltap 返回是增量（ delta ：希腊字母第四个）
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>int</span> <span class=nf>pit_expect_msb</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>val</span><span class=p>,</span> <span class=n>u64</span> <span class=o>*</span><span class=n>tscp</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=n>deltap</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>u64</span> <span class=n>tsc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>prev_tsc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>count</span> <span class=o>&lt;</span> <span class=mi>50000</span><span class=p>;</span> <span class=n>count</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>pit_verify_msb</span><span class=p>(</span><span class=n>val</span><span class=p>))</span> <span class=c1>// PIT 的 MSB 等于 val 时跳出循环
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>prev_tsc</span> <span class=o>=</span> <span class=n>tsc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>tsc</span> <span class=o>=</span> <span class=nf>get_cycles</span><span class=p>();</span> <span class=c1>//读取 tsc 的值，最终是调用上一章提到的 __native_read_tsc() 函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>deltap</span> <span class=o>=</span> <span class=nf>get_cycles</span><span class=p>()</span> <span class=o>-</span> <span class=n>prev_tsc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>tscp</span> <span class=o>=</span> <span class=n>tsc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>count</span> <span class=o>&gt;</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>  这个宏确定的是迭代次数，也就是获取多少次 PIT 的 MSB 。
</span></span></span><span class=line><span class=cl><span class=cm>  我们的目标是最大错误率为 500ppm（实际上真正的误差要小得多），但是耗时不能超过 50ms ，
</span></span></span><span class=line><span class=cl><span class=cm>  MAX_QUICK_PIT_MS * PIT_TICK_RATE / 1000  得到的是 50ms 内的时钟周期个数，也就是计数器减少的数值，
</span></span></span><span class=line><span class=cl><span class=cm>  最后除以 256 是因为我们只取 MSB 。 
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=cp>#define MAX_QUICK_PIT_MS 50
</span></span></span><span class=line><span class=cl><span class=cp>#define MAX_QUICK_PIT_ITERATIONS (MAX_QUICK_PIT_MS * PIT_TICK_RATE / 1000 / 256) </span><span class=c1>//=233
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=nf>quick_pit_calibrate</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>u64</span> <span class=n>tsc</span><span class=p>,</span> <span class=n>delta</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>d1</span><span class=p>,</span> <span class=n>d2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 关闭蜂鸣器 */</span>
</span></span><span class=line><span class=cl>    <span class=nf>outb</span><span class=p>((</span><span class=nf>inb</span><span class=p>(</span><span class=mh>0x61</span><span class=p>)</span> <span class=o>&amp;</span> <span class=o>~</span><span class=mh>0x02</span><span class=p>)</span> <span class=o>|</span> <span class=mh>0x01</span><span class=p>,</span> <span class=mh>0x61</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      计数器 2 , 读写方式是先低后高，工作模式是 0 , 二进制计数
</span></span></span><span class=line><span class=cl><span class=cm>      当计数器工作模式设为 0 后，该计数器的输出信号立即变为低电平，且计数过程中一直保持低电平。在经初值寄存器赋初值后，开始计数，在每个 CLK 时钟下降沿，计数器进行减 1 计数，当计数减到 0 时，OUT 输出信号变为高电平，且一直保持到该计数器重新赋初值。该信号可以作为中断请求信号。
</span></span></span><span class=line><span class=cl><span class=cm>      0 模式无自动装入计数初始值的功能，若要继续计数，则需要重新写入计数初始值。在计数期间，装入新的初始值，计数器会在初始值写入后重新开始计数。
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=nf>outb</span><span class=p>(</span><span class=mh>0xb0</span><span class=p>,</span> <span class=mh>0x43</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 从 0xffff 开始计数 */</span>
</span></span><span class=line><span class=cl>    <span class=nf>outb</span><span class=p>(</span><span class=mh>0xff</span><span class=p>,</span> <span class=mh>0x42</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>outb</span><span class=p>(</span><span class=mh>0xff</span><span class=p>,</span> <span class=mh>0x42</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      这里需要一个微小的延时，最简单的方法是第一次 PIT
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=nf>pit_verify_msb</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      下面通过一个迭代过程测量出一段时间(50ms)内 TSC 的增长
</span></span></span><span class=line><span class=cl><span class=cm>      每次循环，PIT 都会减少 256 , i 次循环就是 (I * 256 / PIT_TICK_RATE) 秒
</span></span></span><span class=line><span class=cl><span class=cm>      delta 记录的是循环过程中 TSC 数值的增长
</span></span></span><span class=line><span class=cl><span class=cm>      循环结束后，用这两个数值计算主频
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>pit_expect_msb</span><span class=p>(</span><span class=mh>0xff</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tsc</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>d1</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>MAX_QUICK_PIT_ITERATIONS</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>pit_expect_msb</span><span class=p>(</span><span class=mh>0xff</span><span class=o>-</span><span class=n>i</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>delta</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>d2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>delta</span> <span class=o>-=</span> <span class=n>tsc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>d1</span><span class=o>+</span><span class=n>d2</span> <span class=o>&gt;=</span> <span class=n>delta</span> <span class=o>&gt;&gt;</span> <span class=mi>11</span><span class=p>)</span> <span class=c1>//确保误差小于 500ppm ，不理解
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>pit_verify_msb</span><span class=p>(</span><span class=mh>0xfe</span> <span class=o>-</span> <span class=n>i</span><span class=p>))</span>  <span class=c1>//再次检测 PIT 的 MSB ，确保 PIT 的值已经是 0xfe-i
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>goto</span> <span class=n>success</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>printk</span><span class=p>(</span><span class=s>&#34;Fast TSC calibration failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>success</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>	  kHz = ticks / time-in-seconds / 1000;
</span></span></span><span class=line><span class=cl><span class=cm>	  kHz = (t2 - t1) / (I * 256 / PIT_TICK_RATE) / 1000
</span></span></span><span class=line><span class=cl><span class=cm>	  kHz = ((t2 - t1) * PIT_TICK_RATE) / (I * 256 * 1000)
</span></span></span><span class=line><span class=cl><span class=cm>      主频通过 delta 返回
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=n>delta</span> <span class=o>*=</span> <span class=n>PIT_TICK_RATE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>do_div</span><span class=p>(</span><span class=n>delta</span><span class=p>,</span> <span class=n>i</span><span class=o>*</span><span class=mi>256</span><span class=o>*</span><span class=mi>1000</span><span class=p>);</span> <span class=c1>// do_div() 是内核的 64 位除法函数，结果保持在第一参数，返回余数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printk</span><span class=p>(</span><span class=s>&#34;Fast TSC calibration using PIT</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>delta</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>通常用 PIT 快速校准 TSC 都会成功，直接用返回值作为 tsc_khz ，并赋予 cpu_khz 作为主频。如果失败，会继续用一种复杂的方式计算 PIT 和 TSC 。</p><h2 id=5proccpuinfo class="relative group">5./proc/cpuinfo <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#5proccpuinfo aria-label=锚点>#</a></span></h2><p>在用户空间，我们是通过 <code>/proc/cpuinfo</code> 文件获得 CPU 主频的。proc 文件系统中的文件，必须在内核源码的某个位置创建并使用 <code>file_operations</code> 声明，cpuinfo 的声明位于 <code>fs/proc/cpuinfo.c</code> 文件：</p><div class="highlight line-numbers"><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>    <span class=k>static</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>file_operations</span> <span class=n>proc_cpuinfo_operations</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>open</span>		<span class=o>=</span> <span class=n>cpuinfo_open</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>read</span>		<span class=o>=</span> <span class=n>seq_read</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>llseek</span>		<span class=o>=</span> <span class=n>seq_lseek</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>release</span>	<span class=o>=</span> <span class=n>seq_release</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>__init</span> <span class=nf>proc_cpuinfo_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>proc_create</span><span class=p>(</span><span class=s>&#34;cpuinfo&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>proc_cpuinfo_operations</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>然后在 <code>arch/x86/kernel/cpu/proc.c</code> 文件中有很多 <code>show_cpuinfo_*()</code> 函数，比如 <code>static int show_cpuinfo(struct seq_file *m, void *v)</code> ，它们会调用 <code>seq_printf()</code> 函数把信息输出到 /proc/cpuinfo 文件中:</p><div class="highlight line-numbers"><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=nf>show_cpuinfo</span><span class=p>(</span><span class=k>struct</span> <span class=n>seq_file</span> <span class=o>*</span><span class=n>m</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>cpuinfo_x86</span> <span class=o>*</span><span class=n>c</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>cpu</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>cpu</span> <span class=o>=</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>cpu_index</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>seq_printf</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=s>&#34;processor</span><span class=se>\t</span><span class=s>: %u</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;vendor_id</span><span class=se>\t</span><span class=s>: %s</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;cpu family</span><span class=se>\t</span><span class=s>: %d</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;model</span><span class=se>\t\t</span><span class=s>: %u</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;model name</span><span class=se>\t</span><span class=s>: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>cpu</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>c</span><span class=o>-&gt;</span><span class=n>x86_vendor_id</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>?</span> <span class=n>c</span><span class=o>-&gt;</span><span class=nl>x86_vendor_id</span> <span class=p>:</span> <span class=s>&#34;unknown&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>c</span><span class=o>-&gt;</span><span class=n>x86</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>c</span><span class=o>-&gt;</span><span class=n>x86_model</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>c</span><span class=o>-&gt;</span><span class=n>x86_model_id</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>?</span> <span class=n>c</span><span class=o>-&gt;</span><span class=nl>x86_model_id</span> <span class=p>:</span> <span class=s>&#34;unknown&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>可以看出大部分 CPU 信息都是通过 <code>struct cpuinfo_x86 *c</code> 结构获取的，这个结构的声明在 <code>arch/x86/include/asm/processor.h</code> 文件，在这个文件中搜索该结构的引用，会找到 <code>extern void cpu_detect(struct cpuinfo_x86 *c);</code> 等类似的函数，这些函数内通过 <code>cpuid()</code> 函数从硬件寄存器上读取信息，然后填充 <code>struct cpuinfo_x86 *c</code> 结构 ，这是一个内联函数 ：</p><div class="highlight line-numbers"><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>    <span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>cpuid</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>op</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=kt>unsigned</span> <span class=kt>int</span> <span class=o>*</span><span class=n>eax</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=o>*</span><span class=n>ebx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=kt>unsigned</span> <span class=kt>int</span> <span class=o>*</span><span class=n>ecx</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=o>*</span><span class=n>edx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>eax</span> <span class=o>=</span> <span class=n>op</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>ecx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>__cpuid</span><span class=p>(</span><span class=n>eax</span><span class=p>,</span> <span class=n>ebx</span><span class=p>,</span> <span class=n>ecx</span><span class=p>,</span> <span class=n>edx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>函数内的 <code>__cpuid()</code> 是封装了 <code>native_cpuid()</code> 函数的宏定义，也在这个文件里定义：</p><div class="highlight line-numbers"><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>    <span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>native_cpuid</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=o>*</span><span class=n>eax</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=o>*</span><span class=n>ebx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=o>*</span><span class=n>ecx</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=o>*</span><span class=n>edx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* ecx is often an input as well as an output. */</span>
</span></span><span class=line><span class=cl>        <span class=k>asm</span> <span class=k>volatile</span><span class=p>(</span><span class=s>&#34;cpuid&#34;</span>
</span></span><span class=line><span class=cl>            <span class=o>:</span> <span class=s>&#34;=a&#34;</span> <span class=p>(</span><span class=o>*</span><span class=n>eax</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;=b&#34;</span> <span class=p>(</span><span class=o>*</span><span class=n>ebx</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;=c&#34;</span> <span class=p>(</span><span class=o>*</span><span class=n>ecx</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;=d&#34;</span> <span class=p>(</span><span class=o>*</span><span class=n>edx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=o>:</span> <span class=s>&#34;0&#34;</span> <span class=p>(</span><span class=o>*</span><span class=n>eax</span><span class=p>),</span> <span class=s>&#34;2&#34;</span> <span class=p>(</span><span class=o>*</span><span class=n>ecx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=o>:</span> <span class=s>&#34;memory&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>这里是通过汇编指令读取相应的寄存器，这些指令属于 CPUID ，是 X86 架构的处理器补充指令，用于发现处理器的详细信息，参考<a href=https://zh.wikipedia.org/wiki/CPUID target=_blank rel=noreferrer>https://zh.wikipedia.org/wiki/CPUID</a>。</p><p>还有一些信息不是通过 CUPID 获取的，比如 CPU 主频（CPU frequency），在 <code>arch/x86/kernel/cpu/proc.c</code> 文件的 <code>show_cpuinfo()</code> 函数中可以看到：</p><div class="highlight line-numbers"><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>cpu_has</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>X86_FEATURE_TSC</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>freq</span> <span class=o>=</span> <span class=nf>cpufreq_quick_get</span><span class=p>(</span><span class=n>cpu</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>freq</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>freq</span> <span class=o>=</span> <span class=n>cpu_khz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=nf>seq_printf</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=s>&#34;cpu MHz</span><span class=se>\t\t</span><span class=s>: %u.%03u</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>freq</span> <span class=o>/</span> <span class=mi>1000</span><span class=p>,</span> <span class=p>(</span><span class=n>freq</span> <span class=o>%</span> <span class=mi>1000</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>它是先调用 <code>cpufreq_quick_get()</code> 函数返回一个值，这是 cpufrep 模块的一个函数，它的返回值与 sysfs 中 <code>/sys/devices/system/cpu/cpu[n]/cpufreq/</code> 目录下的 scaling_cur_freq 完全一致，而且可以动态变化。如果调用失败，就把 cpu_khz 作为 CPU 主频。</p><p>CPU 的主频是可以动态调节的。主频越高，功耗也越高，为了节省 CPU 的功耗和减少发热，我们可以根据当前 CPU 的负载情况，动态地提供刚好足够的主频给 CPU 。Linux 内核提供了一套框架来完成这个目标，这就是 cpufrep 子系统。</p><p>cpufrep 子系统在用户空间提供了 sysfs 接口，都位于 <code>/sys/devices/system/cpu</code> 目录下：</p><pre><code>/sys/devices/system/cpu$ ls
cpu0  cpu2  cpufreq  kernel_max  modalias  online    power    probe    uevent
cpu1  cpu3  cpuidle  microcode   offline   possible  present  release
</code></pre><h2 id=6bogomips class="relative group">6.BogoMIPS <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#6bogomips aria-label=锚点>#</a></span></h2><p>在 <code>/proc/cpuinfo</code> 中可以看到一个参数 bogomips ，在 dmesg 中也可以看到类似的信息：</p><pre><code>[    0.000001] Calibrating delay loop (skipped), value calculated using timer frequency.. 6385.48 BogoMIPS (lpj=12770964)
</code></pre><p>从字面意思也可以理解， BogoMIPS 就是伪百万次指令每秒，每秒钟可以执行几百万条指令，是一种衡量 CPU 速度的不科学方法。这条信息来自于内核 <code>init/calibrate.c</code> 文件的 <code>calibrate_delay()</code> 函数。</p><h2 id=参考 class="relative group">参考 <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e5%8f%82%e8%80%83 aria-label=锚点>#</a></span></h2><ul><li><a href=http://www.expreview.com/57334.html target=_blank rel=noreferrer>CPU 频率</a></li><li><a href=https://wiki.osdev.org/Programmable_Interval_Timer target=_blank rel=noreferrer>Programmable Interval Timer</a></li><li><a href=https://wiki.archlinux.org/index.php/CPU_frequency_scaling target=_blank rel=noreferrer>CPU frequency scaling</a></li></ul></div></section><footer class="pt-8 max-w-prose print:hidden"><div class=flex><img class="!mb-0 !mt-0 me-4 h-24 w-24 rounded-full" width=96 height=96 alt=Shaocheng.Li src=/img/author_hucdd16a8e5aab658b1bf3664f1886d7a1_71871_192x192_fill_box_center_3.png loading=lazy><div class=place-self-center><div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">作者</div><div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">Shaocheng.Li</div><div class="text-sm text-neutral-700 dark:text-neutral-400">A Linux software engineer.</div><div class="text-2xl sm:text-lg"><div class="flex flex-wrap text-neutral-400 dark:text-neutral-500"><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://github.com/exbob target=_blank aria-label=Github rel="me noopener noreferrer"><span class="relative inline-block align-text-bottom px-1 icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span></a></div></div></div></div><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="group flex" href=/posts/2018/07/05/><span class="me-2 text-neutral-700 transition-transform group-hover:-translate-x-[2px] group-hover:text-primary-600 dark:text-neutral dark:group-hover:text-primary-400"><span class="ltr:inline rtl:hidden">&larr;</span><span class="ltr:hidden rtl:inline">&rarr;</span></span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">Linux 内核调试方法</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2018-07-05 08:00:00 +0800 +0800">2018 July 5</time>
</span></span></a></span><span><a class="group flex text-right" href=/posts/2018/09/21/><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">包管理器 dnf 学习笔记</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2018-09-21 08:00:00 +0800 +0800">2018 September 21</time>
</span></span><span class="ms-2 text-neutral-700 transition-transform group-hover:-translate-x-[2px] group-hover:text-primary-600 dark:text-neutral dark:group-hover:text-primary-400"><span class="ltr:inline rtl:hidden">&rarr;</span><span class="ltr:hidden rtl:inline">&larr;</span></span></a></span></div></div><div class=pt-3><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class=pt-3><script src=https://giscus.app/client.js data-repo=exbob/exbob.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkyMzM5ODIwNTg=" data-category=Announcements data-category-id=DIC_kwDODfJIas4Cc6dQ data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light_protanopia data-lang=zh-CN crossorigin=anonymous async></script></div></div></footer></article><div class="pointer-events-none absolute bottom-0 end-0 top-[100vh] w-12"><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 backdrop-blur hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label=回到顶部 title=回到顶部>&uarr;</a></div></main><footer class="py-10 print:hidden"><div class="flex items-center justify-between"><div><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2024
Shaocheng.Li</p><p class="text-xs text-neutral-500 dark:text-neutral-400">由 <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://github.com/jpanther/congo target=_blank rel="noopener noreferrer">Congo</a> 强力驱动</p></div><div class="flex flex-row items-center"><div class="me-14 cursor-pointer text-sm text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"><button id=appearance-switcher-0 type=button aria-label="appearance switcher"><div class="flex items-center justify-center w-12 h-12 dark:hidden" title=切换为深色模式><span class="relative inline-block align-text-bottom px-1 icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden w-12 h-12 dark:flex" title=切换为浅色模式><span class="relative inline-block align-text-bottom px-1 icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></div></div></footer><div id=search-wrapper class="invisible fixed inset-0 z-50 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]" data-url=https://shaocheng.li/><div id=search-modal class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex items-center justify-between flex-none px-2"><form class="flex items-center flex-auto min-w-0"><div class="flex items-center justify-center w-8 h-8 text-neutral-400"><span class="relative inline-block align-text-bottom px-1 icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder=搜索 tabindex=0></form><button id=close-search-button class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title="关闭 (Esc)">
<span class="relative inline-block align-text-bottom px-1 icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto px-2 overflow-auto"><ul id=search-results></ul></section></div></div></div></body></html>