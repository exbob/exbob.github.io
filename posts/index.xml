<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Shaocheng.Li</title>
        <link>https://shaocheng.li/posts/</link>
        <description>Recent content in Posts on Shaocheng.Li</description>
        <generator>Hugo -- gohugo.io</generator>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Tue, 24 Mar 2020 21:15:11 +0800</lastBuildDate>
        <atom:link href="https://shaocheng.li/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>使用 pm2 管理进程</title>
            <link>https://shaocheng.li/posts/2020/03/24/</link>
            <pubDate>Tue, 24 Mar 2020 21:15:11 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2020/03/24/</guid>
            <description>PM2 是基于 nodejs 的进程管理工具，需要用 npm 安装，通常用于管理 node 进程，也可以管理其他语言编写的软件，官网是 https://pm2.keymetrics.io/ ，具有如下特性：</description>
            <content type="html"><![CDATA[<p>PM2 是基于 nodejs 的进程管理工具，需要用 npm 安装，通常用于管理 node 进程，也可以管理其他语言编写的软件，官网是 <a href="https://pm2.keymetrics.io/" target="_blank">https://pm2.keymetrics.io/</a> ，具有如下特性：</p>
]]></content>
        </item>
        
        <item>
            <title>Markdown Syntax Guide</title>
            <link>https://shaocheng.li/posts/2020/01/15/</link>
            <pubDate>Wed, 15 Jan 2020 14:31:11 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2020/01/15/</guid>
            <description>This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.
Headings The following HTML &amp;lt;h1&amp;gt;—&amp;lt;h6&amp;gt; elements represent six levels of section headings. &amp;lt;h1&amp;gt; is the highest section level while &amp;lt;h6&amp;gt; is the lowest.
H1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo.</description>
            <content type="html"><![CDATA[

<p>This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.</p>

<h1 id="headings">Headings</h1>

<p>The following HTML <code>&lt;h1&gt;</code>—<code>&lt;h6&gt;</code> elements represent six levels of section headings. <code>&lt;h1&gt;</code> is the highest section level while <code>&lt;h6&gt;</code> is the lowest.</p>

<h1 id="h1">H1</h1>

<h2 id="h2">H2</h2>

<h3 id="h3">H3</h3>

<h4 id="h4">H4</h4>

<h5 id="h5">H5</h5>

<h6 id="h6">H6</h6>

<h1 id="paragraph">Paragraph</h1>

<p>Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.</p>

<p>Itatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.</p>

<h1 id="blockquotes">Blockquotes</h1>

<p>The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.</p>

<h2 id="blockquote-without-attribution">Blockquote without attribution</h2>

<blockquote>
<p>Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.</p>
</blockquote>

<h2 id="blockquote-with-attribution">Blockquote with attribution</h2>

<blockquote>
<p>Don&rsquo;t communicate by sharing memory, share memory by communicating. — Rob Pike1</p>
</blockquote>

<h1 id="tables">Tables</h1>

<p>Tables aren&rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.</p>

<table>
<thead>
<tr>
<th>Name</th>
<th>Age</th>
</tr>
</thead>

<tbody>
<tr>
<td>Bob</td>
<td>27</td>
</tr>

<tr>
<td>Alice</td>
<td>23</td>
</tr>
</tbody>
</table>

<h1 id="code-blocks">Code Blocks</h1>

<p>Code block with backticks</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">html
<span style="color:#75715e">&lt;!DOCTYPE html&gt;</span>
&lt;<span style="color:#f92672">html</span> <span style="color:#a6e22e">lang</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;en&#34;</span>&gt;
&lt;<span style="color:#f92672">head</span>&gt;
  &lt;<span style="color:#f92672">meta</span> <span style="color:#a6e22e">charset</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;UTF-8&#34;</span>&gt;
  &lt;<span style="color:#f92672">title</span>&gt;Example HTML5 Document&lt;/<span style="color:#f92672">title</span>&gt;
&lt;/<span style="color:#f92672">head</span>&gt;
&lt;<span style="color:#f92672">body</span>&gt;
  &lt;<span style="color:#f92672">p</span>&gt;Test&lt;/<span style="color:#f92672">p</span>&gt;
&lt;/<span style="color:#f92672">body</span>&gt;
&lt;/<span style="color:#f92672">html</span>&gt;</code></pre></div>
<h1 id="list-types">List Types</h1>

<p>Ordered List</p>

<ol>
<li>First item</li>
<li>Second item</li>
<li>Third item</li>
</ol>

<p>Unordered List</p>

<ul>
<li>List item</li>
<li>Another item</li>
<li>And another item</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>iproute2 学习笔记</title>
            <link>https://shaocheng.li/posts/2020/01/08/</link>
            <pubDate>Wed, 08 Jan 2020 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2020/01/08/</guid>
            <description>iproute2 是一个 Linux 网络管理工具包，提供了 ip 、tc 、ss 等组件，集成了原有的 ifconfg 、arp 、route 、netstat 等多种命令的功能，并新增了很多特性。
1. ip 命令 ip 命令的语法是：
ip [OPTIONS] OBJECT {COMMAND|help} 其中：
 OBJECT 表示操作对象，可选的值有 { link | addr | addrlabel | route | rule | neigh | ntable | tunnel | maddr | mroute | mrule | monitor | xfrm | token } ，常用的对象包括：  link：网络设备 addr：设备上的协议（IP或IPv6）地址 addrlabel：协议地址选择的标签配置 route：路由表条目 rule：路由策略数据库中的规则 neigh: ARP 表  OPTIONS 表示选项，可选的值有 { -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] | -h[uman-readable] | -iec | -f[amily] { inet | inet6 | ipx | dnet | link } | -o[neline] | -t[imestamp] | -b[atch] [filename] | -rc[vbuf] [size] } 常用的选项包括：  -V，-Version：显示指令版本信息 -s，-stats，statistics：输出详细信息 -h，-human，-human-readable：输出人类可读的统计信息和后缀 -o，-oneline：将每条记录输出到一行，用 \字符替换换行符   1.</description>
            <content type="html"><![CDATA[

<p>iproute2 是一个 Linux 网络管理工具包，提供了 ip 、tc 、ss 等组件，集成了原有的 ifconfg 、arp 、route 、netstat 等多种命令的功能，并新增了很多特性。</p>

<h2 id="1-ip-命令">1. ip 命令</h2>

<p>ip 命令的语法是：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ip <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> OBJECT <span style="color:#f92672">{</span>COMMAND|help<span style="color:#f92672">}</span></code></pre></div>
<p>其中：</p>

<ul>
<li>OBJECT 表示操作对象，可选的值有 <code>{ link | addr | addrlabel | route | rule | neigh | ntable | tunnel | maddr | mroute | mrule | monitor | xfrm | token }</code> ，常用的对象包括：

<ul>
<li><code>link</code>：网络设备</li>
<li><code>addr</code>：设备上的协议（IP或IPv6）地址</li>
<li><code>addrlabel</code>：协议地址选择的标签配置</li>
<li><code>route</code>：路由表条目</li>
<li><code>rule</code>：路由策略数据库中的规则</li>
<li><code>neigh</code>: ARP 表</li>
</ul></li>
<li>OPTIONS 表示选项，可选的值有 <code>{ -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] | -h[uman-readable] | -iec | -f[amily] { inet | inet6 | ipx | dnet | link } | -o[neline] | -t[imestamp] | -b[atch] [filename] | -rc[vbuf] [size] }</code> 常用的选项包括：

<ul>
<li><code>-V，-Version</code>：显示指令版本信息</li>
<li><code>-s，-stats，statistics</code>：输出详细信息</li>
<li><code>-h，-human，-human-readable</code>：输出人类可读的统计信息和后缀</li>
<li><code>-o，-oneline</code>：将每条记录输出到一行，用 <code>\</code>字符替换换行符</li>
</ul></li>
</ul>

<h3 id="1-1-配置网卡">1.1 配置网卡</h3>

<p>调用 <code>ip addr</code> 可以查看所有网卡的信息和配置，也可以在后追加网卡的接口名称，单独查看特定网卡，以 <code>enp1s0</code> 为例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@localhost:~# ip addr show enp1s0
<span style="color:#ae81ff">3</span>: enp1s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style="color:#ae81ff">1500</span> qdisc mq state UP group default qlen <span style="color:#ae81ff">1000</span>
    link/ether <span style="color:#ae81ff">00</span>:1d:f3:52:b7:94 brd ff:ff:ff:ff:ff:ff
    inet <span style="color:#ae81ff">192</span>.168.5.242/24 brd <span style="color:#ae81ff">192</span>.168.5.255 scope global enp1s0
       valid_lft forever preferred_lft forever
    inet6 fe80::21d:f3ff:fe52:b794/64 scope link 
       valid_lft forever preferred_lft forever</code></pre></div>
<p>每个字段的含义：</p>

<ul>
<li><code>&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</code> : <code>BROADCAST</code>表示该接口支持广播；<code>MULTICAST</code>表示该接口支持多播；<code>UP</code>表示该网络接口已启用；<code>LOWER_UP</code>表示网络电缆已插入，设备已连接至网络。</li>
<li><code>mtu 1500</code>：最大传输单元（链路层最大一次传输的上层数据大小，也就是一个 IP 包的最大值）为 1500 字节。</li>
<li><code>qdisc mq</code>：用于数据包排队 。</li>
<li><code>state UP</code>：网络接口已启用，如果接口没有启用，会显示 DOWN 。</li>
<li><code>qlen 1000</code>：传输队列长度。</li>
<li><code>link/ether 00:1d:f3:52:b7:94</code> : 网卡的 MAC 地址。</li>
<li><code>brd ff:ff:ff:ff:ff:ff</code> : 广播 MAC 地址。</li>
<li><code>inet 192.168.5.242/24</code> : 网卡的 IPv4 地址。</li>
<li><code>brd 192.168.5.255</code> : 广播 IPv4 地址。</li>
<li><code>scope global</code>：全局有效，如果显示为 <code>link</code> 表示仅对此设备有效。</li>
<li><code>enp1s0</code> : 如果前面有 <code>dynamic</code> 字符，表示这个网卡的 IP 是动态获取的。</li>
<li><code>valid_lft forever</code> :  IP 的有效期是永久，如果是动态获取的 IP ，会显示剩余的有效时间。</li>
<li><code>preferred_lft forever</code> :  首选 IP 的地址的有效期。</li>
</ul>

<p>为网卡添加或者删除一个 IP 地址：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ip addr add/del <span style="color:#ae81ff">192</span>.168.0.123/24 dev enp1s0</code></pre></div>
<p>启动或者禁用一个网卡：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ip link set enp1s0 up/down</code></pre></div>
<p>设置网卡的其他特性也可以用 <code>ip link set</code> 语法。例如：</p>

<ul>
<li><code>arp on/off</code> : 改变网卡的 NOARP 标识，设为 off 表示禁用该网卡的 ARP 协议。网卡处于 UP 状态时不能执行这个操作。</li>
<li><code>multicast on/off</code> : 改变网卡的 MULTICAST 标识，设为 off 表示禁用该网卡的组播。</li>
<li><code>dynamic on/off</code> : 改变网卡的 DYNAMIC 标识，设为 off 表示禁止该网卡动态获取 IP。</li>
<li><code>mtu NUMBER</code> : 设置该网卡的最大传输单元。</li>
</ul>

<p>查看网卡的流量统计：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@localhost:~# ip -s -s link ls enp1s0
<span style="color:#ae81ff">3</span>: enp1s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style="color:#ae81ff">1500</span> qdisc mq state UP mode DEFAULT group default qlen <span style="color:#ae81ff">1000</span>
    link/ether <span style="color:#ae81ff">00</span>:1d:f3:52:b7:94 brd ff:ff:ff:ff:ff:ff
    RX: bytes  packets  errors  dropped overrun mcast   
    <span style="color:#ae81ff">42861012</span>   <span style="color:#ae81ff">137710</span>   <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">151</span>     
    RX errors: length   crc     frame   fifo    missed
               <span style="color:#ae81ff">0</span>        <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       
    TX: bytes  packets  errors  dropped carrier collsns 
    <span style="color:#ae81ff">520406</span>     <span style="color:#ae81ff">6159</span>     <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       
    TX errors: aborted  fifo   window heartbeat transns
               <span style="color:#ae81ff">0</span>        <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">2</span>       </code></pre></div>
<h3 id="1-2-配置路由表">1.2 配置路由表</h3>

<p>显示系统的路由表：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@localhost:~# ip route show
default via <span style="color:#ae81ff">10</span>.76.141.9 dev enp0s29u1u4c2  proto static  metric <span style="color:#ae81ff">100</span> 
<span style="color:#ae81ff">10</span>.76.141.8/29 dev enp0s29u1u4c2  proto kernel  scope link  src <span style="color:#ae81ff">10</span>.76.141.12  metric <span style="color:#ae81ff">100</span> 
<span style="color:#ae81ff">192</span>.168.5.0/24 dev enp1s0  proto kernel  scope link  src <span style="color:#ae81ff">192</span>.168.5.242  metric <span style="color:#ae81ff">100</span> 
<span style="color:#ae81ff">192</span>.168.99.0/24 dev wlp3s0  proto kernel  scope link  src <span style="color:#ae81ff">192</span>.168.99.1  metric <span style="color:#ae81ff">600</span> </code></pre></div>
<ul>
<li><p><code>default</code> 一行表示缺省路由。</p></li>

<li><p><code>via 10.76.141.9</code> 表示网关，也就是吓一跳的 IP 。</p></li>

<li><p>普通路由的第一个字段表示目标网段。</p></li>

<li><p><code>dev enp1s0</code> 表示出口网卡。</p></li>

<li><p><code>metric 100</code> 表示优先级，数字小的优先。</p></li>
</ul>

<p>添加一条到主机的静态路由：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ip route add <span style="color:#ae81ff">192</span>.0.2.1 via <span style="color:#ae81ff">192</span>.168.145.2 dev enp1s0</code></pre></div>
<ul>
<li><code>add</code> 表示添加，如果要删除可以用 del 命令</li>
<li><code>192.0.2.1</code> 表示目标主机的 IP</li>
<li><code>via 192.168.145.2</code> 表示吓一跳地址</li>
<li><code>dev enp1s0</code> 表示出口的网卡设备</li>
</ul>

<p>如果要添加到网络的静态路由，将目标地址设为一个网段即可：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ip route add <span style="color:#ae81ff">192</span>.0.2.1/24 via <span style="color:#ae81ff">192</span>.168.145.2 dev enp1s0</code></pre></div>
<p>如果要添加一条默认路由，将目标地址设为 default 即可：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ip route add default via <span style="color:#ae81ff">192</span>.168.145.2 dev enp1s0</code></pre></div>
<h3 id="1-3-配置-arp">1.3 配置 ARP</h3>

<p>查看系统的 ARP 缓存：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@localhost:~# ip neigh show
<span style="color:#ae81ff">192</span>.168.5.252 dev enp1s0 lladdr 8c:a6:df:0c:7a:0a REACHABLE
<span style="color:#ae81ff">192</span>.168.5.36 dev enp1s0 lladdr <span style="color:#ae81ff">98</span>:ee:cb:a9:c1:98 STALE
<span style="color:#ae81ff">192</span>.168.5.50 dev enp1s0 lladdr f8:7b:20:ee:d2:47 STALE
<span style="color:#ae81ff">192</span>.168.5.64 dev enp1s0 lladdr <span style="color:#ae81ff">74</span>:27:ea:6f:08:35 STALE
<span style="color:#ae81ff">10</span>.76.141.9 dev enp0s29u1u4c2 lladdr 4c:54:99:45:e5:d5 REACHABLE
fe80::4e54:99ff:fe45:e5d5 dev enp0s29u1u4c2 lladdr 4c:54:99:45:e5:d5 router REACHABLE</code></pre></div>
<p>每一行都是一条 ARP ，以第一行为例：</p>

<ul>
<li><code>192.168.5.252</code> 表示设备的 IP 。</li>
<li><code>dev enp1s0</code> 表示发现此设备的网卡。</li>
<li><code>lladdr 8c:a6:df:0c:7a:0a</code> 表示此设备的 MAC 地址。</li>
<li><code>REACHABLE</code> 表示这条 ARP 条目的状态：

<ul>
<li><code>REACHABLE</code> 表示条目有效，设备在线。</li>
<li><code>STALE</code> 表示条目有效，但是设备未必在线。</li>
<li><code>FAILED</code> 表示条目无效，设备不在线。</li>
<li><code>PERMANENT</code> 表示此条目永久有效，直到管理员将其删除，通常是手动添加的静态 ARP 绑定。</li>
</ul></li>
</ul>

<p>添加一条静态 ARP ：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ip neight add dev enp1s0 add <span style="color:#ae81ff">192</span>.168.5.50 lladdr f8:7b:20:ee:d2:47 nud permanent</code></pre></div>
<p>如果 ARP 表中已经存在了这样的 ARP 映射，执行 add 命令会报错，可以用 replace 将其替换，其他参数不变：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ip neight relpace dev enp1s0 add <span style="color:#ae81ff">192</span>.168.5.50 lladdr f8:7b:20:ee:d2:47 nud permanent</code></pre></div>
<p>删除一条 ARP 时不用这么多参数，只需指定接口和 IP 即可：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ip neight delete dev enp1s0 add <span style="color:#ae81ff">192</span>.168.5.50</code></pre></div>
<p>清空当前 ARP 表：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ip neight flush dev enp1s0</code></pre></div>
<h2 id="2-ss-命令">2. ss 命令</h2>

<p>ss 是查看 socket 连接信息的工具。常用的参数有：</p>

<ul>
<li>-a ，显示所有 socket 连接的信息。</li>
<li>-4 ，只显示 IPv4 的 socket 。</li>
<li>-6 ，只显示 IPv6 的 socket 。</li>
<li>-t ，只显示 TCP 协议的 socket 。</li>
<li>-u ，只显示 UCP 协议的 socket 。</li>
<li>-x ，只显示 Unix 域的 socket 。</li>
<li>-l ，显示处于 LISTEN 状态的 socket 。</li>
<li>-o ，显示定时器信息。</li>
<li>-p ，</li>
<li>-e ，</li>
</ul>

<h2 id="参考">参考：</h2>

<ul>
<li><p><a href="http://www.policyrouting.org/iproute2.doc.html" target="_blank">http://www.policyrouting.org/iproute2.doc.html</a></p></li>

<li><p><a href="https://linux.cn/article-3144-1.html" target="_blank">https://linux.cn/article-3144-1.html</a></p></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>UCI 和 ubus 学习笔记</title>
            <link>https://shaocheng.li/posts/2019/12/24/</link>
            <pubDate>Tue, 24 Dec 2019 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2019/12/24/</guid>
            <description>UCI 和 ubus 都是 Openwrt 项目提供的软件，UCI 提供了统一的配置文件格式和读写工具，ubus 提供了基于 Unix Socket 的进程间通信框架。两个软件都可以方便的移植到其他 Linux 系统，以 Ubuntu 系统为例，首先要安装一些依赖的软件：
apt-get install pkg-config apt-get install lua5.1 apt-get install liblua5.1-dev apt-get install cmake apt-get install libjson-c-dev 然后要编译安装 libubox ：
git clone https://git.openwrt.org/project/libubox.git cd libubox cmake . make make install 编译时可能出现找不到头文件的错误：
/root/libubox/lua/uloop.c:21:17: fatal error: lua.h: No such file or directory 这是路径问题，因为 lua 的头文件在 /usr/include/lua5.1 目录下，所有修改 uloop.c 文件，为 lua.h 等头文件前面加上 lua5.1/ 路径：
#include &amp;lt;lua5.1/lua.h&amp;gt;#include &amp;lt;lua5.1/lualib.h&amp;gt;#include &amp;lt;lua5.1/lauxlib.h&amp;gt; 1. UCI 编译安装 uci</description>
            <content type="html"><![CDATA[

<p>UCI 和 ubus 都是 Openwrt 项目提供的软件，UCI 提供了统一的配置文件格式和读写工具，ubus 提供了基于 Unix Socket 的进程间通信框架。两个软件都可以方便的移植到其他 Linux 系统，以 Ubuntu 系统为例，首先要安装一些依赖的软件：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">apt-get install pkg-config
apt-get install lua5.1
apt-get install liblua5.1-dev
apt-get install cmake
apt-get install libjson-c-dev</code></pre></div>
<p>然后要编译安装 libubox ：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git clone https://git.openwrt.org/project/libubox.git
cd libubox
cmake .
make
make install</code></pre></div>
<p>编译时可能出现找不到头文件的错误：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">/root/libubox/lua/uloop.c:21:17: fatal error: lua.h: No such file or directory</code></pre></div>
<p>这是路径问题，因为 lua 的头文件在 <code>/usr/include/lua5.1</code> 目录下，所有修改 uloop.c 文件，为 lua.h 等头文件前面加上 <code>lua5.1/</code> 路径：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;lua5.1/lua.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;lua5.1/lualib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;lua5.1/lauxlib.h&gt;</span></code></pre></div>
<h2 id="1-uci">1. UCI</h2>

<p>编译安装 uci</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git clone https://git.openwrt.org/project/uci.git
cd uci
cmake .
make 
make install</code></pre></div>
<p>安装完成后执行一次 <code>sudo ldconfig -v</code> ，否则可能找不到刚安装的共享库。</p>

<p>UCI 的配置文件格式是 <code>config -&gt; section -&gt; option</code> 这样的层级关系，它提供了 uci 命令读写配置文件，语法可以直接用 <code>uci -h</code> 获得。我们可以新建 <code>/etc/config/system</code> 文件，然后做一次配置测试：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">/etc/config$ uci add system info
cfg0184d1
/etc/config$ uci show
system.@info<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span><span style="color:#f92672">]=</span>info
/etc/config$ uci rename system.@info<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span><span style="color:#f92672">]=</span>time
/etc/config$ uci show
system.time<span style="color:#f92672">=</span>info
/etc/config$ uci set system.time.zone<span style="color:#f92672">=</span>As^C
/etc/config$ cat /etc/timezone
Asia/Chongqing
/etc/config$ uci set system.time.zone<span style="color:#f92672">=</span>Asia/Chongqing
/etc/config$ uci show
system.time<span style="color:#f92672">=</span>info
system.time.zone<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Asia/Chongqing&#39;</span>
/etc/config$ uci commit system
/etc/config$ cat system
config info <span style="color:#e6db74">&#39;time&#39;</span>
        option zone <span style="color:#e6db74">&#39;Asia/Chongqing&#39;</span></code></pre></div>
<h2 id="2-ubus">2. ubus</h2>

<p>ubus 是基于 unix socket 的进程间通信框架，包含守护进程、命令行工具和链接库，守护进程 ubusd 作为 socket server ，用户可用 lua 或者 C 语言的 API 实现 socket client ，client 和 server 之间用 json 格式进行通信，client 端的消息处理抽象处理对象（object）和方法（method）。ubus 通过对 socket 的封装，简化了进程间通信的步骤，只需按照固定模式调用 ubus 提供的API即可。有两种常见的应用场景：</p>

<ol>
<li>服务器-客户端的形式，进程 A 注册一系列服务，进程 B 调用这些服务</li>
<li>订阅-通知的形式，进程 A 提供订阅服务，其他进程可用订阅或者退订这些服务，进程 A 可用向所有订阅者发布消息</li>
</ol>

<p>编译安装 ubus</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git clone https://git.openwrt.org/project/ubus.git
cd ubus
cmake .
make
make install</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Python Socket 编程笔记</title>
            <link>https://shaocheng.li/posts/2019/11/26/</link>
            <pubDate>Tue, 26 Nov 2019 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2019/11/26/</guid>
            <description>1. 套接字 套接字（Socket）是一种操作系统提供的进程间通信机制，可以用于不同主机间的进程通信，最早由 UNIX 提出，现在广泛用于各种操作系统，同时也特指这种机制下的通信端点。根据通信地址的不同种类，Socket 可以分为三类：
 INET ，这是 IPv4 地址域的套接字，用于 IPv4 网络间的通信。 INET6 ，这是 IPv6 地址域的套接字，用于 IPv6 网络间的通信。 UNIX ，这是 UNIX 域的套接字，用于主机内的进程间通信。  套接字常用的报文类型有两种：
 SOCK_DGRAM，固定长度，无连接不可靠的报文传递，两个对等进程之间通信时不需要建立逻辑连接，直接向对方的套接字发送报文即可。在 INET 套接字中，这种报文使用的默认协议是 UDP 。 SOCK_STREAM，有序的，可靠的，双向的，面向连接的字节流，两个对等进程在正式通信之前，要先建立逻辑连接。在 INET 套接字中，这种报文使用的默认协议是 TCP 。  Python 提供了 socket 模块用于底层 socket 通信，模块提供了一个同名的类，以及其他读写 socket 的方法。
2. 获得主机信息 获取本机的名字和 IP ：
$ python3 Python 3.7.4 (default, Jul 9 2019, 18:13:23) [Clang 10.0.1 (clang-1001.0.46.4)] on darwin Type &amp;#34;help&amp;#34;, &amp;#34;copyright&amp;#34;, &amp;#34;credits&amp;#34; or &amp;#34;license&amp;#34; for more information.</description>
            <content type="html"><![CDATA[

<h2 id="1-套接字">1. 套接字</h2>

<p>套接字（Socket）是一种操作系统提供的进程间通信机制，可以用于不同主机间的进程通信，最早由 UNIX 提出，现在广泛用于各种操作系统，同时也特指这种机制下的通信端点。根据通信地址的不同种类，Socket 可以分为三类：</p>

<ol>
<li>INET ，这是 IPv4 地址域的套接字，用于 IPv4 网络间的通信。</li>
<li>INET6 ，这是 IPv6 地址域的套接字，用于 IPv6 网络间的通信。</li>
<li>UNIX ，这是 UNIX 域的套接字，用于主机内的进程间通信。</li>
</ol>

<p>套接字常用的报文类型有两种：</p>

<ul>
<li>SOCK_DGRAM，固定长度，无连接不可靠的报文传递，两个对等进程之间通信时不需要建立逻辑连接，直接向对方的套接字发送报文即可。在 INET 套接字中，这种报文使用的默认协议是 UDP 。</li>
<li>SOCK_STREAM，有序的，可靠的，双向的，面向连接的字节流，两个对等进程在正式通信之前，要先建立逻辑连接。在 INET 套接字中，这种报文使用的默认协议是 TCP 。</li>
</ul>

<p>Python 提供了 socket 模块用于底层 socket 通信，模块提供了一个同名的类，以及其他读写 socket 的方法。</p>

<h2 id="2-获得主机信息">2. 获得主机信息</h2>

<p>获取本机的名字和 IP ：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#960050;background-color:#1e0010">$</span> python3
Python <span style="color:#ae81ff">3.7</span><span style="color:#f92672">.</span><span style="color:#ae81ff">4</span> (default, Jul  <span style="color:#ae81ff">9</span> <span style="color:#ae81ff">2019</span>, <span style="color:#ae81ff">18</span>:<span style="color:#ae81ff">13</span>:<span style="color:#ae81ff">23</span>)
[Clang <span style="color:#ae81ff">10.0</span><span style="color:#f92672">.</span><span style="color:#ae81ff">1</span> (clang<span style="color:#f92672">-</span><span style="color:#ae81ff">1001.0</span><span style="color:#f92672">.</span><span style="color:#ae81ff">46.4</span>)] on darwin
Type <span style="color:#e6db74">&#34;help&#34;</span>, <span style="color:#e6db74">&#34;copyright&#34;</span>, <span style="color:#e6db74">&#34;credits&#34;</span> <span style="color:#f92672">or</span> <span style="color:#e6db74">&#34;license&#34;</span> <span style="color:#66d9ef">for</span> more information<span style="color:#f92672">.</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#f92672">import</span> socket
<span style="color:#f92672">&gt;&gt;&gt;</span> socket<span style="color:#f92672">.</span>gethostname()
<span style="color:#e6db74">&#39;lscMBP.local&#39;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> socket<span style="color:#f92672">.</span>gethostbyname(<span style="color:#e6db74">&#39;lscMBP.local&#39;</span>)
<span style="color:#e6db74">&#39;127.0.0.1&#39;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> socket<span style="color:#f92672">.</span>gethostbyname(<span style="color:#e6db74">&#39;localhost&#39;</span>)
<span style="color:#e6db74">&#39;127.0.0.1&#39;</span></code></pre></div>
<p>也可以通过域名获得远程主机的 IP ：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> socket<span style="color:#f92672">.</span>gethostbyname(<span style="color:#e6db74">&#39;www.baidu.com&#39;</span>)
<span style="color:#e6db74">&#39;14.215.177.38&#39;</span></code></pre></div>
<p>以上方法返回的 IP 地址都是 str 类型，socket 模块提供格式转换的方法，可以把字符串转换为 32 位的整型：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> addr <span style="color:#f92672">=</span> socket<span style="color:#f92672">.</span>gethostbyname(<span style="color:#e6db74">&#39;localhost&#39;</span>)
<span style="color:#f92672">&gt;&gt;&gt;</span> addr
<span style="color:#e6db74">&#39;127.0.0.1&#39;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> socket<span style="color:#f92672">.</span>inet_aton(addr)
<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x7f\x00\x00\x01</span><span style="color:#e6db74">&#39;</span></code></pre></div>
<p>也可以把 32 位整型 IP 地址转换为字符串：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> socket<span style="color:#f92672">.</span>inet_ntoa(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\xc0\xa8\x00\x01</span><span style="color:#e6db74">&#39;</span>)
<span style="color:#e6db74">&#39;192.168.0.1&#39;</span></code></pre></div>
<h2 id="3-udp-socket">3. UDP socket</h2>

<p>socket 编程的第一步，通常是先新建一个 socket 对象，作为通信端点自身的抽象，最基本的方法是：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">socket<span style="color:#f92672">.</span>socket(family<span style="color:#f92672">=</span>AF_INET, type<span style="color:#f92672">=</span>SOCK_STREAM, proto<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, fileno<span style="color:#f92672">=</span>None)</code></pre></div>
<p>参数 family 用于设置域，常用的值是：</p>

<ul>
<li>AF_INET : IPv4 域</li>
<li>AF_UNIX : UNIX 域</li>
</ul>

<p>参数 type 用于设置报文的类型，常用的值是：</p>

<ul>
<li>SOCK_STREAM : 有序的，可靠的，双向的，面向连接的字节流</li>
<li>SOCK_DGRAM : 固定长度的，无连接的，不可靠的数据报</li>
</ul>

<p>参数 proto 用于设置协议类型，0 表示默认，对于 SOCK_STREAM 类型，默认的协议就是 TCP ，对于 SOCK_DGRAM 类型，默认的协议就是 UDP 。</p>

<p>新建 socket 后，可以调用 <code>socket.bind()</code> 方法为 socket 对象绑定一个本机的 IP 和端口，表示用该端口收发数据：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">socket<span style="color:#f92672">.</span>bind(address)</code></pre></div>
<ul>
<li>对于 AF_INET , address 应该是一个元组 (host, port) ，host 是一个表示 IPv4 或者域名的字符串，host 是表示端口号的数字。</li>
<li>对于 AF_UNIX ，address 应该是一个表示 sock 文件绝对路径的字符串</li>
</ul>

<p>如果没有调用 <code>socket.bind()</code> 绑定端口，系统会为 socket 随机分配可用的端口。所以，接收方必须绑定端口，发送方通常可用等待系统分配，下面是一个简单的例子。</p>

<p>接收方绑定了 UDP:20000 端口，循环接收数据，并打印发送方的地址：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#!/usr/bin/env  python3</span>

<span style="color:#f92672">import</span> socket

<span style="color:#66d9ef">with</span> socket<span style="color:#f92672">.</span>socket(socket<span style="color:#f92672">.</span>AF_INET, socket<span style="color:#f92672">.</span>SOCK_DGRAM) <span style="color:#66d9ef">as</span> s :
    s<span style="color:#f92672">.</span>bind((<span style="color:#e6db74">&#39;127.0.0.1&#39;</span>, <span style="color:#ae81ff">20000</span>))
    <span style="color:#66d9ef">while</span> True :
        data, addr <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span>recvfrom(<span style="color:#ae81ff">1024</span>)
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;Received&#39;</span>, repr(data), <span style="color:#e6db74">&#39;from&#39;</span>, repr(addr))</code></pre></div>
<p>发送方向指定的地址发送一个字符串：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#!/usr/bin/env  python3</span>

<span style="color:#f92672">import</span> socket

<span style="color:#66d9ef">with</span> socket<span style="color:#f92672">.</span>socket(socket<span style="color:#f92672">.</span>AF_INET, socket<span style="color:#f92672">.</span>SOCK_DGRAM) <span style="color:#66d9ef">as</span> s :
    s<span style="color:#f92672">.</span>sendto(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;Hello world&#39;</span>, (<span style="color:#e6db74">&#39;127.0.0.1&#39;</span>, <span style="color:#ae81ff">20000</span>))</code></pre></div>
<p>对于 UDP ，新建 socket 后，不需要建立连接，可用直接向对方的 IP 和端口发送数据。通常用 <code>socket.redvfrom()</code> 和 <code>socket.sendto()</code> 函数收发 UDP 数据。</p>

<h2 id="4-tcp-socket">4. TCP socket</h2>

<p>TCP 有如下几个特点：</p>

<ul>
<li>面向连接，发送数据前必须建立连接，确认接收方存在</li>
<li>有序传送，数据按发送者写入的顺序被读取</li>
<li>可靠，网络传输中丢失的数据包会被检测到并重新发送</li>
</ul>

<p>TCP socket 编程的 API 调用次序如下：</p>

<p><img src="/images/2019-11-26/2019-11-26_1.jpg" alt="" /></p>

<p>服务器端的 socket 绑定本机 IP 和端口后，调用 <code>socket.listen()</code> 方法表示愿意接受连接请求：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">socket<span style="color:#f92672">.</span>listen([backlog])</code></pre></div>
<p>参数 backlog 可选，如果没有设置，系统会提供一个默认值，表示该进程允许进去请求队列的的连接数量的最大值，如果队列满了，会拒绝多余的连接请求。所以，backlog 的值应该基于服务器期望负载和处理的连接数量进行设置。</p>

<p>之后，套接字可以调用 <code>socket.accept()</code> 方法获得连接请求，并建立连接：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">socket<span style="color:#f92672">.</span>accept()</code></pre></div>
<p>默认情况下这个方法会阻塞，收到客户端的请求后会返回一个元组 (conn, address) ，其中，conn 是客户端的 socket ，用于向客户端收发数据，address 是客户端 socket 绑定的地址。</p>

<p>客户端可以调用 <code>socket.connect()</code> 方法向服务器端发起连接：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">socket<span style="color:#f92672">.</span>connect(address)</code></pre></div>
<p>参数 address 是表示服务器端地址的元组 (host, port) ，调用失败会抛出一个 OSError 异常。连接成功后，可以调用 <code>socket.send()</code> 和 <code>socket.recv()</code> 收发数据，下面是一个简单的例子。</p>

<p>服务器端：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#!/usr/bin/env  python3</span>

<span style="color:#f92672">import</span> socket

host <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;127.0.0.1&#34;</span>
port <span style="color:#f92672">=</span> <span style="color:#ae81ff">20000</span>

<span style="color:#66d9ef">with</span> socket<span style="color:#f92672">.</span>socket(socket<span style="color:#f92672">.</span>AF_INET, socket<span style="color:#f92672">.</span>SOCK_STREAM) <span style="color:#66d9ef">as</span> s :
    s<span style="color:#f92672">.</span>bind((host, port))
    s<span style="color:#f92672">.</span>listen()
    conn, addr <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span>accept()
    <span style="color:#66d9ef">with</span> conn :
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Connected by&#34;</span>, addr)
        <span style="color:#66d9ef">while</span> True :
            data <span style="color:#f92672">=</span> conn<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">1024</span>) <span style="color:#75715e">#阻塞，直到对方 socket 关闭</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> data :
                <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Received finish&#34;</span>)
                <span style="color:#66d9ef">break</span>
            <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Received : &#34;</span>, repr(data))
            conn<span style="color:#f92672">.</span>sendall(data)
            <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Reply !&#34;</span>)</code></pre></div>
<p>客户端：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#!/usr/bin/env  python3</span>

<span style="color:#f92672">import</span> socket

host <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;127.0.0.1&#34;</span>
port <span style="color:#f92672">=</span> <span style="color:#ae81ff">20000</span>

<span style="color:#66d9ef">with</span> socket<span style="color:#f92672">.</span>socket(socket<span style="color:#f92672">.</span>AF_INET, socket<span style="color:#f92672">.</span>SOCK_STREAM) <span style="color:#66d9ef">as</span> s :
    <span style="color:#66d9ef">try</span> :
        s<span style="color:#f92672">.</span>connect((host, port))
        s<span style="color:#f92672">.</span>sendall(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;Hello world&#39;</span>)
        data <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">1024</span>) <span style="color:#75715e"># 阻塞，直到对方 socket 关闭</span>
    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">OSError</span> <span style="color:#66d9ef">as</span> err :
        <span style="color:#66d9ef">print</span>(err)
    <span style="color:#66d9ef">else</span> :
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Received : &#34;</span>, repr(data))</code></pre></div>
<h2 id="5-unix-socket">5. UNIX socket</h2>

<p>UNIX 域套接字用于同一台主机内的进程间通信，也提供 STREAM 和 DGRAM 两种报文类型，但 UNIX 域套接字的 DGRAM 是可靠的，不会丢失也不会传递出错。编程方法与 INET 域类似，只是 UNIX socket 需要绑定的地址是主机上的 socket 类型文件，下面是一个 STREAM 类型的例子。</p>

<p>服务器端：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#!/usr/bin/env  python3</span>

<span style="color:#f92672">import</span> socket
<span style="color:#f92672">import</span> os

SOCK <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;./server.sock&#34;</span>
<span style="color:#66d9ef">if</span> os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>exists(SOCK):
    os<span style="color:#f92672">.</span>remove(SOCK)

<span style="color:#66d9ef">with</span> socket<span style="color:#f92672">.</span>socket(socket<span style="color:#f92672">.</span>AF_UNIX, socket<span style="color:#f92672">.</span>SOCK_STREAM) <span style="color:#66d9ef">as</span> s :
    s<span style="color:#f92672">.</span>bind(SOCK)
    s<span style="color:#f92672">.</span>listen()
    conn, _ <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span>accept()
    <span style="color:#66d9ef">with</span> conn :
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Connected by&#34;</span>, SOCK)
        <span style="color:#66d9ef">while</span> True :
            data <span style="color:#f92672">=</span> conn<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">1024</span>)
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> data :
                <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Received finish&#34;</span>)
                <span style="color:#66d9ef">break</span>
            <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Received :&#34;</span>, repr(data))
            conn<span style="color:#f92672">.</span>sendall(data)
            <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Reply !&#34;</span>)

os<span style="color:#f92672">.</span>remove(SOCK)</code></pre></div>
<p>客户端：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#!/usr/bin/env  python3</span>

<span style="color:#f92672">import</span> socket

SOCK <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;./server.sock&#34;</span>

<span style="color:#66d9ef">with</span> socket<span style="color:#f92672">.</span>socket(socket<span style="color:#f92672">.</span>AF_UNIX, socket<span style="color:#f92672">.</span>SOCK_STREAM) <span style="color:#66d9ef">as</span> s :
    <span style="color:#66d9ef">try</span> :
        s<span style="color:#f92672">.</span>connect(SOCK)
        s<span style="color:#f92672">.</span>sendall(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;Hello world&#39;</span>)
        data <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">1024</span>)
    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">OSError</span> <span style="color:#66d9ef">as</span> err :
        <span style="color:#66d9ef">print</span>(err)
    <span style="color:#66d9ef">else</span> :
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Received : &#34;</span>, repr(data))</code></pre></div>
<h2 id="6-bytes-对象">6. bytes 对象</h2>

<p>socket 只能收发 bytes 类型的数据，这是 Python 内建的一个数据类型，是用于表示字节序列的对象，bytes 对象提供的很多方法仅在处理 ASCII 兼容数据时有效，且与字符串对象密切相关。bytes 类的定义：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">bytes</span>([source[, encoding[, errors]]])</code></pre></div>
<ul>
<li>如果 source 是一个整数，会返回一个长度为 source ，内容全为 0 的初始化字节序列。</li>

<li><p>如果 source 是一个字符串，会按照 encoding 指定的编码将字符串转换为字节序列。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> b<span style="color:#f92672">=</span>bytes(<span style="color:#ae81ff">10</span>)
<span style="color:#f92672">&gt;&gt;&gt;</span> b
<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00</span><span style="color:#e6db74">&#39;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> a<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;hello&#34;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> b<span style="color:#f92672">=</span>bytes(a,<span style="color:#e6db74">&#39;ascii&#39;</span>)
<span style="color:#f92672">&gt;&gt;&gt;</span> b
<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;hello&#39;</span></code></pre></div></li>
</ul>

<p>更简便的方法是在一个字符串前面加上字符 <code>b</code> ，表示这是一个 bytes 类型的字符串：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> a<span style="color:#f92672">=</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;hello&#39;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> type(a)
<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#a6e22e">bytes</span><span style="color:#e6db74">&#39;&gt;</span></code></pre></div>
<p>str 类型的字符串可以调用 <code>encode()</code> 方法转换为 bytes 类型：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> a<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;hello&#39;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> a<span style="color:#f92672">.</span>encode()
<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;hello&#39;</span></code></pre></div>
<p>bytes 类型的字符串可以调用 <code>decode()</code> 方法转换为 str 类型：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> a<span style="color:#f92672">=</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;hello&#39;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> a<span style="color:#f92672">.</span>decode()
<span style="color:#e6db74">&#39;hello&#39;</span></code></pre></div>
<p>bytes 类提供了 <code>hex()</code> 方法，可以返回实例的十六进制数字的字符串对象：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> a<span style="color:#f92672">=</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;hello&#39;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> a<span style="color:#f92672">.</span>hex()
<span style="color:#e6db74">&#39;68656c6c6f&#39;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> type(a<span style="color:#f92672">.</span>hex())
<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#a6e22e">str</span><span style="color:#e6db74">&#39;&gt;</span></code></pre></div>
<p>除了显式 ASCII 字符，也可以直接定义一串十六进制序列，这样，非 ASCII 字符也可以使用 bytes ：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> a<span style="color:#f92672">=</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x68\x65\x6c</span><span style="color:#e6db74">&#39;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> a
<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;hel&#39;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> a<span style="color:#f92672">=</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x01\x02</span><span style="color:#e6db74">&#39;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> a
<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x01\x02</span><span style="color:#e6db74">&#39;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> a<span style="color:#f92672">.</span>hex()
<span style="color:#e6db74">&#39;0102&#39;</span></code></pre></div>
<p>因为 bytes 是以字节为单位的序列，可以用下标索引读取每个字节：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> a<span style="color:#f92672">=</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;hello&#39;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> a<span style="color:#f92672">.</span>hex()
<span style="color:#e6db74">&#39;68656c6c6f&#39;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> a[<span style="color:#ae81ff">0</span>]
<span style="color:#ae81ff">104</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> a[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">2</span>]
<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;he&#39;</span></code></pre></div>
<p>也可以用 <code>list()</code> 方法把 bytes 转换为元组，或者用元组定义 bytes ：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> a<span style="color:#f92672">=</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;hello&#39;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> list(a)
[<span style="color:#ae81ff">104</span>, <span style="color:#ae81ff">101</span>, <span style="color:#ae81ff">108</span>, <span style="color:#ae81ff">108</span>, <span style="color:#ae81ff">111</span>]
<span style="color:#f92672">&gt;&gt;&gt;</span> b<span style="color:#f92672">=</span>bytes([<span style="color:#ae81ff">104</span>, <span style="color:#ae81ff">101</span>, <span style="color:#ae81ff">108</span>, <span style="color:#ae81ff">108</span>, <span style="color:#ae81ff">111</span>])
<span style="color:#f92672">&gt;&gt;&gt;</span> b
<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;hello&#39;</span></code></pre></div>
<p>利用这个特性，我们可以处理非 ASCII 编码的数据，例如把一个 32 位无符号整数变成长度为 4 的 bytes ：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x12345678</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> n
<span style="color:#ae81ff">305419896</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> b1 <span style="color:#f92672">=</span> (n<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xff000000</span>) <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">24</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> b2 <span style="color:#f92672">=</span> (n<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xff0000</span>) <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">16</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> b3 <span style="color:#f92672">=</span> (n<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xff00</span>) <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">8</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> b4 <span style="color:#f92672">=</span> (n<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xff</span>)
<span style="color:#f92672">&gt;&gt;&gt;</span> bs <span style="color:#f92672">=</span> bytes([b1, b2, b3, b4])
<span style="color:#f92672">&gt;&gt;&gt;</span> bs
<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x12</span><span style="color:#e6db74">4Vx&#39;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> bs<span style="color:#f92672">.</span>hex()
<span style="color:#e6db74">&#39;12345678&#39;</span></code></pre></div>
<h2 id="7-struct-模块">7. Struct 模块</h2>

<p>非 ASCII 编码的数据转换为 bytes 对象比较麻烦，python 提供了 struct 模块来解决二进制数据类型与 bytes 之间的转换。<code>struct.pack()</code> 函数可以把任意数据类型转换为 bytes ：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">struct<span style="color:#f92672">.</span>pack(format, v1, v2, <span style="color:#f92672">...</span>)</code></pre></div>
<p>第一个参数是处理指令，后面的参数是要处理的数据，返回一个 bytes 对象，例如把一个 32 位无符号整数变成长度为 4 的 bytes ：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#f92672">import</span> struct
<span style="color:#f92672">&gt;&gt;&gt;</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#39;&gt;I&#39;</span>,<span style="color:#ae81ff">0x12345678</span>)
<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x12</span><span style="color:#e6db74">4Vx&#39;</span></code></pre></div>
<p><code>&gt;I</code> 中的 <code>&gt;</code> 表示字节序是大端，也就是网络序，<code>I</code> 表示一个 4 字节的无符号整数，后面的数据要和处理指令一致。处理指令的第一个字符总要定义字节序、大小和对齐方式，可选如下字符：</p>

<table>
<thead>
<tr>
<th align="left">字符</th>
<th>字节序</th>
<th>大小</th>
<th>对齐方式</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">@</td>
<td>原生</td>
<td>原生</td>
<td>原生</td>
</tr>

<tr>
<td align="left">=</td>
<td>原生</td>
<td>标准</td>
<td>无</td>
</tr>

<tr>
<td align="left">&lt;</td>
<td>小端</td>
<td>标准</td>
<td>无</td>
</tr>

<tr>
<td align="left">&gt;</td>
<td>大端</td>
<td>标准</td>
<td>无</td>
</tr>

<tr>
<td align="left">!</td>
<td>网络序（大端）</td>
<td>标准</td>
<td>无</td>
</tr>
</tbody>
</table>

<ul>
<li>如果没有设置，默认使用 <code>@</code> 。</li>
<li>字节序分为大端和小端，<code>原生</code> 表示与本地的主机系统保持一致。</li>
<li>大小是指不同类型所占的字节数，<code>原生</code> 表示与本机使用的 C 编译器保持一致，<code>标准</code> 是指 struct 模块内置的标准大小，参考下面的格式字符表。</li>
<li>字节对齐方式与 C 语言相同。</li>
</ul>

<p>字节序是指数据存储方式，Intel 处理和 Linux 系统都是小端，也就是低位数据存放在高位地址上，而 TCP/IP 协议使用的网络序是大端，低位数据存放在低位地址上。例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> a<span style="color:#f92672">=</span><span style="color:#ae81ff">0x01020304</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#34;I&#34;</span>, a)
<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x04\x03\x02\x01</span><span style="color:#e6db74">&#39;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#34;!I&#34;</span>, a)
<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x01\x02\x03\x04</span><span style="color:#e6db74">&#39;</span></code></pre></div>
<p>struct 模块的本质是把 C 语言的数据类型转换为 Python 的数据类型，常用的类型转换如下表所示：</p>

<table>
<thead>
<tr>
<th>字符</th>
<th>C 类型</th>
<th>Python 类型</th>
<th>大小</th>
<th>备注</th>
</tr>
</thead>

<tbody>
<tr>
<td>c</td>
<td>char</td>
<td>bytes of length 1</td>
<td>1</td>
<td></td>
</tr>

<tr>
<td>b</td>
<td>signed char</td>
<td>integer</td>
<td>1</td>
<td></td>
</tr>

<tr>
<td>B</td>
<td>unsigned char</td>
<td>integer</td>
<td>1</td>
<td></td>
</tr>

<tr>
<td>?</td>
<td>_Bool</td>
<td>bool</td>
<td>1</td>
<td></td>
</tr>

<tr>
<td>h</td>
<td>short</td>
<td>integer</td>
<td>2</td>
<td></td>
</tr>

<tr>
<td>H</td>
<td>unsigned short</td>
<td>integer</td>
<td>2</td>
<td></td>
</tr>

<tr>
<td>i</td>
<td>int</td>
<td>integer</td>
<td>4</td>
<td></td>
</tr>

<tr>
<td>I</td>
<td>unsigned int</td>
<td>integer</td>
<td>4</td>
<td></td>
</tr>

<tr>
<td>l</td>
<td>long</td>
<td>integer</td>
<td>4</td>
<td></td>
</tr>

<tr>
<td>L</td>
<td>unsigned long</td>
<td>integer</td>
<td>4</td>
<td></td>
</tr>

<tr>
<td>q</td>
<td>long long</td>
<td>integer</td>
<td>8</td>
<td></td>
</tr>

<tr>
<td>Q</td>
<td>unsigned long long</td>
<td>integer</td>
<td>8</td>
<td></td>
</tr>

<tr>
<td>f</td>
<td>float</td>
<td>float</td>
<td>4</td>
<td></td>
</tr>

<tr>
<td>d</td>
<td>double</td>
<td>float</td>
<td>8</td>
<td></td>
</tr>

<tr>
<td>s</td>
<td>char[]</td>
<td>bytes</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<p>在字符前可以加一个数字，表示有连续多个这样的数据，例如 <code>4I</code> 等同于 <code>IIII</code> 。对于 s 字符，默认只会去 bytes 数据的第一个字节，如果前面加一个数字，表示取 bytes 数去的前面几个字节。</p>

<p><code>struct.unpack()</code> 函数可以把 bytes 类型转换为其他数据类型，例如把一个 6 字节的 bytes 转换为一个 4 字节的无符号整数和一个 2 字节的无符号整数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> struct<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#39;&gt;IH&#39;</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\xf0\xf0\xf0\xf0\x08\x08</span><span style="color:#e6db74">&#39;</span>)
(<span style="color:#ae81ff">4042322160</span>, <span style="color:#ae81ff">2056</span>)</code></pre></div>
<p>举例填充一个数据帧，由两个单字节整数，一个四字节整数和四个字符组成：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> buff <span style="color:#f92672">=</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#39;2BI4s&#39;</span>, <span style="color:#ae81ff">0x01</span>, <span style="color:#ae81ff">0x02</span>, <span style="color:#ae81ff">0x12345678</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;will&#39;</span>)
<span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#66d9ef">print</span>(buff)
<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x01\x02\x00\x00</span><span style="color:#e6db74">xV4</span><span style="color:#ae81ff">\x12</span><span style="color:#e6db74">will&#39;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> a <span style="color:#f92672">=</span> struct<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#39;2BI4s&#39;</span>,buff)
<span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#66d9ef">print</span>(a)
(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">305419896</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;will&#39;</span>)
<span style="color:#f92672">&gt;&gt;&gt;</span> struct<span style="color:#f92672">.</span>calcsize(<span style="color:#e6db74">&#39;2BI4s&#39;</span>)
<span style="color:#ae81ff">12</span></code></pre></div>
<p><code>struct.calcsize()</code> 函数用于计算数据格式所占的字节数，为了与 <code>I</code> 型数据字节对齐，两个 <code>B</code> 型数据都填充了一个字节，所以实际占用了 12 个字节。</p>

<p>上面处理的数据帧中，每个位置的长度都是固定的，而现实中的很多协议都有不定长的字段，处理这种数据时，需要把字段长度也一起打包，后面才方便解包。例如打包一个长度不定的字符串：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> s <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;hello&#39;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> data <span style="color:#f92672">=</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#34;I</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">s&#34;</span> <span style="color:#f92672">%</span> len(s), len(s), s)
<span style="color:#f92672">&gt;&gt;&gt;</span> data
<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x05\x00\x00\x00</span><span style="color:#e6db74">hello&#39;</span></code></pre></div>
<p>解包的时候先获取字符串长度，然后在读取字符串：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> int_size <span style="color:#f92672">=</span> struct<span style="color:#f92672">.</span>calcsize(<span style="color:#e6db74">&#34;I&#34;</span>)
<span style="color:#f92672">&gt;&gt;&gt;</span> (i,)<span style="color:#f92672">=</span>struct<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#34;I&#34;</span>, data[:int_size])
<span style="color:#f92672">&gt;&gt;&gt;</span> i
<span style="color:#ae81ff">5</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> data_content <span style="color:#f92672">=</span> struct<span style="color:#f92672">.</span>unpack(<span style="color:#e6db74">&#34;I</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">s&#34;</span> <span style="color:#f92672">%</span> i, data)
<span style="color:#f92672">&gt;&gt;&gt;</span> data_content
(<span style="color:#ae81ff">5</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;hello&#39;</span>)</code></pre></div>
<h2 id="8-非阻塞和超时">8. 非阻塞和超时</h2>

<p>sokcet 对象有三种模式：阻塞、非阻塞和超时：</p>

<ul>
<li>阻塞，会一直等待，直到操作成功，或者返回错误。</li>
<li>非阻塞，无论操作是否成功，都会立即返回，等待时间为 0 。</li>
<li>超时，会等待一段时间，之后会返回一个超时错误。</li>
</ul>

<p>默认情况下，新建的 socket 对象总是阻塞的，<code>accept()</code> 、<code>connect()</code>  和 <code>recv()</code> 等方法都会受到阻塞的影响。可以调用如下函数设为非阻塞：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">socket<span style="color:#f92672">.</span>setblocking(flag)</code></pre></div>
<ul>
<li>flag 设为 Ture 表示阻塞。</li>
<li>flag 设为 False 表示非阻塞。</li>
</ul>

<p>非阻塞模式下，默认的等待时间是 0 ，可以设置等待时间，这样就会变为超时模式，设置方法是：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">socket<span style="color:#f92672">.</span>settimeout(value)</code></pre></div>
<p>参数 value 应该设置一个浮点数，时间单位是秒。</p>

<p>通过 <code>socket.accept()</code> 方法返回的 socket 对象是什么模式，取决于多种因素，最好设置一次。</p>

<h2 id="9-并发">9. 并发</h2>

<p>实现 Socket 服务器并发的为了同时接收并处理更多的客户端连接，方法有很多，比如多线程，接收到一个客户端连接后就新建一个线程去处理，主线程继续等待新的连接。以 Unix Socket 为例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#!/usr/bin/env  python3</span>
<span style="color:#f92672">import</span> threading
<span style="color:#f92672">import</span> socket
<span style="color:#f92672">import</span> os

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">handle</span>(conn):
    <span style="color:#66d9ef">print</span>(threading<span style="color:#f92672">.</span>current_thread()<span style="color:#f92672">.</span>name)
    <span style="color:#66d9ef">with</span> conn :
        <span style="color:#66d9ef">while</span> True :
            data <span style="color:#f92672">=</span> conn<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">1024</span>)
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> data :
                <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Received finish&#34;</span>)
                <span style="color:#66d9ef">break</span>
            <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Received :&#34;</span>, repr(data))
            conn<span style="color:#f92672">.</span>sendall(data)
            <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Reply !&#34;</span>)
    <span style="color:#66d9ef">return</span>

SOCK <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;./server.sock&#34;</span>
<span style="color:#66d9ef">if</span> os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>exists(SOCK):
    os<span style="color:#f92672">.</span>remove(SOCK)

<span style="color:#66d9ef">with</span> socket<span style="color:#f92672">.</span>socket(socket<span style="color:#f92672">.</span>AF_UNIX, socket<span style="color:#f92672">.</span>SOCK_STREAM) <span style="color:#66d9ef">as</span> s :
    s<span style="color:#f92672">.</span>bind(SOCK)
    s<span style="color:#f92672">.</span>listen()
    <span style="color:#66d9ef">while</span> True :
        conn, _ <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span>accept()
        t <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Thread(target<span style="color:#f92672">=</span>handle, args<span style="color:#f92672">=</span>(conn, ))
        t<span style="color:#f92672">.</span>start()

os<span style="color:#f92672">.</span>remove(SOCK)</code></pre></div>
<h2 id="参考">参考</h2>

<ul>
<li><a href="https://docs.python.org/3/library/socket.html" target="_blank">socket 文档</a></li>
<li><a href="https://python-parallel-programmning-cookbook.readthedocs.io/zh_CN/latest/index.html" target="_blank">Python并行编程</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Ubuntu 下获取和编译内核源码的方法</title>
            <link>https://shaocheng.li/posts/2019/09/20/</link>
            <pubDate>Fri, 20 Sep 2019 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2019/09/20/</guid>
            <description>以 Ubuntu 16.04 为例，如果只想获得当前内核版本的源码可以用 apt-get ，如果想获取当前系统的所有内核源码建议用 git 。
1. apt-get 通常是用 apt-get source 下载：
apt-get source linux-image-$(uname -r)  源码会直接下载到当前目录，并自动解压，所以建议在 /usr/src/ 目录下执行：
root@ubuntu:/usr/src# ls linux-4.4.0 linux_4.4.0-161.189.dsc linux-headers-4.4.0-142 linux_4.4.0-161.189.diff.gz linux_4.4.0.orig.tar.gz linux-headers-4.4.0-142-generic   linux_4.4.0.orig.tar.gz 是标准内核源码 linux_4.4.0-161.189.diff.gz 是 Ubuntu kernel 的补丁 linux_4.4.0-161.189.dsc 是 Debian Source Control 文档，用于描述源码版本的相关信息 linux-4.4.0 是前两个文件解压打补丁后的源码目录  这样自动下载的小版本号通常是最新的，如果想精确匹配当前的内核版本，可以在 https://launchpad.net/ubuntu/+source/linux/ 搜索所需的版本，也是这样的三个文件，下载后需要手动解压打补丁：
tar xfvz &amp;lt;filname&amp;gt;.orig.tar.gz gunzip &amp;lt;filename&amp;gt;.diff.gz cd ./&amp;lt;filename&amp;gt; patch -p1 -i &amp;lt;file name&amp;gt;.diff  此外，用 apt-cache search linux-source 和 apt-get install linux-source 也可以搜索并下载当前内核版本的源码，并自动解压到 /usr/src/ 目录下。</description>
            <content type="html"><![CDATA[

<p>以 Ubuntu 16.04 为例，如果只想获得当前内核版本的源码可以用 <code>apt-get</code> ，如果想获取当前系统的所有内核源码建议用 <code>git</code> 。</p>

<h2 id="1-apt-get">1. apt-get</h2>

<p>通常是用  <code>apt-get source</code> 下载：</p>

<pre><code>apt-get source linux-image-$(uname -r)
</code></pre>

<p>源码会直接下载到当前目录，并自动解压，所以建议在 <code>/usr/src/</code> 目录下执行：</p>

<pre><code>root@ubuntu:/usr/src# ls
linux-4.4.0                  linux_4.4.0-161.189.dsc  linux-headers-4.4.0-142
linux_4.4.0-161.189.diff.gz  linux_4.4.0.orig.tar.gz  linux-headers-4.4.0-142-generic
</code></pre>

<ul>
<li>linux_4.4.0.orig.tar.gz 是标准内核源码</li>
<li>linux_4.4.0-161.189.diff.gz 是 Ubuntu kernel 的补丁</li>
<li>linux_4.4.0-161.189.dsc 是 Debian Source Control 文档，用于描述源码版本的相关信息</li>
<li>linux-4.4.0 是前两个文件解压打补丁后的源码目录</li>
</ul>

<p>这样自动下载的小版本号通常是最新的，如果想精确匹配当前的内核版本，可以在 <a href="https://launchpad.net/ubuntu/+source/linux/" target="_blank">https://launchpad.net/ubuntu/+source/linux/</a> 搜索所需的版本，也是这样的三个文件，下载后需要手动解压打补丁：</p>

<pre><code>tar xfvz &lt;filname&gt;.orig.tar.gz
gunzip &lt;filename&gt;.diff.gz
cd ./&lt;filename&gt;
patch -p1 -i &lt;file name&gt;.diff 
</code></pre>

<p>此外，用 <code>apt-cache search linux-source</code>  和 <code>apt-get install linux-source</code> 也可以搜索并下载当前内核版本的源码，并自动解压到 <code>/usr/src/</code> 目录下。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@ubuntu:/usr/src$ ls
linux-headers-4.4.0-116  linux-headers-4.4.0-116-generic  linux-source-4.4.0 linux-source-4.4.0.tar.gz
root@ubuntu:/usr/src$ ls linux-source-4.4.0/
debian debian.master linux-source-4.4.0.tar.gz</code></pre></div>
<p>其中 <code>debian</code> 和 <code>debian.master</code> 目录下存放的是 ubuntu 发行版中针对内核修改的配置、补丁、说明和一些工具，在 <code>/usr/src/</code> 目录下执行如下命令解压，所有源码就解压在 <code>linux-source-4.4.0</code> 目录下，：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">/usr/src$ tar xvf linux-source-4.4.0.tar.gz</code></pre></div>
<h2 id="2-git">2. git</h2>

<p>Ubuntu 使用的内核源码都是用 git 维护的，每个版本的源代码都保存在 <code>kernel.ubuntu.com</code>上的 git 存储库中。可以下载你需要的版本：</p>

<pre><code>git clone git://kernel.ubuntu.com/ubuntu/ubuntu-&lt;release codename&gt;.git
</code></pre>

<p>例如下载 16.04 LTS Xenial Xerus 的源码：</p>

<pre><code>git clone git://kernel.ubuntu.com/ubuntu/ubuntu-xenial.git
</code></pre>

<p>这个版本库包含了当前内核源码的所有 commit ，可以检出所需的具体版本。</p>

<h2 id="3-编译">3. 编译</h2>

<p>编译内核前，需要安装一些依赖，并复制一份系统自带的配置文件：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@ubuntu:~# apt-get install libncurses5-dev bc libssl-dev
root@ubuntu:~# cp -rf /boot/config-4.4.0-116-generic /usr/src/linux-source-4.4.0/.config</code></pre></div>
<p>如果只是想修改个别模块，必须先复制当前安装的模块的符号表</p>

<pre><code>root@ubuntu:/usr/src/linux-4.4# cp -rf /lib/modules/4.4.0-142-generic/build/Module.symvers ./Module.symvers
</code></pre>

<p>然后执行 <code>make M=&lt;module dir&gt;</code> 命令编译。</p>

<h2 id="参考">参考</h2>

<ul>
<li><a href="https://wiki.ubuntu.com/Kernel/BuildYourOwnKernel" target="_blank">Build Your Own Kernel</a></li>
<li><a href="https://wiki.ubuntu.com/Kernel/Dev/KernelGitGuide" target="_blank">Kernel Git Guide</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>使用 keepalived 实现双机热备</title>
            <link>https://shaocheng.li/posts/2019/08/24/</link>
            <pubDate>Sat, 24 Aug 2019 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2019/08/24/</guid>
            <description>keepalived 是一个用 C 语言编写的免费开源软件，它实现了 VRRP协议，同时提供了强大的负载均衡 (LVS) 功能。我们可以用他的 VRRP 功能实现路由器或者服务器等网络设备的双机热备。简单的说，两台路由器，一台作为主机，一台作为备机，两台路由器有自己的独立 IP ，同时共享一个虚拟 IP ，主机正常是，这个虚拟 IP 指向主机，当主机出现故障时，虚拟 IP 指向备机，实现了路由器的无缝自动切换。网络拓扑如下图所示：
虚拟 IP 的实现方式有很多种，比较可靠的方法是为一个网卡定义多个 IP ，端口名用冒号隔开一个数字，用 ifconfig 命令实现，例如：
ifconfig eth0:0 192.168.6.100 netmask 255.255.255.0 up   用点隔开一个数字的端口名属于 VLAN 网卡，例如 eth0.100 ，具有不同的特性和应用。
 安装 keepalived 官网在 https://www.keepalived.org/ ，可以编译源码进行安装。在 ubuntu 系统下，直接用 apt 安装：
apt-get install keepalived  配置 keepalived 只有一个配置文件 keepalived.conf，通常位于 /etc/keepalived/ 目录下，keepalived 还提供了很多配置文件的实例，安装在 /usr/share/doc/keepalived/sample/ 目录下。对于双机热备，最简单的配置如下：
主机 ：
vrrp_instance VI_1 { # 定义一个 VRRP 实例，VI_1 表示这个实例的名称，同一组 VRRP 路由器的实例名称必须一致 state MASTER # 定义本机的初始状态，MASTER 表示主机，BACKUP 表示备机 interface enp3s0 # 指定 VRRP 运行的网卡 virtual_router_id 51 # 定义 VRRP 路由器的 ID ，取值 1~255 ，同一组 VRRP 路由器的 ID 必须一致，这个 ID 会用于虚拟路由器的 MAC 地址 priority 100 # 定义本机的优先级，取值 1~254 ，数字越大，优先级越高，MASTER 应该比 BACKUP 高 50 以上。 virtual_ipaddress { # 定义虚拟 IP 192.</description>
            <content type="html"><![CDATA[

<p>keepalived 是一个用 C 语言编写的免费开源软件，它实现了 VRRP协议，同时提供了强大的负载均衡 (LVS) 功能。我们可以用他的 VRRP 功能实现路由器或者服务器等网络设备的双机热备。简单的说，两台路由器，一台作为主机，一台作为备机，两台路由器有自己的独立 IP ，同时共享一个虚拟 IP ，主机正常是，这个虚拟 IP 指向主机，当主机出现故障时，虚拟 IP 指向备机，实现了路由器的无缝自动切换。网络拓扑如下图所示：</p>

<p><img src="/images/2019-08-24/2019-08-24_1.jpg" alt="" /></p>

<p>虚拟 IP 的实现方式有很多种，比较可靠的方法是为一个网卡定义多个 IP ，端口名用冒号隔开一个数字，用  ifconfig 命令实现，例如：</p>

<pre><code>ifconfig eth0:0 192.168.6.100 netmask 255.255.255.0 up
</code></pre>

<blockquote>
<p>用点隔开一个数字的端口名属于 VLAN 网卡，例如 eth0.100 ，具有不同的特性和应用。</p>
</blockquote>

<h2 id="安装">安装</h2>

<p>keepalived 官网在 <a href="https://www.keepalived.org/" target="_blank">https://www.keepalived.org/</a> ，可以编译源码进行安装。在 ubuntu 系统下，直接用 apt 安装：</p>

<pre><code>apt-get install keepalived
</code></pre>

<h2 id="配置">配置</h2>

<p>keepalived 只有一个配置文件 keepalived.conf，通常位于 <code>/etc/keepalived/</code> 目录下，keepalived 还提供了很多配置文件的实例，安装在 <code>/usr/share/doc/keepalived/sample/</code> 目录下。对于双机热备，最简单的配置如下：</p>

<p>主机 ：</p>

<pre><code>vrrp_instance VI_1 {   # 定义一个 VRRP 实例，VI_1 表示这个实例的名称，同一组 VRRP 路由器的实例名称必须一致
    state MASTER        # 定义本机的初始状态，MASTER 表示主机，BACKUP 表示备机
    interface enp3s0     # 指定 VRRP 运行的网卡
    virtual_router_id 51  # 定义 VRRP 路由器的 ID ，取值 1~255 ，同一组 VRRP 路由器的 ID 必须一致，这个 ID 会用于虚拟路由器的 MAC 地址
    priority 100               # 定义本机的优先级，取值 1~254 ，数字越大，优先级越高，MASTER 应该比 BACKUP 高 50 以上。
    virtual_ipaddress {   # 定义虚拟 IP 
        192.168.1.3/24
    }
}
</code></pre>

<p>备机：</p>

<pre><code>vrrp_instance VI_1 {
    state BACKUP
    interface enp3s0
    virtual_router_id 51
    priority 40
    virtual_ipaddress {
        192.168.1.3/24
    }
}
</code></pre>

<p>配置完成后，执行 <code>systemctl start keepalived</code> 命令启动 keepalived 服务。</p>

<h2 id="验证">验证</h2>

<p>主机正常的情况下，可以看到主机的  VRRP 实例处于 MASTER 状态：</p>

<pre><code># systemctl  status keepalived.service
● keepalived.service - Keepalive Daemon (LVS and VRRP)
   Loaded: loaded (/lib/systemd/system/keepalived.service; enabled; vendor preset: enabled)
   Active: active (running) since Sat 2019-08-24 16:22:33 CST; 9min ago
  Process: 2311 ExecStart=/usr/sbin/keepalived $DAEMON_ARGS (code=exited, status=0/SUCCESS)
 Main PID: 2315 (keepalived)
    Tasks: 3
   Memory: 1.2M
      CPU: 195ms
   CGroup: /system.slice/keepalived.service
           ├─2315 /usr/sbin/keepalived
           ├─2316 /usr/sbin/keepalived
           └─2319 /usr/sbin/keepalived

Aug 24 16:22:33 ubuntu Keepalived_vrrp[2319]: Using LinkWatch kernel netlink reflector...
Aug 24 16:22:33 ubuntu Keepalived_healthcheckers[2316]: Registering Kernel netlink reflector
Aug 24 16:22:33 ubuntu Keepalived_healthcheckers[2316]: Registering Kernel netlink command channel
Aug 24 16:22:33 ubuntu Keepalived_healthcheckers[2316]: Opening file '/etc/keepalived/keepalived.conf'.
Aug 24 16:22:33 ubuntu Keepalived_healthcheckers[2316]: Using LinkWatch kernel netlink reflector...
Aug 24 16:25:27 ubuntu Keepalived_vrrp[2319]: VRRP_Instance(VI_1) Entering MASTER STATE
</code></pre>

<p>以及虚拟 IP 指向主机的网卡：</p>

<pre><code>root@ubuntu:~# ip addr
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: enp3s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:1d:f3:52:99:10 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.1/24 brd 192.168.1.255 scope global enp3s0
       valid_lft forever preferred_lft forever
    inet 192.168.1.3/24 scope global secondary enp3s0
       valid_lft forever preferred_lft forever
    inet6 fe80::21d:f3ff:fe52:9910/64 scope link
       valid_lft forever preferred_lft forever
</code></pre>

<p>如果把主机关闭，则备机的 VRRP 实例状态会变为 MASTER ，虚拟 IP 也会指向备机的网卡：</p>

<pre><code># systemctl  status keepalived.service
● keepalived.service - Keepalive Daemon (LVS and VRRP)
   Loaded: loaded (/lib/systemd/system/keepalived.service; enabled; vendor preset: enabled)
   Active: active (running) since Sat 2019-08-24 16:22:33 CST; 9min ago
  Process: 2311 ExecStart=/usr/sbin/keepalived $DAEMON_ARGS (code=exited, status=0/SUCCESS)
 Main PID: 2315 (keepalived)
    Tasks: 3
   Memory: 1.2M
      CPU: 195ms
   CGroup: /system.slice/keepalived.service
           ├─2315 /usr/sbin/keepalived
           ├─2316 /usr/sbin/keepalived
           └─2319 /usr/sbin/keepalived

Aug 24 16:22:33 ubuntu Keepalived_vrrp[2319]: Using LinkWatch kernel netlink reflector...
Aug 24 16:22:33 ubuntu Keepalived_healthcheckers[2316]: Registering Kernel netlink reflector
Aug 24 16:22:33 ubuntu Keepalived_healthcheckers[2316]: Registering Kernel netlink command channel
Aug 24 16:22:33 ubuntu Keepalived_healthcheckers[2316]: Opening file '/etc/keepalived/keepalived.conf'.
Aug 24 16:22:33 ubuntu Keepalived_healthcheckers[2316]: Using LinkWatch kernel netlink reflector...
Aug 24 16:22:34 ubuntu Keepalived_vrrp[2319]: VRRP_Instance(VI_1) Entering BACKUP STATE
Aug 24 16:25:26 ubuntu Keepalived_vrrp[2319]: VRRP_Instance(VI_1) Transition to MASTER STATE
Aug 24 16:25:27 ubuntu Keepalived_vrrp[2319]: VRRP_Instance(VI_1) Entering MASTER STATE
</code></pre>

<h2 id="参考">参考</h2>

<ul>
<li><a href="https://cshihong.github.io/2017/12/18/%E8%99%9A%E6%8B%9F%E8%B7%AF%E7%94%B1%E5%86%97%E4%BD%99%E5%8D%8F%E8%AE%AE-VRRP/" target="_blank">虚拟路由冗余协议(VRRP)</a></li>
<li><a href="https://qizhanming.com/blog/2018/05/17/how-to-config-keepalived-on-centos-7" target="_blank">CentOS 7 配置 Keepalived 实现双机热备</a></li>
<li><a href="http://www.xumenger.com/virtual-ip-20190220/" target="_blank">虚拟 IP 技术</a></li>
<li><a href="https://www.cnblogs.com/JohnABC/p/5951340.html" target="_blank">Linux-eth0 eth0:1 和eth0.1关系、ifconfig以及虚拟IP实现介绍</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>使用 openssl 进行 AES 加密</title>
            <link>https://shaocheng.li/posts/2019/08/18/</link>
            <pubDate>Sun, 18 Aug 2019 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2019/08/18/</guid>
            <description>aes 加密需要一个字符串作为密钥，自己写一个，或者用完成的工具生成一随机的，假设密钥为 passphrase ，加密一个文件 file：
openssl enc -aes-128-cbc -in file -out file.enc -k passphrase  也可以把密钥存放在一个文本文件，然后用 -kfile 选项指定：
openssl enc -aes-128-cbc -in file -out file.enc -kfile passphrase.txt  </description>
            <content type="html"><![CDATA[<p>aes 加密需要一个字符串作为密钥，自己写一个，或者用完成的工具生成一随机的，假设密钥为 <code>passphrase</code> ，加密一个文件 file：</p>

<pre><code>openssl enc -aes-128-cbc -in file -out file.enc -k passphrase
</code></pre>

<p>也可以把密钥存放在一个文本文件，然后用 <code>-kfile</code> 选项指定：</p>

<pre><code>openssl enc -aes-128-cbc -in file -out file.enc -kfile passphrase.txt
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>使用 OpenVPN 实现远程访问</title>
            <link>https://shaocheng.li/posts/2019/07/02/</link>
            <pubDate>Tue, 02 Jul 2019 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2019/07/02/</guid>
            <description>有时我们需要连接不同局域网的两台主机，使其可以互相访问，比如用家里的电脑登录办公室电脑的某个服务。我们可以使用 OpenVPN 实现这个功能，它的原理是在两台电脑上安装 OpenVPN 客户端，同时连接公网上的 OpenVPN 服务器，OpenVPN 会将这两台电脑组成一个虚拟局域网，它们就可以像局域网内一样互相访问了。搭建 VPN 前的网络拓扑如下：
家里的电脑是 Windows7 系统，办公室的电脑安装了 Ubuntu16.04 ，公网上的 VPS 安装了 Ubuntu16.04 。如果全部都是 Windows 系统，配置起来会更方便一点，Linux 下的文本操作略显繁琐，好在 SoftEther 提供了可以远程管理的 GUI 工具。
1. 在 VPS 上安装 SoftEther SoftEther 这套软件其实是一个完整的夸平台 VPN 解决方案，在单一软件内集成了 OpenVPN 、L2TP 、IPsec 等 VPN 协议，我们可以用它在 VPS 上搭建一个 OpenVPN 的服务器，非常方便。
首先在 SoftEther 下载中心 下载 X64-Linux 平台的 SoftEther VPN Server，我下载的版本是 softether-vpnserver-v4.29-9680-rtm-2019.02.28-linux-x64-64bit.tar.gz ，将其解压到 VPS 的用户根目录下，得到一个名为 vpnserver 的文件夹，在这个文件夹下执行 ./.install.sh ，根据提示依次输入三次数字 1 并按回车即可完成编译安装，所有的可执行文件还是在这个路径下，先执行 sudo ./vpnserver start 让服务器在后台运行，然后执行 ./vpncmd 开始初始化配置，按如下输入：</description>
            <content type="html"><![CDATA[

<p>有时我们需要连接不同局域网的两台主机，使其可以互相访问，比如用家里的电脑登录办公室电脑的某个服务。我们可以使用 OpenVPN 实现这个功能，它的原理是在两台电脑上安装 OpenVPN 客户端，同时连接公网上的 OpenVPN 服务器，OpenVPN 会将这两台电脑组成一个虚拟局域网，它们就可以像局域网内一样互相访问了。搭建 VPN 前的网络拓扑如下：</p>

<p><img src="/images/2019-07-02/2019-07-02_1.jpg" alt="" /></p>

<p>家里的电脑是 Windows7 系统，办公室的电脑安装了 Ubuntu16.04 ，公网上的 VPS 安装了 Ubuntu16.04 。如果全部都是 Windows 系统，配置起来会更方便一点，Linux 下的文本操作略显繁琐，好在 SoftEther 提供了可以远程管理的 GUI 工具。</p>

<h2 id="1-在-vps-上安装-softether">1. 在 VPS 上安装 SoftEther</h2>

<p>SoftEther 这套软件其实是一个完整的夸平台 VPN 解决方案，在单一软件内集成了 OpenVPN 、L2TP 、IPsec 等 VPN 协议，我们可以用它在 VPS 上搭建一个 OpenVPN 的服务器，非常方便。</p>

<p>首先在 <a href="https://www.softether-download.com/cn.aspx?product=softether" target="_blank">SoftEther 下载中心</a> 下载 X64-Linux 平台的 SoftEther VPN Server，我下载的版本是 <code>softether-vpnserver-v4.29-9680-rtm-2019.02.28-linux-x64-64bit.tar.gz</code> ，将其解压到 VPS 的用户根目录下，得到一个名为 vpnserver 的文件夹，在这个文件夹下执行 <code>./.install.sh</code> ，根据提示依次输入三次数字 <code>1</code> 并按回车即可完成编译安装，所有的可执行文件还是在这个路径下，先执行 <code>sudo ./vpnserver start</code> 让服务器在后台运行，然后执行 <code>./vpncmd</code> 开始初始化配置，按如下输入：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ubuntu@VM-231-137-ubuntu:~/vpnserver$ sudo ./vpnserver start
The SoftEther VPN Server service has been started.
ubuntu@VM-231-137-ubuntu:~/vpnserver$ ./vpncmd
vpncmd command - SoftEther VPN Command Line Management Utility
SoftEther VPN Command Line Management Utility <span style="color:#f92672">(</span>vpncmd command<span style="color:#f92672">)</span>
Version <span style="color:#ae81ff">4</span>.29 Build <span style="color:#ae81ff">9680</span>   <span style="color:#f92672">(</span>English<span style="color:#f92672">)</span>
Compiled <span style="color:#ae81ff">2019</span>/02/28 <span style="color:#ae81ff">19</span>:22:54 by yagi at pc33
Copyright <span style="color:#f92672">(</span>c<span style="color:#f92672">)</span> SoftEther VPN Project. All Rights Reserved.

By using vpncmd program, the following can be achieved.

<span style="color:#ae81ff">1</span>. Management of VPN Server or VPN Bridge
<span style="color:#ae81ff">2</span>. Management of VPN Client
<span style="color:#ae81ff">3</span>. Use of VPN Tools <span style="color:#f92672">(</span>certificate creation and Network Traffic Speed Test Tool<span style="color:#f92672">)</span>

Select <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span> or <span style="color:#ae81ff">3</span>: <span style="color:#f92672">[</span>在这里输入 <span style="color:#ae81ff">1</span> ，表示管理 VPN 服务器<span style="color:#f92672">]</span>

Specify the host name or IP address of the computer that the destination VPN Server or VPN Bridge is operating on.
By specifying according to the format ‘host name:port number’, you can also specify the port number.
<span style="color:#f92672">(</span>When the port number is unspecified, <span style="color:#ae81ff">443</span> is used.<span style="color:#f92672">)</span>
If nothing is input and the Enter key is pressed, the connection will be made to the port number <span style="color:#ae81ff">8888</span> of localhost <span style="color:#f92672">(</span>this computer<span style="color:#f92672">)</span>.
Hostname of IP Address of Destination:<span style="color:#f92672">[</span>这里敲回车键，按默认配置使用 <span style="color:#ae81ff">443</span> 端口<span style="color:#f92672">]</span>

If connecting to the server by Virtual Hub Admin Mode, please input the Virtual Hub name.
If connecting by server admin mode, please press Enter without inputting anything.
Specify Virtual Hub Name: <span style="color:#f92672">[</span>这里敲回车键<span style="color:#f92672">]</span>

Connection has been established with VPN Server “localhost” <span style="color:#f92672">(</span>port <span style="color:#ae81ff">443</span><span style="color:#f92672">)</span>.You have administrator privileges <span style="color:#66d9ef">for</span> the entire VPN Server.

VPN Server&gt;<span style="color:#f92672">[</span>输入 ServerPasswordSet ，表示设置一个密码<span style="color:#f92672">]</span>

ServerPasswordSet command - Set VPN Server Administrator PasswordPlease enter the password. To cancel press the Ctrl+D key.
Password: <span style="color:#f92672">[</span>输入你的密码<span style="color:#f92672">]</span>
Confirm input: <span style="color:#f92672">[</span>再次输入你的密码<span style="color:#f92672">]</span></code></pre></div>
<p>之后的配置可以用 Windows 下的远程管理工具进行。</p>

<p>首先在 <a href="https://www.softether-download.com/cn.aspx?product=softether" target="_blank">SoftEther 下载中心</a> 下载 X64-Windows 平台的 SoftEther VPN Server ，把它安装在家里的笔记本上，安装时选择 <code>SoftEther VPN Server 管理工具（仅限管理工具）</code> ，我们只是用它来连接并配置 VPS 上的 VPN 服务器：</p>

<p><img src="/images/2019-07-02/2019-07-02_2.jpg" alt="" /></p>

<p>安装完成后启动 <code>SoftEther VPN Server 管理器</code> ，在连接设置界面中点击 <code>新设置</code> 按钮，在弹出的对话框中按如下设置，新建一个指向 VPS 的连接：</p>

<p><img src="/images/2019-07-02/2019-07-02_3.jpg" alt="" /></p>

<p>新建成功后，在连接设置界面双击这个设置，开始连接 VPS ，连接成功后会弹出一个管理对话框，这里会出现一个默认的虚拟 HUB ，先将其删除，然后点击 <code>创建虚拟 HUB</code> 按钮，按如下设置，然后点击 <code>确定</code> ，就可以新建一个虚拟 HUB ，其中名字和密码都可以自定义：</p>

<p><img src="/images/2019-07-02/2019-07-02_4.jpg" alt="" /></p>

<p>回到管理界面，双击刚才新建的这个虚拟 HUB ，进入这个 HUB 的管理界面：</p>

<p><img src="/images/2019-07-02/2019-07-02_5.jpg" alt="" /></p>

<p>点击 <code>管理用户</code> ，为这个 HUB 新建一个用户，按如下设置：</p>

<p><img src="/images/2019-07-02/2019-07-02_6.jpg" alt="" /></p>

<p>回到这个 HUB 的管理界面，点击 <code>虚拟 NAT 和 虚拟 DHCP 服务器</code> ，在弹出的对话框中点击 <code>启动 SecureNAT</code> ，如果想修改配置，可以点击  <code>SecureNAT 配置</code>  。至此，VPN 服务器配置都结束了，我们需要导出相应的客户端配置，供后面的客户端使用。在管理界面的右下角点击 <code>OpenVPN/MS-SSTP 设置</code> 按钮，在弹出的对话框中按如下设置：</p>

<p><img src="/images/2019-07-02/2019-07-02_7.jpg" alt="" />
然后点击 <code>为 OpenVPN Client 生成配置样本文件</code> 就可以导出一个保护配置文件的压缩包，压缩包里会有两个配置文件，我们使用 L3 用于远程访问的这个：</p>

<p><img src="/images/2019-07-02/2019-07-02_8.jpg" alt="" /></p>

<blockquote>
<p>注意，VPS 上使用了默认的 TCP:443 和 UDP:1194 端口，要记得在 VPS 的防火墙上打开这两个端口，否则会造成客户端连接失败。</p>
</blockquote>

<h2 id="2-在家里电脑上安装-openvpn-客户端">2. 在家里电脑上安装 OpenVPN 客户端</h2>

<p>在 <a href="https://openvpn.net/community-downloads/" target="_blank">OpenVPN 下载中心</a> 下载 Win7 版的安装包，一路 Next 安装成功后启动 OpenVPN GUI ，首次启动会提示没有配置文件，这时需要在状态栏的 OpenVPN 图标上点击右键，选择 <code>导入配置文件...</code> :</p>

<p><img src="/images/2019-07-02/2019-07-02_9.jpg" alt="" /></p>

<p>导入上一步得到的 <code>vm-231-137-ubunt_openvpn_remote_access_l3.ovpn</code> 配置文件，然后点击 <code>连接</code> ，按提示输入 OpenVPN 服务器中设置的用户名和密码：</p>

<p><img src="/images/2019-07-02/2019-07-02_10.jpg" alt="" /></p>

<p>点击 <code>确定</code> 后开始连接，连接成功后会获得虚拟局域网为本机分配的 IP ：</p>

<p><img src="/images/2019-07-02/2019-07-02_11.jpg" alt="" /></p>

<h2 id="3-在办公室电脑上安装-openvpn-客户端">3. 在办公室电脑上安装 OpenVPN 客户端</h2>

<p>在 Ubuntu 上用 <code>sudo apt-get install openvpn</code> 命令安装 OpenVPN ，然后把配置文件 <code>vm-231-137-ubunt_openvpn_remote_access_l3.ovpn</code> 复制到 <code>/etc/openvpn/</code> 路径下，并改名为 <code>client.conf</code> ，然后执行 <code>systemctl start openvpn@client</code> 启动连接：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@ubuntu:~# systemctl start openvpn@client
Enter Auth Username: ****
Enter Auth Password: ***********
root@ubuntu:~# systemctl status openvpn@client
● openvpn@client.service - OpenVPN connection to client
   Loaded: loaded <span style="color:#f92672">(</span>/lib/systemd/system/openvpn@.service; disabled; vendor preset: enabled<span style="color:#f92672">)</span>
   Active: active <span style="color:#f92672">(</span>running<span style="color:#f92672">)</span> since Wed <span style="color:#ae81ff">2019</span>-07-03 <span style="color:#ae81ff">10</span>:12:01 CST; 11s ago
     Docs: man:openvpn<span style="color:#f92672">(</span><span style="color:#ae81ff">8</span><span style="color:#f92672">)</span>
           https://community.openvpn.net/openvpn/wiki/Openvpn23ManPage
           https://community.openvpn.net/openvpn/wiki/HOWTO
  Process: <span style="color:#ae81ff">2409</span> ExecStart<span style="color:#f92672">=</span>/usr/sbin/openvpn --daemon ovpn-%i --status /run/openvpn/%i.status <span style="color:#ae81ff">10</span> --cd /etc/openvp
 Main PID: <span style="color:#ae81ff">2429</span> <span style="color:#f92672">(</span>openvpn<span style="color:#f92672">)</span>
   CGroup: /system.slice/system-openvpn.slice/openvpn@client.service
           └─2429 /usr/sbin/openvpn --daemon ovpn-client --status /run/openvpn/client.status <span style="color:#ae81ff">10</span> --cd /etc/openvp

Jul <span style="color:#ae81ff">03</span> <span style="color:#ae81ff">10</span>:12:04 ubuntu ovpn-client<span style="color:#f92672">[</span><span style="color:#ae81ff">2429</span><span style="color:#f92672">]</span>: ROUTE_GATEWAY <span style="color:#ae81ff">10</span>.231.222.129/255.255.255.248 IFACE<span style="color:#f92672">=</span>enp0s29u1u3u1c2 HWA
Jul <span style="color:#ae81ff">03</span> <span style="color:#ae81ff">10</span>:12:04 ubuntu ovpn-client<span style="color:#f92672">[</span><span style="color:#ae81ff">2429</span><span style="color:#f92672">]</span>: TUN/TAP device tun0 opened
Jul <span style="color:#ae81ff">03</span> <span style="color:#ae81ff">10</span>:12:04 ubuntu ovpn-client<span style="color:#f92672">[</span><span style="color:#ae81ff">2429</span><span style="color:#f92672">]</span>: TUN/TAP TX queue length set to <span style="color:#ae81ff">100</span>
Jul <span style="color:#ae81ff">03</span> <span style="color:#ae81ff">10</span>:12:04 ubuntu ovpn-client<span style="color:#f92672">[</span><span style="color:#ae81ff">2429</span><span style="color:#f92672">]</span>: do_ifconfig, tt-&gt;ipv6<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, tt-&gt;did_ifconfig_ipv6_setup<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
Jul <span style="color:#ae81ff">03</span> <span style="color:#ae81ff">10</span>:12:04 ubuntu ovpn-client<span style="color:#f92672">[</span><span style="color:#ae81ff">2429</span><span style="color:#f92672">]</span>: /sbin/ip link set dev tun0 up mtu <span style="color:#ae81ff">1500</span>
Jul <span style="color:#ae81ff">03</span> <span style="color:#ae81ff">10</span>:12:04 ubuntu ovpn-client<span style="color:#f92672">[</span><span style="color:#ae81ff">2429</span><span style="color:#f92672">]</span>: /sbin/ip addr add dev tun0 local <span style="color:#ae81ff">192</span>.168.30.13 peer <span style="color:#ae81ff">192</span>.168.30.14
Jul <span style="color:#ae81ff">03</span> <span style="color:#ae81ff">10</span>:12:04 ubuntu ovpn-client<span style="color:#f92672">[</span><span style="color:#ae81ff">2429</span><span style="color:#f92672">]</span>: /sbin/ip route add <span style="color:#ae81ff">118</span>.89.16.2/32 via <span style="color:#ae81ff">10</span>.231.222.129
Jul <span style="color:#ae81ff">03</span> <span style="color:#ae81ff">10</span>:12:04 ubuntu ovpn-client<span style="color:#f92672">[</span><span style="color:#ae81ff">2429</span><span style="color:#f92672">]</span>: /sbin/ip route add <span style="color:#ae81ff">0</span>.0.0.0/1 via <span style="color:#ae81ff">192</span>.168.30.14
Jul <span style="color:#ae81ff">03</span> <span style="color:#ae81ff">10</span>:12:04 ubuntu ovpn-client<span style="color:#f92672">[</span><span style="color:#ae81ff">2429</span><span style="color:#f92672">]</span>: /sbin/ip route add <span style="color:#ae81ff">128</span>.0.0.0/1 via <span style="color:#ae81ff">192</span>.168.30.14
Jul <span style="color:#ae81ff">03</span> <span style="color:#ae81ff">10</span>:12:04 ubuntu ovpn-client<span style="color:#f92672">[</span><span style="color:#ae81ff">2429</span><span style="color:#f92672">]</span>: Initialization Sequence Completed
root@ubuntu:~# ps -ef | grep openvpn
root      <span style="color:#ae81ff">2429</span>     <span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">10</span>:12 ?        <span style="color:#ae81ff">00</span>:00:00 /usr/sbin/openvpn --daemon ovpn-client --status /run/openvpn/client.status <span style="color:#ae81ff">10</span> --cd /etc/openvpn --script-security <span style="color:#ae81ff">2</span> --config /etc/openvpn/client.conf --writepid /run/openvpn/client.pid
root      <span style="color:#ae81ff">2503</span>  <span style="color:#ae81ff">1858</span>  <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">10</span>:12 pts/0    <span style="color:#ae81ff">00</span>:00:00 grep --color<span style="color:#f92672">=</span>auto openvpn</code></pre></div>
<p>连接成功后会出现 tun0 网络接口，并获得一个 IP ：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@ubuntu:~# ifconfig tun0
tun0      Link encap:UNSPEC  HWaddr <span style="color:#ae81ff">00</span>-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00
          inet addr:192.168.30.13  P-t-P:192.168.30.14  Mask:255.255.255.255
          UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1500  Metric:1
          RX packets:6 errors:0 dropped:0 overruns:0 frame:0
          TX packets:6 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:100
          RX bytes:396 <span style="color:#f92672">(</span><span style="color:#ae81ff">396</span>.0 B<span style="color:#f92672">)</span>  TX bytes:396 <span style="color:#f92672">(</span><span style="color:#ae81ff">396</span>.0 B<span style="color:#f92672">)</span>

root@ubuntu:~# cat /run/openvpn/client.status
OpenVPN STATISTICS
Updated,Wed Jul  <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">10</span>:12:52 <span style="color:#ae81ff">2019</span>
TUN/TAP read bytes,594
TUN/TAP write bytes,594
TCP/UDP read bytes,4196
TCP/UDP write bytes,2725
Auth read bytes,850
END</code></pre></div>
<h2 id="4-测试">4. 测试</h2>

<p>连接成功后的网络拓扑如下：</p>

<p><img src="/images/2019-07-02/2019-07-02_12.jpg" alt="" /></p>

<p>客户端通过 VPN 隧道连接到了服务器的虚拟 HUB 上，共同组成了一个 <code>192.168.30.0/24</code> 的局域网，客户端直接可以想局域网内一样相互访问，在家里电脑上 ping 办公室内的电脑：</p>

<p><img src="/images/2019-07-02/2019-07-02_13.jpg" alt="" /></p>

<h2 id="5-配置签名证书">5. 配置签名证书</h2>

<p>上面建立的 VPN 服务器支持的是密码验证，如果要使用签名证书认证，需要用 OpenVPN 搭建服务器，因为 SoftEther 对签名证书认证支持不够完善。签名证书由服务器端签发，需要制作三个证书： CA 证书、服务器端证书和客户端证书。</p>

<h3 id="5-1-生成证书">5.1. 生成证书</h3>

<p>先在服务器端使用 <code>sudo apt-get install openvpn easy-rsa</code> 命令安装 OpenVPN 和证书制作工具 easy-rsa 。然后把 <code>/usr/share/easy-rsa/</code> 文件夹及其内容复制到 <code>/etc/openvpn/</code> 路径下，然后编辑其中的 <code>vars</code> 文件，这个文件是 easy-rsa 的配置文件，包含了生成证书和密钥时使用的选项，可以使用默认值，或者根据实际情况修改如下选项：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># These are the default values for fields</span>
<span style="color:#75715e"># which will be placed in the certificate.</span>
<span style="color:#75715e"># Don&#39;t leave any of these fields blank.</span>
export KEY_COUNTRY<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;CN&#34;</span>   <span style="color:#75715e">#国家</span>
export KEY_PROVINCE<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;GD&#34;</span>  <span style="color:#75715e">#省份</span>
export KEY_CITY<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Shenzhen&#34;</span>  <span style="color:#75715e">#城市</span>
export KEY_ORG<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Fort-Funston&#34;</span>  <span style="color:#75715e">#组织/公司</span>
export KEY_EMAIL<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;me@myhost.mydomain&#34;</span>  <span style="color:#75715e">#Email</span>
export KEY_OU<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;MyOrganizationalUnit&#34;</span>  <span style="color:#75715e">#部门名称</span>

<span style="color:#75715e"># X509 Subject Field</span>
export KEY_NAME<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;EasyRSA&#34;</span> <span style="color:#75715e">#密钥的名称</span></code></pre></div>
<p>然后使这项选项生效，并初始化，需要先切换到 root 用户：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ubuntu@VM-231-137-ubuntu:~$ sudo su
root@VM-231-137-ubuntu:~# cd /etc/openvpn/easy-rsa
root@VM-231-137-ubuntu:/etc/openvpn/easy-rsa# source vars
NOTE: If you run ./clean-all, I will be doing a rm -rf on /etc/openvpn/easy-rsa/keys
root@VM-231-137-ubuntu:/etc/openvpn/easy-rsa# ./clean-all</code></pre></div>
<p>执行 <code>./build-ca</code> 新建 CA 证书，一路回车即可，生成的证书和密钥在 keys 文件夹下，把证书复制到 <code>/etc/openvpn/</code> 目录下：</p>

<pre><code>root@VM-231-137-ubuntu:/etc/openvpn/easy-rsa# ls keys/
ca.crt  ca.key  index.txt  serial
root@VM-231-137-ubuntu:/etc/openvpn/easy-rsa# cp -rf keys/ca.crt  /etc/openvpn/
</code></pre>

<p>执行 <code>./build-key-server EasyRSA</code> 新建服务器端证书，其中 <code>EasyRSA</code> 是 vars 文件中设置的 <code>KEY_NAME</code> 的值，再执行 <code>./build-dh</code> 生成密钥交换所需的 Diffe-Hellman 文件，一路回车后，生成的证书和密钥等都在 keys 文件夹下，把他们复制到 <code>/etc/openvpn/</code> 目录下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@VM-231-137-ubuntu:/etc/openvpn/easy-rsa# ll keys/
total <span style="color:#ae81ff">60</span>
drwx------ <span style="color:#ae81ff">2</span> root root <span style="color:#ae81ff">4096</span> Jul  <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">17</span>:51 ./
drwxr-xr-x <span style="color:#ae81ff">3</span> root root <span style="color:#ae81ff">4096</span> Jul  <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">17</span>:43 ../
-rw-r--r-- <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">5702</span> Jul  <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">17</span>:45 <span style="color:#ae81ff">01</span>.pem
-rw-r--r-- <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">5702</span> Jul  <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">17</span>:45 EasyRSA.crt
-rw-r--r-- <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">1094</span> Jul  <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">17</span>:45 EasyRSA.csr
-rw------- <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">1704</span> Jul  <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">17</span>:45 EasyRSA.key
-rw-r--r-- <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">1801</span> Jul  <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">17</span>:27 ca.crt
-rw------- <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">1704</span> Jul  <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">17</span>:27 ca.key
-rw-r--r-- <span style="color:#ae81ff">1</span> root root  <span style="color:#ae81ff">424</span> Jul  <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">17</span>:51 dh2048.pem
-rw-r--r-- <span style="color:#ae81ff">1</span> root root  <span style="color:#ae81ff">146</span> Jul  <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">17</span>:45 index.txt
-rw-r--r-- <span style="color:#ae81ff">1</span> root root   <span style="color:#ae81ff">21</span> Jul  <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">17</span>:45 index.txt.attr
-rw-r--r-- <span style="color:#ae81ff">1</span> root root    <span style="color:#ae81ff">0</span> Jul  <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">17</span>:23 index.txt.old
-rw-r--r-- <span style="color:#ae81ff">1</span> root root    <span style="color:#ae81ff">3</span> Jul  <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">17</span>:45 serial
-rw-r--r-- <span style="color:#ae81ff">1</span> root root    <span style="color:#ae81ff">3</span> Jul  <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">17</span>:23 serial.old
root@VM-231-137-ubuntu:/etc/openvpn/easy-rsa# cp -rf keys/EasyRSA.crt /etc/openvpn/
root@VM-231-137-ubuntu:/etc/openvpn/easy-rsa# cp -rf keys/EasyRSA.key /etc/openvpn/
root@VM-231-137-ubuntu:/etc/openvpn/easy-rsa# cp -rf keys/dh2048.pem /etc/openvpn/</code></pre></div>
<p>执行 <code>./build-key client</code> 新建客户端证书，client 是证书名称，可以自定义，生成的客户端证书和密钥等都在 keys 文件夹下：</p>

<pre><code>root@VM-231-137-ubuntu:/etc/openvpn/easy-rsa# ll keys/
total 92
drwx------ 2 root root 4096 Jul  3 17:57 ./
drwxr-xr-x 3 root root 4096 Jul  3 17:43 ../
-rw-r--r-- 1 root root 5702 Jul  3 17:45 01.pem
-rw-r--r-- 1 root root 5578 Jul  3 17:57 02.pem
-rw-r--r-- 1 root root 5702 Jul  3 17:45 EasyRSA.crt
-rw-r--r-- 1 root root 1094 Jul  3 17:45 EasyRSA.csr
-rw------- 1 root root 1704 Jul  3 17:45 EasyRSA.key
-rw-r--r-- 1 root root 1801 Jul  3 17:27 ca.crt
-rw------- 1 root root 1704 Jul  3 17:27 ca.key
-rw-r--r-- 1 root root 5578 Jul  3 17:57 client.crt
-rw-r--r-- 1 root root 1094 Jul  3 17:57 client.csr
-rw------- 1 root root 1704 Jul  3 17:57 client.key
-rw-r--r-- 1 root root  424 Jul  3 17:51 dh2048.pem
-rw-r--r-- 1 root root  291 Jul  3 17:57 index.txt
-rw-r--r-- 1 root root   21 Jul  3 17:57 index.txt.attr
-rw-r--r-- 1 root root   21 Jul  3 17:45 index.txt.attr.old
-rw-r--r-- 1 root root  146 Jul  3 17:45 index.txt.old
-rw-r--r-- 1 root root    3 Jul  3 17:57 serial
-rw-r--r-- 1 root root    3 Jul  3 17:45 serial.old
</code></pre>

<h3 id="5-2-服务器端配置">5.2. 服务器端配置</h3>

<p>服务器端可以复制 OpenVPN 自带的配置文件模板，得到 server.conf ，然后进行修改：</p>

<pre><code>root@VM-231-137-ubuntu:~# cp -rf /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz /etc/openvpn/
root@VM-231-137-ubuntu:~# cd /etc/openvpn/
root@VM-231-137-ubuntu:/etc/openvpn# gzip -d server.conf.gz
</code></pre>

<p>注意如下几个选项：</p>

<pre><code>port 1194   # 监听的端口，使用默认的 1194 就行
proto udp  # 使用的传输层协议，默认使用 UDP
dev tun  # 这里设置了虚拟网卡的类型，tun 表示网络层设备，它操作 IP 数据包，tap 表示以太网设备，它操作链路层的以太网数据帧。
ca ca.crt  # 指定 CA 证书
cert EasyRSA.crt  # 指定服务器端证书
key EasyRSA.key  # 指定服务器端密钥
dh dh2048.pem  # 指定 Diffe-Hellman 文件
server 10.8.0.0 255.255.255.0  # 设置虚拟局域网的网段，10.8.0.1 会留给服务器自用
client-to-client  # 允许客户端之间相互可见，否则多个客户端只能看到服务器，而看不到彼此
duplicate-cn  # 这个选项允许多个客户端使用相同的证书和密钥进行连接，并分配不同的 IP 
</code></pre>

<p>保存后切回普通用户，然后启动 OpenVPN 服务器：</p>

<pre><code>root@VM-231-137-ubuntu:~# exit
exit
ubuntu@VM-231-137-ubuntu:~$ cd
ubuntu@VM-231-137-ubuntu:~$ systemctl start openvpn@server
ubuntu@VM-231-137-ubuntu:~$ systemctl status openvpn@server
* openvpn@server.service - OpenVPN connection to server
   Loaded: loaded (/lib/systemd/system/openvpn@.service; disabled; vendor preset: enabled
   Active: active (running) since Thu 2019-07-04 09:05:45 CST; 2s ago
     Docs: man:openvpn(8)
           https://community.openvpn.net/openvpn/wiki/Openvpn23ManPage
           https://community.openvpn.net/openvpn/wiki/HOWTO
  Process: 20430 ExecStart=/usr/sbin/openvpn --daemon ovpn-%i --status /run/openvpn/%i.st
 Main PID: 20439 (openvpn)
   CGroup: /system.slice/system-openvpn.slice/openvpn@server.service
           `-20439 /usr/sbin/openvpn --daemon ovpn-server --status /run/openvpn/server.st

Jul 04 09:05:45 VM-231-137-ubuntu ovpn-server[20439]: do_ifconfig, tt-&gt;ipv6=0, tt-&gt;did_if
Jul 04 09:05:45 VM-231-137-ubuntu ovpn-server[20439]: /sbin/ip link set dev tun0 up mtu 1
Jul 04 09:05:45 VM-231-137-ubuntu ovpn-server[20439]: /sbin/ip addr add dev tun0 local 10
Jul 04 09:05:45 VM-231-137-ubuntu ovpn-server[20439]: /sbin/ip route add 10.8.0.0/24 via
Jul 04 09:05:45 VM-231-137-ubuntu ovpn-server[20439]: UDPv4 link local (bound): [undef]
Jul 04 09:05:45 VM-231-137-ubuntu ovpn-server[20439]: UDPv4 link remote: [undef]
Jul 04 09:05:45 VM-231-137-ubuntu ovpn-server[20439]: MULTI: multi_init called, r=256 v=2
Jul 04 09:05:45 VM-231-137-ubuntu ovpn-server[20439]: IFCONFIG POOL: base=10.8.0.4 size=6
Jul 04 09:05:45 VM-231-137-ubuntu ovpn-server[20439]: IFCONFIG POOL LIST
Jul 04 09:05:45 VM-231-137-ubuntu ovpn-server[20439]: Initialization Sequence Completed
ubuntu@VM-231-137-ubuntu:~$ ifconfig tun0
tun0      Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00
          inet addr:10.8.0.1  P-t-P:10.8.0.2  Mask:255.255.255.255
          UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:100
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
</code></pre>

<h3 id="5-3-客户端配置">5.3. 客户端配置</h3>

<p>客户端的认证需要三个文件：ca.crt 、client.crt 和 client.key ，它们都在服务器 <code>/etc/openvpn/easy-rsa/keys/</code> 目录下已经生成了，客户端的配置文件也可用 OpenVPN 提供的模板 <code>/usr/share/doc/openvpn/examples/sample-config-files/client.conf</code> 进行修改。</p>

<p>以 Ubuntu 系统为例，把以上四个文件复制到客户端的 <code>/etc/openvpn/</code> 目录下，然后修改配置文件 <code>/etc/openvpn/</code> ，注意如下几个选项。</p>

<pre><code>dev tun   # 虚拟网卡类型，与服务器保持一致
proto udp   # 传输层协议类型，与服务器保持一致
remote 118.89.16.2 1194   # 服务器的 IP 和端口
ca ca.crt   # CA 证书的文件名，因为在同一目录下，所以不用加路径
cert client.crt  # 客户端证书
key client.key  # 客户端密钥
</code></pre>

<p>保存后启动 OpenVPN 客户端连接，这次就不用再输入用户名和密码了：</p>

<pre><code>root@ubuntu:~# systemctl start openvpn@client
root@ubuntu:~# ifconfig tun0
tun0      Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00
          inet addr:10.8.0.6  P-t-P:10.8.0.5  Mask:255.255.255.255
          UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:100
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
</code></pre>

<p>如果是 Windows 客户端，配置文件的后缀要改成 <code>.ovpn</code> ，其他都是一样的。</p>
]]></content>
        </item>
        
        <item>
            <title>UDP socket 编程实践</title>
            <link>https://shaocheng.li/posts/2018/12/20/</link>
            <pubDate>Thu, 20 Dec 2018 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2018/12/20/</guid>
            <description>UDP 是面向非连接的，如果通讯双方都在局域网中，服务器端和客户端没有区别，如果是局域网内的主机与公网上的主机通讯，由于 NAT 地址转换协议的作用，必须由局域网内的主机主动向公网的主句发送数据，公网的主机作为服务器端，必须接收客户端的数据后，解析出源 IP 和端口，再反向发送，实现双向通讯。下面是一个简单的 Demo 。
服务器端：
// server.c  #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;netinet/in.h&amp;gt; #include &amp;lt;arpa/inet.h&amp;gt; #include &amp;lt;string.h&amp;gt; #define SERVER_PORT 6789  #define CPU_PORT 9009  #define BUFF_LEN 1024  int main(int argc, char* argv[]) { int server_fd, count; struct sockaddr_in ser_addr; struct sockaddr_in src_addr; socklen_t len; char buf[BUFF_LEN]; server_fd = socket(AF_INET, SOCK_DGRAM, 0); //IPV4,UDP  memset(&amp;amp;ser_addr, 0, sizeof(ser_addr)); ser_addr.sin_family = AF_INET; ser_addr.</description>
            <content type="html"><![CDATA[<p>UDP 是面向非连接的，如果通讯双方都在局域网中，服务器端和客户端没有区别，如果是局域网内的主机与公网上的主机通讯，由于 NAT 地址转换协议的作用，必须由局域网内的主机主动向公网的主句发送数据，公网的主机作为服务器端，必须接收客户端的数据后，解析出源 IP 和端口，再反向发送，实现双向通讯。下面是一个简单的 Demo 。</p>

<p>服务器端：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    <span style="color:#75715e">// server.c
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/socket.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;netinet/in.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;arpa/inet.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    
    <span style="color:#75715e">#define SERVER_PORT 6789
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#define CPU_PORT 9009
</span><span style="color:#75715e"></span>    <span style="color:#75715e">#define BUFF_LEN 1024
</span><span style="color:#75715e"></span>    
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[])
    {
        <span style="color:#66d9ef">int</span> server_fd, count;
        <span style="color:#66d9ef">struct</span> sockaddr_in ser_addr; 
        <span style="color:#66d9ef">struct</span> sockaddr_in src_addr;
        socklen_t len;
        <span style="color:#66d9ef">char</span> buf[BUFF_LEN];
    
        server_fd <span style="color:#f92672">=</span> socket(AF_INET, SOCK_DGRAM, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">//IPV4,UDP
</span><span style="color:#75715e"></span>    
        memset(<span style="color:#f92672">&amp;</span>ser_addr, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(ser_addr));
        ser_addr.sin_family <span style="color:#f92672">=</span> AF_INET;
        ser_addr.sin_addr.s_addr <span style="color:#f92672">=</span> htonl(INADDR_ANY); <span style="color:#75715e">// any ip
</span><span style="color:#75715e"></span>        ser_addr.sin_port <span style="color:#f92672">=</span> htons(SERVER_PORT);  <span style="color:#75715e">// server port
</span><span style="color:#75715e"></span>    
        bind(server_fd, (<span style="color:#66d9ef">struct</span> sockaddr<span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>ser_addr, <span style="color:#66d9ef">sizeof</span>(ser_addr));
    
        <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>)
        {
            <span style="color:#75715e">// recv
</span><span style="color:#75715e"></span>            memset(buf, <span style="color:#ae81ff">0</span>, BUFF_LEN);
            len <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(src_addr);
            count <span style="color:#f92672">=</span> recvfrom(server_fd, buf, BUFF_LEN, <span style="color:#ae81ff">0</span>, (<span style="color:#66d9ef">struct</span> sockaddr<span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>src_addr, <span style="color:#f92672">&amp;</span>len);  <span style="color:#75715e">//block
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(count <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
            {
                printf(<span style="color:#e6db74">&#34;recieve data fail!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
            }
            printf(<span style="color:#e6db74">&#34;server recv from %s:%d : %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,inet_ntoa(src_addr.sin_addr),ntohs(src_addr.sin_port),buf);
    
            <span style="color:#75715e">// send
</span><span style="color:#75715e"></span>            memset(buf, <span style="color:#ae81ff">0</span>, BUFF_LEN);
            sprintf(buf, <span style="color:#e6db74">&#34;Server have recieved %d bytes data!&#34;</span>, count);
            printf(<span style="color:#e6db74">&#34;server send : %s</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>,buf);
            <span style="color:#75715e">// send to src_addr
</span><span style="color:#75715e"></span>            sendto(server_fd, buf, BUFF_LEN, <span style="color:#ae81ff">0</span>, (<span style="color:#66d9ef">struct</span> sockaddr<span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>src_addr, len);
        }
    
        close(server_fd);
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    }</code></pre></div>
<p>客户端：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c:n" data-lang="c:n">    // cpu.c
    #include &lt;stdio.h&gt;
    #include &lt;unistd.h&gt;
    #include &lt;sys/types.h&gt;
    #include &lt;sys/socket.h&gt;
    #include &lt;netinet/in.h&gt;
    #include &lt;arpa/inet.h&gt;
    #include &lt;string.h&gt;
    
    #define SERVER_IP &#34;118.89.16.24&#34;
    #define SERVER_PORT 6789
    #define CPU_PORT 9009
    #define BUFF_LEN 1024
    
    int main(int argc, char* argv[])
    {
        int cpu_fd;
        struct sockaddr_in ser_addr;
        struct sockaddr_in src_addr;
        struct sockaddr_in my_addr;
        socklen_t len;
        char buf[BUFF_LEN] = &#34;cpu msg!&#34;;
    
        cpu_fd = socket(AF_INET, SOCK_DGRAM, 0); //IPV4,UDP
    
        memset(&amp;my_addr, 0, sizeof(my_addr));
        my_addr.sin_family = AF_INET;
        my_addr.sin_addr.s_addr = htonl(INADDR_ANY); // any ip
        my_addr.sin_port = htons(CPU_PORT);  // server port
        bind(cpu_fd, (struct sockaddr*)&amp;my_addr, sizeof(my_addr));
    
        memset(&amp;ser_addr, 0, sizeof(ser_addr));
        ser_addr.sin_family = AF_INET;
        ser_addr.sin_addr.s_addr = inet_addr(SERVER_IP); 
        ser_addr.sin_port = htons(SERVER_PORT);
    
        len = sizeof(ser_addr);
        printf(&#34;CPU send : %s\n&#34;,buf);  
        sendto(cpu_fd, buf, BUFF_LEN, 0, (struct sockaddr*)&amp;ser_addr, len);
    
        memset(buf, 0, BUFF_LEN);
        recvfrom(cpu_fd, buf, BUFF_LEN, 0, (struct sockaddr*)&amp;src_addr, &amp;len);  //recv msg from server
        printf(&#34;CPU recv from %s:%d : %s\n&#34;,inet_ntoa(src_addr.sin_addr),ntohs(src_addr.sin_port),buf);
    
        close(cpu_fd);
        return 0;
    }</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>iptables 学习笔记</title>
            <link>https://shaocheng.li/posts/2018/12/12/</link>
            <pubDate>Wed, 12 Dec 2018 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2018/12/12/</guid>
            <description>关于 iptables 的原理，这里有一份教程写得深入浅出，浅显易懂：
 iptables 详解  常用的命令可以参考参考 iptables 手册
下面记录一些常见的 iptables 应用场景。
1. IP 转发 IP 转发也可以叫做路由转发，用于连接两个不同的网段，做软路由时经常用到，如下是一个应用场景的网络拓扑：
中间的路由器上是 Linux 系统，有两张网卡，eth0 作为 LAN 口连接内网，wan 作为 WAN 口连接公网。要实现软路由功能，使内网的设备可以通过 WAN 口上网。首先需要开启内核的 IP 转发功能，可以用 sysctl 命令或者直接查看 /proc/sys/net/ipv4/ip_forward 文件获得当前系统的 ip_forward 是否开启：
~# sysctl net.ipv4.ip_forward net.ipv4.ip_forward = 0 ~# cat /proc/sys/net/ipv4/ip_forward 0  Linux 系统默认是禁止 IP 转发的，所有返回 0 ，可以用 sysctl 命令或者直接向 /proc/sys/net/ipv4/ip_forward 文件写 1 来开启 IP 转发，如果要永久开启，可以在 /etc/sysctl.conf 文件中修改配置：
~# cat /etc/sysctl.conf | grep ip_forward net.</description>
            <content type="html"><![CDATA[

<p>关于 iptables 的原理，这里有一份教程写得深入浅出，浅显易懂：</p>

<ul>
<li><a href="http://www.zsythink.net/archives/1199" target="_blank">iptables 详解</a></li>
</ul>

<p><img src="/images/2018-12-12/2018-12-12_1.png" alt="" /></p>

<p>常用的命令可以参考参考 <a href="https://linux.die.net/man/8/iptables" target="_blank">iptables 手册</a></p>

<p>下面记录一些常见的 iptables 应用场景。</p>

<h2 id="1-ip-转发">1. IP 转发</h2>

<p>IP 转发也可以叫做路由转发，用于连接两个不同的网段，做软路由时经常用到，如下是一个应用场景的网络拓扑：</p>

<p><img src="/images/2018-12-12/2018-12-12_2.png" alt="" /></p>

<p>中间的路由器上是 Linux 系统，有两张网卡，eth0 作为 LAN 口连接内网，wan 作为 WAN 口连接公网。要实现软路由功能，使内网的设备可以通过 WAN 口上网。首先需要开启内核的 IP 转发功能，可以用 sysctl 命令或者直接查看 <code>/proc/sys/net/ipv4/ip_forward</code> 文件获得当前系统的 ip_forward 是否开启：</p>

<pre><code>~# sysctl net.ipv4.ip_forward
net.ipv4.ip_forward = 0
~# cat /proc/sys/net/ipv4/ip_forward
0
</code></pre>

<p>Linux 系统默认是禁止 IP 转发的，所有返回 0 ，可以用 sysctl 命令或者直接向 <code>/proc/sys/net/ipv4/ip_forward</code> 文件写 1 来开启 IP 转发，如果要永久开启，可以在 <code>/etc/sysctl.conf</code> 文件中修改配置：</p>

<pre><code>~# cat /etc/sysctl.conf | grep ip_forward
net.ipv4.ip_forward=1
</code></pre>

<p>然后在 iptables 中添加规则：</p>

<pre><code># Default policy to drop all incoming packets
iptables -P INPUT DROP
iptables -P FORWARD DROP

# Accept incoming packets from localhost and the LAN interface
iptables -A INPUT -i lo -j ACCEPT
iptables -A INPUT -i eth0 -j ACCEPT

# Accept incoming packets from the WAN if the router initiated the connection
iptables -A INPUT -i wan -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# Forward LAN packets to the WAN
iptables -A FORWARD -i eth0 -o wan -j ACCEPT

# Forward WAN packets to the LAN if the LAN initiated the connection
iptables -A FORWARD -i wan -o eth0 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# NAT traffic going out the WAN interface
iptables -t nat -A POSTROUTING -o wwan -j MASQUERADE
</code></pre>

<h2 id="2-端口映射">2. 端口映射</h2>

<p>端口映射就是将外网主机的一个端口映射到内网中某台主机的某个端口，当用户访问外网主机的这个端口时，实际上是由内网主机的相应端口通讯。如下是一个典型的应用场景：</p>

<p><img src="/images/2018-12-12/2018-12-12_3.png" alt="" /></p>

<p>在这个网络拓扑里，右侧 192.168.2.101 的主机想要访问下方路由器连接的 192.168.1.101 主机的 HTTP 服务，该怎么办呢？</p>

<p>方法是在下方路由器上做端口映射，将 192.168.1.101 的 80 端口映射到 192.168.2.103 的 80 端口上，这样直接访问 192.168.2.103:80 就可以与 192.168.1.101:80 通讯。
具体添加的规则是：</p>

<pre><code>iptables -t nat -I PREROUTING -i eth2 -d 192.168.2.103 -p tcp --dport 80 -j DNAT --to-destination 192.168.1.101:80
iptables -t nat -I POSTROUTING -o eth1 -d 192.168.1.101 -p tcp --dport 80 -j SNAT --to-source 192.168.1.1
</code></pre>

<p>当 192.168.2.101 访问 192.168.2.103:80 时，第一条规则在入口处修改了数据包的目的地址，第二条规则在出口处修改了源地址，就将数据包转移到了 192.168.1.101:80 。</p>

<h2 id="3-禁止-ping">3. 禁止 ping</h2>

<p>禁止 ping 指的是禁止别的主机 ping 本机，可以添加如下规则：</p>

<pre><code>iptables -t filter -I INPUT -p icmp -m icmp --icmp-type 8/0 -j REJECT
# or
iptables -t filter -I INPUT -p icmp -m icmp --icmp-type 8 -j REJECT
# or
iptables -t filter -I INPUT -p icmp -m icmp --icmp-type &quot;echo-request&quot; -j REJECT
</code></pre>

<p>发出的 ping 请求属于 type 8 类型的 ICMP 报文，这条规则表示 type 为 8 ，code 为 0 的 ICMP 包会被拒绝。</p>
]]></content>
        </item>
        
        <item>
            <title>用 timedatectl 管理系统时间</title>
            <link>https://shaocheng.li/posts/2018/09/24/</link>
            <pubDate>Mon, 24 Sep 2018 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2018/09/24/</guid>
            <description>查看当前系统时间：
$ timedatectl status Local time: Thu 2018-09-20 09:42:53 CST Universal time: Thu 2018-09-20 01:42:53 UTC RTC time: Thu 2018-09-20 01:42:53 Time zone: Asia/Chongqing (CST, +0800) Network time on: yes NTP synchronized: yes RTC in local TZ: no RTC in local TZ: no 表示 RTC 时钟不是用本地时间，而是使用 UTC 时间，可以改成使用本地时间，但是并不推荐这么做：
$ timedatectl set-local-rtc 1 $ timedatectl Local time: Thu 2018-09-20 03:57:58 CEST Universal time: Thu 2018-09-20 01:57:58 UTC RTC time: Thu 2018-09-20 03:57:59 Time zone: Europe/Paris (CEST, +0200) Network time on: yes NTP synchronized: yes RTC in local TZ: yes Warning: The system is configured to read the RTC time in the local time zone.</description>
            <content type="html"><![CDATA[<p>查看当前系统时间：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ timedatectl status
      Local time: Thu <span style="color:#ae81ff">2018</span>-09-20 <span style="color:#ae81ff">09</span>:42:53 CST
  Universal time: Thu <span style="color:#ae81ff">2018</span>-09-20 <span style="color:#ae81ff">01</span>:42:53 UTC
        RTC time: Thu <span style="color:#ae81ff">2018</span>-09-20 <span style="color:#ae81ff">01</span>:42:53
       Time zone: Asia/Chongqing <span style="color:#f92672">(</span>CST, +0800<span style="color:#f92672">)</span>
 Network time on: yes
NTP synchronized: yes
 RTC in local TZ: no</code></pre></div>
<p><code>RTC in local TZ: no</code> 表示 RTC 时钟不是用本地时间，而是使用 UTC 时间，可以改成使用本地时间，但是并不推荐这么做：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ timedatectl set-local-rtc <span style="color:#ae81ff">1</span>
$ timedatectl
      Local time: Thu <span style="color:#ae81ff">2018</span>-09-20 <span style="color:#ae81ff">03</span>:57:58 CEST
  Universal time: Thu <span style="color:#ae81ff">2018</span>-09-20 <span style="color:#ae81ff">01</span>:57:58 UTC
        RTC time: Thu <span style="color:#ae81ff">2018</span>-09-20 <span style="color:#ae81ff">03</span>:57:59
       Time zone: Europe/Paris <span style="color:#f92672">(</span>CEST, +0200<span style="color:#f92672">)</span>
 Network time on: yes
NTP synchronized: yes
 RTC in local TZ: yes

Warning: The system is configured to read the RTC time in the local time zone.
         This mode can not be fully supported. It will create various problems
         with time zone changes and daylight saving time adjustments. The RTC
         time is never updated, it relies on external facilities to maintain it.
         If at all possible, use RTC in UTC by calling
         <span style="color:#e6db74">&#39;timedatectl set-local-rtc 0&#39;</span>.</code></pre></div>
<p>列出所有可用的时区：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ timedatectl list-timezones</code></pre></div>
<p>修改时区：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ timedatectl set-timezone <span style="color:#e6db74">&#34;Europe/Paris&#34;</span>
$ timedatectl
      Local time: Thu <span style="color:#ae81ff">2018</span>-09-20 <span style="color:#ae81ff">03</span>:46:02 CEST
  Universal time: Thu <span style="color:#ae81ff">2018</span>-09-20 <span style="color:#ae81ff">01</span>:46:02 UTC
        RTC time: Thu <span style="color:#ae81ff">2018</span>-09-20 <span style="color:#ae81ff">01</span>:46:02
       Time zone: Europe/Paris <span style="color:#f92672">(</span>CEST, +0200<span style="color:#f92672">)</span>
 Network time on: yes
NTP synchronized: yes
 RTC in local TZ: no
$ cat /etc/timezone
Europe/Paris
$ date
Thu Sep <span style="color:#ae81ff">20</span> <span style="color:#ae81ff">03</span>:46:48 CEST <span style="color:#ae81ff">2018</span></code></pre></div>
<p>设置时间和日期：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">timedatectl set-time <span style="color:#e6db74">&#39;16:10:40 2018-11-20&#39;</span></code></pre></div>
<p>关闭时间同步，实际是关闭 <code>systemd-timesyncd.service</code> 服务：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ timedatectl set-ntp <span style="color:#ae81ff">0</span>
$ timedatectl
      Local time: Thu <span style="color:#ae81ff">2018</span>-09-20 <span style="color:#ae81ff">04</span>:19:41 CEST
  Universal time: Thu <span style="color:#ae81ff">2018</span>-09-20 <span style="color:#ae81ff">02</span>:19:41 UTC
        RTC time: Thu <span style="color:#ae81ff">2018</span>-09-20 <span style="color:#ae81ff">02</span>:19:41
       Time zone: Europe/Paris <span style="color:#f92672">(</span>CEST, +0200<span style="color:#f92672">)</span>
 Network time on: no
NTP synchronized: yes
 RTC in local TZ: no
$ systemctl status systemd-timesyncd.service
● systemd-timesyncd.service - Network Time Synchronization
   Loaded: loaded <span style="color:#f92672">(</span>/lib/systemd/system/systemd-timesyncd.service; disabled; vendor preset: enabled<span style="color:#f92672">)</span>
  Drop-In: /lib/systemd/system/systemd-timesyncd.service.d
           └─disable-with-time-daemon.conf
   Active: inactive <span style="color:#f92672">(</span>dead<span style="color:#f92672">)</span>
     Docs: man:systemd-timesyncd.service<span style="color:#f92672">(</span><span style="color:#ae81ff">8</span><span style="color:#f92672">)</span>

Feb <span style="color:#ae81ff">11</span> <span style="color:#ae81ff">17</span>:28:02 ubuntu systemd-timesyncd<span style="color:#f92672">[</span><span style="color:#ae81ff">472</span><span style="color:#f92672">]</span>: System clock time unset or jumped backwards, restoring from recorded timestamp:
Sep <span style="color:#ae81ff">19</span> <span style="color:#ae81ff">11</span>:36:39 ubuntu systemd<span style="color:#f92672">[</span><span style="color:#ae81ff">1</span><span style="color:#f92672">]</span>: Started Network Time Synchronization.
Sep <span style="color:#ae81ff">20</span> <span style="color:#ae81ff">03</span>:19:45 ubuntu systemd-timesyncd<span style="color:#f92672">[</span><span style="color:#ae81ff">472</span><span style="color:#f92672">]</span>: Synchronized to time server <span style="color:#ae81ff">91</span>.189.91.157:123 <span style="color:#f92672">(</span>ntp.ubuntu.com<span style="color:#f92672">)</span>.
Sep <span style="color:#ae81ff">20</span> <span style="color:#ae81ff">04</span>:19:37 ubuntu systemd<span style="color:#f92672">[</span><span style="color:#ae81ff">1</span><span style="color:#f92672">]</span>: Stopping Network Time Synchronization...
Sep <span style="color:#ae81ff">20</span> <span style="color:#ae81ff">04</span>:19:37 ubuntu systemd<span style="color:#f92672">[</span><span style="color:#ae81ff">1</span><span style="color:#f92672">]</span>: Stopped Network Time Synchronization.
Sep <span style="color:#ae81ff">20</span> <span style="color:#ae81ff">04</span>:20:27 ubuntu systemd<span style="color:#f92672">[</span><span style="color:#ae81ff">1</span><span style="color:#f92672">]</span>: Starting Network Time Synchronization...
Sep <span style="color:#ae81ff">20</span> <span style="color:#ae81ff">04</span>:20:27 ubuntu systemd<span style="color:#f92672">[</span><span style="color:#ae81ff">1</span><span style="color:#f92672">]</span>: Started Network Time Synchronization.
Sep <span style="color:#ae81ff">20</span> <span style="color:#ae81ff">04</span>:20:27 ubuntu systemd-timesyncd<span style="color:#f92672">[</span><span style="color:#ae81ff">1901</span><span style="color:#f92672">]</span>: Synchronized to time server <span style="color:#ae81ff">91</span>.189.89.198:123 <span style="color:#f92672">(</span>ntp.ubuntu.com<span style="color:#f92672">)</span>.
Sep <span style="color:#ae81ff">20</span> <span style="color:#ae81ff">04</span>:20:51 ubuntu systemd<span style="color:#f92672">[</span><span style="color:#ae81ff">1</span><span style="color:#f92672">]</span>: Stopping Network Time Synchronization...
Sep <span style="color:#ae81ff">20</span> <span style="color:#ae81ff">04</span>:20:51 ubuntu systemd<span style="color:#f92672">[</span><span style="color:#ae81ff">1</span><span style="color:#f92672">]</span>: Stopped Network Time Synchronization.</code></pre></div>
<p><code>systemd-timesyncd.service</code> 调用的是 <code>/lib/systemd/systemd-timesyncd</code> 守护进程执行时间同步，配置文件是 <code>/etc/systemd/timesyncd.conf</code> ，有两个选项：</p>

<ul>
<li>NTP= ，主 NTP 服务器域名或者 IP 列表，多个地址之间用空格隔开。</li>
<li>FallbackNTP= ，备用 NTP 服务器域名或者 IP 列表，多个地址之间用空格隔开。</li>
</ul>

<p>每次时间同步后都会更新 <code>/var/lib/systemd/clock</code> 文件：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ ll /var/lib/systemd/clock
-rw-r--r-- <span style="color:#ae81ff">1</span> systemd-timesync systemd-timesync <span style="color:#ae81ff">0</span> Spe <span style="color:#ae81ff">25</span> <span style="color:#ae81ff">14</span>:09 /var/lib/systemd/clock</code></pre></div>
<p>大约 20 分钟同步一次，这个时间间隔不可以设置。</p>
]]></content>
        </item>
        
        <item>
            <title>包管理器 dnf 学习笔记</title>
            <link>https://shaocheng.li/posts/2018/09/21/</link>
            <pubDate>Fri, 21 Sep 2018 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2018/09/21/</guid>
            <description>dnf 是 Fedora 上的新一代软件包管理器，从 Fedora22 开始取代了原有的 yum 。拥有超级用户权限才可以使用 dnf 在系统上安装、更新和删除软件包。
1. 配置 dnf 的配置文件位于 /etc/dnf/dnf.conf ,文件里的配置信息按不同种类分为多个小节，其中必须的 [main] 小节包含了所有全局选项，还可能包含一些 [repository] 小节用于设置特定存储库的选项，但是建议在 /etc/yum.repos.d/ 目录中的 .repo 文件里定义某个存储库的选项，这些选项的值会覆盖 [main] 小节的同名选项。
最简单的 /etc/dnf/dnf.conf 文件类似如下：
[main] gpgcheck=1 installonly_limit=3 clean_requirements_on_remove=true  常用的选项和含义包括：
 gpgcheck=value ，value 可选两个值，0 表示禁止所有 GPG 签名检查，1 表示对所有安装的包进行 GPG 签名检查。 installonlypkgs=space separated list of packages ，这个选项中列出的软件包只安装不更新，多个软件包之间用空格分开。 installonly_limit=value ，value 是一个整数，表示 installonlypkgs 指令中列出的软件包可以同时安装的最大版本数。installonlypkgs 指令的默认值包括几个不同的内核包，因此，更改 installonly_limit 的值也会影响任何单个内核包的最大安装版本数。 /etc/dnf/dnf.conf 中列出的默认值为 installonly_limit = 3，建议不要降低此值，尤其是低于2。 keepcache=value ，value 可选两个值，0 表示成功安装后不保留标头和软件包的缓存，这是默认值。1 表示成功安装后保留缓存。  2.</description>
            <content type="html"><![CDATA[

<p>dnf 是 Fedora 上的新一代软件包管理器，从 Fedora22 开始取代了原有的 yum 。拥有超级用户权限才可以使用 dnf 在系统上安装、更新和删除软件包。</p>

<h2 id="1-配置">1. 配置</h2>

<p>dnf 的配置文件位于 <code>/etc/dnf/dnf.conf</code> ,文件里的配置信息按不同种类分为多个小节，其中必须的 [main] 小节包含了所有全局选项，还可能包含一些 [repository] 小节用于设置特定存储库的选项，但是建议在 <code>/etc/yum.repos.d/</code> 目录中的 <code>.repo</code> 文件里定义某个存储库的选项，这些选项的值会覆盖 [main] 小节的同名选项。</p>

<p>最简单的 <code>/etc/dnf/dnf.conf</code> 文件类似如下：</p>

<pre><code>[main]
gpgcheck=1
installonly_limit=3
clean_requirements_on_remove=true
</code></pre>

<p>常用的选项和含义包括：</p>

<ul>
<li>gpgcheck=value ，value 可选两个值，0 表示禁止所有 GPG 签名检查，1 表示对所有安装的包进行 GPG 签名检查。</li>
<li>installonlypkgs=space separated list of packages ，这个选项中列出的软件包只安装不更新，多个软件包之间用空格分开。</li>
<li>installonly_limit=value ，value 是一个整数，表示 installonlypkgs 指令中列出的软件包可以同时安装的最大版本数。installonlypkgs 指令的默认值包括几个不同的内核包，因此，更改 installonly_limit 的值也会影响任何单个内核包的最大安装版本数。 /etc/dnf/dnf.conf 中列出的默认值为 installonly_limit = 3，建议不要降低此值，尤其是低于2。</li>
<li>keepcache=value ，value 可选两个值，0 表示成功安装后不保留标头和软件包的缓存，这是默认值。1 表示成功安装后保留缓存。</li>
</ul>

<h2 id="2-使用">2. 使用</h2>

<h3 id="2-1-更新">2.1. 更新</h3>

<p>检测并安装所有软件包的更新：</p>

<pre><code>dnf upgrade
</code></pre>

<p>如果带有包的名字就可以单独更新某个包：</p>

<pre><code>dnf upgrade package_name
</code></pre>

<p>只检查可用的更新：</p>

<pre><code>dnf check-update
</code></pre>

<h3 id="2-2-查找">2.2. 查找</h3>

<p>在源里搜索所有名字里包含 <code>term</code> 的包：</p>

<pre><code>dnf search term
</code></pre>

<p>名字匹配时支持两种通配符，如果名字本身就包含这两个通配符，可以用反斜杠转义：</p>

<ul>
<li>* ，星号可以匹配任何字符多次</li>
<li>？，问号可以匹配任何一个字符</li>
</ul>

<p>列出所有已安装的和可安装的软件包：</p>

<pre><code>dnf list all
</code></pre>

<p>仅列出已安装的软件包</p>

<pre><code>dnf list installed
</code></pre>

<p>列出未安装但可用的软件包：</p>

<pre><code>dnf list available
</code></pre>

<p>也可以列出名字匹配的包：</p>

<pre><code>dnf list term
</code></pre>

<p>显示某个包的详细信息：</p>

<pre><code>dnf info package_name
</code></pre>

<h3 id="2-3-安装">2.3. 安装</h3>

<p>用 install 命令安装软件包，可以一次安装多个：</p>

<pre><code>dnf install package_name...
</code></pre>

<p>如果不知道某个软件包的名字，只知道它的某个二进制文件的安装路径，也可以只写该文件的路径，dnf 会自动搜索并安装，例如：</p>

<pre><code>dnf install /usr/sbin/named
</code></pre>

<p>删除某个包用 remove 命令：</p>

<pre><code>dnf remove package_name...
</code></pre>

<h3 id="2-4-历史">2.4. 历史</h3>

<p>dnf 的 history 命令可以让用户查看使用记录，包括安装、更新、删除等各种操作使用的命令和时间等详情，例如列出所有的历史操作记录：</p>

<pre><code>dnf history list
</code></pre>

<p>根据操作顺序的 ID 列出某个范围的历史记录：</p>

<pre><code>dnf history list start_id..end_id
</code></pre>

<p>撤销某一步操作：</p>

<pre><code>dnf history undo id
</code></pre>

<p>重做某一步操作：</p>

<pre><code>dnf history redo id
</code></pre>

<h2 id="参考">参考</h2>

<p>[DNF Command Reference](<a href="https://dnf.readthedocs.io/en/latest/command_ref.html&gt;" target="_blank">https://dnf.readthedocs.io/en/latest/command_ref.html&gt;</a></p>
]]></content>
        </item>
        
        <item>
            <title>Linux 系统如何获取 CPU 主频</title>
            <link>https://shaocheng.li/posts/2018/08/07/</link>
            <pubDate>Tue, 07 Aug 2018 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2018/08/07/</guid>
            <description>1.CPU 主频 CPU 的主频是指 CPU 核心的时钟频率，它是 CPU 执行指令的最小时间单位。CPU 内部有时钟管理模块，通过外部振荡器（获取其他时钟电路）输入一个特定的频率（外频），经过内部的 PLL 电路（倍频器）锁定到一个很高的频率，再经过不同的分频，供给不同的模块和总线使用，供给 CPU 的就称为主频,就是通常所说的“主频 = 外频 x 倍频”。目前桌面 X86 CPU 的外频由主板供给，通常是 100MHz ，倍频通常是固定设置的。如果要超频，通常是在主板的 BIOS 中修改倍频因子，也有特殊情况可以增加外频。
X86-Linux 体系有三种硬件时钟：
 Real Time Clock(RTC) ，实时时钟，通常位于 CMOS ，独立工作 Programmalbe Interval Timer(PIT) ，可编程的间隔定时器，通常由 8254 芯片实现 Time Stamp Counter(TSC) ，时间戳控制器，记录 CPU 时钟周期  Linux 内核在计算 CPU 主频时会用到 PIT 和 TSC 。以下是在 kernel 3.4 版本中分析。
2.Programmalbe Interval Timer (PIT) Programmalbe Interval Timer (PIT) 是现代计算机的重要组成部分，尤其是在多任务环境中。 PIT 是用 8253&amp;frasl;8254 芯片实现的，由于历史原因，外接的晶振频率是 1.</description>
            <content type="html"><![CDATA[

<h2 id="1-cpu-主频">1.CPU 主频</h2>

<p>CPU 的主频是指 CPU 核心的时钟频率，它是 CPU 执行指令的最小时间单位。CPU 内部有时钟管理模块，通过外部振荡器（获取其他时钟电路）输入一个特定的频率（外频），经过内部的 PLL 电路（倍频器）锁定到一个很高的频率，再经过不同的分频，供给不同的模块和总线使用，供给 CPU 的就称为主频,就是通常所说的“主频 = 外频 x 倍频”。目前桌面 X86 CPU 的外频由主板供给，通常是 100MHz ，倍频通常是固定设置的。如果要超频，通常是在主板的 BIOS 中修改倍频因子，也有特殊情况可以增加外频。</p>

<p>X86-Linux 体系有三种硬件时钟：</p>

<ul>
<li>Real Time Clock(RTC) ，实时时钟，通常位于 CMOS ，独立工作</li>
<li>Programmalbe Interval Timer(PIT) ，可编程的间隔定时器，通常由 8254 芯片实现</li>
<li>Time Stamp Counter(TSC) ，时间戳控制器，记录 CPU 时钟周期</li>
</ul>

<p>Linux 内核在计算 CPU 主频时会用到 PIT 和 TSC 。以下是在 kernel 3.4 版本中分析。</p>

<h2 id="2-programmalbe-interval-timer-pit">2.Programmalbe Interval Timer (PIT)</h2>

<p>Programmalbe Interval Timer (PIT) 是现代计算机的重要组成部分，尤其是在多任务环境中。 PIT 是用 <sup>8253</sup>&frasl;<sub>8254</sub> 芯片实现的，由于历史原因，外接的晶振频率是 1.193182 MHz ，Linux 内核里的定义在 <code>include/linux/timex.h</code> 文件：</p>

<pre><code>/* The clock frequency of the i8253/i8254 PIT */
#define PIT_TICK_RATE 1193182ul
</code></pre>

<p><sup>8253</sup>&frasl;<sub>8254</sub> 内置三个独立的 16 位减法计数器用于分频，每个计数器有一个输出用于特定的功能，示意图如下：</p>

<p><img src="/images/2018-08-07/2018-08-07_1.png" alt="" /></p>

<ol>
<li>Channel 0 ：PIT Channel 0 的输出连接在中断控制器上，因此它会产生 “IRQ 0”。通常在引导阶段，BIOS 将 Channel 0 设置为 65535 或 0（转换为65536），这将提供 18.2065Hz 的输出频率（每 54.9254ms 一次的中断）。 Channel 0 可能是最有用的 PIT 通道，因为它是唯一连接到 IRQ 的通道，可以用它产生定时中断。选择工作模式时，要注意 IRQ0 是由 Channel 0 输出电压的上升沿产生的。</li>
<li>Channel 1 ：PIT Channel 1 的输出曾被用于刷新 DRAM 或 RAM 。通常，RAM 中的每个位由一个电容器组成，该电容器保持代表该位状态的微小电荷，但是由于泄漏，这些电容器需要定期“刷新”，以便它们不会忘记自己的状态。在以后的机器上，DRAM 刷新是通过专用硬件完成的，不再使用 PIT 。在大规模集成电路中实现的现代计算机上，PIT Channel 1 不再可用。</li>
<li>Channel 2 ：PIT Channel 2 的输出连接在蜂鸣器上，因此输出的频率决定了蜂鸣器产生的声音的频率。这是唯一可以通过软件控制门信号的通道（通过I/O 端口 0x61 的 bit0），也可以用软件读取其输出。</li>
</ol>

<p>PIT 的 <sup>8253</sup>&frasl;<sub>8254</sub> 芯片有四个寄存器，包括三个数据寄存器和一个模式控制寄存器，它们的地址和功能描述：</p>

<table>
<thead>
<tr>
<th>I/O port</th>
<th>Usage</th>
</tr>
</thead>

<tbody>
<tr>
<td>0x40</td>
<td>Channel 0 data port (read/write)</td>
</tr>

<tr>
<td>0x41</td>
<td>Channel 1 data port (read/write)</td>
</tr>

<tr>
<td>0x42</td>
<td>Channel 2 data port (read/write)</td>
</tr>

<tr>
<td>0x43</td>
<td>Mode/Command register (write only, a read is ignored)</td>
</tr>
</tbody>
</table>

<p>模式控制寄存器的格式：</p>

<p><img src="/images/2018-08-07/2018-08-07_2.jpg" alt="" /></p>

<p>编程方式是先在模式控制寄存器中设置计数器、读写方式和工作模式，然后向相应的计数器中写入初始值。</p>

<h2 id="3-time-stamp-counter-tsc">3.Time Stamp Counter (TSC)</h2>

<p>时间戳控制器 Time Stamp Counter (TSC) 是 X86 CPU 里的一个 64 位寄存器，自 Pentium 开始引入，用于记录 CPU 复位后的周期数，CPU 内部时钟每产生一个时钟周期，该寄存器就加一，也就是 CPU 主频的节拍记录器。我们可以用单位时间内 TSC 记录的时钟周期个数来推算 CPU 的实际频率，比如一秒内 TSC 的值增长了 1000 ，那么主频就是 1KHz 。在单核 CPU 上，TSC 是一个简单高效的获取高精度 CPU 时序信息的方式，但是在多核 CPU 、休眠操作系统上，这个方式无法提供准确信息，依赖 TSC 会降低软件的可移植性。在 Windows 平台上，微软反对使用 TSC 进行高精度计时，在 POSIX 系统上，程序可以使用 <code>clock_gettime()</code> 函数读取 CLOCK_MONOTONIC 时钟的值来获得类似的功能。在 Linux 的内核上，可以用启动参数 <code>notsc</code> 禁用 TSC 。</p>

<p>X86 CPU 提供了 RDTSC 指令来读取 TSC 的值，低 32 位存放在 EAX 寄存器，高 32 位存放在 EDX 寄存器:</p>

<table>
<thead>
<tr>
<th>指令</th>
<th>操作码</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>RDTSC</td>
<td>0F 31</td>
<td>将 TSC 的值读入 EDX:EAX</td>
</tr>
</tbody>
</table>

<p>在内核源码的 <code>arch/x86/include/asm/msr.h</code> 文件中提供了读取方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C {.line-numbers}" data-lang="C {.line-numbers}">#ifdef CONFIG_X86_64
#define DECLARE_ARGS(val, low, high)	unsigned low, high
#define EAX_EDX_VAL(val, low, high)	((low) | ((u64)(high) &lt;&lt; 32))
#define EAX_EDX_ARGS(val, low, high)	&#34;a&#34; (low), &#34;d&#34; (high)
#define EAX_EDX_RET(val, low, high)	&#34;=a&#34; (low), &#34;=d&#34; (high)
#else
#define DECLARE_ARGS(val, low, high)	unsigned long long val
#define EAX_EDX_VAL(val, low, high)	(val)
#define EAX_EDX_ARGS(val, low, high)	&#34;A&#34; (val)
#define EAX_EDX_RET(val, low, high)	&#34;=A&#34; (val)
#endif
static __always_inline unsigned long long __native_read_tsc(void)
{
    DECLARE_ARGS(val, low, high);
    asm volatile(&#34;rdtsc&#34; : EAX_EDX_RET(val, low, high));
    return EAX_EDX_VAL(val, low, high);
}</code></pre></div>
<p>我们可以在用户空间用 C 语言内联汇编实现同样的功能：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C {.line-numbers}" data-lang="C {.line-numbers}">#include &lt;stdio.h&gt;
int main()
{
    unsigned int low=0, high=0;
    asm volatile(&#34;rdtsc&#34; : &#34;=a&#34;(low), &#34;=d&#34;(high));
    printf(&#34;0x%x 0x%x\n&#34;,high,low);
}</code></pre></div>
<h2 id="4-计算主频">4.计算主频</h2>

<p>Linux 内核在初始化阶段用 TSC 来计算 CPU 主频。我们可以在 dmesg 中找到类似的信息：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell {.line-numbers}" data-lang="shell {.line-numbers}">$ dmesg | grep -E &#34;TSC|tsc&#34;
tsc: Fast TSC calibration using PIT
tsc: Detected 3192.872 MHz processor
TSC deadline timer enabled
tsc: Refined TSC clocksource calibration: 3192.747 MHz
Switched to clocksource tsc</code></pre></div>
<p>前缀的 tsc 是模块的名称，有些内核可能没有这个，没有关系，我们从 <code>Detected 3192.872 MHz processor</code> 入手，这是在 <code>arch/x86/kernel/tsc.c</code> 文件的 <code>tsc_init()</code> 函数中打印的信息，属于内核的时钟子系统，它通过如下路径调用：</p>

<pre><code>start_kernel() -&gt; time_init() —&gt; x86_late_time_init() -&gt; tsc_init()
</code></pre>

<p>这个函数执行的是 TSC 模块的初始化工作，然后校准 TSC 频率，设置为 CPU 主频，判断 TSC 频率是否可靠，用 TSC 频率计算 lpj 等，我们先关注这一段：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C {.line-numbers}" data-lang="C {.line-numbers}">unsigned int __read_mostly cpu_khz;
EXPORT_SYMBOL(cpu_khz);
unsigned int __read_mostly tsc_khz;
EXPORT_SYMBOL(tsc_khz);

void __init tsc_init(void)
{
    ...
    tsc_khz = x86_platform.calibrate_tsc();
    cpu_khz = tsc_khz;
    if (!tsc_khz) {
        mark_tsc_unstable(&#34;could not calculate TSC khz&#34;);
        return;
    }
    printk(&#34;Detected %lu.%03lu MHz processor.\n&#34;,
            (unsigned long)cpu_khz / 1000,
            (unsigned long)cpu_khz % 1000);
    ...
}</code></pre></div>
<p>其中的 <code>x86_platform.calibrate_tsc()</code> 调用的是 <code>native_calibrate_tsc()</code> 函数，它的功能是校准 tsc ，获取 tsc 频率。首先用 PIT 快速校准 TSC ，它的原理是用 PIT 记录一段时间，再测量这段时间内 TSC 的变换量，就可以计算出主频，通过 <code>quick_pit_calibrate()</code> 函数实现：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C {.line-numbers}" data-lang="C {.line-numbers}">/*
  读取 PIT 的 MSB ，判断 MSB 是否等于参数 val
*/
static inline int pit_verify_msb(unsigned char val)
{
    /* Ignore LSB */
    inb(0x42);
    return inb(0x42) == val;
}
/*
  这个函数通过一个 for 循环不断的读取和判断 PIT 和 TSC ，最终用 *tscp 返回 MSB==val 时的 TSC 的值，*deltap 返回是增量（ delta ：希腊字母第四个）
*/
static inline int pit_expect_msb(unsigned char val, u64 *tscp, unsigned long *deltap)
{
    int count;
    u64 tsc = 0, prev_tsc = 0;
    for (count = 0; count &lt; 50000; count++) {
        if (!pit_verify_msb(val)) // PIT 的 MSB 等于 val 时跳出循环
            break;
        prev_tsc = tsc;
        tsc = get_cycles(); //读取 tsc 的值，最终是调用上一章提到的 __native_read_tsc() 函数
    }
    *deltap = get_cycles() - prev_tsc;
    *tscp = tsc;
    return count &gt; 5;
}

/*
  这个宏确定的是迭代次数，也就是获取多少次 PIT 的 MSB 。
  我们的目标是最大错误率为 500ppm（实际上真正的误差要小得多），但是耗时不能超过 50ms ，
  MAX_QUICK_PIT_MS * PIT_TICK_RATE / 1000  得到的是 50ms 内的时钟周期个数，也就是计数器减少的数值，
  最后除以 256 是因为我们只取 MSB 。 
*/
#define MAX_QUICK_PIT_MS 50
#define MAX_QUICK_PIT_ITERATIONS (MAX_QUICK_PIT_MS * PIT_TICK_RATE / 1000 / 256) //=233
static unsigned long quick_pit_calibrate(void)
{
    int i;
    u64 tsc, delta;
    unsigned long d1, d2;

    /* 关闭蜂鸣器 */
    outb((inb(0x61) &amp; ~0x02) | 0x01, 0x61);
    /*
      计数器 2 , 读写方式是先低后高，工作模式是 0 , 二进制计数
      当计数器工作模式设为 0 后，该计数器的输出信号立即变为低电平，且计数过程中一直保持低电平。在经初值寄存器赋初值后，开始计数，在每个 CLK 时钟下降沿，计数器进行减 1 计数，当计数减到 0 时，OUT 输出信号变为高电平，且一直保持到该计数器重新赋初值。该信号可以作为中断请求信号。
      0 模式无自动装入计数初始值的功能，若要继续计数，则需要重新写入计数初始值。在计数期间，装入新的初始值，计数器会在初始值写入后重新开始计数。
    */
    outb(0xb0, 0x43);

    /* 从 0xffff 开始计数 */
    outb(0xff, 0x42);
    outb(0xff, 0x42);

    /*
      这里需要一个微小的延时，最简单的方法是第一次 PIT
    */
    pit_verify_msb(0);

    /*
      下面通过一个迭代过程测量出一段时间(50ms)内 TSC 的增长
      每次循环，PIT 都会减少 256 , i 次循环就是 (I * 256 / PIT_TICK_RATE) 秒
      delta 记录的是循环过程中 TSC 数值的增长
      循环结束后，用这两个数值计算主频
    */
    if (pit_expect_msb(0xff, &amp;tsc, &amp;d1)) {
        for (i = 1; i &lt;= MAX_QUICK_PIT_ITERATIONS; i++) {
            if (!pit_expect_msb(0xff-i, &amp;delta, &amp;d2))
                break;
            delta -= tsc;
            if (d1+d2 &gt;= delta &gt;&gt; 11) //确保误差小于 500ppm ，不理解
                continue;
            if (!pit_verify_msb(0xfe - i))  //再次检测 PIT 的 MSB ，确保 PIT 的值已经是 0xfe-i
                break;
            goto success;
        }
    }
    printk(&#34;Fast TSC calibration failed\n&#34;);
    return 0;
success:
    /*
	  kHz = ticks / time-in-seconds / 1000;
	  kHz = (t2 - t1) / (I * 256 / PIT_TICK_RATE) / 1000
	  kHz = ((t2 - t1) * PIT_TICK_RATE) / (I * 256 * 1000)
      主频通过 delta 返回
    */
    delta *= PIT_TICK_RATE;
    do_div(delta, i*256*1000); // do_div() 是内核的 64 位除法函数，结果保持在第一参数，返回余数
    printk(&#34;Fast TSC calibration using PIT\n&#34;);
    return delta;
}</code></pre></div>
<p>通常用 PIT 快速校准 TSC 都会成功，直接用返回值作为 tsc_khz ，并赋予 cpu_khz 作为主频。如果失败，会继续用一种复杂的方式计算 PIT 和 TSC 。</p>

<h2 id="5-proc-cpuinfo">5./proc/cpuinfo</h2>

<p>在用户空间，我们是通过 <code>/proc/cpuinfo</code> 文件获得 CPU 主频的。proc 文件系统中的文件，必须在内核源码的某个位置创建并使用 <code>file_operations</code> 声明，cpuinfo 的声明位于 <code>fs/proc/cpuinfo.c</code> 文件：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C {.line-numbers}" data-lang="C {.line-numbers}">    static const struct file_operations proc_cpuinfo_operations = {
        .open		= cpuinfo_open,
        .read		= seq_read,
        .llseek		= seq_lseek,
        .release	= seq_release,
    };

    static int __init proc_cpuinfo_init(void)
    {
        proc_create(&#34;cpuinfo&#34;, 0, NULL, &amp;proc_cpuinfo_operations);
        return 0;
    }</code></pre></div>
<p>然后在 <code>arch/x86/kernel/cpu/proc.c</code> 文件中有很多 <code>show_cpuinfo_*()</code> 函数，比如 <code>static int show_cpuinfo(struct seq_file *m, void *v)</code> ，它们会调用 <code>seq_printf()</code> 函数把信息输出到 /proc/cpuinfo 文件中:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C {.line-numbers}" data-lang="C {.line-numbers}">    static int show_cpuinfo(struct seq_file *m, void *v)
    {
        struct cpuinfo_x86 *c = v;
        unsigned int cpu;
        int i;

        cpu = c-&gt;cpu_index;
        seq_printf(m, &#34;processor\t: %u\n&#34;
            &#34;vendor_id\t: %s\n&#34;
            &#34;cpu family\t: %d\n&#34;
            &#34;model\t\t: %u\n&#34;
            &#34;model name\t: %s\n&#34;,
            cpu,
            c-&gt;x86_vendor_id[0] ? c-&gt;x86_vendor_id : &#34;unknown&#34;,
            c-&gt;x86,
            c-&gt;x86_model,
            c-&gt;x86_model_id[0] ? c-&gt;x86_model_id : &#34;unknown&#34;);
        ...
    }</code></pre></div>
<p>可以看出大部分 CPU 信息都是通过 <code>struct cpuinfo_x86 *c</code> 结构获取的，这个结构的声明在 <code>arch/x86/include/asm/processor.h</code> 文件，在这个文件中搜索该结构的引用，会找到 <code>extern void cpu_detect(struct cpuinfo_x86 *c);</code> 等类似的函数，这些函数内通过 <code>cpuid()</code> 函数从硬件寄存器上读取信息，然后填充 <code>struct cpuinfo_x86 *c</code> 结构 ，这是一个内联函数 ：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C {.line-numbers}" data-lang="C {.line-numbers}">    static inline void cpuid(unsigned int op,
                unsigned int *eax, unsigned int *ebx,
                unsigned int *ecx, unsigned int *edx)
    {
        *eax = op;
        *ecx = 0;
        __cpuid(eax, ebx, ecx, edx);
    }</code></pre></div>
<p>函数内的 <code>__cpuid()</code> 是封装了 <code>native_cpuid()</code> 函数的宏定义，也在这个文件里定义：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C {.line-numbers}" data-lang="C {.line-numbers}">    static inline void native_cpuid(unsigned int *eax, unsigned int *ebx,
                    unsigned int *ecx, unsigned int *edx)
    {
        /* ecx is often an input as well as an output. */
        asm volatile(&#34;cpuid&#34;
            : &#34;=a&#34; (*eax),
            &#34;=b&#34; (*ebx),
            &#34;=c&#34; (*ecx),
            &#34;=d&#34; (*edx)
            : &#34;0&#34; (*eax), &#34;2&#34; (*ecx)
            : &#34;memory&#34;);
    }</code></pre></div>
<p>这里是通过汇编指令读取相应的寄存器，这些指令属于 CPUID ，是 X86 架构的处理器补充指令，用于发现处理器的详细信息，参考<a href="https://zh.wikipedia.org/wiki/CPUID" target="_blank">https://zh.wikipedia.org/wiki/CPUID</a>。</p>

<p>还有一些信息不是通过 CUPID 获取的，比如 CPU 主频（CPU frequency），在 <code>arch/x86/kernel/cpu/proc.c</code> 文件的 <code>show_cpuinfo()</code> 函数中可以看到：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C {.line-numbers}" data-lang="C {.line-numbers}">if (cpu_has(c, X86_FEATURE_TSC)) {
	unsigned int freq = cpufreq_quick_get(cpu);
	if (!freq)
		freq = cpu_khz;
	seq_printf(m, &#34;cpu MHz\t\t: %u.%03u\n&#34;, freq / 1000, (freq % 1000));
}</code></pre></div>
<p>它是先调用 <code>cpufreq_quick_get()</code> 函数返回一个值，这是 cpufrep 模块的一个函数，它的返回值与 sysfs 中 <code>/sys/devices/system/cpu/cpu[n]/cpufreq/</code> 目录下的 scaling_cur_freq 完全一致，而且可以动态变化。如果调用失败，就把 cpu_khz 作为 CPU 主频。</p>

<p>CPU 的主频是可以动态调节的。主频越高，功耗也越高，为了节省 CPU 的功耗和减少发热，我们可以根据当前 CPU 的负载情况，动态地提供刚好足够的主频给 CPU 。Linux 内核提供了一套框架来完成这个目标，这就是 cpufrep 子系统。</p>

<p>cpufrep 子系统在用户空间提供了 sysfs 接口，都位于 <code>/sys/devices/system/cpu</code> 目录下：</p>

<pre><code>/sys/devices/system/cpu$ ls
cpu0  cpu2  cpufreq  kernel_max  modalias  online    power    probe    uevent
cpu1  cpu3  cpuidle  microcode   offline   possible  present  release
</code></pre>

<h2 id="6-bogomips">6.BogoMIPS</h2>

<p>在 <code>/proc/cpuinfo</code> 中可以看到一个参数 bogomips ，在 dmesg 中也可以看到类似的信息：</p>

<pre><code>[    0.000001] Calibrating delay loop (skipped), value calculated using timer frequency.. 6385.48 BogoMIPS (lpj=12770964)
</code></pre>

<p>从字面意思也可以理解， BogoMIPS 就是伪百万次指令每秒，每秒钟可以执行几百万条指令，是一种衡量 CPU 速度的不科学方法。这条信息来自于内核 <code>init/calibrate.c</code> 文件的 <code>calibrate_delay()</code> 函数。</p>

<h2 id="参考">参考</h2>

<ul>
<li><a href="http://www.expreview.com/57334.html" target="_blank">CPU 频率</a></li>
<li><a href="https://wiki.osdev.org/Programmable_Interval_Timer" target="_blank">Programmable Interval Timer</a></li>
<li><a href="https://wiki.archlinux.org/index.php/CPU_frequency_scaling" target="_blank">CPU frequency scaling</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Linux 内核调试方法</title>
            <link>https://shaocheng.li/posts/2018/07/05/</link>
            <pubDate>Thu, 05 Jul 2018 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2018/07/05/</guid>
            <description>基于 Ubuntu 14.04 ，Linux Kernel 4.0 以上版本。
 1. printk() printk() 是内核提供的函数，用于将内核空间的信息打印到用户空间缓冲区，打印的信息可以通过 demsg 命令查看，或者直接查看 /proc/kmsg 文件。缓冲区是一个环形队列的结构，消息太多时，旧的消息就会被逐渐覆盖，缓冲区大小是在 kernel/printk/printk.c 文件中的代码设置的：
#define __LOG_BUF_LEN (1 &amp;lt;&amp;lt; CONFIG_LOG_BUF_SHIFT) static char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);  缓冲区大小是 CONFIG_LOG_BUF_SHIFT*2 个字节，CONFIG_LOG_BUF_SHIFT 是在 init/Kconfig 文件中设置的，我们可以在 menuconfig 的相关路径中修改：
General setup -&amp;gt; Kernel log buffer size(16 =&amp;gt; 64KB, 17 =&amp;gt; 128kB)  还可以在加载内核时用启动参数 log_buf_len=n[KMG] 设置，其中的 n 必须是 2 的整数倍。
在调用 printk() 函数时要设置消息级别，从 0 到 7 ，数值越小级别越高，相应的宏定义在 include/linux/kern_levels.h 文件中：
#define KERN_EMERG KERN_SOH &amp;quot;0&amp;quot; /* system is unusable */ #define KERN_ALERT KERN_SOH &amp;quot;1&amp;quot; /* action must be taken immediately */ #define KERN_CRIT KERN_SOH &amp;quot;2&amp;quot; /* critical conditions */ #define KERN_ERR KERN_SOH &amp;quot;3&amp;quot; /* error conditions */ #define KERN_WARNING KERN_SOH &amp;quot;4&amp;quot; /* warning conditions */ #define KERN_NOTICE KERN_SOH &amp;quot;5&amp;quot; /* normal but significant condition */ #define KERN_INFO KERN_SOH &amp;quot;6&amp;quot; /* informational */ #define KERN_DEBUG KERN_SOH &amp;quot;7&amp;quot; /* debug-level messages */ #define KERN_DEFAULT KERN_SOH &amp;quot;d&amp;quot; /* the default kernel loglevel */  内核中还有一个默认日志级别，只有数值小于这个级别的消息才会被打印到控制台上，大于或者等于这个数值的消息不会显示，它设置在 lib/Kconfig.</description>
            <content type="html"><![CDATA[

<blockquote>
<p>基于 Ubuntu 14.04 ，Linux Kernel 4.0 以上版本。</p>
</blockquote>

<h2 id="1-printk">1. printk()</h2>

<p><code>printk()</code> 是内核提供的函数，用于将内核空间的信息打印到用户空间缓冲区，打印的信息可以通过 demsg 命令查看，或者直接查看 /proc/kmsg 文件。缓冲区是一个环形队列的结构，消息太多时，旧的消息就会被逐渐覆盖，缓冲区大小是在 kernel/printk/printk.c 文件中的代码设置的：</p>

<pre><code>#define __LOG_BUF_LEN (1 &lt;&lt; CONFIG_LOG_BUF_SHIFT)
static char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);
</code></pre>

<p>缓冲区大小是 CONFIG_LOG_BUF_SHIFT*2 个字节，CONFIG_LOG_BUF_SHIFT 是在 init/Kconfig 文件中设置的，我们可以在 menuconfig 的相关路径中修改：</p>

<pre><code>General setup -&gt; Kernel log buffer size(16 =&gt; 64KB, 17 =&gt; 128kB)
</code></pre>

<p>还可以在加载内核时用启动参数 log_buf_len=n[KMG] 设置，其中的 n 必须是 2 的整数倍。</p>

<p>在调用 <code>printk()</code> 函数时要设置消息级别，从 0 到 7 ，数值越小级别越高，相应的宏定义在 include/linux/kern_levels.h 文件中：</p>

<pre><code>#define KERN_EMERG      KERN_SOH &quot;0&quot;    /* system is unusable */
#define KERN_ALERT      KERN_SOH &quot;1&quot;    /* action must be taken immediately */
#define KERN_CRIT       KERN_SOH &quot;2&quot;    /* critical conditions */
#define KERN_ERR        KERN_SOH &quot;3&quot;    /* error conditions */
#define KERN_WARNING    KERN_SOH &quot;4&quot;    /* warning conditions */
#define KERN_NOTICE     KERN_SOH &quot;5&quot;    /* normal but significant condition */
#define KERN_INFO       KERN_SOH &quot;6&quot;    /* informational */
#define KERN_DEBUG      KERN_SOH &quot;7&quot;    /* debug-level messages */

#define KERN_DEFAULT    KERN_SOH &quot;d&quot;    /* the default kernel loglevel */
</code></pre>

<p>内核中还有一个默认日志级别，只有数值小于这个级别的消息才会被打印到控制台上，大于或者等于这个数值的消息不会显示，它设置在 lib/Kconfig.debug 文件中，缺省情况下会设为 KERN_WARNING(4) ，我们可以在 menuconfig 的相关路径中设置：</p>

<pre><code>Kernel hacking -&gt; printk and dmesg options -&gt; Default message log level(1-7)
</code></pre>

<p>也可以用内核启动参数 loglevel=n 设置，n 的取值是 0~7 。如果直接设置了启动参数 debug ，那么日志级别就是 KERN_DEBUG(7) ，所有调试信息都会显示在控制台上。还可以在系统启动后，在 /proc/sys/kernel/printk 文件中调整 <code>printk()</code> 函数的输出等级，该文件有四个数值，各自的含义：</p>

<ol>
<li>控制台的日志级别:当前的打印级别,优先级高于该值(值越小,优先级越高)的消息将被打印至控制台</li>
<li>默认的消息日志级别: 将用该优先级来打印没有优先级前缀的消息,也就是直接写 <code>printk(&quot;xxx&quot;)</code> 而不带打印级别的情况下,会使用该打印级别</li>
<li>最低的控制台日志级别: 控制台日志级别可被设置的最小值(一般是1)</li>
<li>默认的控制台日志级别: 控制台日志级别的默认值</li>
</ol>

<p>修改方法：</p>

<pre><code>root@sh-VirtualBox:/proc/sys/kernel# cat printk
4   4   1   7
root@sh-VirtualBox:/proc/sys/kernel# echo 5 &gt; printk
root@sh-VirtualBox:/proc/sys/kernel# cat printk
5   4   1   7
root@sh-VirtualBox:/proc/sys/kernel# echo  &quot;5 5&quot; &gt; printk
root@sh-VirtualBox:/proc/sys/kernel# cat printk
5   5   1   7
</code></pre>

<p>默认情况下，<code>printk()</code> 打印的消息是带时间戳的，可以在 menuconfig 的相应路径下关闭或者打开：</p>

<pre><code>Kernel hacking -&gt; printk and dmesg options -&gt; Show timing information on printks
</code></pre>

<p>为了方便调用，内核提供很多封装了 <code>printk()</code> 函数的宏，在 <code>/include/linux/printk.h</code> 头文件中声明的 <code>pr_xxx()</code> ，例如：</p>

<pre><code>#define pr_fmt(fmt) fmt
#define pr_err(fmt, ...) printk(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)
#define pr_warning(fmt, ...) printk(KERN_WARNING pr_fmt(fmt), ##__VA_ARGS__)
#define pr_info(fmt, ...) printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)
</code></pre>

<p>我们可用通过 <code>pr_fmt(fmt)</code> 添加一些自定义的消息格式，例如：</p>

<pre><code>#define pr_fmt(fmt) &quot;[driver] watchdog:&quot; fmt
</code></pre>

<p>这里要注意 <code>pr_debug()</code>，它与其他的宏不同，需要满足如下两个条件之一才会打印信息：</p>

<ol>
<li>在源文件、或者编译时定义了 DEBUG 宏，这个方式在开发内核模块时很有用</li>
<li>开启了 CONFIG_DYNAMIC_DEBUG ，也就是 menuconfig 中的 <code>Kernel hacking -&gt; printk and dmesg options</code></li>
</ol>

<p>这里还有一个问题，内核启动后，需要一段时间才能准备好控制台，这段时间内的内核信息是无法通过控制台显示，内核为此提供了 early printk 机制，它会在内核启动后就注册一个 boot console ，让后将内核信息显示在这个控制台上。使能 early printk 的方法有两步：</p>

<ol>
<li>在 menuconfig 中打开 Early printk ：<code>Kernel hacking -&gt; Early printk</code></li>
<li>在启动参数中设置 earlyprintk=[vga|serial][,ttySn[,baudrate]][,keep]</li>
</ol>

<p>如果用户空间的 <code>printf()</code> 和内核空间的 <code>printk()</code> 同时执行，二者的输出会互相干扰，内核为此提供了 /dev/ttyprintk 设备文件，可以将用户空间的信息打印到这个设备中，这样用户信息与内核信息就会顺序输出，输出的消息会自带 [U] 前缀。对于没有 /dev/ttyprintk 设备的系统，可以用  /dev/kmsg 代替，只是没有了 [U] 标识，需要用户自己添加前缀。</p>

<h2 id="2-sysrq-键">2. SysRq 键</h2>

<p>标准键盘的右上角有一个 PrintScreen/SysRq 键，它的一个功能是截屏，另一个功能是当系统死机无法输入命令时，用这个按键获取内核信息。SysRq 键在确认内核运行、调查死机原因等情况时非常有效。关于它的详细情况可以参考内核的 Documentation/sysrq.txt 文件。</p>

<p>要使用 SysRq 键，需要启动内核配置 CONFIG_MAGIC_SYSRQ ，在 menuconfig 中的路径是：</p>

<pre><code>Kernel hacking -&gt; Magic SysRq key
</code></pre>

<p>系统启动后，就可以在 /proc/sys/kernel/sysrq 文件中设置 SysRq 按键的功能，该文件的默认值是内核选项 CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE 设置的,必须是十六进制，在 menuconfig 的路径是：</p>

<pre><code>Kernel hacking -&gt; (0x01) Enable magic Sysrq key functions by default
</code></pre>

<blockquote>
<p>注意，/proc/sys/kernel/sysrq 设置的各项功能，只对从键盘和串口控制台的输入有效，对于远程 ssh 等方式无效。直接向 /proc/sysrq-trigger 写入命令键则不受限制：<code>echo [command key] &gt; /proc/sysrq-trigger</code> 。</p>
</blockquote>

<p>这个文件的值是位掩码，取值如下，括号内是命令键：</p>

<ul>
<li>0 ，禁用 sysrq</li>
<li>1 ，使能所有 sysrq 功能</li>
<li>2 = 0x2 ，允许控制控制台日志级别（0~9）</li>
<li>4 = 0x4 ，使能键盘控制 (kr)</li>
<li>8 = 0x8 ，使能显示进行等信息（lptwmcz）</li>
<li>16 = 0x10 ，使能 sync 命令（s）</li>
<li>32 = 0x20 ，使能只读状态下的重新挂在（u）</li>
<li>64 = 0x40 ，使能进程信号，例如 term, kill（ei）</li>
<li>128 = 0x80 ，使能重启和关机（b）</li>
<li>256 = 0x100 ，允许控制实时任务（q）</li>
</ul>

<p>可以直接修改这个文件的值，比如使能 sync 和重新挂载：</p>

<pre><code># echo 48 &gt; /proc/sys/kernel/sysrq
</code></pre>

<p>也可以在 <code>/etc/sysctl.d/10-magic-sysrq.conf</code> 文件中修改 kernel.sysrq 选项（也可能在 <code>/etc/sysctl.conf</code> 文件中）。配置好功能后，通过组合键 <code>Alt-SysRq-&lt;command key&gt;</code> 就可以使用 SysRq 键的各项功能，功能键如下：</p>

<pre><code>'b' - Will immediately reboot the system without syncing or unmounting your disks.
'c' - Will perform a system crash by a NULL pointer dereference. A crashdump will be taken if configured.
'd' - Shows all locks that are held.
'e' - Send a SIGTERM to all processes, except for init.
'f' - Will call the oom killer to kill a memory hog process, but do not panic if nothing can be killed.
'g' - Used by kgdb (kernel debugger)
'h' - Will display help (actually any other key than those listed here will display help. but 'h' is easy to remember :-)
'i' - Send a SIGKILL to all processes, except for init.
'j' - Forcibly &quot;Just thaw it&quot; - filesystems frozen by the FIFREEZE ioctl.
'k' - Secure Access Key (SAK) Kills all programs on the current virtual console. NOTE: See important comments below in SAK section.
'l' - Shows a stack backtrace for all active CPUs.
'm' - Will dump current memory info to your console.
'n' - Used to make RT tasks nice-able
'o' - Will shut your system off (if configured and supported).
'p' - Will dump the current registers and flags to your console.
'q' - Will dump per CPU lists of all armed hrtimers (but NOT regular timer_list timers) and detailed information about all clockevent devices.
'r' - Turns off keyboard raw mode and sets it to XLATE.
's' - Will attempt to sync all mounted filesystems.
't' - Will dump a list of current tasks and their information to your console.
'u' - Will attempt to remount all mounted filesystems read-only.
'v' - Forcefully restores framebuffer console
'v' - Causes ETM buffer dump [ARM-specific]
'w' - Dumps tasks that are in uninterruptable (blocked) state.
'x' - Used by xmon interface on ppc/powerpc platforms. Show global PMU Registers on sparc64. Dump all TLB entries on MIPS.
'y' - Show global CPU Registers [SPARC-64 specific]
'z' - Dump the ftrace buffer
'0'-'9' - Sets the console log level, controlling which kernel messages will be printed to your console. ('0', for example would make it so that only emergency messages like PANICs or OOPSes would make it to your console.)
</code></pre>

<p>如果系统疑似死机，可以一次执行 s-u-b 命令重启内核，如果不需要重启，可以执行 c 命令提取崩溃转储，获取内核信息（内核崩溃转储是指将系统内存的内容输出到文件）。还可以尝试用 i 命令向进程发送 SIGKILL 信号，使系统恢复。</p>

<h2 id="3-kdump">3. Kdump</h2>

<p>Kdump 是内核提供的崩溃转储功能，工作原理是在系统内核崩溃时启动一个特殊的 dump-capture kernel 把系统内存里的数据保存到磁盘文件中，由内核机制和用户空间工具共同完成。Dump-capture kernel 可以是独立的，也可以和系统内核集成在一起（这需要硬件支持）。Kdump 的工作过程如下：</p>

<ol>
<li>系统内核启动的时候，要给 dump-capture kernel 预留一块内存空间；</li>
<li>内核启动完成后，用户空间的 kdump service 执行 <code>kexec -p</code> 命令把 dump-capture kernel 载入预留的内存里（<code>/sys/kernel/kexec_crash_loaded</code> 的值为 1 表示已经加载）；</li>
<li>如果系统发生 crash，生产内核会自动 reboot 进入 dump-capture kernel，dump-capture kernel 只使用自己的预留内存，确保其余的内存数据不会被改动，它的任务是把系统内存里的数据写入到 dump 文件，比如 /var/crash/vmcore，为了减小文件的大小，它会通过 makedumpfile(8) 命令对内存数据进行挑选和压缩；</li>
<li>dump 文件写完之后，dump-capture kernel 自动 reboot 。</li>
</ol>

<p>预留内存的方法是用内核启动参数 <code>crashkernel=size[@offset]</code> 实现的，某些内核支持 <code>crashkernel=auto</code> 自动分配大小，如果不支持，或者系统没有足够内存，就需要手动设置。通常 offset 可以设置为 16MB(0x1000000) ，size 根据系统内存的大小设置，而且要与 64MB 对齐：</p>

<ol>
<li>如果系统内存小于 512MB ，则不要保留内存</li>
<li>如果系统内存介于 512MB 到 2GB 之间，可以保留 64MB 内存</li>
<li>如果系统内存大于 2GB ，可以保留 128MB 内存</li>
</ol>

<p>可能导致内核崩溃的事件包括：</p>

<ul>
<li>Kernel Panic</li>
<li>Non Maskable Interrupts (NMI)</li>
<li>Machine Check Exceptions (MCE)</li>
<li>Hardware failure</li>
<li>Manual intervention</li>
</ul>

<p>对于某些崩溃事件（例如 panic、NMI），内核会自动做出反应，并通过 kexec 触发崩溃转储，其他情况下需要手动捕获内存信息。</p>

<p>在 Ubuntu 上首先要安装内核崩溃转储工具：</p>

<pre><code>$ sudo apt-get install linux-crashdump
</code></pre>

<blockquote>
<p>如果是 Fedora 操作系统，通常是安装 crash 和 kexec-tools 软件包。</p>
</blockquote>

<p>linux-crashdump 包安装了三个工具，分别是：crash，kexec-tools 和 makedumpfile。安装过程中会出现如下对话框，选择 Yes ，表示默认使能 kdump ：</p>

<pre><code>|------------------------| Configuring kdump-tools |------------------------|
|                                                                           |
|                                                                           |
| If you choose this option, the kdump-tools mechanism will be enabled. A   |
| reboot is still required in order to enable the crashkernel kernel        |
| parameter.                                                                |
|                                                                           |
| Should kdump-tools be enabled by default?                                 |
|                                                                           |
|                    &lt;Yes&gt;                       &lt;No&gt;                       |
|                                                                           |
|---------------------------------------------------------------------------|
</code></pre>

<p>然后编辑 <code>/etc/default/kdump-tools</code> 文件，修改选项 <code>USE_KDUMP=1</code> ，使能内核加载 kdump ，然后重启系统，内核自动激活 crashkernel= 启动参数 ，kdump-tools 默认启动，用 <code>kdump-config show</code> 命令和 <code>/sys/kernel/kexec_crash_loaded</code> 文件查看 kdump 的配置和状态，在 <code>/proc/cmdline</code> 文件中查看 crashkernel 的设置：</p>

<pre><code>$ kdump-config show
DUMP_MODE:        kdump
USE_KDUMP:        1
KDUMP_SYSCTL:     kernel.panic_on_oops=1
KDUMP_COREDIR:    /var/crash
crashkernel addr: 0x2d000000
current state:    ready to kdump

kexec command:
/sbin/kexec -p --command-line=&quot;BOOT_IMAGE=/boot/vmlinuz-4.4.0-31-generic root=UUID=2744d8e0-18c2-493f-b61c-d887647494a0 ro quiet splash vt.handoff=7 irqpoll maxcpus=1 nousb&quot; --initrd=/boot/initrd.img-4.4.0-31-generic /boot/vmlinuz-4.4.0-31-generic
$ cat /sys/kernel/kexec_crash_loaded
1
$ cat /proc/cmdline 
BOOT_IMAGE=/boot/vmlinuz-4.4.0-31-generic root=UUID=2744d8e0-18c2-493f-b61c-d887647494a0 ro quiet splash crashkernel=384M-:128M vt.handoff=7
</code></pre>

<p>系统启动后，可以通过向 <code>/sys/kernel/kexec_crash_size</code> 写入一个比原来小的数值来缩小甚至完全释放 crashkernel 。然后执行 <code>sudo kdump-config load</code> 加载 kdump ，也可以把 /etc/init.d/kdump-tool 服务设为默认启动，这样系统会自动加载。准备工作完成后，尝试提取崩溃转储，先确保 sysrq=1 ，然后手动触发一次崩溃：</p>

<pre><code># echo c &gt; /proc/sysrq-tirgger
</code></pre>

<p>稍等片刻，如果转储成功，内核会自动重启，并且在 /var/crash/ 目录下生成转储文件：</p>

<pre><code>$ ls -l /var/crash/*
total 28
drwxr-sr-x 2 root whoopsie  4096  7月  6 11:45 201807061145
-rw-r----- 1 root whoopsie 18095  7月  6 11:45 linux-image-4.4.0-31-generic-201807061145.crash
$ ls -l /var/crash/201807061145/
total 55300
-rw------- 1 root whoopsie    41223  7月  6 11:45 dmesg.201807061145
-rw------- 1 root whoopsie 56578589  7月  6 11:45 dump.201807061145
</code></pre>

<blockquote>
<p>转储需要时间，如果手动关机重启会导致转储不完整，数据无法解读。</p>
</blockquote>

<p>如果是 RedHat 系统，生成的转储文件是 vmcore ，可以直接用 crash 命令分析。而 Ubuntu 提供了叫做 Apport 的工具，将系统内其他有用的信息一起打包生成了 linux-image-4.4.0-31-generic-201807061145.crash 文件，而以时间戳命名的文件夹 201807061145 包含了 dmesg 信息文件和 kdump 转储文件，对于某些版本，这两个文件也包含在 crash 文件中。对 crash 文件解压后可以得到几个与系统信息有关的纯文本文件：</p>

<pre><code>$ sudo apport-unpack /var/crash/linux-image-4.4.0-31-generic-201807061145.crash ~/201807061145.crash
$ ls ~/201807061145.crash
Architecture  Date  DistroRelease  Package  ProblemType  Uname  VmCoreDmesg
</code></pre>

<h2 id="4-崩溃测试">4. 崩溃测试</h2>

<p>内核有一个 lkdtm 模块，Linux Kernel Dump Test Module ，通过各种方式使内核崩溃，用于测试崩溃转储的功能。通常发行版的内核不会使能这个模块，需要启用内核 CONFIG_LKDTM 选项，在 menuconfig 的路径是：</p>

<pre><code>Kernel hacking -&gt; RunTime Testing -&gt; Linux Kernel Dump Test Tool Module
</code></pre>

<p>最好编译成模块，然后加载模块时，通过模块参数指定崩溃位置和崩溃原因，即可造成所需的内核崩溃。</p>

<h2 id="5-crash-命令">5. crash 命令</h2>

<p>crash 是一个强大的交互式工具，基于 gdb ，用于分析内核映像，比如内核崩溃转储信息。有些系统中，安装 linux-crashdump 时会包含 crash ，如果没有，需要手动安装：</p>

<pre><code>sudo apt-get install crash
</code></pre>

<p>分析之前需要安装系带有 debug-info 的内核，叫做 kernel-debuginfo ，这是 redhat 的叫法， ubuntu 下叫 debug symbols，简称 dbgsym 。 ubuntu 默认安装时不会安装 dbgsym ，默认仓库上也没有 dbgsym 包。 dbgsym 包存在于独立的仓库上，官方仓库地址为 <code>http://ddebs.ubuntu.com/</code> ，安装方法参考：<a href="https://oolap.com/2015-11-07-ubuntu-install-dbgsym" target="_blank">https://oolap.com/2015-11-07-ubuntu-install-dbgsym</a> 。kernel-debuginfo 的版本应该和系统运行的内核版本完全一致，如果是自行编译的内核，可能无法在官方仓库中找到对应版本的 kernel-debuginfo ，这时可以自行编译安装 kernel-debuginfo ，参考下一节。安装完成后，会在 <code>/usr/lib/debug/boot/</code> 目录下生成带有调试信息的 vmlinux ，然后用 crash 工具分析 kdump 生成崩溃转储信息：</p>

<pre><code>$ sudo crash  /usr/lib/debug/boot/vmlinux-4.4.0-31-generic /var/crash/201807061145/dump.201807061145
</code></pre>

<p>下面以一个 Fedora14(kernel 2.6.37) 下产生的转储文件 vmcore 为例说明 crash 的用法，crash 成功启动后先打印一段转储文件的分析报告，包括崩溃时间、崩溃类型、CPU、内存等，然后进入一个交互环境：</p>

<pre><code>KERNEL: /boot/vmlinux
DUMPFILE: vmcore
CPUS: 1
DATE: Fri Jul 27 13:59:13 2018
UPTIME: 00:05:23
LOAD AVERAGE: 0.01, 0.11, 0.07
TASKS: 56
NODENAME: localhost.localdomain
RELEASE: 2.6.37.6
VERSION: #11 SMP Thu Jul 26 15:42:06 CST 2018
MACHINE: i686 (1500 Mhz)
MEMORY: 1 GB
PANIC: &quot;[  323.903003] Oops: 0002 [#1] SMP &quot; (check log for details)
PID: 4437
COMMAND: &quot;bash&quot;
TASK: f6ec0c90 [THREAD_INFO: f6d2e000]
CPU: 0
STATE: TASK_RUNNING (PANIC)
crash &gt;
</code></pre>

<p>可以看到引起崩溃的进程是 <code>PID: 4437</code> , crash 提供了 ps 命令显示所有进程的状态，用 <code>ps | grep 4437</code> 可以筛选出引起崩溃的进程：</p>

<pre><code>crash &gt; ps | grep 4437
  PID    PPID    CPU      TASK      ST   %MEM    VSZ    RSS   COMM 
  4437   4426    0    f6ec0c90       RU    0.2   8064   1780   bash
</code></pre>

<p>bt 命令用于输出某个进程的内核栈的遍历，没有指定 PID 时默认输出引起崩溃的进程的内核栈信息：</p>

<pre><code>crash&gt; bt
PID: 4437   TASK: f6ec0c90  CPU: 0   COMMAND: &quot;bash&quot;
#0 [f6d2fdec] crash_kexec at c0466264
#1 [f6d2fe2c] __bad_area_nosemaphore at c04225b5
#2 [f6d2fe48] bad_area at c042260c
#3 [f6d2fe60] do_page_fault at c079c8c9
#4 [f6d2fed8] error_code (via page_fault) at c079a685
EAX: 00000063  EBX: 00000063  ECX: ffffffd6  EDX: 00000000  EBP: f6d2ff18 
DS:  007b      ESI: c095dfe0  ES:  007b      EDI: 00000004  GS:  00e0
CS:  0060      EIP: c061e0b9  ERR: ffffffff  EFLAGS: 00010046
#5 [f6d2ff0c] sysrq_handle_crash at c061e0b9 
#6 [f6d2ff1c] __handle_sysrq at c061e63d 
#7 [f6d2ff40] write_sysrq_trigger at c061e6e2
#8 [f6d2ff50] proc_reg_write at c0507c84    
#9 [f6d2ff74] vfs_write at c04cdf4c
#10 [f6d2ff90] sys_write at c04ce11d
#11 [f6d2ffb0] ia32_sysenter_target at c0403298 
EAX: 00000004  EBX: 00000001  ECX: b77f8000  EDX: 00000002
DS:  007b      ESI: b77f8000  ES:  007b      EDI: 00000002 
SS:  007b      ESP: bfc32fd0  EBP: bfc33008  GS:  0033 
CS:  0073      EIP: b77fc424  ERR: 00000004  EFLAGS: 00000246
</code></pre>

<p>可以看到系统崩溃前最后一条调用是 <code>#5 [f6d2ff0c] sysrq_handle_crash at c061e0b9</code> ，我们用 <code>dis</code> 命令看一下这个地址的反汇编结果：</p>

<pre><code>crash&gt; dis -l c061e0b9 
/usr/src/linux-2.6.37/drivers/tty/sysrq.c: 134
0xc061e0b9 &lt;sysrq_handle_crash+23&gt;:     movb   $0x1,0x0   
</code></pre>

<p>出错的代码位于 <code>/usr/src/linux-2.6.37/drivers/tty/sysrq.c</code> 文件的 134 行：</p>

<pre><code>129 static void sysrq_handle_crash(int key) 
130 {  
131     char *killer = NULL;
132     panic_on_oops = 1;      /* force panic */ 
133     wmb(); 
134     *killer = 1; 
135 }  
</code></pre>

<p>这里为指针赋值 <code>*killer = 1</code> ，而 131 行定义的是一个空指针，比如出错。</p>

<p>crash 还有很多命令：</p>

<ul>
<li>log ：打印系统消息缓冲区，从而可能找到系统崩溃的线索。</li>
<li>sys ：显示系统概况。</li>
<li>kmem ：显示内存使用信息。</li>
<li>irq ：显示中断的信息。</li>
<li>mod ：显示模块信息。</li>
<li>runq ：显示处于运行队列的进程。</li>
<li>struct ：显示结构的定义、地址和数据。</li>
</ul>

<h2 id="6-kernel-debuginfo">6. kernel-debuginfo</h2>

<p>kernel-debuginfo 是指带有 Debug information 的内核，就是在编译内核是指定 CONFIG_DEBUG_INFO 等相关选项，在 menuconfig 的路径是：</p>

<pre><code>Kernel hacking -&gt; Kernel debugging -&gt; Compile the kernel with debug info
</code></pre>

<p>与 Kdump 分析相关的选项还有：</p>

<ul>
<li>kexec system call ：CONFIG_KEXEC=y</li>
<li>sysfs file system support ： CONFIG_SYSFS=y</li>
<li>Compile the kernel with debug info ： CONFIG_DEBUG_INFO=Y</li>
<li>kernel crash dumps ： CONFIG_CRASH_DUMP=y</li>
<li>/proc/vmcore support ： CONFIG_PROC_VMCORE=y</li>
</ul>

<p>编译成功后，就会在源码目录下生成带有 debuginfo 的内核镜像 vmlinux ，kdump 、crash 等内核调试方法都会用到它。vmlinux 是一个包含 Linux kernel 的静态链接的可执行文件，ELF 格式。通常 /boot 目录下启动的内核是 vmlinuz ，它是 vmlinux 经过 gzip 和 objcopy 制作出来的压缩文件。vmlinuz 是一种统称，有两种具体的表现形式 zImage 和 bzImage 。bzimage 和 zImage 的区别在于本身的大小，以及加载到内存时的地址不同，zImage在 0～640KB，而bzImage 则在 1M 以上的位置。</p>

<p>不同的程序查找这个内核的路径是不一样的，通常需要在如下路径建立这个内核的符号链接：</p>

<pre><code>/boot/vmlinux-`uname -r`
/usr/lib/debug/lib/modules/`uname -r`/vmlinux
/lib/modules/`uname -r`/vmlinux
</code></pre>

<p>有些程序还需要在 <code>/lib/modules/</code> 目录下建立内核源码树和构建目录的符号链接：</p>

<pre><code>/lib/modules/`uname -r`/source
/lib/modules/`uname -r`/build
</code></pre>

<h2 id="7-nmi">7. NMI</h2>

<p>NMI(non-maskable interrupt) 就是不可屏蔽的中断，当 x86 发生了无法恢复的硬件故障后，会触发这个中断通知操作系统，如果操作系统配置了 kdump，还会触发崩溃转储。根据 Intel 的软件开发者手册第三卷 6.7 的描述，NMI 的来源有两个：</p>

<ul>
<li>外部引脚 NMI pin，外部设备可以通过这个引脚触发 NMI ，有些服务器甚至提供了 NMI 触发按钮</li>
<li>处理器系统总线或者 APIC 串行总线产生的 NMI 消息（包括芯片错误、内存校验错误、总线数据损坏等）</li>
</ul>

<p>x86 在 IO 端口寄存器 0x70 的 bit7 提供了 NMI_Enable 位，可以如下代码使能、或者禁用 NMI ：</p>

<pre><code>void NMI_enable(void)
{
    outb(0x70, inb(0x70)&amp;0x7F);
}
void NMI_disable(void)
{
    outb(0x70, inb(0x70)|0x80);
}
</code></pre>

<p>Linux 内核提供了名为 NMI watchdog 的机制，用于检测系统是否失去响应（也称为 lockup，包括 soft lockup 和 hard lockup），原理是周期性的产生 NMI ，由 NMI handler 响应中断并刷新 hrtimer 定时器，如果一段时间内没有刷新，就表示系统失去了相应，于是调用 panic，超时时间在内核配置里设置，默认是 5 秒。相关代码在内核的 <code>kernel/watchdog.c</code> 文件中。</p>

<p>NMI watchdog 依赖 APIC ，所有要将 APIC 编译进内核，启动参数中也不要关闭 APIC 。传统的 x86 架构采用 8259A 芯片处理中断，现在的 x86 架构都引入了 APIC 。可以执行 <code>cat /proc/interrupts</code> ，如果输出结果中列出了 IO-APIC-* ，说明系统正在使用 APIC ，如果看到 XT-PIC ，说明系统正在使用 8259A 芯片。</p>

<p>NMI watchdog 的开关是内核启动参数 <code>nmi_watchdog=[panic,]N</code> ，也可以在 /etc/sysctl.conf 、/etc/sysctl.d/* 等配置文件中添加内核参数 <code>kernel.nmi_watchdog=[panic,]N</code> 。其中 panic 可选，表示 NMI watchdog 超时时产生 panic ，进而可以触发 kdump 。N 可以取值 0~2 ，0 表示禁用 NMI watchdog ，如果要启用 NMI watchdog ，在具有 IO-ACPI 的系统中设为 1 ，在没有 IO-ACPI 的系统中设为 2 。设置成功后，可以看到如下内核信息：</p>

<pre><code>$ dmesg | grep NMI
ACPI: LAPIC_NMI (acpi_id[0xff] high edge lint[0x1])
NMI watchdog: enabled on all CPUs, permanently consumes one hw-PMU counter.
</code></pre>

<p>然后可以看到 NMI 中断计数：</p>

<pre><code>$ cat /proc/interrupts  | grep NMI
NMI:        449        207        197        179   Non-maskable interrupts
</code></pre>

<blockquote>
<p>因为 NMI 是硬件产生的，所以在虚拟机上测试很可能会失败，内核会报错误信息 : NMI watchdog: disable(cpu0): hardware events not enabled</p>
</blockquote>

<p>我们可以编写一个模块验证 NMI watchdog 能否正常工作，它的原理是在加载模块时禁用所有中断，这样 NMI handler 就不会响应，也不会刷新定时器，直到超时：</p>

<pre><code>#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/interrupt.h&gt;

static int __init nmitest_init(void)
{
    printk(&quot;nmitest init\n&quot;);
    local_irq_disable();
    while(1);
    return 0;
}

static void __exit nmitest_exit(void)
{
    printk(&quot;nmitest exit\n&quot;);
}

module_init(nmitest_init);
module_exit(nmitest_exit);

MODULE_LICENSE(&quot;GPL&quot;);
</code></pre>

<p>系统运行过程中要禁用 NMI watchdog ，可以将 <code>/proc/sys/kernel/nmi_watchdog</code> 设为 0 。</p>

<h2 id="8-soft-lockup-和-hard-lockup">8. Soft lockup 和 Hard lockup</h2>
]]></content>
        </item>
        
        <item>
            <title>systemd 的网络管理</title>
            <link>https://shaocheng.li/posts/2018/05/09/</link>
            <pubDate>Wed, 09 May 2018 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2018/05/09/</guid>
            <description>0. 简介 systemd 是 freedesktop 的项目，官网 https://www.freedesktop.org/wiki/Software/systemd/ ,项目源码在 github 上发布，可以在 https://github.com/systemd/systemd 查看所有版本更新、 Bug Fix 和版本对应的文档等。
systemd-networkd 是 systemd 默认提供的网络管理服务，可以完全管理以太网，对于无线网卡，还需要其他服务支持，比如管理 Wi-Fi 的 wpa_supplicant@.service ，管理 PPP 的 ppp@.service 。
管理网卡前，应该确保各网卡的驱动都已经正常加载，systemd 的 systemd-modules-load.service 负责在系统启动时静态加载内核模块。它会从以下路径搜索可用的配置文件：
/etc/modules-load.d/*.conf /run/modules-load.d/*.conf /usr/lib/modules-load.d/*.conf  配置文件的内容就是一个内核模块名称的列表，可以用井号 # 或者分号 ; 注释单个模块。
1. 基本配置 我的系统中，systemd 的版本是 216 ，有两个以太网卡和一个 Wi-Fi 网卡，先查看一下网卡列表，再查看 systemd-networkd.service 的状态：
~# networkctl list IDX LINK TYPE OPERATIONAL SETUP 1 lo loopback carrier unmanaged 2 wlp1s0 wlan off unmanaged 3 enp0s20f6 ether routable configured 4 enp0s20f7 ether no-carrier configured 4 links listed.</description>
            <content type="html"><![CDATA[

<h2 id="0-简介">0. 简介</h2>

<p>systemd 是 <a href="https://www.freedesktop.org" target="_blank">freedesktop</a> 的项目，官网 <a href="https://www.freedesktop.org/wiki/Software/systemd/" target="_blank">https://www.freedesktop.org/wiki/Software/systemd/</a> ,项目源码在 github 上发布，可以在 <a href="https://github.com/systemd/systemd" target="_blank">https://github.com/systemd/systemd</a> 查看所有版本更新、 Bug Fix 和版本对应的文档等。</p>

<p>systemd-networkd 是 systemd 默认提供的网络管理服务，可以完全管理以太网，对于无线网卡，还需要其他服务支持，比如管理 Wi-Fi 的 wpa_supplicant@.service ，管理 PPP 的 ppp@.service 。</p>

<p>管理网卡前，应该确保各网卡的驱动都已经正常加载，systemd 的 systemd-modules-load.service 负责在系统启动时静态加载内核模块。它会从以下路径搜索可用的配置文件：</p>

<pre><code>/etc/modules-load.d/*.conf
/run/modules-load.d/*.conf
/usr/lib/modules-load.d/*.conf
</code></pre>

<p>配置文件的内容就是一个内核模块名称的列表，可以用井号 # 或者分号  ;  注释单个模块。</p>

<h2 id="1-基本配置">1. 基本配置</h2>

<p>我的系统中，systemd 的版本是 216 ，有两个以太网卡和一个 Wi-Fi 网卡，先查看一下网卡列表，再查看 systemd-networkd.service 的状态：</p>

<pre><code>~# networkctl list
IDX LINK             TYPE               OPERATIONAL SETUP     
1 lo               loopback           carrier     unmanaged 
2 wlp1s0           wlan               off         unmanaged 
3 enp0s20f6        ether              routable    configured
4 enp0s20f7        ether              no-carrier  configured
4 links listed.
~# systemctl status systemd-networkd 
a—? systemd-networkd.service - Network Service
Loaded: loaded (/lib/systemd/system/systemd-networkd.service; enabled)
Active: active (running) since Fri 2018-04-27 17:49:22 UTC; 24min ago
    Docs: man:systemd-networkd.service(8)
Main PID: 260 (systemd-network)
Status: &quot;Processing requests...&quot;
CGroup: /system.slice/systemd-networkd.service
        a””a”€260 /lib/systemd/systemd-networkd

Apr 27 17:49:21 quark systemd[1]: Starting Network Service...
Apr 27 17:49:22 quark systemd-networkd[260]: lo              : gained carrier
Apr 27 17:49:22 quark systemd[1]: Started Network Service.
Apr 27 17:49:22 quark systemd-networkd[260]: eth1            : renamed to enp0s20f7
Apr 27 17:49:22 quark systemd-networkd[260]: eth0            : renamed to enp0s20f6
Apr 27 17:49:23 quark systemd-networkd[260]: enp0s20f6       : gained carrier
Apr 27 17:49:23 quark systemd-networkd[260]: enp0s20f7       : gained carrier
Apr 27 17:49:25 quark systemd-networkd[260]: enp0s20f6       : lost carrier
Apr 27 17:49:26 quark systemd-networkd[260]: enp0s20f7       : lost carrier
</code></pre>

<p>sytemd-network.service 的配置文件可以位于 /usr/lib/systemd/network/ 或者 /etc/systemd/network/ 目录下，后者具有最高优先级。配置文件有三种类型：</p>

<ol>
<li>.network 文件，设置网卡的 IP 等各项属性</li>
<li>.netdev 文件，新建一个虚拟网卡</li>
<li>.link 文件，每当一个网卡出现时，udev 都会查找与它同名的 .link 文件</li>
</ol>

<p>这几类文件都遵循下面的规则：</p>

<ul>
<li>各选项的值都支持星号 * 通配符</li>
<li>当 [Match] 段内的条件都匹配时，后面的配置项才会被激活</li>
<li>如果 [Match] 段为空，表示后面的配置项在任何情况下都可用</li>
<li>无论配置文件在哪个目录，都会统一安装字典顺序进行加载</li>
<li>同名文件可以相互替换</li>
</ul>

<p>如果要给 enp0s20f6 配置一个静态 IP ，可以在 /etc/systemd/network/ 目录下新建一个 eth0.network 文件，内容如下：</p>

<pre><code>[Match]
Name=enp0s20f6  # 匹配名为 enp0s20f6 的网卡
[Network]
DHCP=none    # 关闭 DHCP 客户端，
Address=192.168.5.242/24  # 设置 IP 和子网掩码
Gateway=192.168.5.50   # 设置网关，这项设置会将该网卡添加到缺省路由
DNS=8.8.8.8  # 设置 DNS 
</code></pre>

<p>如果要使用 DHCP 自动获取 IP ，也将 DHCP 设为如下值：</p>

<ul>
<li>v4 ，只接受 ipv4 的 IP</li>
<li>v6 ，只接受 ipv6 的 IP</li>
<li>both ，同时接受 ipv4 和 ipv6 格式的 IP</li>
</ul>

<p>启动 DHCP 客户端后，Gateway 和 DNS 也会自动获取，有时我们不希望这样，可以在配置文件中添加一个 [DHCP] 段，做如下设置：</p>

<pre><code>[DHCP]
UseDNS=false # 不使用 DHCP 分配的 DNS ，默认值是 true
UseRoutes=false # 不会将本网卡设为缺省路由，默认值是 true 
</code></pre>

<p>在这里会出现一个 Bug ，就是 UseRoutes 设置无效，高版本中已经解决，解决方案在 <a href="https://github.com/systemd/systemd/pull/3075" target="_blank">https://github.com/systemd/systemd/pull/3075</a> 。</p>

<h2 id="2-wi-fi-配置">2. Wi-Fi 配置</h2>

<p>Wi-Fi 连接还是使用 wpa_supplicant 程序，systemd 提供了 wpa_supplicant@.service 管理整个流程，然后再用 systemd-networkd.service 配置 IP 等。</p>

<p>wpa_supplicant@.service 的内容：</p>

<pre><code>[Unit]
Description=WPA supplicant daemon (interface-specific version)
Requires=sys-subsystem-net-devices-%i.device
After=sys-subsystem-net-devices-%i.device

# NetworkManager users will probably want the dbus version instead.

[Service]
Type=simple
ExecStart=/usr/sbin/wpa_supplicant -c/etc/wpa_supplicant/wpa_supplicant-%I.conf -i%I

[Install]
Alias=multi-user.target.wants/wpa_supplicant@%i.service
</code></pre>

<p>这是 service 模板，启动时在 <code>@</code> 符号之后加入 Wi-Fi 网卡的名称使其实例实例化，这个名词还会关联到 wpa_supplicant 的配置文件，我们先在 /etc/ 下新建一个 wpa_supplicant 目录，然后新建一个 wpa_supplicant-wlp1s0.conf 文件，内容如下：</p>

<pre><code>ctrl_interface=/var/run/wpa_supplicant
ctrl_interface_group=wheel
update_config=1
eapol_version=1
ap_scan=1
fast_reauth=1
</code></pre>

<p>用 wpa_passphrase 添加无线路由器配置：</p>

<pre><code>~# sudo wpa_passphrase [essid] [password] &gt;&gt; /etc/wpa_supplicant/wpa_supplicant-wlp1s0.conf
</code></pre>

<p>在 /etc/systemd/network/ 目录下添加配置文件 wireless.network ，内容如下：</p>

<pre><code>[Match]
Name=wlp1s0
[Network]
DHCP=yes
</code></pre>

<p>最后重启各项服务：</p>

<pre><code>~# systemctl restart systemd-networkd
~# systemctl restart wpa_supplicant@wlp1s0
~# systemctl restart systemd-resolved
</code></pre>

<h2 id="3-3g-4g-配置">3. 3G/4G 配置</h2>

<p>依然使用 pppd 进行 3G/4G 拨号，systemd 提供了 ppp@.service 服务管理 pppd 。首先在 /etc/ppp/peers/ 下建好 ppp 拨号文件 me909s ，然后启动服务：</p>

<pre><code>~# systemctl start ppp@me909s 
</code></pre>

<h2 id="4-关闭-ipv6">4. 关闭 IPv6</h2>

<p>向内核参数加入 ipv6.disable=1 可以完全关闭 IPv6 功能。此外，只加入 ipv6.disable_ipv6=1 内核参数可以保留 IPv6 功能，但不会向网卡分配 IPv6 地址，做法是：</p>

<pre><code>~# echo 1 &gt; /proc/sys/net/ipv6/conf/enp0s20f6/disable_ipv6
</code></pre>

<h2 id="5-ssh-server">5. ssh server</h2>

<p>目前流行的启动 ssh server 的方式是调用 sshd.socket ：</p>

<pre><code>~# systemctl start sshd.socket
</code></pre>

<p>旧有的 sshd.service 模式会在后台保持一个 sshd 的守护进程，每当有 ssh 连接要建立时，就创建一个新进程，比较适合 SSH 下有大量流量的系统；</p>

<p>新的 sshd.socket 方式也是在每次要建立新的ssh连接时生成一个守护进程的实例，不过监听端口则是交给了 systemd 来完成，意味着没有 ssh 连接的时候，也不会有 sshd 守护进程运行，大部分情况下，使用 sshd.socket 服务更为合适。这也与 MacOS 下的行为相一致，默认只监听端口，有连接时才创建进程。</p>

<p>另外，通过使用 .socket 文件来管理需要监听端口的服务，可以直接通过 systemctl 来查看一些网络相关的信息，如监听的端口、目前已经接受的连接数、目前正连接的连接数等。</p>

<h2 id="参考">参考</h2>

<ul>
<li><a href="https://forum.manjaro.org/t/how-to-use-systemd-networkd-to-manage-your-wifi/1557" target="_blank">How to use systemd-networkd to manage your wifi</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Systemd-networkd" target="_blank">Systemd-network</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Yocto 学习笔记</title>
            <link>https://shaocheng.li/posts/2018/04/27/</link>
            <pubDate>Fri, 27 Apr 2018 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2018/04/27/</guid>
            <description>0. Quick Start 构建一个 yocto 系统镜像的基本流程如下：
1. 准备宿主机系统，安装必要的开发工具。 2. 初始化构建环境，通常是利用 oe-init-build-env 脚本，默认会新建一个构建目录 build 。 3. 编辑 build/conf/local.conf 文件，确认 MACHINE 变量，为 4. 开始构建系统镜像，最终的镜像文件会生成在 build/tmp/deploy/images/ 目录下。
先在宿主机安装 Ubuntu Server 18.04 ，至少预留 50GB 硬盘空间，推荐 100GB ，然后安装如下软件包：
$ sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat cpio python python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping libsdl1.2-dev xterm  用 git 克隆一份 yocto 源码：
$ git clone git://git.yoctoproject.org/poky Cloning into &#39;poky&#39;.</description>
            <content type="html"><![CDATA[

<h2 id="0-quick-start">0. Quick Start</h2>

<p>构建一个 yocto 系统镜像的基本流程如下：</p>

<p><img src="/images/2018-04-27/2018-04-27_1.jpg" alt="" />
1. 准备宿主机系统，安装必要的开发工具。
2. 初始化构建环境，通常是利用 oe-init-build-env 脚本，默认会新建一个构建目录 build 。
3. 编辑 build/conf/local.conf 文件，确认 MACHINE 变量，为
4. 开始构建系统镜像，最终的镜像文件会生成在 build/tmp/deploy/images/ 目录下。</p>

<p>先在宿主机安装 Ubuntu Server 18.04 ，至少预留 50GB 硬盘空间，推荐 100GB ，然后安装如下软件包：</p>

<pre><code>$ sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat cpio python python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping libsdl1.2-dev xterm
</code></pre>

<p>用 git 克隆一份 yocto 源码：</p>

<pre><code>$ git clone git://git.yoctoproject.org/poky
Cloning into 'poky'...
remote: Counting objects: 367178, done.
remote: Compressing objects: 100% (88161/88161), done.
remote: Total 367178 (delta 272761), reused 366942 (delta 272525)
Receiving objects: 100% (367178/367178), 133.26 MiB | 6.40 MiB/s, done.
Resolving deltas: 100% (272761/272761), done.
Checking connectivity... done.
$ cd poky/
$ git status
On branch master
Your branch is up to date with 'origin/master'.
nothing to commit, working tree clean
$ git branch  -a
* master
  remotes/origin/1.1_M1
  remotes/origin/1.1_M2
  ...  
  remotes/origin/1.6_M5
  remotes/origin/HEAD -&gt; origin/master
  remotes/origin/bernard
  ...
  remotes/origin/rocko
  remotes/origin/rocko-next
  remotes/origin/sumo
  remotes/origin/sumo-next
</code></pre>

<p>克隆到本地的仓库处于 master 分支，在<a href="https://wiki.yoctoproject.org/wiki/Releases" target="_blank">这里</a>可以看到 yocto 的版本发行记录，我们应该检出当前的版本 2.4.2(Rocko) ：</p>

<pre><code>$ git checkout -b rocko origin/rocko
Branch 'rocko' set up to track remote branch 'rocko' from 'origin'.
Switched to a new branch 'rocko'
$ git branch
  master
* rocko
</code></pre>

<p>每个分支内又有很多 tags ，先查看当前的版本和 tag 信息:</p>

<pre><code>$ git describe
rocko-18.0.2-105-g701cc0009f
$ git show rocko-18.0.2
tag rocko-18.0.2
Tagger: Tracy Graydon &lt;tracy.graydon@intel.com&gt;
Date:   Mon Mar 12 14:51:03 2018 -0700

Tagging for yocto-2.4.2
... ...
commit 342fbd6a3e57021c8e28b124b3adb241936f3d9d (tag: yocto-2.4.2, tag: rocko-18.0.2)
Author: Anuj Mittal &lt;anuj.mittal@intel.com&gt;
Date:   Tue Feb 20 08:33:45 2018 +0800
</code></pre>

<p>可以看到，当前版本已经是 tag rocko-18.0.2 之后的第 105 次 commit ，可以选择将版本回退到一个特定的 tag 。然后初始化编译环境：</p>

<pre><code>$ source oe-init-build-env build
</code></pre>

<p>以后所有编译生成的文件都位于 build 目录下，然后开始编译：</p>

<pre><code>$ bitbake core-image-sato
</code></pre>

<p>默认会构建出一个基于 qemu 的系统镜像。</p>
]]></content>
        </item>
        
        <item>
            <title>Libpcap 学习笔记</title>
            <link>https://shaocheng.li/posts/2018/04/23/</link>
            <pubDate>Mon, 23 Apr 2018 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2018/04/23/</guid>
            <description>0. 简介 libpcap 是用于捕获 TCP/IP 网络数据包的 C/C++ 库，支持 Linux 系统，Tcpdump 就是在其基础上开发的，通常用于网络嗅探、数据抓取、协议分析等，官网是 http://www.tcpdump.org ，主要的功能有：
 数据包捕获：捕获流经网卡的原始数据包 规则过滤：提供自带规则过滤功能，按需要选择过滤规则 流量采集与统计：采集网络中的流量信息 自定义数据包发送：构造任何格式的原始数据包  包捕获机制是在数据链路层增加一个旁路处理，并不干扰系统自身的网络协议栈的处理，对发送和接收的数据包通过 Linux 内核做过滤和缓冲处理，最后直接传递给上层应用程序。在 Linux 发行版上可以直接安装 libpcap 或者开发库 libpcap-devel ，也可以下载源码后编译安装。
1. 编程 调用 libpcap 库函数前要包含的头文件：
#include &amp;lt;pcap/pcap.h&amp;gt;  调用 libpcap 库抓包的流程：
 查找网卡，目的是发现可用的网卡，实现的函数为 pcap_lookupdev() 。 获得网卡参数，这里是利用 pcap_lookupnet() 函数，获得指定网卡的 IP 地址和子网掩码。 打开网卡，利用第一步的返回值，决定使用哪个网卡，调用 pcap_open_live() 将其打开。 编译过滤策略，Lipcap 的重要功能就是提供数据包的过滤，实现的函数是 pcap_compile() 。 设置过滤器，调用 pcap_setfilter() 函数将编译好的过滤策略设置到相应网卡。 开始捕获数据包，有多种实现函数，具有不同的特性。 关闭网卡，释放资源。  如果是用源码包编译安装的话，在 tests 目录下有几个例程可以参考。
1.1. 查找网卡 char errbuf[PCAP_ERRBUF_SIZE]; int pcap_findalldevs(pcap_if_t **alldevsp, char *errbuf); void pcap_freealldevs(pcap_if_t *alldevs);  pcap_freealldevs() 函数可以搜索当前系统中的网卡，并构造一个网卡设备链表。如果调用成功，函数返回 0 ，指针 alldevsp 会指向列表的第一个元素；否则返回 -1 ，指针为 NULL ，并在 errbuf 中存放错误信息，errbuf 至少应该是 PCAP_ERRBUF_SIZE 个字节长度的。链表中的每个元素都是 pcap_if_t 类型：</description>
            <content type="html"><![CDATA[

<h2 id="0-简介">0. 简介</h2>

<p>libpcap 是用于捕获 TCP/IP 网络数据包的 C/C++ 库，支持 Linux 系统，Tcpdump 就是在其基础上开发的，通常用于网络嗅探、数据抓取、协议分析等，官网是 <a href="http://www.tcpdump.org" target="_blank">http://www.tcpdump.org</a> ，主要的功能有：</p>

<ul>
<li>数据包捕获：捕获流经网卡的原始数据包</li>
<li>规则过滤：提供自带规则过滤功能，按需要选择过滤规则</li>
<li>流量采集与统计：采集网络中的流量信息</li>
<li>自定义数据包发送：构造任何格式的原始数据包</li>
</ul>

<p>包捕获机制是在数据链路层增加一个旁路处理，并不干扰系统自身的网络协议栈的处理，对发送和接收的数据包通过 Linux 内核做过滤和缓冲处理，最后直接传递给上层应用程序。在 Linux 发行版上可以直接安装 libpcap 或者开发库 libpcap-devel ，也可以下载源码后编译安装。</p>

<h2 id="1-编程">1. 编程</h2>

<p>调用 libpcap 库函数前要包含的头文件：</p>

<pre><code>#include &lt;pcap/pcap.h&gt;
</code></pre>

<p>调用 libpcap 库抓包的流程：</p>

<ol>
<li>查找网卡，目的是发现可用的网卡，实现的函数为 <code>pcap_lookupdev()</code> 。</li>
<li>获得网卡参数，这里是利用 <code>pcap_lookupnet()</code> 函数，获得指定网卡的 IP 地址和子网掩码。</li>
<li>打开网卡，利用第一步的返回值，决定使用哪个网卡，调用 <code>pcap_open_live()</code> 将其打开。</li>
<li>编译过滤策略，Lipcap 的重要功能就是提供数据包的过滤，实现的函数是 <code>pcap_compile()</code> 。</li>
<li>设置过滤器，调用 <code>pcap_setfilter()</code> 函数将编译好的过滤策略设置到相应网卡。</li>
<li>开始捕获数据包，有多种实现函数，具有不同的特性。</li>
<li>关闭网卡，释放资源。</li>
</ol>

<p>如果是用源码包编译安装的话，在 tests 目录下有几个例程可以参考。</p>

<h3 id="1-1-查找网卡">1.1. 查找网卡</h3>

<pre><code>char errbuf[PCAP_ERRBUF_SIZE];
int pcap_findalldevs(pcap_if_t **alldevsp, char *errbuf);
void pcap_freealldevs(pcap_if_t *alldevs);
</code></pre>

<p><code>pcap_freealldevs()</code> 函数可以搜索当前系统中的网卡，并构造一个网卡设备链表。如果调用成功，函数返回 0 ，指针 alldevsp 会指向列表的第一个元素；否则返回 -1 ，指针为 NULL ，并在 errbuf 中存放错误信息，errbuf 至少应该是 PCAP_ERRBUF_SIZE 个字节长度的。链表中的每个元素都是 pcap_if_t 类型：</p>

<pre><code>struct pcap_if {
        struct pcap_if *next;
        char *name;             /* 网卡设备名称，可以调用 &quot;pcap_open_live()&quot; 打开*/
        char *description;      /* 网卡设备描述, 可以为 NULL */
        struct pcap_addr *addresses;  
        bpf_u_int32 flags;      /* PCAP_IF_ interface flags */
};
typedef struct pcap_if pcap_if_t;
</code></pre>

<p>addresses 是 <code>struct pcap_addr</code> 类型的指针，包含了 IP 、掩码等网卡信息：</p>

<pre><code>struct pcap_addr {
        struct pcap_addr *next;
        struct sockaddr *addr;          /* address */
        struct sockaddr *netmask;       /* netmask for that address */
        struct sockaddr *broadaddr;     /* broadcast address for that address */
        struct sockaddr *dstaddr;       /* P2P destination address for that address */
};
typedef struct pcap_addr pcap_addr_t;
</code></pre>

<p>bpf_u_int32 flags 是设置网卡状态属性的变量，可选值有：</p>

<ul>
<li>PCAP_IF_LOOPBACK ，把网卡设为 loopback 接口</li>
<li>PCAP_IF_UP ，网卡状态设为 UP</li>
<li>PCAP_IF_RUNNING ，网卡状态设为 running</li>
</ul>

<p>使用完成后，调用如下函数释放设备链表：</p>

<pre><code>void pcap_freealldevs(pcap_if_t *alldevs);
</code></pre>

<p>下面是一个简单的例子：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;pcap/pcap.h&gt;

int main()
{
    int ret = 0;
    int i = 0;
    char errbuf[PCAP_ERRBUF_SIZE] = &quot;\0&quot;;
    pcap_if_t *devsp = NULL;
    pcap_if_t *temp = NULL;

    printf(&quot;start libpcap\n&quot;);
    ret = pcap_findalldevs(&amp;devsp, errbuf);
    if(ret==0  &amp;&amp; devsp)
    {
        for(temp=devsp;temp;temp=temp-&gt;next)
        {
            printf(&quot;%d : interface name %s\n&quot;,i++,temp-&gt;name);
        }
    }
    else
    {
        printf(&quot;pcap_findalldevs error : %s\n&quot;, errbuf);
    }
    return 0;
}
</code></pre>

<p>编译：</p>

<pre><code>$ gcc -Wall test.c -o test -lpcap
</code></pre>

<p>执行：</p>

<pre><code>$ ./test
start libpcap
0 : interface name eth0
1 : interface name any
2 : interface name lo
3 : interface name nflog
4 : interface name nfqueue
5 : interface name usbmon1
</code></pre>

<h3 id="1-2-打开网卡">1.2. 打开网卡</h3>

<p>获得了网卡名称后，就可以调用相关函数把它打开：</p>

<pre><code>pcap_t *pcap_open_live(const char *device, int snaplen, int promisc, int to_ms, char *errbuf);
</code></pre>

<p>该函数的作用获得指定网卡的操作句柄，并设置句柄的各种属性，后面的抓包函数都是直接操作这个句柄。各参数的含义：</p>

<ul>
<li>device 是网卡名称的字符串</li>
<li>snaplen 表示对每个数据包，从开头抓取多少个字节，任何一个协议的一个数据包长度都小于 65536 字节，我们可以用这个参数设置只抓取头部，而不关系具体内容</li>
<li>promise 设为 0 表示关闭混杂模式，1 表示打开，此时网卡也必须打开混杂模式，例如 ifconfig eth0 promisc</li>
<li>to_ms 用于设置某些抓包函数的超时时间，单位是毫秒，0 表示一直等待</li>
<li>errbuf 用于存放错误信息</li>
</ul>

<p>该函数调用成功时会返回一个 pcap_t 类型的指针，失败则返回 NULL 。使用完毕后，应该调用下面的函数将其关闭：</p>

<pre><code>void pcap_close(pcap_t * p);
</code></pre>

<p>如果想要知道某个网卡的类型，可以调用 pcap_datalink() ，它会返回网卡数据链路类型：</p>

<pre><code>int pcap_datalink(pcap_t *p);
</code></pre>

<p>它的返回值列表可以在 <a href="http://www.tcpdump.org/linktypes.html" target="_blank">http://www.tcpdump.org/linktypes.html</a> 查到，常见的有：</p>

<table>
<thead>
<tr>
<th>LINKTYPE_ name</th>
<th>value</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>LINKTYPE_ETHERNET</td>
<td>1</td>
<td>IEEE 802.3 以太网</td>
</tr>

<tr>
<td>LINKTYPE_PPP</td>
<td>9</td>
<td>PPP, 描述在 RFC 1661 和 RFC 1662</td>
</tr>

<tr>
<td>LINKTYPE_IEEE802_11</td>
<td>105</td>
<td>IEEE 802.11 无线</td>
</tr>
</tbody>
</table>

<h3 id="1-3-获取数据包">1.3. 获取数据包</h3>

<p>libpcap 有多种获取数据包的方法，可以根据不同的应用场景进行选择。</p>

<pre><code>const u_char *pcap_next(pcap_t *p, struct pcap_pkthdr *h);
</code></pre>

<p><code>pcap_next()</code> 在获取一个数据包后立即返回，并将数据包存放在返回值指向的内存中，这段内存可能随时被更改或者释放，所以，如果要对数据做进一步处理，最好先拷贝一份，调用失败会返回 NULL 。这种方式处理数据包的内容并不方便，所有我们通常只用这个方法统计数据量，参数 <code>struct pcap_pkthdr *h</code> 记录了数据包的其他信息：</p>

<pre><code>struct pcap_pkthdr
{
  struct timeval ts;    /* 时间戳 */
  bpf_u_int32 caplen;   /* 本次捕获的数据长度 */
  bpf_u_int32 len;      /* 这个数据包的真实长度 */
};
</code></pre>

<p>因为不能保证每次捕获的包是完整的，例如一个包长 1480，但是捕获到1000的时候，可能因为某些原因就中止了，所以caplen 是记录实际捕获的长度，也就是 1000，而 len 就是1480。</p>

<p>另一个重要的方法是 pcap_loop() ：</p>

<pre><code>int pcap_loop(pcap_t * p, int cnt, pcap_handler callback, u_char * user);
</code></pre>

<p>该函数会连续捕获 cnt 个数据包后退出，如果 cnt &lt; 0 ，会一直循环抓包，直到出现错误或者调用 <code>pcap_breakloop()</code> 。在低版本中，没有定义 cnt==0 时的情况，不同平台上的特性无法确定。函数正常退出时返回 0 ，出错返回 -1 ，如果是被 <code>pcap_breakloop()</code> 中断的会返回 -2 。每当收到足够的数据包时，<code>pcap_loop()</code> 会调用 callback 回调函数，并可以通过 <code>u_char * user</code> 向回调函数传递参数，我们可以在回调函数里处理收到的数据包：</p>

<pre><code>typedef void (*pcap_handler)(u_char *user, const struct pcap_pkthdr *h, const u_char *bytes);  
</code></pre>

<p>数据包就存放在指针参数 bytes 指向的内存里，长度可以通过第二个参数 <code>struct pcap_pkthdr *h</code> 获取。下面是一个简单的例子：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;
#include &lt;pcap.h&gt;

void get_packet(u_char * arg, const struct pcap_pkthdr * pkthdr, const u_char * packet)
{
    int * id = (int *)arg;

    printf(&quot;id: %d\n&quot;, ++(*id));
    printf(&quot;Packet length: %d\n&quot;, pkthdr-&gt;len);
    printf(&quot;Number of bytes: %d\n&quot;, pkthdr-&gt;caplen);
    printf(&quot;Recieved time: %s\n&quot;, ctime((const time_t *)&amp;pkthdr-&gt;ts.tv_sec));
    //print packet
    int i;
    for(i=0; i&lt;pkthdr-&gt;len; ++i)  {
        printf(&quot; %02x&quot;, packet[i]);
        if( (i + 1) % 16 == 0 )
            printf(&quot;\n&quot;);
    }
    printf(&quot;\n\n&quot;);
}

int main()
{
    char dev[10]=&quot;eth0&quot;;
    char errbuf[1024];
    int id = 0;

    pcap_t* device=pcap_open_live(dev,65535,1,0,errbuf);
    if(!device){
        printf(&quot;couldn't open the net device: %s\n&quot;,errbuf);
        return 1;
    }

    //capture the packet
    pcap_loop(device,-1,get_packet,(u_char*)&amp;id);

    return 0;
}
</code></pre>

<p>另一个方法 <code>pcap_dispatch()</code> 与 <code>pcap_loop()</code> 非常相似，参数完全相同：</p>

<pre><code>int pcap_dispatch(pcap_t *p, int cnt, pcap_handler callback, u_char *user);
</code></pre>

<p>不同的是，这个函数有超时设定，超时时间由 <code>pcap_open_live()</code> 函数的第四个参数 to_ms 设置，如果超过 to_ms 毫秒还没有收到数据就会返回。正常情况下，这个函数的返回值是收到的数据包个数，没收到就返回 0 ，出错时返回 -1 ，如果是被 <code>pcap_breakloop()</code> 中断的会返回 -2 。有一点要注意，该函数返回后，如果还要继续抓包，可以直接调用 <code>pcap_dispatch()</code> 继续抓包，除非调用出错，否则不要关闭设备，频繁的打开关闭设备可能出现意想不到的错误。参数 cnt 表示的是最大值，即最多收到 cnt 个数据包就返回，因为一次只读取一个缓冲区内的数据包，可能会处理少于 cnt 的数据包，如果设为 -1 或者 0 ，表示捕获一个缓冲区内的所有数据包。</p>

<p>这几个函数出错时，可以用 <code>pcap_geterr()</code> 获取错误信息：</p>

<pre><code>char *pcap_geterr(pcap_t *p);
</code></pre>

<p>返回值是执行错误信息字符串的指针，最好拷贝一份再做处理。</p>

<h3 id="1-3-过滤器">1.3. 过滤器</h3>

<p>libpcap 的过滤器是利用 BPF 来筛选网络数据包的，它是类 Unix 系统上数据链路层的一种原始接口，我们可以在过滤器中设置规则，获取想要的网络数据包，比如只获取 UDP 数据包，只获取特定地址的数据包等。过滤数据包需要完成三件事：</p>

<ol>
<li>构造过滤表达式，这是一个包含筛选规则的字符串</li>
<li>把过滤表达式编译到 BPF</li>
<li>应用过滤器</li>
</ol>

<p>过滤表达式的语法比较简单，一个过滤表达式通常由一个 id （名字或数字）和多个修饰词组成，修饰词分为三种：</p>

<ul>
<li>type ，用来说明 id 是什么类型，可选的 net 、host 和 port 分别表示网络、主机和端口，没有声明时默认是 host ，例如 <code>net 192.168</code> , <code>host 192.168.5.252</code> ， <code>port 22</code>  。</li>
<li>dir ，表示 id 的传输方向，可选 src 、dst 等，默认是 src or dst ，例如 <code>dst port 22</code> 表示目的端口是 22 。</li>
<li>proto ，限定匹配的协议，比如链路层协议 ether 、wlan ，网络层协议 ip ，传输层协议 tcp 、udp 等。</li>
</ul>

<p>多个表达式可以用 and 、or 、not 连接，表示逻辑与、或、非。 下面是一些常用的表达式，更多细节可以查看 <a href="https://www.tcpdump.org/manpages/pcap-filter.7.html" target="_blank">https://www.tcpdump.org/manpages/pcap-filter.7.html</a> :</p>

<pre><code>#只接受源地址是 192.168.1.1 的数据包
src host 192.168.1.1
#只接受目的端口是 8000 的数据包
dst port 8000
#只接受 UDP 数据包
udp 
#不接受 TCP 数据包
not tcp
#只接受 ip 的 ttl==5 的数据包（ip 首部第八个字节是 ttl）
ip[8]==5
#接受来自 192.168.5.252 主机，且目的端口是 22 或者 23 的数据包
dst port 192.168.5.252 and (dst port 22 or dst port 23)
</code></pre>

<p>构造好过滤表达式后，就可以调用 <code>pcap_compile()</code> 函数进行编译：</p>

<pre><code>int pcap_compile(pcap_t *p, struct bpf_program *fp, const char *str, int optimize, bpf_u_int32 netmask);
</code></pre>

<p>fp 是一个传出参数，用于保存编译后的 BPF ，str 就是过滤表达式，optimize 设为 1 表示对过滤表达式进行优化，netmask 设为 0 即可。编译成功返回 0 ，失败返回 -1 。</p>

<blockquote>
<p>注意， 在 libpcap 1.8.0 以及之后的版本中，<code>pcap_compile()</code> 可以用于多线程，旧版本中，该函数是线程不安全的，如果用于多线程，需要做互斥同步。</p>
</blockquote>

<p>编译成功后，调用 <code>pcap_setfilter()</code> 应用这个过滤器：</p>

<pre><code>int pcap_setfilter(pcap_t *p, struct bpf_program *fp);
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>Tkinter 学习笔记</title>
            <link>https://shaocheng.li/posts/2017/12/18/</link>
            <pubDate>Mon, 18 Dec 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/12/18/</guid>
            <description>0. 开始 Tkinter 是 Python 内置的 GUI 框架，安装后 Python 后即可使用：
Python 3.6.2 (v3.6.2:5fd33b5926, Jul 16 2017, 20:11:06) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type &amp;quot;help&amp;quot;, &amp;quot;copyright&amp;quot;, &amp;quot;credits&amp;quot; or &amp;quot;license&amp;quot; for more information. &amp;gt;&amp;gt;&amp;gt; import tkinter as tk &amp;gt;&amp;gt;&amp;gt; tk._test()  运行结果：
下面这个例子只包含一个 Quit 按钮:
import tkinter as tk window = tk.Tk() #定义一个顶层窗口 window.title(&#39;my window&#39;) #定义窗口的标题 window.geometry(&#39;200x100&#39;) #设置窗口的大小 quitbutton = tk.Button(window, text=&amp;quot;Quit&amp;quot;, command=window.quit) #在 window 上定义一个按钮，显示 Quit ，点击按钮执行 quit 方法 quitbutton.</description>
            <content type="html"><![CDATA[

<h2 id="0-开始">0. 开始</h2>

<p>Tkinter 是 Python 内置的 GUI 框架，安装后 Python 后即可使用：</p>

<pre><code>Python 3.6.2 (v3.6.2:5fd33b5926, Jul 16 2017, 20:11:06)
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import tkinter as tk
&gt;&gt;&gt; tk._test()
</code></pre>

<p>运行结果：</p>

<p><img src="/images/2017-12-18/2017-12-18_1.png" alt="" /></p>

<p>下面这个例子只包含一个 Quit 按钮:</p>

<pre><code>import tkinter as tk

window = tk.Tk() #定义一个顶层窗口
window.title('my window')  #定义窗口的标题
window.geometry('200x100')  #设置窗口的大小

quitbutton = tk.Button(window, text=&quot;Quit&quot;, command=window.quit)  #在 window 上定义一个按钮，显示 Quit ，点击按钮执行 quit 方法
quitbutton.grid()  #显示这个按钮
window.mainloop()  #开始主循环
</code></pre>

<p>运行结果：</p>

<p><img src="/images/2017-12-18/2017-12-18_2.png" alt="" /></p>

<h2 id="1-布局管理">1. 布局管理</h2>

<p>Tkinter 有多种布局管理系统，grid 是最常用的一种。以顶层窗口作为根控件形成一个控件树，一个父控件上可以包含很多子控件，例如顶层窗口上有按钮、输入框等，大体应该是如下的结构：</p>

<p><img src="/images/2017-12-18/2017-12-18_3.png" alt="" /></p>

<p>新建一个控件分为两步：</p>

<pre><code>self.thing = tk.Constructor(parent, ...)
self.thing.grid(...)
</code></pre>

<ol>
<li>定义控件，Constructor 是一种控件的类， 比如 Button、Frame ，parent 表示该控件的父控件</li>
<li>将控件放到窗口上，所有的控件都有 grid 方法，负责通知布局管理器将这个组件放置到合适的位置</li>
</ol>

<p>grid 布局将父控件的显示区域划分为网格，使用 grid 布局的过程就是为各个子控件指定行号和列号，左上角的坐标是 (0,0)，不需要为每个单元格指定大小，grid 布局会自动设置一个合适的大小。grid 方法的原型是 <code>w.grid(option=value, ...)</code> ，它将控件 w 注册到父控件的 grid 布局，并设置所处的单元格坐标，常用属性如下：</p>

<ul>
<li>column ，列坐标，默认是 0</li>
<li>row ，行坐标，默认是新启一行</li>
<li>sticky ，控件填充单元格的方式，不设置该选项时默认是横竖居中，它有两种可选值，可以用加号组合：

<ul>
<li>紧贴单元格的某个角落：sticky=tk.NE (右上角) ， tk.SE (右下角) ， tk.SW (左下角) 或者 tk.NW (左上角)</li>
<li>紧贴单元格的某条边线：sticky=tk.N (上边居中) ， tk.E (右边居中) ， tk.S (底边居中) 或者 tk.W (左边居中)</li>
</ul></li>
<li>padx ，横向内边距</li>
<li>pady ，纵向内边距</li>
</ul>

<p>也可以手动设置当前控件的单元格大小：</p>

<ul>
<li>设置第 N 列：<code>w.columnconfigure(N, option=value, ...)</code></li>
<li>设置第 N 行：<code>w.rowconfigure(N, option=value, ...)</code></li>
</ul>

<p>option 有三个属性可选：</p>

<ul>
<li>minsize ，行或者列的最小尺寸，单位是像素</li>
<li>pad ，行或者列占用的尺寸大小，单位是像素</li>
<li>weight ，设置行或者列占用的比例，使网格尺寸具有弹性，</li>
</ul>

<p>例如：</p>

<pre><code>import tkinter as tk

window = tk.Tk()
window.title('my window')
window.geometry('200x100')
window.columnconfigure(0, weight=1)  #第一列占用 1/3 宽度
window.columnconfigure(1, weight=2)  #第二列占用 2/3 宽度
window.rowconfigure(0, weight=1)  #第一行占用全部高度

Abutton = tk.Button(window, text=&quot;A&quot;)
Abutton.grid()
Bbutton = tk.Button(window, text=&quot;B&quot;)
Bbutton.grid(row=0,column=1,sticky=tk.W+tk.E)

window.mainloop()
</code></pre>

<p>运行结果：</p>

<p><img src="/images/2017-12-18/2017-12-18_4.png" alt="" /></p>

<p>还有一些常用的方法：</p>

<ul>
<li>w.grid_forget() ，隐藏一个控件</li>
<li>w.grid_propagate() ，控件的尺寸通常是由控件里的内容决定的，但是有时需要强制设置控件大小，这就要先设置 <code>w.grid_propagate(0)</code> ，然后设置尺寸</li>
<li>w.grid_info()，返回一个字典，包含了控件的属性名称和值</li>
<li>w.grid_size()，返回一个元组，包含两个元素，分别是行和列</li>
<li>w.grid_configure(option, &hellip;) ，设置 grid 的属性，例如 <code>w.grid_configure(padx=5,pady=5)</code></li>
</ul>

<h2 id="2-一个完整的例子">2. 一个完整的例子</h2>

<h3 id="2-1-设计">2.1. 设计</h3>

<p>这个例子是一个单窗口 GUI 应用，功能是将英尺转换为米，界面草图是这个样子：</p>

<p><img src="/images/2017-12-18/2017-12-18_5.jpg" alt="" /></p>

<p>第一行有一个输入框，单位 feet 放在一个标签里，第二行中间是一个空白标签，用于放置转换后的结果，左右分别是文字说明，右下角是一个 &lsquo;Calculate&rsquo; 按钮，按下时获取输入框中的数值，转换成米后显示在中间的标签中。整个窗口是一个 3x3 的 grid 布局：</p>

<p><img src="/images/2017-12-18/2017-12-18_6.jpg" alt="" /></p>

<p>三行所占高度应该是 1:1:1 ，三列所占的宽度应该是 2:1:1 ，输入框宽度 7 个字符。</p>

<h3 id="2-2-编码">2.2. 编码</h3>

<p>新建一个目录，编辑源文件 mygui.py ，代码如下：</p>

<pre><code>#!~/py3-env/bin/python
import tkinter as tk

#新建一个根窗口，并设置窗口标题
window = tk.Tk()
window.title('Feet to Meters')

#按下按钮是调用的函数，获取输入框的值，转换成米制单位在写入标签
def calculate(*args):
    value = float(feet.get())
    meters.set( (0.3048*value*10000.0 + 0.5) / 10000.0 )

#在窗口上绘制一个框架，并定义框架的内边距
mainframe = tk.Frame(window,padx=15,pady=25)
#mainframe 会占满整个窗口
mainframe.grid(row=0,column=0,sticky=tk.N+tk.W+tk.E+tk.S)
mainframe.rowconfigure(0,weight=1)
mainframe.columnconfigure(0,weight=1)

#输入框位于第一行第二列，左右占满，宽度是 7 个字符，内部文本右对齐，并且是程序启动后默认的焦点
feet=tk.StringVar()
feet_entry = tk.Entry(mainframe,width=7,justify=tk.RIGHT,textvariable=feet)
feet_entry.grid(row=0,column=1,sticky=tk.W+tk.E)
feet_entry.focus()

feet_label = tk.Label(mainframe,text=&quot;Feet&quot;,anchor=tk.W)
feet_label.grid(row=0,column=2,sticky=tk.W)

meters=tk.StringVar()
tk.Label(mainframe,text=&quot;is equivalent to&quot;).grid(row=1,column=0,sticky=tk.E)
tk.Label(mainframe,textvariable=meters).grid(row=1,column=1,sticky=tk.W+tk.E)
tk.Label(mainframe,text=&quot;Meters&quot;).grid(row=1,column=2,sticky=tk.W+tk.W)

#在右下角放置一个按钮，按下时执行 calculate 函数
tk.Button(mainframe,text=&quot;Calculate&quot;,command=calculate).grid(row=2,column=2,sticky=tk.W)

#设置 mainframe 内每个控件的内边距为 5
for child in mainframe.winfo_children():
    child.grid_configure(padx=5,pady=5)

#按下回车键时也会执行转换
window.bind('&lt;Return&gt;', calculate)

window.mainloop()
</code></pre>

<p>保存后运行，看一下效果：</p>

<p><img src="/images/2017-12-18/2017-12-18_7.png" alt="" /></p>

<h3 id="2-3-打包">2.3. 打包</h3>

<p>测试成功后用 pyinstaller 将源码打包，这样在其他计算机上也可以运行，甚至不用安装 python ，但是有一点要注意，在 macOS 下用 pyinstaller 打包的程序只能运行于 macOS ，在 Windows 下用 pyinstaller 打包的程序只能运行于 Windows 。先安装 pyinstaller ：</p>

<pre><code>$ pip  install  pyinstaller
$ python -m PyInstaller --version
3.3.1
</code></pre>

<p>这个版本在 macOS 上有个 Bug ，就是打包的 tkinter 程序在运行时会报如下的错误：</p>

<pre><code>ImportError: dlopen(/var/folders/gk/q_9lv83d6999mzn5d3cjrry80000gn/T/_MEIlRBLqx/_tkinter.so, 2): Library not loaded: @loader_path/Tcl
  Referenced from: /var/folders/gk/q_9lv83d6999mzn5d3cjrry80000gn/T/_MEIlRBLqx/_tkinter.so
  Reason: image not found
</code></pre>

<p>需要安装下面提供的补丁修改 pyinstaller : <a href="https://github.com/pyinstaller/pyinstaller/pull/2969" target="_blank">https://github.com/pyinstaller/pyinstaller/pull/2969</a> 。然后在源码目录下执行：</p>

<pre><code>$ pyinstaller  -w  -F  mygui.py
</code></pre>

<p>-F 表示将所有文件和库打包成一个文件，这样在没有安装 python 的计算机上也可以运行，-w 表示关闭终端，否则在运行生成的应用在打开时会运行一个终端。生成的应用程序在 dist 目录下，该目录下有两个文件，mygui 是调试版，mygui.app 是发行版，双击 mygui.app 即可运行：</p>

<p><img src="/images/2017-12-18/2017-12-18_8.png" alt="" /></p>

<p>默认打包后的程序是不支持 Retina 屏幕的，所以在 macOS 上会显示模糊。需要先生成一个 spec 文件：</p>

<pre><code>$ pyi-makespec -w -F mygui.py
</code></pre>

<p>然后编辑生成的 mygui.spec ，添加 <code>info_plist</code> 并设置 <code>'NSHighResolutionCapable': 'True'</code> ：</p>

<pre><code>app = BUNDLE(exe,
             name='mygui.app',
             icon=None,
             bundle_identifier=None,
             info_plist={
                 'NSHighResolutionCapable': 'True'
             }
            )
</code></pre>

<p>保存后用这个配置文件执行打包任务：</p>

<pre><code>$ pyinstaller -w -F mygui.spec
</code></pre>

<p>这样生成的应用就支持 Retina 屏幕了。</p>

<h2 id="3-常用控件">3. 常用控件</h2>

<p>每个控件都是一个类，调用控件的初始化函数就会新建一个实例。</p>

<h3 id="3-1-按钮">3.1. 按钮</h3>

<p>按钮的原型：</p>

<pre><code>w = tk.Button(parent, option=value, ...)
</code></pre>

<ul>
<li>bg or background  ，背景颜色</li>
<li>bd or borderwidth  ，边框宽度，默认是 2</li>
<li>anchor ，按钮上文字的对齐位置，例如 anchor=tk.NE 表示右上角对齐</li>
<li>text ，按钮上显示的文字</li>
<li>textvariable ，为该属性设置一个控制变量 StringVal 类的实例，以后修改这个变量就可以修改标签内显示的文本</li>
<li>command ，设置按钮按下时的行为，可以指向一个函数或者方法</li>
<li>width ，按钮的宽度，单位是字符个数，如果按钮显示的是图片，则单位是像素</li>
<li>padx ，按钮边框与文字之间的横向间距，就是内边距，单位是像素</li>
<li>pady ，按钮边框与文字之间的纵向间距，单位是像素</li>
<li>relief ，3D 样式，默认值是 relief=tk.RAISED，可选四个值：tk.GROOVE(边框突出)，tk.RIDGE(边框凹陷)，tk.SUNKEN(整体凹陷)，tk.RAISED(整体突出)，边框宽度由 borderwidth 决定</li>
<li>state ，按钮的状态，默认是 tk.NORMAL ，鼠标悬停时这个值是 tk.ACTIVE ，设为 tk.DISABLED 时按钮变灰并且失效</li>
</ul>

<p>它有两个方法：</p>

<ul>
<li>.invoke() ，调用 command 指定的函数。</li>
<li>.flash() ，使按钮的颜色在按下和放开之间闪烁几次。</li>
</ul>

<p>例程：</p>

<pre><code>import tkinter as tk

window = tk.Tk()
window.title('my window')
window.geometry('200x100')
window.columnconfigure(0, weight=1)
window.rowconfigure(0, weight=1)

button = tk.Button(window, anchor=tk.CENTER, text='Quit', command=window.quit)
button.grid()

window.mainloop()
</code></pre>

<p>运行结果：</p>

<p><img src="/images/2017-12-18/2017-12-18_9.png" alt="" /></p>

<h3 id="3-2-标签">3.2. 标签</h3>

<p>标签控件可以显示一行或者多行文本，或者一张图片。</p>

<pre><code>w = tk.Label(parent, option, ...)
</code></pre>

<p>常用属性；</p>

<ul>
<li>activebackground ，鼠标经过时的背景颜色</li>
<li>activeforeground ，鼠标经过时的前景颜色</li>
<li>anchor ，文本或者图片的对齐位置，默认是  anchor=tk.CENTER</li>
<li>bg or background ，背景颜色</li>
<li>bd or borderwidth  ，边框宽度，默认是 2</li>
<li>text ，显示是文本</li>
<li>textvariable ，为该属性设置一个控制变量 StringVal 类的实例，以后修改这个变量就可以修改标签内显示的文本</li>
<li>width ，宽度，单位是字符，如果没有设置，宽度随内容变化</li>
<li>padx ，按钮边框与文字之间的横向间距，就是内边距，单位是像素</li>
<li>pady ，按钮边框与文字之间的纵向间距，单位是像素</li>
<li>relief ，3D 样式，默认值是 relief=tk.FLAT，可选四个值：tk.GROOVE(边框突出)，tk.RIDGE(边框凹陷)，tk.SUNKEN(整体凹陷)，tk.RAISED(整体突出)，边框宽度由 borderwidth 决定</li>
</ul>

<p>例程：</p>

<pre><code>import tkinter as tk

window = tk.Tk()
window.title('my window')
window.geometry('200x100')
window.columnconfigure(0, weight=1)
window.rowconfigure(0, weight=1)

label = tk.Label(window, bg='#ff0000', text='Please',padx=5, pady=3)
label.grid()

window.mainloop()
</code></pre>

<p>运行结果：</p>

<p><img src="/images/2017-12-18/2017-12-18_10.png" alt="" /></p>

<h3 id="3-3-输入框">3.3. 输入框</h3>

<p>输入框可以显示和输入单行文本，文本中的字符编号从 0 开始，常量 tk.END 表示文本的结尾，tk.INSERT 表示当前光标所处的位置，原型：</p>

<pre><code>w = tk.Entry(parent, option, ...)
</code></pre>

<p>常用属性：</p>

<ul>
<li>bg or background  ，背景颜色</li>
<li>bd or borderwidth  ，边框宽度，默认是 0</li>
<li>width ，输入框能够容纳的字符数，默认是 20</li>
<li>show，默认情况下，输入的字符会直接显示，如果是密码，需要隐藏，可以要求输入的字符都显示为星号： <code>show='*'</code></li>
<li>justify ，输入框内文本的对齐方式，默认是左对齐 justify=tk.LEFT ，还可选 tk.CENTER 和 tk.RIGHT</li>
<li>validate ，设置检查输入框内容的时机</li>
<li>validatecommand ，设置一个回调函数，负责检查输入框的内容</li>
<li>textvariable ，为该属性设置一个控制变量 StringVar 类的实例，就可以用 v.get() 方法取回输入框中内容，或者用 v.set(value) 设置，v 就是这个实例</li>
<li>state ，默认是 tk.NORMAL ，鼠标悬停时这个值是 tk.ACTIVE ，设为 tk.DISABLED 时输入框变灰，并无法输入。</li>
</ul>

<p>常用方法：</p>

<ul>
<li>.delete(first, last=None) ，删除字符，从第 first 个字符到第 last 个字符之前。</li>
<li>.get() ，获取输入框中的文本，返回值是字符串。</li>
<li>.insert(index, s) ，在第 index 个字符前插入字符串 s 。</li>
</ul>

<p>例程：</p>

<pre><code>import tkinter as tk

window = tk.Tk()
window.title('my window')
window.geometry('300x100')
window.columnconfigure(0, weight=1)
window.columnconfigure(1, weight=2)
window.rowconfigure(0, weight=1)

label1 = tk.Label(window,text=&quot;Username:&quot;, anchor=tk.E)
label1.grid(row=0,column=0,sticky=tk.SE)
user = tk.Entry(window, width=16, justify=tk.RIGHT)
user.grid(row=0,column=1,sticky=tk.SW)

label2 = tk.Label(window,text=&quot;Password:&quot;, anchor=tk.E)
label2.grid(row=1,column=0,sticky=tk.NE)
passwd = tk.Entry(window, width=16,show='*', justify=tk.RIGHT)
passwd.grid(row=1,column=1,sticky=tk.NW)

window.mainloop()
</code></pre>

<p>运行结果：</p>

<p><img src="/images/2017-12-18/2017-12-18_11.png" alt="" /></p>

<p>有时我们需要检查输入的文本是否合法，这需要定义一个检测函数，并设置调用它的时间，具体步骤：</p>

<ol>
<li>定义一个回调函数，负责检查输入的内容，如果合法就返回 True ，否则返回 False</li>
<li>用 <code>w.register(function)</code> 方法将回掉函数封装为 Tcl ，它会返回一个字符串，用它设置 validatecommand</li>
<li>设置 validate ，声明调用回掉函数的时机，常用从选项有：

<ul>
<li>&lsquo;focus&rsquo; ，输入框获得或者失去焦点时</li>
<li>&lsquo;focusin&rsquo; ，输入框获得焦点时</li>
<li>&lsquo;focusout&rsquo; ，输入框失去焦点时</li>
<li>&lsquo;key&rsquo; ，内容改变时</li>
<li>&lsquo;all&rsquo; ，以上任何情况发生时</li>
<li>&lsquo;none&rsquo; ，关闭内容检查，这是默认值</li>
</ul></li>
</ol>

<h3 id="3-4-框架">3.4. 框架</h3>

<p>框架是其他控件的容器，顶层窗口本质上就是一个框架，默认情况下，框架会紧紧的包裹它的控件，它的原型：</p>

<pre><code>w = Frame(parent, option, ...)
</code></pre>

<p>常用属性：</p>

<ul>
<li>bg or background  ，背景颜色</li>
<li>bd or borderwidth  ，边框宽度，默认是 0</li>
<li>width ，框架的宽度， <code>w.grid_propagate(0)</code>  时有效</li>
<li>height ，框架的高度，<code>w.grid_propagate(0)</code>  时有效</li>
<li>padx ，在框架与控件之间的横向间距，单位是像素</li>
<li>pady ，在框架与控件之间的纵向间距</li>
<li>relief ，3D 样式，默认情况下，框架是完全隐形的 relief=tk.FLAT，可选四个值：tk.GROOVE(边框突出)，tk.RIDGE(边框凹陷)，tk.SUNKEN(整体凹陷)，tk.RAISED(整体突出)，边框宽度由 borderwidth 决定</li>
</ul>

<p>下面是一个例程：</p>

<pre><code>import tkinter as tk

window = tk.Tk()
window.title('my window')
window.geometry('200x100')
window.columnconfigure(0, weight=1)
window.rowconfigure(0, weight=1)

frame = tk.Frame(window,height=50,width=100,relief=tk.GROOVE,bd=5)
frame.grid_propagate(0)
frame.grid()

label = tk.Label(frame, text=&quot;Label&quot;)
label.grid()

window.mainloop()
</code></pre>

<p>运行结果：</p>

<p><img src="/images/2017-12-18/2017-12-18_12.png" alt="" /></p>

<h3 id="3-5-标签框架">3.5. 标签框架</h3>

<p>LabelFrame 控件是带有标签的框架，原型：</p>

<pre><code>w = tk.LabelFrame(parent, option, ...)
</code></pre>

<p>常用属性：</p>

<ul>
<li>bg or background  ，背景颜色</li>
<li>bd or borderwidth  ，边框宽度，默认是 2</li>
<li>width ，框架的宽度， <code>w.grid_propagate(0)</code>  时有效</li>
<li>height ，框架的高度，<code>w.grid_propagate(0)</code>  时有效</li>
<li>labelwidget ，可以在标签中插入任何控件，代替原来的文本</li>
<li>text ，标签中的文字</li>

<li><p>labelanchor ，标签在框架上的位置，默认值是 &lsquo;nw&rsquo; ，可选值：</p>

<p><img src="./_image/2017-12-21-10-35-09.png" alt="" /></p></li>

<li><p>padx=N ，在框架与控件之间，横向添加 N 个像素</p></li>

<li><p>pady=N ，在框架与控件之间，纵向添加 N 个像素</p></li>

<li><p>relief ，3D 样式，默认情况下，默认值是 tk.GROOVE，可选四个值：tk.GROOVE(边框突出)，tk.RIDGE(边框凹陷)，tk.SUNKEN(整体凹陷)，tk.RAISED(整体突出)，边框宽度由 borderwidth 决定</p></li>
</ul>

<p>例程：</p>

<pre><code>import tkinter as tk

window = tk.Tk()
window.title('my window')
window.minsize(width=300,height=150)
window.columnconfigure(0, weight=1)
window.rowconfigure(0, weight=1)

login = tk.LabelFrame(window,text=&quot;Login&quot;,labelanchor='n',padx=10,pady=10)
login.grid()

label1 = tk.Label(login,text=&quot;Username:&quot;, anchor=tk.E)
label1.grid(row=0,column=0,sticky=tk.SE)
user = tk.Entry(login, width=16, justify=tk.RIGHT)
user.grid(row=0,column=1,sticky=tk.SW)

label2 = tk.Label(login,text=&quot;Password:&quot;, anchor=tk.E)
label2.grid(row=1,column=0,sticky=tk.NE)
passwd = tk.Entry(login, width=16,show='*', justify=tk.RIGHT)
passwd.grid(row=1,column=1,sticky=tk.NW)

window.mainloop()
</code></pre>

<p>运行结果：</p>

<p><img src="/images/2017-12-18/2017-12-18_13.png" alt="" /></p>

<h3 id="3-6-菜单">3.6. 菜单</h3>

<h2 id="4-顶层窗口">4. 顶层窗口</h2>

<p><code>Tk()</code> 是由 root 新建的顶层窗口，如果要新建其他窗口，需要调用 <code>.Toplevel()</code> 方法：</p>

<pre><code>w = tk.Toplevel(option, ...)
</code></pre>

<h3 id="4-1-常用属性">4.1. 常用属性</h3>

<ul>
<li>bg or background ，背景颜色</li>
<li>bd or borderwidth  ，边框宽度，默认是 0</li>
<li>menu ，为该属性传递一个 menu 控件的实例，会为窗口添加一个菜单栏，如果是 Windows 或者 Unix 系统，菜单栏会出现在串口的顶端，如果是 MacOS ，菜单栏会出现在屏幕顶端</li>
</ul>

<h3 id="4-2-常用方法">4.2. 常用方法</h3>

<ul>
<li>.maxsize(width=None, height=None) ，设置窗口的最大尺寸。</li>
<li>.minsize(width=None, height=None) ，设置窗口的最小尺寸。</li>
<li>.title(text=None) ，设置窗口标题。</li>
<li>.withdraw() ，隐藏窗口。</li>
<li>.geometry(newGeometry=None) ，设置窗口的尺寸，参数 newGeometry 是一个几何字符串。</li>
</ul>

<h2 id="5-通用方法">5. 通用方法</h2>

<p>下面是每个控件都支持的方法。</p>

<ul>
<li>w.mainloop() ，主循环，处理各种事件，通常在所有静态控件新建完毕后调用，</li>
<li>w.quit() ，结束主循环 <code>.mainloop()</code> ，程序退出</li>
<li>w.bind(sequence=None, func=None, add=None) ，将当前控件上发生的事件与某些函数绑定，sequence 是描述事件的字符串</li>
<li>w.bind_all(sequence=None, func=None, add=None)，将当前应用上所有控件发生的事件与某写函数绑定</li>
<li>w.bind_class(className, sequence=None, func=None, add=None) ，将某一类控件发生的事件与某些函数绑定，className 是控件类的名称，比如 &lsquo;Button&rsquo;</li>
<li>w.winfo_screenheight() ，返回屏幕垂直方向的分辨率</li>
<li>w.winfo_screenwidth() ，返回屏幕水平方向的分辨率</li>
<li>w.winfo_children() ，返回一个包含所有子控件的列表，从低到高排序</li>
<li>w.configure(option=value, &hellip;) ，设置一个或者多个属性</li>
</ul>

<h2 id="6-标准属性">6. 标准属性</h2>

<h3 id="6-1-坐标">6.1. 坐标</h3>

<p>Tkinter 的坐标系以左上角为原点，横轴是 x ：</p>

<p><img src="/images/2017-12-18/2017-12-18_14.png" alt="" /></p>

<p>Tkinter 还定义了一些常量，用于控制相对位置，比如标签内文字的对齐方向等，下面是这些常量的示意图：</p>

<p><img src="/images/2017-12-18/2017-12-18_15.png" alt="" /></p>

<h3 id="6-2-单位">6.2. 单位</h3>

<p>许多控件的长度、宽度、或者其他尺寸的单位可以是像素、字符，也可以用其他单位描述，只需在数字的后面跟上单位即可：</p>

<table>
<thead>
<tr>
<th>单位</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>c</td>
<td>厘米</td>
</tr>

<tr>
<td>i</td>
<td>英寸</td>
</tr>

<tr>
<td>m</td>
<td>毫米</td>
</tr>

<tr>
<td>p</td>
<td>打印机的点</td>
</tr>
</tbody>
</table>

<h3 id="6-3-颜色">6.3. 颜色</h3>

<p>Tkinter 中的颜色可以用 RGB 字符串表示：</p>

<table>
<thead>
<tr>
<th>字符串</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>#rgb</td>
<td>每种颜色占四位</td>
</tr>

<tr>
<td>#rrggbb</td>
<td>每种颜色占八位</td>
</tr>

<tr>
<td>#rrrgggbbb</td>
<td>每种颜色占十二位</td>
</tr>
</tbody>
</table>

<p>比如 &lsquo;#FFF&rsquo; 是白色，&rsquo;#000000&rsquo; 是黑色，&rsquo;#FF0000&rsquo; 是红色。还可以使用已经定义的标准颜色名称，比如 &lsquo;white&rsquo; ， &lsquo;black&rsquo; ， &lsquo;red&rsquo; ， &lsquo;green&rsquo; ， &lsquo;blue&rsquo; ， &lsquo;cyan&rsquo; ， &lsquo;yellow&rsquo; 和 &lsquo;magenta&rsquo; 。</p>

<h3 id="6-4-几何字符串">6.4. 几何字符串</h3>

<p>几何字符串是描述顶层窗口大小和位置的标准方法，通常的格式是 <code>'wxh±x±y'</code>，由三个部分组成：</p>

<ul>
<li>w 和 h 分别表示宽和高，单位是像素，用 x 连接，这个部分是必须的</li>
<li>如果后面跟着 +x ，表示窗口的左边框距离屏幕左边框 x 个像素，如果是 -x ，表示窗口的左边框超出屏幕左边框 x 个像素</li>
<li>如果后面还正常 +y ，表示窗口的上边框距离屏幕上边框 y 个像素，如果是 -y ，表示窗口的上边框超出屏幕上边框 y 个像素</li>
</ul>

<h2 id="7-控制变量">7. 控制变量</h2>

<p>Tkinter 的控制变量是一种特定的对象，它的行为类似 Python 的普通变量，就是值的容器。它的特殊之处是可以由一组控件共享，如果某个控制变量 c 调用 <code>c.set()</code> 方法改变了自己的值，那么所有使用 c 的控件都会自动更新。控制变量的作用是保存控件上的某些值。控制变量有三种：</p>

<pre><code>v = tk.DoubleVar()   # Holds a float; default value 0.0
v = tk.IntVar()      # Holds an int; default value 0
v = tk.StringVar()   # Holds a string; default value ''
</code></pre>

<p>控制变量有两个方法：</p>

<ul>
<li>.get() ，返回变量的值</li>
<li>.set(value) ，设置变量的值</li>
</ul>

<p>用到控制变量的控件包括：</p>

<table>
<thead>
<tr>
<th>控件</th>
<th>属性</th>
<th>类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>Button</td>
<td>textvariable</td>
<td>StringVar</td>
</tr>

<tr>
<td>Entry</td>
<td>textvariable</td>
<td>StringVar</td>
</tr>

<tr>
<td>Label</td>
<td>textvariable</td>
<td>StringVar</td>
</tr>

<tr>
<td>Checkbutton</td>
<td>variable</td>
<td>IntVar</td>
</tr>

<tr>
<td>Menubutton</td>
<td>textvariable</td>
<td>StringVar</td>
</tr>
</tbody>
</table>

<h2 id="8-焦点-引导键盘输入">8. 焦点：引导键盘输入</h2>

<p>某个控件被设为焦点（focus），意味着键盘输入会直接作用于这个控件。Tkinter 可以设置某个控件为默认焦点，也可以设置各种控件的焦点顺序，也就是用 Tab 键切换时的顺序。</p>

<h2 id="9-事件-对刺激做出反应">9. 事件：对刺激做出反应</h2>

<p>前面我们都在描述怎么绘制图形界面，下面我们讨论如今将控件与后台功能联系起来，让用户的操作得到实际的反馈。</p>

<p>事件（event）就是应用程序上发生的事情，比如键盘输入、鼠标单击或者双击，应用程序应该对此作出反应。很多控件都有一些内置的行为，比如按钮按下时会调用 command 指向的函数。Tkinker 允许为一个或者多个事件定义相应的处理方法，有三中绑定级别：</p>

<ol>
<li>单独绑定，为一个控件上可能发生的某些事件绑定一个方法：<code>w.bind(sequence=None, func=None, add=None)</code> ，比如在 canvas 控件里为 PageUp 按键绑定一个翻页功能的方法。</li>
<li>分类绑定，为所用同类控件上可能发生的某些事件绑定一个方法：<code>w.bind_class(className, sequence=None, func=None, add=None)</code> ，比如双击鼠标时所有的按钮同时按下。</li>
<li>应用绑定，为应用上所有控件可能发生的某些事件绑定一个犯法：<code>w.bind_all(sequence=None, func=None, add=None)</code> 。</li>
</ol>

<p>Tkinter 用事件序列字符串（sequence） 的方式描述事件，一个字符串可以描述一个或者多个事件，字符串遵循如下格式：</p>

<pre><code>&lt;[modifier-]...type[-detail]&gt;
</code></pre>

<ul>
<li>字符串由尖括号 &lt;&gt; 包围</li>
<li>type 是必选项，指事件类型，例如按键，鼠标等</li>
<li>modifier 是可选项，可以连续设置多个，与 type 组成混合体来描述组合键，例如按下 shift 的时候单击鼠标</li>
<li>detail 是可选项，描述具体是哪个键盘按键、哪个鼠标按键。</li>
</ul>

<p>下面是三个例子：</p>

<table>
<thead>
<tr>
<th>sequence</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>Button-1</td>
<td>按下鼠标左键</td>
</tr>

<tr>
<td>KeyPress-H</td>
<td>按下键盘上的 H 键</td>
</tr>

<tr>
<td>Control-Shift-KeyPress-H</td>
<td>按下 control-shift-H 组合键</td>
</tr>
</tbody>
</table>

<h3 id="9-1-type">9.1. type</h3>

<p>常用的事件类型：</p>

<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>Activate</td>
<td>36</td>
<td>控件被激活，这个事件是由控件的 state 属性变化引起的</td>
</tr>

<tr>
<td>Button</td>
<td>4</td>
<td>按下鼠标，具体哪个键被按下由 detail 决定，按了几次由 modifier 决定</td>
</tr>

<tr>
<td>ButtonRelease</td>
<td>5</td>
<td>松开鼠标，通常松开时触发事件比按下时更好</td>
</tr>

<tr>
<td>Configure</td>
<td>22</td>
<td>控件的大小发生改变</td>
</tr>

<tr>
<td>Deactivate</td>
<td>37</td>
<td>控件的状态由激活变为不可用（灰色），这个事件是由控件的 state 属性变化引起的</td>
</tr>

<tr>
<td>Destroy</td>
<td>17</td>
<td>控件被毁灭</td>
</tr>

<tr>
<td>Enter</td>
<td>7</td>
<td>鼠标移动到了控件上</td>
</tr>

<tr>
<td>Expose</td>
<td>12</td>
<td>控件从被其他窗口遮挡的状态变为可见时</td>
</tr>

<tr>
<td>FocusIn</td>
<td>9</td>
<td>控件获得输入焦点时，这个事件可以由程序内部产生，比如调用 <code>.focus_set()</code>  时</td>
</tr>

<tr>
<td>FocusOut</td>
<td>10</td>
<td>输入焦点从控件上移开时，这个事件可以由程序内部产生</td>
</tr>

<tr>
<td>KeyPress</td>
<td>2</td>
<td>按下键盘按键，具体哪个键被按下由 detail 决定，按了几次由 modifier 决定</td>
</tr>

<tr>
<td>KeyRelease</td>
<td>3</td>
<td>松开键盘按键，</td>
</tr>

<tr>
<td>Leave</td>
<td>8</td>
<td>鼠标从控件上移开</td>
</tr>

<tr>
<td>Map</td>
<td>19</td>
<td>控件变为可见时，比如调用 <code>.grid()</code> 方法</td>
</tr>

<tr>
<td>Motion</td>
<td>6</td>
<td>在控件内移动鼠标</td>
</tr>

<tr>
<td>MouseWheel</td>
<td>38</td>
<td>上下移动鼠标滚轮，只在 Windows 和 macOS 下有效， Linux 不支持</td>
</tr>

<tr>
<td>Unmap</td>
<td>18</td>
<td>控件变为不可见状态，比如调用 <code>.grid_remove()</code> 方法</td>
</tr>

<tr>
<td>Visibility</td>
<td>15</td>
<td>应用程序窗口的一部分在屏幕上变为可见</td>
</tr>
</tbody>
</table>

<h3 id="9-2-modifier">9.2. modifier</h3>

<p>所有可选的 modifier 名称：</p>

<table>
<thead>
<tr>
<th>modifier</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>Alt</td>
<td>按住 Alt 键</td>
</tr>

<tr>
<td>Any</td>
<td>表示任意的，用于概况一类事件，比如 &lsquo;<Any-KeyPress>&rsquo; 表示按下任意按键</td>
</tr>

<tr>
<td>Control</td>
<td>按住 control 键</td>
</tr>

<tr>
<td>Double</td>
<td>双击，即很短的时间内连续发生两次，例如 &lsquo;<Double-Button-1>&rsquo; 表示双击鼠标左键</td>
</tr>

<tr>
<td>Lock</td>
<td>按下 shift lock 键</td>
</tr>

<tr>
<td>Shift</td>
<td>按住 shift 键</td>
</tr>

<tr>
<td>Triple</td>
<td>三击，即很短的时间内连续发生三次</td>
</tr>
</tbody>
</table>

<h3 id="9-3-detail">9.3. detail</h3>

<p>对于鼠标事件，1 表示鼠标左键，3 表示鼠标右键。对于键盘事件，Tkinter 提供了多种方式识别按键，这几种方式都是 Event 类支持的属性 ：</p>

<ul>
<li>.keysym 表示按键的符号，有的按键有两个符号</li>
<li>.keycode 表示按键的编码，但是这种编码没有区分同一按键上的不同符号，比如小键盘的数字 2 (KP_2) 和向下箭头 (KP_Down) 是同一个按键，编码都是 88 ，也无法区分大小写，所以 a 和 A 的编码是一样的</li>
<li>.keysym_num 表示与按键符号相对应的编码</li>
</ul>

<p>下表是美式 101-key 键盘通用字符集的部分符号：</p>

<table>
<thead>
<tr>
<th>.keysym</th>
<th>.keycode</th>
<th>.keysym_num</th>
<th>Key</th>
</tr>
</thead>

<tbody>
<tr>
<td>Alt_L</td>
<td>64</td>
<td>65513</td>
<td>The left-hand alt key</td>
</tr>

<tr>
<td>Alt_R</td>
<td>113</td>
<td>65514</td>
<td>The right-hand alt key</td>
</tr>

<tr>
<td>BackSpace</td>
<td>22</td>
<td>65288</td>
<td>backspace</td>
</tr>

<tr>
<td>Cancel</td>
<td>110</td>
<td>65387</td>
<td>break</td>
</tr>

<tr>
<td>Caps_Lock</td>
<td>66</td>
<td>65549</td>
<td>CapsLock</td>
</tr>

<tr>
<td>Control_L</td>
<td>37</td>
<td>65507</td>
<td>The left-hand control key</td>
</tr>

<tr>
<td>Control_R</td>
<td>109</td>
<td>65508</td>
<td>The right-hand control key</td>
</tr>

<tr>
<td>Delete</td>
<td>107</td>
<td>65535</td>
<td>Delete</td>
</tr>

<tr>
<td>Down</td>
<td>104</td>
<td>65364</td>
<td>↓</td>
</tr>

<tr>
<td>End</td>
<td>103</td>
<td>65367</td>
<td>end</td>
</tr>

<tr>
<td>Escape</td>
<td>9</td>
<td>65307</td>
<td>esc</td>
</tr>

<tr>
<td>Execute</td>
<td>111</td>
<td>65378</td>
<td>SysReq</td>
</tr>

<tr>
<td>F1</td>
<td>67</td>
<td>65470</td>
<td>Function key F1</td>
</tr>

<tr>
<td>F2</td>
<td>68</td>
<td>65471</td>
<td>Function key F2</td>
</tr>

<tr>
<td>Fi</td>
<td>66+i</td>
<td>65469+i</td>
<td>Function key Fi</td>
</tr>

<tr>
<td>F12</td>
<td>96</td>
<td>65481</td>
<td>Function key F12</td>
</tr>

<tr>
<td>Home</td>
<td>97</td>
<td>65360</td>
<td>home</td>
</tr>

<tr>
<td>Insert</td>
<td>106</td>
<td>65379</td>
<td>insert</td>
</tr>

<tr>
<td>Left</td>
<td>100</td>
<td>65361</td>
<td>←</td>
</tr>

<tr>
<td>Linefeed</td>
<td>54</td>
<td>106</td>
<td>Linefeed (control-J)</td>
</tr>

<tr>
<td>KP_0</td>
<td>90</td>
<td>65438</td>
<td>0 on the keypad</td>
</tr>

<tr>
<td>KP_1</td>
<td>87</td>
<td>65436</td>
<td>1 on the keypad</td>
</tr>

<tr>
<td>KP_2</td>
<td>88</td>
<td>65433</td>
<td>2 on the keypad</td>
</tr>

<tr>
<td>KP_3</td>
<td>89</td>
<td>65435</td>
<td>3 on the keypad</td>
</tr>

<tr>
<td>KP_4</td>
<td>83</td>
<td>65430</td>
<td>4 on the keypad</td>
</tr>

<tr>
<td>KP_5</td>
<td>84</td>
<td>65437</td>
<td>5 on the keypad</td>
</tr>

<tr>
<td>KP_6</td>
<td>85</td>
<td>65432</td>
<td>6 on the keypad</td>
</tr>

<tr>
<td>KP_7</td>
<td>79</td>
<td>65429</td>
<td>7 on the keypad</td>
</tr>

<tr>
<td>KP_8</td>
<td>80</td>
<td>65431</td>
<td>8 on the keypad</td>
</tr>

<tr>
<td>KP_9</td>
<td>81</td>
<td>65434</td>
<td>9 on the keypad</td>
</tr>

<tr>
<td>KP_Add</td>
<td>86</td>
<td>65451</td>
<td>+ on the keypad</td>
</tr>

<tr>
<td>KP_Begin</td>
<td>84</td>
<td>65437</td>
<td>The center key (same key as 5) on the keypad</td>
</tr>

<tr>
<td>KP_Decimal</td>
<td>91</td>
<td>65439</td>
<td>Decimal (.) on the keypad</td>
</tr>

<tr>
<td>KP_Delete</td>
<td>91</td>
<td>65439</td>
<td>delete on the keypad</td>
</tr>

<tr>
<td>KP_Divide</td>
<td>112</td>
<td>65455</td>
<td>/ on the keypad</td>
</tr>

<tr>
<td>KP_Down</td>
<td>88</td>
<td>65433</td>
<td>↓ on the keypad</td>
</tr>

<tr>
<td>KP_End</td>
<td>87</td>
<td>65436</td>
<td>end on the keypad</td>
</tr>

<tr>
<td>KP_Enter</td>
<td>108</td>
<td>65421</td>
<td>enter on the keypad</td>
</tr>

<tr>
<td>KP_Home</td>
<td>79</td>
<td>65429</td>
<td>home on the keypad</td>
</tr>

<tr>
<td>KP_Insert</td>
<td>90</td>
<td>65438</td>
<td>insert on the keypad</td>
</tr>

<tr>
<td>KP_Left</td>
<td>83</td>
<td>65430</td>
<td>← on the keypad</td>
</tr>

<tr>
<td>KP_Multiply</td>
<td>63</td>
<td>65450</td>
<td>× on the keypad</td>
</tr>

<tr>
<td>KP_Next</td>
<td>89</td>
<td>65435</td>
<td>PageDown on the keypad</td>
</tr>

<tr>
<td>KP_Prior</td>
<td>81</td>
<td>65434</td>
<td>PageUp on the keypad</td>
</tr>

<tr>
<td>KP_Right</td>
<td>85</td>
<td>65432</td>
<td>→ on the keypad</td>
</tr>

<tr>
<td>KP_Subtract</td>
<td>82</td>
<td>65453</td>
<td>- on the keypad</td>
</tr>

<tr>
<td>KP_Up</td>
<td>80</td>
<td>65431</td>
<td>↑ on the keypad</td>
</tr>

<tr>
<td>Next</td>
<td>105</td>
<td>65366</td>
<td>PageDown</td>
</tr>

<tr>
<td>Num_Lock</td>
<td>77</td>
<td>65407</td>
<td>NumLock</td>
</tr>

<tr>
<td>Pause</td>
<td>110</td>
<td>65299</td>
<td>pause</td>
</tr>

<tr>
<td>Print</td>
<td>111</td>
<td>65377</td>
<td>PrintScrn</td>
</tr>

<tr>
<td>Prior</td>
<td>99</td>
<td>65365</td>
<td>PageUp</td>
</tr>

<tr>
<td>Return</td>
<td>36</td>
<td>65293</td>
<td>The enter key (control-M). The name Enter refers to a mouse-related event, not a keypress; see Section 54, “Events”</td>
</tr>

<tr>
<td>Right</td>
<td>102</td>
<td>65363</td>
<td>→</td>
</tr>

<tr>
<td>Scroll_Lock</td>
<td>78</td>
<td>65300</td>
<td>ScrollLock</td>
</tr>

<tr>
<td>Shift_L</td>
<td>50</td>
<td>65505</td>
<td>The left-hand shift key</td>
</tr>

<tr>
<td>Shift_R</td>
<td>62</td>
<td>65506</td>
<td>The right-hand shift key</td>
</tr>

<tr>
<td>Tab</td>
<td>23</td>
<td>65289</td>
<td>The tab key</td>
</tr>

<tr>
<td>Up</td>
<td>98</td>
<td>65362</td>
<td>↑</td>
</tr>
</tbody>
</table>

<h2 id="10-ttk-主题控件">10. ttk : 主题控件</h2>

<p>从 Tk 8.5 开始，正式加入了 ttk 模块，这个模块可以替代大部分 Tkinter 原有的机制，而且带来了很多优势：</p>

<ul>
<li>在 Tk 8.5 以前，开发者经常抱怨的就是 Tkinter 的 UI 风格无法适应操作系统，显得很难看。ttk 可以在自适应不同的操作系统 UI 风格，无需修改程序代码。</li>
<li>原有的控件都有一个  ttk 的版本，还增加了一些新的控件</li>
<li>带来了更加简化和易于操作的控件属性。</li>
</ul>

<p>推荐使用如下方式导入 ttk 模块：</p>

<pre><code>from tkinter import ttk
</code></pre>

<p>这样的话，ttk.Label 就表示 Label 控件。</p>

<h3 id="10-1-ttk-button">10.1. ttk.Button</h3>

<p>按钮控件，原型：</p>

<pre><code>w = ttk.Button(parent, option=value, ...)
</code></pre>

<p>常用属性：</p>

<ul>
<li>command ，按下按钮是调用的函数</li>
<li>image ，设置按钮上显示的图片</li>
<li>text ，设置按钮上显示的文字</li>
<li>compound ，如果同时设置了 image 和 text ，该属性设置了 image 相对于 text 的位置，有四个可选值：tk.TOP (image 在 text 上面) ，tk.BOTTOM (image 在 text 下面) ，tk.LEFT (image 在 text 左边) ，tk.RIGHT (image 在 text 右边)</li>
<li>textvariable ，控制变量 StringVal</li>
<li>width ，按钮的宽度，单位是字符个数，如果按钮显示的是图片，则单位是像素</li>
<li>underline ，设置一个数字 n ，按钮上的第 n 个字符会显示一条下划线</li>
<li>style ，原 Tkinter 的样式属性都被这个属性代替了</li>
</ul>

<p>出来通用方法，它还有一个自己的方法：</p>

<ul>
<li>.invoke() ，调用 command 指定的函数。</li>
</ul>

<h3 id="10-2-ttk-entry">10.2. ttk.Entry</h3>

<p>输入框，函数原型：</p>

<pre><code>w = ttk.Entry(parent, option=value, ...)
</code></pre>

<p>常用属性：</p>

<ul>
<li>width ，输入框能够容纳的字符数，默认是 20</li>
<li>show，默认情况下，输入的字符会直接显示，如果是密码，需要隐藏，可以要求输入的字符都显示为星号： <code>show='*'</code></li>
<li>justify ，输入框内文本的对齐方式，默认是左对齐 justify=tk.LEFT ，还可选 tk.CENTER 和 tk.RIGHT</li>
<li>validate ，设置检查输入框内容的时机</li>
<li>validatecommand ，设置一个回调函数，负责检查输入框的内容</li>
<li>textvariable ，为该属性设置一个控制变量 StringVar 类的实例，就可以用 v.get() 方法取回输入框中内容，或者用 v.set(value) 设置，v 就是这个实例</li>
<li>style ，原 Tkinter 的样式属性都被这个属性代替了</li>
</ul>

<p>ttk.Entry  支持所有 ttk 的通用方法和 tk.Entry 的方法。</p>

<h3 id="10-3-ttk-combobox">10.3. ttk.Combobox</h3>

<p>带下拉菜单的输入框，函数原型：</p>

<pre><code>w = ttk.Combobox(parent, option=value, ...)
</code></pre>

<p>常用属性：</p>

<ul>
<li>exportselection ，默认情况下，选中的内容会自动复制到剪贴板，设置 <code>exportselection=0</code> 可以关闭这个特性</li>
<li>height ，设置下拉菜单中选项的最大行数，默认是 20 ，如果超过这个值，会自动出现滚动条</li>
<li>justify ，输入框内文本的对齐方式，默认是左对齐 justify=tk.LEFT ，还可选 tk.CENTER 和 tk.RIGHT</li>
<li>postcommand ，设置一个回调函数，当用户点击下拉菜单是会调用，可用于修改 values 属性</li>
<li>textvariable ，为该属性设置一个控制变量 StringVar 类的实例，就可以用 v.get() 方法取回输入框中内容，或者用 v.set(value) 设置，v 就是这个实例</li>
<li>validate ，设置检查输入框内容的时机</li>
<li>validatecommand ，设置一个回调函数，负责检查输入框的内容</li>
<li>values，设置一个字符串序列，作为下拉菜单中的选项</li>
<li>width ，输入框能够容纳的字符数，默认是 20</li>
<li>style ，原 Tkinter 的样式属性都被这个属性代替了</li>
</ul>

<p>ttk.Combobox 支持所有 ttk 的通用方法和 tk.Entry 的方法，此外还支持：</p>

<ul>
<li>.current([index]) ,</li>
<li>.set(value) ，设置空间输入框中的值为 value</li>
</ul>

<p>ttk.Combobox 的状态会显示不同的行为特性。控件状态由通用方法 <code>.instate()</code> 和 <code>.state()</code> 设置。如果控件处于 disabled 状态，用户无法改变控件的内容；如果空间处于 !disabled &amp; readonly 状态，用户可以通过下拉菜单改变空间内容，但不能直接输入。</p>

<h3 id="10-4-ttk-frame">10.4. ttk.Frame</h3>

<p>框架控件，函数原型：</p>

<pre><code>w = ttk.Frame(parent, option=value, ...)
</code></pre>

<h3 id="10-5-ttk-label">10.5. ttk.Label</h3>

<p>标签控件，函数原型：</p>

<pre><code>w = ttk.Label(parent, option=value, ...)
</code></pre>

<h3 id="10-6-ttk-labelframe">10.6. ttk.LabelFrame</h3>

<p>带标签的框架，函数原型：</p>

<pre><code>w = ttk.LabelFrame(parent, option=value, ...)
</code></pre>

<h3 id="10-7-ttk-notebook">10.7. ttk.Notebook</h3>

<p>标签页控件，函数原型：</p>

<pre><code>w = ttk.Notebook(parent, option=value, ...)
</code></pre>

<h3 id="10-8-ttk-menubutton">10.8. ttk.Menubutton</h3>

<p>下拉菜单，函数原型：</p>

<pre><code>w = ttk.Menubutton(parent, option=value, ...)
</code></pre>

<h2 id="11-ttk-的样式和主题">11. ttk 的样式和主题</h2>

<p>绘制 ttk 控件包含三个层面的抽象概念：</p>

<ol>
<li>theme 表示一个应用中所有控件的设计主题</li>
<li>style 描述了一种控件本身的显示方式，一个 theme 是由多种 style 组成的，你可以使用内置的 style ，也可以新建自己的 style 。</li>

<li><p>每个 style 都是有一个或者多个 element 组成的，一个按钮的 style 通常有四个 element ：外边框，聚焦时的颜色变化，内边距，按钮标签（文本或者图片）：</p>

<p><img src="./_image/2017-12-25-13-28-07.png" alt="" /></p></li>
</ol>

<p>下面依次讨论如何寻找、使用和定制这几层样式。</p>

<h3 id="11-1-寻找并使用-theme">11.1. 寻找并使用 theme</h3>

<p>与样式相关的操作都需要新建一个 <code>ttk.Style()</code> 类的实例，例如获取所有可用的 theme 列表：</p>

<pre><code>&gt;&gt;&gt; from tkinter import ttk
&gt;&gt;&gt; s=ttk.Style()
&gt;&gt;&gt; s.theme_names()
('aqua', 'clam', 'alt', 'default', 'classic')
</code></pre>

<p><code>.theme_names()</code> 会返回一个元组，包含了所有可用的 theme 。如果要查看当前默认的 theme ，直接调用 <code>.theme_use()</code> ，在参数里加上 theme 名就可以改变当前的 theme ：</p>

<pre><code>&gt;&gt;&gt; s.theme_use()
'aqua'
&gt;&gt;&gt; s.theme_use('default')
&gt;&gt;&gt; s.theme_use()
'default'
</code></pre>

<h3 id="11-2-使用和定制-style">11.2. 使用和定制 style</h3>

<p>对于一个给定的 theme ，为每一种控件都定义了默认的 style ，本质上是一个类，每个 style 类名就是控件名加上前缀 &ldquo;T&rdquo; ，下表是 ttk 控件对应的 style 名称：</p>

<table>
<thead>
<tr>
<th>Widget class</th>
<th>Style name</th>
</tr>
</thead>

<tbody>
<tr>
<td>Button</td>
<td>TButton</td>
</tr>

<tr>
<td>Checkbutton</td>
<td>TCheckbutton</td>
</tr>

<tr>
<td>Combobox</td>
<td>TCombobox</td>
</tr>

<tr>
<td>Entry</td>
<td>TEntry</td>
</tr>

<tr>
<td>Frame</td>
<td>TFrame</td>
</tr>

<tr>
<td>Label</td>
<td>TLabel</td>
</tr>

<tr>
<td>LabelFrame</td>
<td>TLabelFrame</td>
</tr>

<tr>
<td>Menubutton</td>
<td>TMenubutton</td>
</tr>

<tr>
<td>Notebook</td>
<td>TNotebook</td>
</tr>

<tr>
<td>PanedWindow</td>
<td>TPanedwindow (not TPanedWindow!)</td>
</tr>

<tr>
<td>Progressbar</td>
<td>Horizontal.TProgressbar or Vertical.TProgressbar, depending on the orient option.</td>
</tr>

<tr>
<td>Radiobutton</td>
<td>TRadiobutton</td>
</tr>

<tr>
<td>Scale</td>
<td>Horizontal.TScale or Vertical.TScale, depending on the orient option.</td>
</tr>

<tr>
<td>Scrollbar</td>
<td>Horizontal.TScrollbar or Vertical.TScrollbar, depending on the orient option.</td>
</tr>

<tr>
<td>Separator</td>
<td>TSeparator</td>
</tr>

<tr>
<td>Sizegrip</td>
<td>TSizegrip</td>
</tr>

<tr>
<td>Treeview</td>
<td>Treeview (not TTreview!)</td>
</tr>
</tbody>
</table>

<p>运行时可以调用控件的 <code>.winfo_class()</code> 方法获得当前使用的 style 类名：</p>

<pre><code>&gt;&gt;&gt; b=ttk.Button(None)
&gt;&gt;&gt; b.winfo_class()
'TButton'
</code></pre>

<p>style 类名有两种格式：</p>

<ol>
<li>对应内置的 sytle 都是一个单词，例如 &lsquo;TButton&rsquo; 或者 &lsquo;TFrame&rsquo;</li>
<li>在内置 style 之上新建的 style 采用这样的格式： &lsquo;newName.oldName&rsquo; ，例如为输入日期的 Entry 控件新建一个 style 可以命名为 &lsquo;Date.TEntry&rsquo;</li>
</ol>

<p>每个 style 都定义了一套相应的属性，例如按钮有一个 foreground 属性用于设置按钮上文字的颜色。可以调用 <code>ttk.Style()</code> 类的 <code>.configure()</code> 方法调节这些属性，第一个参数是 style 类名，之后是要修改的属性和相应的值，例如把按钮上的文字改成绿色：</p>

<pre><code>s.configure('TButton', foreground='green')
</code></pre>

<p>这个方法还可以用来新建 style ，第一个参数定义新 style 类的名称 &lsquo;newName.oldName&rsquo; ，例如新建一个 Style ，按钮上的文字是红褐色：</p>

<pre><code>s = ttk.Style()
s.configure('Kim.TButton', foreground='maroon')
</code></pre>

<p>然后就可以用这个新的 style 新建一个按钮：</p>

<pre><code>self.b = ttk.Button(self, text='Friday', style='Kim.TButton',command=self._fridayHandler)
</code></pre>

<p>你甚至可以构建一套多级 style 。例如新建一个名叫 &lsquo;Panic.Kim.TButton&rsquo; 的 style ，它会继承 &lsquo;Kim.TButton&rsquo; 的所有属性，ttk 要使用某个属性时，首先在 &lsquo;Panic.Kim.TButton&rsquo; 寻找，如果没找到，会上溯到 &lsquo;Kim.TButton&rsquo; ，如果还找不到，再上溯到 &lsquo;TButton&rsquo; 中寻找。</p>

<p>还存在一个 root style 叫做 &lsquo;.&rsquo; ，配置这个 style 的某个属性会对所有控件生效。假设我们想要所有的文本都使用  12-point Helvetica 字体，可以这样配置：</p>

<pre><code>s = ttk.Style()
s.configure('.', font=('Helvetica', 12))
</code></pre>

<h3 id="11-3-element">11.3. element</h3>

<p>一个控件是由多种 element 组成的，控件就像一个“空腔”，腔体内的空间由 element 填充。以 classic theme 为例，一个按钮拥有四个同心 element ，从外都内分别是 focus highlight ， border ， padding 和 label 。每个 element 都有一个 &lsquo;sticky&rsquo; 属性，它的作用是告诉这个 element 如何填充当前的腔体，如果一个 element 的 sticky=&lsquo;ew&rsquo; ，意味着这个 element 应该左右方向撑开，紧贴腔体左右边。</p>

<p>大部分内置的 style 使用 layout 概念来组织腔体内的 element ，要获取某个 style 内的 element 显示方式，可以调用 <code>.layout()</code> 方法：</p>

<pre><code>S.layout(styleName)
</code></pre>

<p>该函数返回一个列表，列表内的元素都是描述 element 显示方式的元组，元组的格式是 (eltName, d) ，eltName 是一个字符串， element 的名称，d 是一个字典，描述 element 显示方式的一些属性，比如：</p>

<ul>
<li>&lsquo;sticky&rsquo; ，属性取值是一个字符串，描述当前 element 在相对父 element 的位置，可以为空，或者有 &lsquo;n&rsquo; ， &rsquo;s&rsquo; ， &lsquo;e&rsquo; 和 &lsquo;w&rsquo; 四个字符组成，分别代表四个方式的对齐方式</li>
<li>&lsquo;side&rsquo; ，如果当前 element 拥有多个子 element ，该属性的取值定义了这些子 element 的对齐方式，可选 &lsquo;left&rsquo; ， &lsquo;right&rsquo; ， &lsquo;top&rsquo; 或者 &lsquo;bottom&rsquo;</li>
<li>&lsquo;children&rsquo; ，如果当前 element 下还有子 element ，可以使用相同格式的列表描述</li>
</ul>

<p>下面以 classic theme 的按钮控件为例分析它的 Layout：</p>

<pre><code>&gt;&gt;&gt; from tkinter import ttk
&gt;&gt;&gt; s = ttk.Style()
&gt;&gt;&gt; s.theme_use('classic')
&gt;&gt;&gt; b = ttk.Button(None,text=&quot;Yo&quot;)
&gt;&gt;&gt; bClass = b.winfo_class()
&gt;&gt;&gt; bClass
'TButton'
&gt;&gt;&gt; layout = s.layout('TButton')
&gt;&gt;&gt; layout
[('Button.highlight', {'sticky': 'nswe', 'children': [('Button.border', {'sticky': 'nswe', 'border': '1', 'children': [('Button.padding', {'sticky': 'nswe', 'children': [('Button.label', {'sticky': 'nswe'})]})]})]})]
</code></pre>

<p>这里我们新建了一个按钮，但是没有显示出来，要让它在窗口显示需要调用 <code>.grid()</code> 方法。Button 控件的 style 是 TButton ，它的 element 分为四层：</p>

<pre><code>[('Button.highlight', {'sticky': 'nswe', 'children': 
    [('Button.border', {'sticky': 'nswe', 'border': '1', 'children': 
        [('Button.padding', {'sticky': 'nswe', 'children': 
            [('Button.label', {'sticky': 'nswe'})]}
        )]}
    )]}
)]
</code></pre>

<p>有外到内：</p>

<ol>
<li>最外层是 highlight ，sticky=&lsquo;nswe&rsquo; 表示四个方向都撑满</li>
<li>第二层是 border ，它有一个 border=&lsquo;1&rsquo; 的属性，表示边框宽度一个像素</li>
<li>第三层是 padding ，表示内边距，默认是 0</li>
<li>最里面是 label ，显示按钮上的文字或者图片，也是四个方向撑满</li>
</ol>

<p>每个 element 都由一个字典描述各自的属性，这些属性的名字都是沿用自 Tkinter ，都可以用 <code>s.configure()</code> 方法配置。要获取这些属性的名字可以调用：</p>

<pre><code>S.element_options(elementName)
</code></pre>

<p>函数返回一个列表：</p>

<pre><code>&gt;&gt;&gt; d = s.element_options('Button.highlight')
&gt;&gt;&gt; d
('highlightcolor', 'highlightthickness')
</code></pre>

<p>要找出某个属性的值可以调用：</p>

<pre><code>s.lookup(layoutName, optName)
</code></pre>

<p>继续前面的例子：</p>

<pre><code>&gt;&gt;&gt; s.lookup('Button.highlight', 'highlightthickness')
1
&gt;&gt;&gt; s.lookup('Button.highlight', 'highlightcolor')
'#d9d9d9'
&gt;&gt;&gt; s.element_options('Button.label')
('compound', 'space', 'text', 'font', 'foreground', 'underline', 'width', 'anchor', 'justify', 'wraplength', 'embossed', 'image', 'stipple', 'background')
&gt;&gt;&gt; s.lookup('Button.label', 'foreground')
'black'
</code></pre>

<h2 id="12-ttk-的通用方法">12. ttk 的通用方法</h2>

<ul>
<li>w.cget(option) ，返回某个属性的值</li>

<li><p>w.configure(option=value, &hellip;) ，设置某个属性的值，如果没有参数，它会返回一个字典，记录了该控件所有属性，属性的值保持在一个元组，格式 (name, dbName, dbClass, default, current)，例如：</p>

<pre><code>&gt;&gt;&gt; from tkinter import ttk
&gt;&gt;&gt; b=ttk.Button(text=&quot;Yo&quot;)
&gt;&gt;&gt; b.configure()
{'takefocus': ('takefocus', 'takeFocus', 'TakeFocus', '', 'ttk::takefocus'), 'command': ('command', 'command', 'Command', '', ''), 'default': ('default', 'default', 'Default', &lt;index object: 'normal'&gt;, &lt;index object: 'normal'&gt;), 'text': ('text', 'text', 'Text', '', 'Yo'), 'textvariable': ('textvariable', 'textVariable', 'Variable', '', ''), 'underline': ('underline', 'underline', 'Underline', -1, -1), 'width': ('width', 'width', 'Width', '', ''), 'image': ('image', 'image', 'Image', '', ''), 'compound': ('compound', 'compound', 'Compound', &lt;index object: 'none'&gt;, &lt;index object: 'none'&gt;), 'padding': ('padding', 'padding', 'Pad', '', ''), 'state': ('state', 'state', 'State', &lt;index object: 'normal'&gt;, &lt;index object: 'normal'&gt;), 'cursor': ('cursor', 'cursor', 'Cursor', '', ''), 'style': ('style', 'style', 'Style', '', ''), 'class': ('class', '', '', '', '')}
</code></pre></li>

<li><p>.state(stateSpec=None) ，获取、设置或者清空当前的状态</p></li>
</ul>

<h2 id="13-ttk-的控件状态">13. ttk 的控件状态</h2>

<p>ttk 的控件有一套 state flags，用于指示控件的状态，这些状态都可以编程打开或者关闭，下表是各种状态的含义：</p>

<table>
<thead>
<tr>
<th>state</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>active</td>
<td>鼠标指针正处于控件内</td>
</tr>

<tr>
<td>alternate</td>
<td>该状态为应用程序保留</td>
</tr>

<tr>
<td>background</td>
<td>Under Windows or MacOS, the widget is located in a window that is not the foreground window.</td>
</tr>

<tr>
<td>disabled</td>
<td>禁用控件</td>
</tr>

<tr>
<td>focus</td>
<td>控件处于聚焦状态</td>
</tr>

<tr>
<td>invalid</td>
<td>控件的内容无效</td>
</tr>

<tr>
<td>pressed</td>
<td>控件被按下</td>
</tr>

<tr>
<td>readonly</td>
<td>只读</td>
</tr>

<tr>
<td>selected</td>
<td>控件被选中</td>
</tr>
</tbody>
</table>

<p>很多方法都通过一个 stateSpec 参数来访问 state 。这个参数可以是以下的值：</p>

<ul>
<li>A single state name such as &lsquo;pressed&rsquo;. A ttk.Button widget is in this state, for example, when the mouse cursor is over the button and mouse button 1 is down.</li>
<li>A single state name preceded with an exclamation point (!); this matches the widget state only when that state is off. For example, a stateSpec argument &lsquo;!pressed&rsquo; specifies a widget that is not currently being pressed.</li>
<li>A sequence of state names, or state names preceded by an &lsquo;!&rsquo;. Such a stateSpec matches only when all of its components match. For example, a stateSpec value of (&lsquo;!disabled&rsquo;, &lsquo;focus&rsquo;) matches a widget only when that widget is not disabled and it has focus.</li>
</ul>

<h2 id="14-模块化编程">14. 模块化编程</h2>

<p>前面我们都是在主程序里，用函数一步步新建控件，绘制界面，如果界面很复杂，这种方式就变的非常麻烦，结构也不清晰，难以维护。一个好的编程方法应该模块化的，按界面的布局划分不同的模块，实现不同的类，每个类里集成了模块上的所有控件，实现对控件的操作方法，然后这个模块就可以新建不同的实例，放在不同的位置。通常用户新建的类可以从 tk.Frame 继承，下面是简单的例子：</p>

<pre><code>import tkinter as tk
from tkinter import ttk 

class application(ttk.Frame):     #新建 application 类，继承了 ttk.Frame
    def __init__(self, parent=None):    #初始化函数，根据模块所处的位置设置父类，默认为空
        ttk.Frame.__init__(self, parent)
        self.grid()    #显示这个模块
        self._createWidgets()   #新建模块上的控件
    def _createWidgets(self):
        self.button = ttk.Button(self, text='Quit', command=self.quit)
        self.button.grid()

window = tk.Tk()    #新建一个窗口
window.title('Sample application')
app = application(window)  #在窗口上放一个 application 模块
window.mainloop()
</code></pre>

<h2 id="参考">参考</h2>

<ul>
<li><a href="http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html" target="_blank">Tkinter 8.5 reference: a GUI for Python</a></li>
<li><a href="http://www.tkdocs.com/tutorial/index.html" target="_blank">TkDocs</a></li>
<li><a href="https://pyinstaller.readthedocs.io/en/stable/" target="_blank">pyinstaller Docs</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Linux 编程笔记</title>
            <link>https://shaocheng.li/posts/2017/12/14/</link>
            <pubDate>Thu, 14 Dec 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/12/14/</guid>
            <description>1. sysconfig() sysconfig() 是获取系统运行时配置信息的函数，包括内存、CPU 等。函数声明：
#include &amp;lt;unistd.h&amp;gt; long sysconf(int name);  参数 name 用于指示要获取的信息，通过返回值将结果返回。新建一个 test.c ，获取当前系统的信息：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #define ONE_MB (1024 * 1024) int main() { printf(&amp;quot;The number of processors configured is :%ld\n&amp;quot;, sysconf(_SC_NPROCESSORS_CONF)); printf(&amp;quot;The number of processors currently online (available) is :%ld\n&amp;quot;, sysconf(_SC_NPROCESSORS_ONLN)); printf(&amp;quot;The pagesize: %ld\n&amp;quot;, sysconf(_SC_PAGESIZE)); printf(&amp;quot;The number of pages: %ld\n&amp;quot;, sysconf(_SC_PHYS_PAGES)); printf(&amp;quot;The number of available pages: %ld\n&amp;quot;, sysconf(_SC_AVPHYS_PAGES)); printf(&amp;quot;The memory size: %lld MB\n&amp;quot;, (long long)sysconf(_SC_PAGESIZE) * (long long)sysconf(_SC_PHYS_PAGES) / ONE_MB ); printf(&amp;quot;The number of files max opened:: %ld\n&amp;quot;, sysconf(_SC_OPEN_MAX)); printf(&amp;quot;The number of ticks per second: %ld\n&amp;quot;, sysconf(_SC_CLK_TCK)); printf(&amp;quot;The max length of host name: %ld\n&amp;quot;, sysconf(_SC_HOST_NAME_MAX)); printf(&amp;quot;The max length of login name: %ld\n&amp;quot;, sysconf(_SC_LOGIN_NAME_MAX)); return 0; }  编译后执行：</description>
            <content type="html"><![CDATA[

<h2 id="1-sysconfig">1. sysconfig()</h2>

<p><code>sysconfig()</code> 是获取系统运行时配置信息的函数，包括内存、CPU 等。函数声明：</p>

<pre><code>#include &lt;unistd.h&gt;
long sysconf(int name);
</code></pre>

<p>参数 name 用于指示要获取的信息，通过返回值将结果返回。新建一个 test.c ，获取当前系统的信息：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

#define ONE_MB (1024 * 1024)

int main()
{
    printf(&quot;The number of processors configured is :%ld\n&quot;, sysconf(_SC_NPROCESSORS_CONF));
    printf(&quot;The number of processors currently online (available) is :%ld\n&quot;, sysconf(_SC_NPROCESSORS_ONLN));
    printf(&quot;The pagesize: %ld\n&quot;, sysconf(_SC_PAGESIZE));
    printf(&quot;The number of pages: %ld\n&quot;, sysconf(_SC_PHYS_PAGES));
    printf(&quot;The number of available pages: %ld\n&quot;, sysconf(_SC_AVPHYS_PAGES));
    printf(&quot;The memory size: %lld MB\n&quot;, (long long)sysconf(_SC_PAGESIZE) * (long long)sysconf(_SC_PHYS_PAGES) / ONE_MB );
    printf(&quot;The number of files max opened:: %ld\n&quot;, sysconf(_SC_OPEN_MAX));
    printf(&quot;The number of ticks per second: %ld\n&quot;, sysconf(_SC_CLK_TCK));
    printf(&quot;The max length of host name: %ld\n&quot;, sysconf(_SC_HOST_NAME_MAX));
    printf(&quot;The max length of login name: %ld\n&quot;, sysconf(_SC_LOGIN_NAME_MAX));
    return 0;
}
</code></pre>

<p>编译后执行：</p>

<pre><code>$ gcc test.c
$ ./a.out
The number of processors configured is :1
The number of processors currently online (available) is :1
The pagesize: 4096
The number of pages: 221303
The number of available pages: 19370
The memory size: 864 MB
The number of files max opened:: 1024
The number of ticks per second: 100
The max length of host name: 64
The max length of login name: 256
</code></pre>

<h2 id="2-attribute">2. <strong>attribute</strong></h2>

<p><code>__attribute__</code> 是 GCC 提供的一种语法，可以帮助我们在编译时对声明的函数、变量和类型做一些特殊处理或者是检查操作，提升城程序的性能。语法格式为: <code>__attribute__ ((attribute-list))</code> ，attribute-list 是指令集 , 分为三种类型：函数属性，变量属性，类型属性。<code>__attribute__</code> 应该出现在函数、变量和类型声明的 “;” 前。</p>

<h3 id="2-1-packed">2.1. packed</h3>

<p>packed 用于设置变量或者结构体成员以最小的对齐方式对齐，减少空间浪费，例如：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct foo1 {
    char a;
    int b[2];
};
struct foo2 {
    char a;
    int b[2];
} __attribute__((packed));


int main()
{
    int s1 = sizeof(struct foo1);
    int s2 = sizeof(struct foo2);
    printf(&quot;s1 = %d\ns2 = %d\n&quot;,s1,s2);

    return 0;
}
</code></pre>

<p>运行结果：</p>

<pre><code>s1 = 12
s2 = 9
</code></pre>

<h3 id="2-2-aligned-alignment">2.2. aligned(alignment)</h3>

<p>aligned 用于指定变量或者结构体成语按照 alignment 字节大小对齐。如果对齐长度有大于 alignment 的，就按照最大对齐长度对齐。例如：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct foo1 {
    char a;
    int b[2];
};
struct foo2 {
    char a;
    int b[2] __attribute__((aligned(8)));
};


int main()
{
    int s1 = sizeof(struct foo1);
    int s2 = sizeof(struct foo2);
    printf(&quot;s1 = %d\ns2 = %d\n&quot;,s1,s2);

    return 0;
}
</code></pre>

<p>运行结果：</p>

<pre><code>s1 = 12
s2 = 16
</code></pre>

<h3 id="2-3-constructor-destructor">2.3. constructor &amp; destructor</h3>

<p>函数属性，设置 constructor 可以使函数在 main 方法之前执行，而设置 destructor 可以使函数在 main 方法之后执行。例如：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void __attribute__((constructor)) fun1()
{
    printf(&quot;function 1\n&quot;);
}
void __attribute__((destructor)) fun2()
{
    printf(&quot;function 2\n&quot;);
}

int main()
{
    printf(&quot;Main\n&quot;);

    return 0;
}
</code></pre>

<p>运行结果：</p>

<pre><code>function 1
Main
function 2
</code></pre>

<h3 id="2-4-visibility">2.4. visibility()</h3>

<p><a href="https://www.ibm.com/developerworks/cn/aix/library/au-aix-symbol-visibility/index.html" target="_blank">控制符号可见性</a>，用与设置函数是否被导出，常用的有两个选项：</p>

<ol>
<li><strong>attribute</strong>((visibility(&ldquo;default&rdquo;))) ，用它定义的符号将被导出。</li>
<li><strong>attribute</strong>((visibility(&ldquo;hidden&rdquo;))) ，用它定义的符号将不被导出，其他对象无法调用。</li>
</ol>

<h2 id="3-size-t">3. size_t</h2>

<p>size_t 是 C/C++ 标准定义的数据类型，无符号，它在不同的系统中大小是不一样的，32 位系统中通常定义为 unsigned int ，4 Byte ，64 位系统中通常定义为 unsigned long ，8 Byte 。它的含义是当前系统可操作的内存最大值，通常用于内存相关的变量，可以确保不会因为类型太小导致变量溢出，提高程序的有效性和可移植性。例如：</p>

<pre><code>void *malloc(size_t n)
</code></pre>

<p>如果把 n 定义为 unsigned int ，那么在 64 位系统中就有溢出的可能性。参考<a href="http://jeremybai.github.io/blog/2014/09/10/size-t" target="_blank">为什么 size_t 很重要</a> 。</p>

<h2 id="4-container-of">4. container_of</h2>

<p>container_of 是 Linux 内核定义的一个宏，在 linux/kernel.h 中声明，它的作用是通过结构体变量中某个成员的地址获得这个结构体变量的地址。定义：</p>

<pre><code>#define container_of(ptr, type, member) ({ \
        const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \
        (type *)( (char *)__mptr - offsetof(type,member) );})
</code></pre>

<p>三个参数分别表示：</p>

<ul>
<li>ptr ：结构体成员变量 member 的地址</li>
<li>type ：结构体类型的名称</li>
<li>member ：结构体中的成员变量的名称</li>
</ul>

<p>宏定义包含两条语句：</p>

<pre><code>const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); 
</code></pre>

<p>首先将 0 转化成 type 类型的指针变量（指向的地址为 0x0 ），然后再引用 member 成员 <code>((type *)0)-&gt;member ) )</code>。注意这里的 typeof(x)，是返回 x 的数据类型，那么 <code>typeof( ((type *)0)-&gt;member )</code> 就是返回 member 成员的数据类型。那么这条语句整体就是定义了一个  member 成员的数据类型的指针 __mptr，指向 ptr ，而 ptr 就是 member 的地址。</p>

<pre><code>(type *)( (char *)__mptr - offsetof(type,member) );
</code></pre>

<p>这条语句中的 offsetof 的作用是获取结构体中某个成员的偏移量，那么从 __mptr 指向的地址向前 offsetof 个字节就是 member 所属结构体变量的首地址。offsetof  的原型：</p>

<pre><code>#define offsetof(type, member) (size_t)&amp;( ((type *)0)-&gt;member )
</code></pre>

<p>type 表示结构体的名称，member 表示成员变量的名称。<code>(type *)0</code> 定义了一个 type 类型的指针，指向的地址是 0 ，那么成员 member 的地址就是它在结构体内的偏移量。</p>

<p>下面这个历程展示 container_of 和 offsetof 的用法：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define offsetof(type, member) (size_t)&amp;( ((type *)0)-&gt;member )

#define container_of(ptr, type, member) ({ \
        const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \
        (type *)( (char *)__mptr - offsetof(type,member) );})

typedef struct foo
{
    char  a;
    int  b;
}foo;


int main()
{
    size_t off_set = 0;
    off_set = offsetof(foo, b);
    printf(&quot;foo-&gt;b offset: %lu\n&quot;,off_set);

    foo s ;
    printf(&quot;s address : %lu\n&quot;,(size_t)&amp;s);
    s.b = 10;
    foo *p = container_of(&amp;(s.b), foo, b);
    printf(&quot;p-&gt;b value : %d\n&quot;, p-&gt;b);
    printf(&quot;p address : %lu\n&quot;, (size_t)p);
    return 0;
}
</code></pre>

<p>运行结果：</p>

<pre><code>foo-&gt;b offset: 4
s address : 140723509298320
p-&gt;b value : 10
p address : 140723509298320
</code></pre>

<h2 id="5-pid-文件">5. PID 文件</h2>

<p>在 Linux 系统的 /var/run/ 目录下可以看到很多 *.pid 文件，很多程序启动后都会在该目录下新建一个自己的 PID 文件，记录该进程的 PID ，方便管理进程。PID 文件的另一个作用是防止进程启动多个副本，进程启动后新建 PID 文件，然后为文件加独占的记录锁，只有获得 PID 文件写入权限（F_WRLCK）的进程才可以启动，并将自身的 PID 写入文件，锁定失败的进程启动退出。下面是一个例程：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;errno.h&gt;
#include &lt;signal.h&gt;
#include &lt;string.h&gt;

int run = 1;

//锁定一个文件，参数是文件描述符，出错返回 -1    
int lockfile(int fd)
{
   struct flock lock;
   lock.l_type = F_WRLCK;  //独占性写锁
   lock.l_whence = SEEK_SET;  //为整个文件加锁
   lock.l_start = 0;
   lock.l_len = 0;
   return fcntl(fd, F_SETLK, &amp;lock);
}

//新建 PID 文件并加锁，参数是 PID 文件的路径和当前进程的 PID ，失败返回负数
int creat_pidfile(const char *pid_file, pid_t pid)
{
    int fd = 0;
    fd = open(pid_file, O_RDWR|O_CREAT, (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH));
    if(fd &lt; 0)
    {
        printf(&quot;ERROR: can not open pid file %s\n&quot;,pid_file);
        return -1;
    }
    if(lockfile(fd)&lt;0)
    {
        if(errno==EACCES || errno==EAGAIN)
        {
            close(fd);
            printf(&quot;WARNING: process already run\n&quot;);
            return 0;
        }
        printf(&quot;ERROR: can not lock pid file: %s error: %s\n&quot;, pid_file, strerror(errno));
        return -2;
    }
    if(dprintf(fd, &quot;%d&quot;, pid)&lt;0)
    {
        close(fd);
        printf(&quot;ERROR: write pid failed\n&quot;);
        return 0;
    }
    return fd;
}

int remove_pidfile(const char *pid_file, int fd)
{
    close(fd);
    remove(pid_file);
    return 0;
}

void handle_sig(int signo)
{
    if( (signo==SIGINT)|(signo==SIGTERM) )
        run=0;
}

int main()
{
    int fd = 0;
    const char *pid_file = &quot;/var/run/test.pid&quot;; 


    fd = creat_pidfile(pid_file,getpid());
    if(fd&gt;0)
        close(fd);
    else
    {
        printf(&quot;create pid file error\n&quot;);
        return -1;
    }


    signal(SIGINT,handle_sig);
    signal(SIGTERM,handle_sig);

    while(run)
    {
        sleep(5);
    }

    remove_pidfile(pid_file,fd);

    return 0;
}
</code></pre>

<h2 id="6-debug">6. Debug</h2>

<p>在源文件里声明：</p>

<pre><code>#ifdef __DEBUG__
#define DEBUG(format, ...) printr(&quot;%03d: &quot;format&quot;&quot;, __LINE__, ##__VA_ARGS__)
#else
#define DEBUG(format, ...)
#endif
</code></pre>

<p>调用 <code>DEBUG()</code> 的语法与 <code>printf()</code> 一样，编译时在 gcc 中声明 <code>-D __DEBUG__</code> 即可打开调试信息。</p>
]]></content>
        </item>
        
        <item>
            <title>计算机是如何实现重启的</title>
            <link>https://shaocheng.li/posts/2017/11/30/</link>
            <pubDate>Thu, 30 Nov 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/11/30/</guid>
            <description>1. Soft Power 早期的计算机主板都是使用 AT 电源管理技术，AT 电源系统非常简单，电源键是机械式开关，只有开闭两种状态，闭合后电流从开关上流过为主板供电，断开后主板上的所有器件同时断电，无法实现待机、软关机等功能，这个时期的 Windows 系统关机后会一直显示一条 &amp;ldquo;It is now safe to turn off your computer&amp;rdquo; 的信息，因为操作系统无法切断电源。这时期的电源可以叫做 Hard Power ，因为全部都是硬件控制的。
后来英特尔提出了 ATX 主板标准，它带来了 Soft Power ，它使用的 ATX 电源没有直接连到电脑的开关，而是插在主板上，可以通过软件控制，下面是 ATX 主板电源接口的信号定义：
它还带来了两个重要的变化：
 备份电源：主板电源接口上有一个 &amp;ldquo;+5VSB&amp;rdquo; 或者 &amp;ldquo;+5V Standby&amp;rdquo; 的信号，即使计算机已经关机，这个 5V 信号也会一直供给主板，主板可以持续运行一些最简单的功能，也就是待机状态，我们可以随时唤醒计算机。该信号还有一个作用就是替代 CMOS 电池。 智能电源控制：电源接口还有 PS-ON 和 PW-OK/PS-RDY 信号，代表“电源接通”和“电源就绪”。你可以试试将 PS-ON 信号与地线短接，ATX 电源会立即启动，风扇开始旋转。主板上某个由 +5VSB 供电的组件就是通过短接 PS-ON 和地来启动计算机的。由于电源中有些部分启动一段时间后才能稳定，电源完全稳定后才会打开 PW-OK/PS-RDY 信号，主板会等待该信号打开后才开始引到启动。  所以，计算机的电源键不再是“打开”计算机，它连接在主板的基本控制器上，控制器检测到电源键按下，再启动电源，引导系统。电源键不再是启动系统的唯一方式，扩展总线上的其他设备也可以。这很重要，计算机关机时，以太网适配器还是保持打开的，这样就可以通过以太网远程启动计算机。
2. 电源管理 现在的计算机都采用了 ACPI(Advanced Configuration and Power Interface) 技术，它是英特尔等公司提出的操作系统应用程序管理所有电源管理接口的规范，包括了软件和硬件方面的规范，操作系统的电源管理功能通过调用 ACPI 接口，实现对符合 ACPI 规范的硬件设备的电源管理，下面是电源管理与 ACPI 的全局结构图：</description>
            <content type="html"><![CDATA[

<h2 id="1-soft-power">1. Soft Power</h2>

<p>早期的计算机主板都是使用 AT 电源管理技术，AT 电源系统非常简单，电源键是机械式开关，只有开闭两种状态，闭合后电流从开关上流过为主板供电，断开后主板上的所有器件同时断电，无法实现待机、软关机等功能，这个时期的 Windows 系统关机后会一直显示一条 &ldquo;It is now safe to turn off your computer&rdquo; 的信息，因为操作系统无法切断电源。这时期的电源可以叫做 Hard Power ，因为全部都是硬件控制的。</p>

<p>后来英特尔提出了 ATX 主板标准，它带来了 Soft Power ，它使用的 <a href="http://www.pcguide.com/ref/power/sup/form_ATX.htm" target="_blank">ATX 电源</a>没有直接连到电脑的开关，而是插在主板上，可以通过软件控制，下面是 ATX 主板电源接口的信号定义：</p>

<p><img src="/images/2017-11-30/2017-11-30_1.jpg" alt="" /></p>

<p>它还带来了两个重要的变化：</p>

<ol>
<li>备份电源：主板电源接口上有一个 &ldquo;+5VSB&rdquo; 或者 &ldquo;+5V Standby&rdquo; 的信号，即使计算机已经关机，这个 5V 信号也会一直供给主板，主板可以持续运行一些最简单的功能，也就是待机状态，我们可以随时唤醒计算机。该信号还有一个作用就是替代 CMOS 电池。</li>
<li>智能电源控制：电源接口还有 PS-ON 和 PW-OK/PS-RDY 信号，代表“电源接通”和“电源就绪”。你可以试试将 PS-ON 信号与地线短接，ATX 电源会立即启动，风扇开始旋转。主板上某个由 +5VSB 供电的组件就是通过短接 PS-ON 和地来启动计算机的。由于电源中有些部分启动一段时间后才能稳定，电源完全稳定后才会打开 PW-OK/PS-RDY 信号，主板会等待该信号打开后才开始引到启动。</li>
</ol>

<p>所以，计算机的电源键不再是“打开”计算机，它连接在主板的基本控制器上，控制器检测到电源键按下，再启动电源，引导系统。电源键不再是启动系统的唯一方式，扩展总线上的其他设备也可以。这很重要，计算机关机时，以太网适配器还是保持打开的，这样就可以通过以太网远程启动计算机。</p>

<h2 id="2-电源管理">2. 电源管理</h2>

<p>现在的计算机都采用了 ACPI(Advanced Configuration and Power Interface) 技术，它是英特尔等公司提出的操作系统应用程序管理所有电源管理接口的规范，包括了软件和硬件方面的规范，操作系统的电源管理功能通过调用 ACPI 接口，实现对符合 ACPI 规范的硬件设备的电源管理，下面是电源管理与 ACPI 的全局结构图：</p>

<p><img src="/images/2017-11-30/2017-11-30_2.png" alt="" /></p>

<p>ACPI 有个概念叫做 power states ，可以理解为电源状态，操作系统可以通过切换设备的电源状态来控制功耗，主板的电源状态有：</p>

<ol>
<li>G0：工作（计算机处于开机工作状态）</li>
<li>G1：睡眠（您的计算机的待机状态，分为几个子状态）

<ul>
<li>S1：CPU 和 RAM 的电源保持打开，但 CPU 未执行指令， 外围设备关闭</li>
<li>S2：CPU 关闭，RAM 保持打开</li>
<li>S3：所有组件关闭，除了 RAM 和触发恢复的设备（键盘）， 当你告诉操作系统“Sleep”时，它会关闭所有进程，然后进入这个模式。</li>
<li>S4：休眠，关闭所有组件。 当您将操作系统告知休眠时，它会停止进程，将 RAM 的内容保存到磁盘，然后进入此模式。</li>
</ul></li>
<li>G2：软关，这就是计算机的“关机”状态， 除了可以触发引导的设备之外，其他电源均已关闭。</li>
<li>G3：机械关闭，ATX 电源本身都已经断电。</li>
</ol>

<p>ACPI 为 CPU 和计算机上的其他设备都定义了不同的电源状态。</p>

<h2 id="3-重启">3. 重启</h2>

<p>当我们在 Linux 系统中执行 reboot 命令时，它会执行系统调用 <code>reboot()</code> 函数：</p>

<pre><code>int reboot(int magic, int magic2, int cmd, void *arg);
</code></pre>

<p>函数定义在内核的 kernel/reboot.c 文件中：</p>

<pre><code>/*
 * Reboot system call: for obvious reasons only root may call it,
 * and even root needs to set up some magic numbers in the registers
 * so that some mistake won't make this reboot the whole machine.
 * You can also set the meaning of the ctrl-alt-del-key here.
 * reboot doesn't sync: do that yourself before calling this.
 */
SYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd, void __user *, arg)
</code></pre>

<p>该函数有个 cmd 参数，通过不同的选项调用相应的内核函数实现不同的功能：</p>

<ul>
<li>LINUX_REBOOT_CMD_CAD_OFF：禁止 CAD ， 这意味着无法通过 ctrl-alt-del 组合键产生 SIGINT 信号触发重启。</li>
<li>LINUX_REBOOT_CMD_CAD_ON：使能 CAD ，可以通过 ctrl-alt-del 组合键触发重启</li>
<li>LINUX_REBOOT_CMD_HALT：关闭操作系统</li>
<li>LINUX_REBOOT_CMD_KEXEC：重新加载内核，当内核配置了 CONFIG_KEXEC 时才有效</li>
<li>LINUX_REBOOT_CMD_POWER_OFF：关机，关闭操作系统，然后让计算机的电源进入 G2 状态</li>
<li>LINUX_REBOOT_CMD_RESTART：立即重启计算机，打印信息 &ldquo;Restarting system.&rdquo;</li>
<li>LINUX_REBOOT_CMD_RESTART2：立即重启计算机， 打印信息 &ldquo;Restarting system with command &lsquo;%s&rsquo;&rdquo;</li>
<li>LINUX_REBOOT_CMD_SW_SUSPEND：休眠，将运行状态保存到硬盘，系统挂起，当内核配置了 CONFIG_HIBERNATION 时有效</li>
</ul>

<p>可以看到，除了重启 ，<code>reboot()</code> 函数还可以实现停机和关机的功能，所有 halt 和 poweroff 命令也会调用该函数。以 Linux kernel 4.1 为例，系统重启的流程如下图：</p>

<p><img src="/images/2017-11-30/2017-11-30_3.png" alt="" /></p>

<p>重启会调用内核函数 <code>kernel_restart()</code> ，定义在 kernel/reboot.c 文件中：</p>

<pre><code>void kernel_restart(char *cmd)
{
    kernel_restart_prepare(cmd);
    migrate_to_reboot_cpu();
    syscore_shutdown();
    if (!cmd)
        pr_emerg(&quot;Restarting system\n&quot;);
    else
        pr_emerg(&quot;Restarting system with command '%s'\n&quot;, cmd);
    kmsg_dump(KMSG_DUMP_RESTART);
    machine_restart(cmd);
}
EXPORT_SYMBOL_GPL(kernel_restart);
</code></pre>

<p>依次完成如下工作:</p>

<ol>
<li>kernel_restart_prepare(cmd)：向关心系统重启的进程发出通知，各进程会依次关闭，然后设置系统状态为 SYSTEM_RESTART，关闭所有外部设备。</li>
<li>syscore_shutdow()：关闭操作系统核心，比如中断</li>
<li>machine_restart(cmd)：硬件重置</li>
</ol>

<p>在 x86 系统中，<code>machine_restart()</code> 函数最终会调用 arch/x86/kernel/reboot.c 文件中的 <code>native_machine_emergency_restart()</code> 函数，根据不同的重置方式，执行相应的 reboot 代码：</p>

<pre><code>static void native_machine_emergency_restart(void)
{
......
    for (;;) {
        /* Could also try the reset bit in the Hammer NB */
        switch (reboot_type) {
        case BOOT_ACPI:
            acpi_reboot();
            reboot_type = BOOT_KBD;
            break;
        case BOOT_KBD:
            mach_reboot_fixups(); /* For board specific fixups */
                for (i = 0; i &lt; 10; i++) {
                kb_wait();
                udelay(50);
                outb(0xfe, 0x64); /* Pulse reset low */
                udelay(50);
            }
            if (attempt == 0 &amp;&amp; orig_reboot_type == BOOT_ACPI) {
                attempt = 1;
                reboot_type = BOOT_ACPI;
            } else {
                reboot_type = BOOT_EFI;
            }
            break;
        case BOOT_EFI:
            efi_reboot(reboot_mode, NULL);
            reboot_type = BOOT_BIOS;
            break;
        case BOOT_BIOS:
            machine_real_restart(MRR_BIOS);
            /* We're probably dead after this, but... */
            reboot_type = BOOT_CF9_SAFE;
            break;
        case BOOT_CF9_FORCE:
            port_cf9_safe = true;
            /* Fall through */
        case BOOT_CF9_SAFE:
            if (port_cf9_safe) {
                u8 reboot_code = reboot_mode == REBOOT_WARM ?  0x06 : 0x0E;
                u8 cf9 = inb(0xcf9) &amp; ~reboot_code;
                outb(cf9|2, 0xcf9); /* Request hard reset */
                udelay(50);
                /* Actually do the reset */
                outb(cf9|reboot_code, 0xcf9);
                udelay(50);
            }
            reboot_type = BOOT_TRIPLE;
            break;
        case BOOT_TRIPLE:
            load_idt(&amp;no_idt);
            __asm__ __volatile__(&quot;int3&quot;);
            /* We're probably dead after this, but... */
            reboot_type = BOOT_KBD;
            break;
        }
    }
}
</code></pre>

<p>可以看出，计算机有多种方式可以重置硬件，在一个无限循环里逐一执行，如果成功，机器就会重启，否则就切换到下一种方法。默认使用 ACPI 方式，其次还有 KBD 、CF9、BIOS、EFI等，使用哪种方式主要取决于内核引导选项 reboot 的设置：</p>

<pre><code>reboot=[mode][,type][,force]
</code></pre>

<p>含义：</p>

<ul>
<li>mode 用于指定重启模式，可以使用如下两种模式之一：warm (热重启，跳过内存检测)，cold (冷重启，检测并重新初始化所有硬件)</li>
<li>type 用于指定重启类型，可以使用如下4种类型之一：bios (为热重启使用 CPU reboot vector)，acpi (优先使用 FADT 中的 ACPI reset register  ，若失败再转为 kbd ，这是目前内核的默认值，定义在 kernel/reboot.c 文件： <code>enum reboot_type reboot_type = BOOT_ACPI;</code>)，kbd (使用键盘控制器冷重启)， efi (优先使用 EFI 提供的 reset_system 运行时服务,若失败再转 kbd )</li>
<li>结尾的 &ldquo;force&rdquo; 表示在重启时不停用其它的 CPU，在某些情况下可以让reboot更可靠。</li>
</ul>

<blockquote>
<p>系统启动后，可以在 /proc/cmdline 文件查看启动时使用的引导选项以和值。可以使用 &ldquo;modinfo -p ${modulename}&rdquo; 命令显示可加载模块的所有可用选项。已经加载到内核中的模块会在 /sys/module/${modulename}/parameters/ 中显示出其选项，并且某些选项的值还可以在运行时通过 &ldquo;echo -n ${value} &gt; /sys/module/${modulename}/parameters/${parm}&rdquo; 进行修改。</p>
</blockquote>

<h3 id="3-1-acpi-reset">3.1. ACPI reset</h3>

<p>ACPI 规定了一个特殊的寄存器 reset register，它可以位于 IO/Memory、或者 PCI bus #0 上的一个设备的配置空间，通过向 reset register 写入特定值来重置计算机。根据 ACPI 的规定，所有硬件必须在这个机制之后重置，主板收到请求后要做如下工作：</p>

<ul>
<li>所有逻辑复位。 这意味着将相应的复位命令发送到包括 CPU，存储控制器，外围控制器等的各种硬件。在大多数情况下，这意味着向设备的 RST 线发送复位信号。</li>
<li>然后引导计算机。主板执行的步骤与刚刚在按下电源键后开机的步骤相同。</li>
</ul>

<p>如果内核使能了 ACPI ，就会通过 ACPI 重置硬件，实现的函数是 <code>acpi_reboot()</code> ，定义在 drivers/acpi/reboot.c 文件：</p>

<pre><code>void acpi_reboot(void)
{
    struct acpi_generic_address *rr;
    struct pci_bus *bus0;
    u8 reset_value;
    unsigned int devfn;

    if (acpi_disabled)
        return;

    rr = &amp;acpi_gbl_FADT.reset_register;
    /* ACPI reset register was only introduced with v2 of the FADT */
    if (acpi_gbl_FADT.header.revision &lt; 2)
        return;

    /* Is the reset register supported? The spec says we should be checking the bit width and bit offset, but Windows ignores these fields */
    if (!(acpi_gbl_FADT.flags &amp; ACPI_FADT_RESET_REGISTER))
        return;

    reset_value = acpi_gbl_FADT.reset_value;

    /* The reset register can only exist in I/O, Memory or PCI config space on a device on bus 0. */
    switch (rr-&gt;space_id) {
    case ACPI_ADR_SPACE_PCI_CONFIG:
        /* The reset register can only live on bus 0. */
        bus0 = pci_find_bus(0, 0);
        if (!bus0)
            return;
        /* Form PCI device/function pair. */
        devfn = PCI_DEVFN((rr-&gt;address &gt;&gt; 32) &amp; 0xffff,
                  (rr-&gt;address &gt;&gt; 16) &amp; 0xffff);
        printk(KERN_DEBUG &quot;Resetting with ACPI PCI RESET_REG.&quot;);
        /* Write the value that resets us. */
        pci_bus_write_config_byte(bus0, devfn,
                (rr-&gt;address &amp; 0xffff), reset_value);
        break;
    case ACPI_ADR_SPACE_SYSTEM_MEMORY:
    case ACPI_ADR_SPACE_SYSTEM_IO:
        printk(KERN_DEBUG &quot;ACPI MEMORY or I/O RESET_REG.\n&quot;);
        acpi_reset();
        break;
    }
}
</code></pre>

<p>ACPI 编程接口的 <a href="http://wiki.osdev.org/FADT" target="_blank">FADT</a> 数据结构描述了 reset register ：</p>

<pre><code>// 12 byte structure; see below for details
struct GenericAddressStructure
{
  uint8_t AddressSpace;  
  uint8_t BitWidth;
  uint8_t BitOffset;
  uint8_t AccessSize;
  uint64_t Address;
};       
GenericAddressStructure ResetReg;
 uint8_t  ResetValue;
</code></pre>

<p>结构成员 AddressSpace 指示了 reset register 所处的地址空间：</p>

<table>
<thead>
<tr>
<th>Value</th>
<th>Address Space</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>System Memory</td>
</tr>

<tr>
<td>1</td>
<td>System I/O</td>
</tr>

<tr>
<td>2</td>
<td>PCI Configuration Space</td>
</tr>
</tbody>
</table>

<p>Linux kernel 用 数据结构 <code>struct acpi_table_fadt</code> 实现了 FADT，定义在 include/acpi/actbl.h 文件，并定义了变量 <code>acpi_gbl_FADT</code> 存放所有数据。如果 reset register 位于 Memory 或者 IO ，<code>acpi_reboot()</code>  会调用 <code>acpi_reset()</code> 向 <code>acpi_gbl_FADT.reset_register</code> 写入 <code>acpi_gbl_FADT.reset_value</code> 完成重置。如果 reset register  在 PCI 配置空间，需要先找到配置空间内的地址，然后写入  <code>acpi_gbl_FADT.reset_value</code> 。</p>

<h3 id="3-2-kbd">3.2. KBD</h3>

<p>KBD 是 keyboard 的缩写，这是通过键盘控制器重置计算机的方式。<a href="http://wiki.osdev.org/%228042%22_PS/2_Controller" target="_blank">8042</a> 是早期 x86 计算机上的 PS/2 键盘控制器，80 年代 IBM 推出搭载 80268 CPU 的 PC/AT 计算机时，为了解决某些兼容问题，为它添加了很多与键盘无关的功能，比如重置 CPU 。8024 的控制寄存器位于 IO 端口 0x64 ，向它写入 0xfe 就可以重置 CPU ：</p>

<pre><code>outb(0xfe, 0x64);
</code></pre>

<p>由于历史原因，直到今天，x86 计算机上依然需要兼容 PC/AT 机的 8042，这种方式几乎可以重启一切 x86 计算机。</p>

<h3 id="3-3-cf9">3.3. CF9</h3>

<p>主板上的南桥芯片也有电源管理的功能，通过 IO 端口 0xCF9 南桥的 Reset Control Register ，以英特尔的南桥芯片 ICH10 为例，寄存器定义详情可以查看芯片的 Datesheet：</p>

<p><img src="/images/2017-11-30/2017-11-30_4.png" alt="" /></p>

<p>内核中有两种选择：</p>

<ol>
<li>向 IO Port CF9 写 0x06。热重启，这种 reset 方法不会使系统设备掉电，仅仅将 CPU 和系统设备的 status 干净彻底的 reset 一 下。</li>
<li>向 IO Port CF9 写 0x0E。冷重启，这是一种非常彻底的 reset 方法，系统的硬件会掉电，然后重新上电。</li>
</ol>

<h3 id="3-4-bios">3.4. BIOS</h3>

<p>这种方式会调用一段汇编代码，使 CPU 跳转到 BIOS 的重置代码处，由 BIOS 重启系统，实现方法在 arch/x86/kernel/reboot.c 文件的  <code>machine_real_restart()</code> 函数：</p>

<pre><code>#ifdef CONFIG_X86_32
    asm volatile(&quot;jmpl *%0&quot; : :
             &quot;rm&quot; (real_mode_header-&gt;machine_real_restart_asm),
             &quot;a&quot; (type));
#else
    asm volatile(&quot;ljmpl *%0&quot; : :
             &quot;m&quot; (real_mode_header-&gt;machine_real_restart_asm),
             &quot;D&quot; (type));
</code></pre>

<h3 id="3-5-efi">3.5. EFI</h3>

<p>调用 EFI/UEFI 提供的接口实现重启。</p>

<h2 id="4-参考">4. 参考</h2>

<ul>
<li><a href="https://superuser.com/questions/294681/how-does-a-computer-restart-itself" target="_blank">How does a computer restart itself</a></li>
<li><a href="http://wiki.ubuntu.com/DebuggingACPI" target="_blank">Debugging ACPI</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Power_management_(简体中文)" target="_blank">Power management</a></li>
<li><a href="https://zh.wikipedia.org/wiki/高级配置与电源接口" target="_blank">ACPI</a></li>
<li><a href="http://wiki.osdev.org/Reboot" target="_blank">Reboot</a></li>
<li><a href="http://www.jinbuguo.com/kernel/boot_parameters.html" target="_blank">Linux 内核引导选项简介</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Linux 系统的 USB 设备结构</title>
            <link>https://shaocheng.li/posts/2017/11/28/</link>
            <pubDate>Tue, 28 Nov 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/11/28/</guid>
            <description>以一台 x86 主机为例，用 lsusb 可以查看它的所有 USB 设备：
# lsusb Bus 001 Device 003: ID 1bc7:0021 Telit HE910 Bus 002 Device 002: ID 04e2:1410 Exar Corp. Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub  在 sys 文件系统的 /sys/bus/usb/devices/ 目录下可以看到所有 USB 设备的树形结构：
/sys/bus/usb/devices# ls -l total 0 lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-0:1.0 -&amp;gt; .</description>
            <content type="html"><![CDATA[<p>以一台 x86 主机为例，用 lsusb 可以查看它的所有 USB 设备：</p>

<pre><code># lsusb
Bus 001 Device 003: ID 1bc7:0021 Telit HE910
Bus 002 Device 002: ID 04e2:1410 Exar Corp. 
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
</code></pre>

<p>在 sys 文件系统的 /sys/bus/usb/devices/ 目录下可以看到所有 USB 设备的树形结构：</p>

<pre><code>/sys/bus/usb/devices# ls -l
total 0
lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-0:1.0 -&gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-0:1.0
lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2 -&gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2
lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.0 -&gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.0
lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.1 -&gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.1
lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.10 -&gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.10
lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.11 -&gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.11
lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.12 -&gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.12
lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.13 -&gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.13
lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.2 -&gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.2
lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.3 -&gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.3
lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.4 -&gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.4
lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.5 -&gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.5
lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.6 -&gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.6
lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.7 -&gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.7
lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.8 -&gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.8
lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.9 -&gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.9
lrwxrwxrwx 1 root root 0 Nov 26 10:57 2-0:1.0 -&gt; ../../../devices/pci0000:00/0000:00:14.4/usb2/2-0:1.0
lrwxrwxrwx 1 root root 0 Nov 26 10:57 2-1 -&gt; ../../../devices/pci0000:00/0000:00:14.4/usb2/2-1
lrwxrwxrwx 1 root root 0 Nov 26 10:57 2-1:1.0 -&gt; ../../../devices/pci0000:00/0000:00:14.4/usb2/2-1/2-1:1.0
lrwxrwxrwx 1 root root 0 Nov 26 10:57 2-1:1.1 -&gt; ../../../devices/pci0000:00/0000:00:14.4/usb2/2-1/2-1:1.1
lrwxrwxrwx 1 root root 0 Nov 26 10:57 usb1 -&gt; ../../../devices/pci0000:00/0000:00:14.3/usb1
lrwxrwxrwx 1 root root 0 Nov 26 10:57 usb2 -&gt; ../../../devices/pci0000:00/0000:00:14.4/usb2
</code></pre>

<p>usb1 和 usb2 是 PCI 总线上的两个 USB controller ，也就是两个 root hub ，它们扩展出两条 USB 总线，而其他设备都是这两条总线下的子设备，它们的命名格式是 <code>根集线器号-集线器端口号:配置.接口</code>，进入 usb2/1-2 目录，查看设备号：</p>

<pre><code>/sys/bus/usb/devices/usb1# cd 1-2/
/sys/bus/usb/devices/usb1/1-2# cat devnum 
3
</code></pre>

<p>可以确认，1-2 就是设备 <code>Bus 001 Device 003: ID 1bc7:0021 Telit HE910</code> 的文件夹，这个设备号是 USB 总线枚举设备时自动分配的，如果拔掉设备重插，设备号会重新分配，自动向后增长。设备目录下还有一些有用的文件：</p>

<ul>
<li>busnum：设备接入的 USB 总线号</li>
<li>idProduct：设备 ID</li>
<li>idVendor：厂商 ID</li>
</ul>

<p>参考：</p>

<ul>
<li><a href="http://www.linux-usb.org/FAQ.html" target="_blank">http://www.linux-usb.org/FAQ.html</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/ABI/stable/sysfs-bus-usb" target="_blank">https://www.kernel.org/doc/Documentation/ABI/stable/sysfs-bus-usb</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>x86 计算机的 PCI 总线结构</title>
            <link>https://shaocheng.li/posts/2017/11/27/</link>
            <pubDate>Mon, 27 Nov 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/11/27/</guid>
            <description>1. 硬件 PCI 总线是一个并行总线，一个时钟周期有 32 个 bit （后扩展到 64 bit） 同时传输，带宽 133MB/s ，PCI 设备具有独立的地址空间，叫做 PCI 总线地址空间，通过 Host bridge 隔离处理器系统的存储器域与 PCI 总线域，下面挂在了一个 PCI 总线树，典型的结构如下图：
PCI 总线主要分为三个部分：
 PCI 设备。符合 PCI 总线标准的设备就被称为 PCI 设备，PCI 总线架构中可以包含多个 PCI 设备。图中的 Audio、LAN 都是一个 PCI 设备。PCI 设备同时也分为主设备和目标设备两种，主设备是一次访问操作的发起者，而目标设备则是被访问者。 PCI 总线。PCI 总线在系统中可以有多条，类似于树状结构进行扩展，每条 PCI 总线都可以连接多个 PCI 设备/桥，上图中有两条 PCI 总线。 PCI 桥。当一条 PCI 总线的承载量不够时，可以用新的 PCI 总线进行扩展，而 PCI 桥则是连接 PCI 总线之间的纽带，如图的 PCI-to-PCI Bridge 。  后期为了提高数据传输速率，又推出了 PCIe 总线，改为串行总线，差分信号传输，带宽提升至 250MB/s ，最新的 PCIe 3.</description>
            <content type="html"><![CDATA[

<h2 id="1-硬件">1. 硬件</h2>

<p>PCI 总线是一个并行总线，一个时钟周期有 32 个 bit （后扩展到 64 bit） 同时传输，带宽 133MB/s ，PCI 设备具有独立的地址空间，叫做 PCI 总线地址空间，通过 Host bridge 隔离处理器系统的存储器域与 PCI 总线域，下面挂在了一个 PCI 总线树，典型的结构如下图：</p>

<p><img src="/images/2017-11-27/2017-11-27_1.png" alt="" /></p>

<p>PCI 总线主要分为三个部分：</p>

<ol>
<li>PCI 设备。符合 PCI 总线标准的设备就被称为 PCI 设备，PCI 总线架构中可以包含多个 PCI 设备。图中的 Audio、LAN 都是一个 PCI 设备。PCI 设备同时也分为主设备和目标设备两种，主设备是一次访问操作的发起者，而目标设备则是被访问者。</li>
<li>PCI 总线。PCI 总线在系统中可以有多条，类似于树状结构进行扩展，每条 PCI 总线都可以连接多个 PCI 设备/桥，上图中有两条 PCI 总线。</li>
<li>PCI 桥。当一条 PCI 总线的承载量不够时，可以用新的 PCI 总线进行扩展，而 PCI 桥则是连接 PCI 总线之间的纽带，如图的 PCI-to-PCI Bridge 。</li>
</ol>

<p>后期为了提高数据传输速率，又推出了 PCIe 总线，改为串行总线，差分信号传输，带宽提升至 250MB/s ，最新的 PCIe 3.0 已经可以达到 8000MB/s 。</p>

<h2 id="2-软件">2. 软件</h2>

<p>在 PCI 总线上，通过 Bus number ，Device number 和 Function number 标识每个 PCI 设备，简称 BDF ，每个 PCI 设备内有单独存储空间，叫做 PCI 配置空间。可以通过 IO 端口 CONFIG_ADDRESS 和 CONFIG_DATA 读取 PCI 配置空间。CONFIG_ADDRESS 的地址是 0xCF8，CONFIG_DATA 的地址是 0xCFC，两个寄存器都为 32bit。CONFIG_ADDRESS 寄存器格式：</p>

<p><img src="/images/2017-11-27/2017-11-27_2.jpg" alt="" /></p>

<ul>
<li>bit31 是使能对 PCI Bus CONFIG_DATA 的访问；</li>
<li>bit 30～24 为保留，为只读，访问时返回值为 0；</li>
<li>bit 23～16 是Bus号；</li>
<li>bit 15～10 是设备号；</li>
<li>bit 10～8 是功能号；</li>
<li>bit 7～2 是配置空间中的寄存器，单位为 DWORD；</li>
<li>bit 1～0 为只读，读取时放回为0。</li>
</ul>

<p>直接操作 IO 端口读取 PCI 配置信息分为两步：</p>

<ol>
<li>向 CONFIG_ADDRESS 寄存器写入要读/写的位置；</li>
<li>从CONFIG_DATA寄存器（端口0xCFC）读/写所需要数据。</li>
</ol>

<p>配置空间共 256 字节（地址 0x00~0xFF）， 前 64 字节（地址 0x00~0x3F ）是所有 PCI 设备必须支持的：</p>

<p><img src="/images/2017-11-27/2017-11-27_3.png" alt="" /></p>

<p>配置空间都是小端存储。Vendor ID 是厂商 ID ，为保证唯一性，需要设备厂商向 PCI SIG 申请获得，Device ID 由厂商自定义。 Base Address Registers （BAR）用来定义该设备占用的 Memory/IO 空间的类型、起始地址和大小，PCI 设备做多有六个 BAR，PCI 桥最多有两个 BAR 。BAR 在 bit0 来表示该设备是映射到 memory 还是 IO，bar 的 bit0 是 readonly 的，也就是说，设备寄存器是映射到 memory 还是 IO 是由设备制造商决定的，其他人无法修改。空间的大小可以用如下方法读取：</p>

<ol>
<li>向寄存器写 0xFFFFFFFF；</li>
<li>读出寄存器的值，并取反；</li>
<li>再加 1 就是该空间的大小。</li>
</ol>

<p>下面是 BAR 的结构图：</p>

<p><img src="/images/2017-11-27/2017-11-27_4.png" alt="" /></p>

<p>PCI 枚举是个不断递归调用发现新设备的过程，系统启动时, 从 Host Bridge 开始寻找设备和桥。发现桥后设置 Bus，会发现一个 PCI 设备子树，递归的过程中，BIOS/UEFI (或者 Linux 内核, 如果配置成这样)与每个 PCI 设备进行配置交易, 为其分配安全的地址空间和中断等资源。在整个过程结束后，一颗完整的资源分配完毕的树就建立好了。</p>

<p>PCIe 规范在 PCI 规范的基础上，将配置空间扩展到 4KB。原来的 CF8/CFC 方法仍然可以访问所有PCIe设备配置空间的头255B，但是该方法访问不了剩下的（255-4k）配置空间。</p>

<h2 id="3-linux">3. Linux</h2>

<h3 id="3-1-user-space">3.1. user space</h3>

<p>Linux 系统下查询 PCI 设备主要用 lspci 命令和 /sys 文件系统，一个 x86 主机为例：</p>

<pre><code># lspci
00:00.0 Host bridge: Intel Corporation Device 0958
00:14.0 SD Host controller: Intel Corporation Device 08a7 (rev 10)
00:14.1 Serial controller: Intel Corporation Device 0936 (rev 10)
00:14.2 USB controller: Intel Corporation Device 0939 (rev 10)
00:14.3 USB controller: Intel Corporation Device 0939 (rev 10)
00:14.4 USB controller: Intel Corporation Device 093a (rev 10)
00:14.5 Serial controller: Intel Corporation Device 0936 (rev 10)
00:14.6 Ethernet controller: Intel Corporation Device 0937 (rev 10)
00:14.7 Ethernet controller: Intel Corporation Device 0937 (rev 10)
00:15.0 Serial bus controller [0c80]: Intel Corporation Device 0935 (rev 10)
00:15.1 Serial bus controller [0c80]: Intel Corporation Device 0935 (rev 10)
00:15.2 Serial bus controller [0c80]: Intel Corporation Device 0934 (rev 10)
00:17.0 PCI bridge: Intel Corporation Device 11c3
00:17.1 PCI bridge: Intel Corporation Device 11c4
00:1f.0 ISA bridge: Intel Corporation Device 095e
01:00.0 Network controller: Intel Corporation Centrino Advanced-N 6205 [Taylor Peak] (rev 34)
</code></pre>

<p>前面的数字依次是总线号：设备号：功能号，第一个设备就是 Host bridge ，<code>00:1f.0 ISA bridge</code> 是一个 ISA 桥，通过 PCI 扩展了一个 ISA 总线，可以兼容过时的 ISA 总线设备。有个两个 PCI bridge ：<code>00:17.0 PCI bridge</code> 和 <code>00:17.1 PCI bridge</code> ，扩展了两条 PCI 总线，也就是说该主机有三条 PCI 总线。而 <code>01:00.0 Network controller</code> 就是 PCI Bus #1 下的一个设备。单独查看该设备的详细信息：</p>

<pre><code># lspci -s 01:00.0 -vv
01:00.0 Network controller: Intel Corporation Centrino Advanced-N 6205 [Taylor Peak] (rev 34)
        Subsystem: Intel Corporation Centrino Advanced-N 6205 AGN
        Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx+
        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-
        Latency: 0
        Interrupt: pin A routed to IRQ 45      #中断管脚和中断号
        Region 0: Memory at 90000000 (64-bit, non-prefetchable) [size=8K]  #设备占用的地址空间
        Capabilities: [c8] Power Management version 3
                Flags: PMEClk- DSI+ D1- D2- AuxCurrent=0mA PME(D0+,D1-,D2-,D3hot+,D3cold+)
                Status: D0 NoSoftRst- PME-Enable- DSel=0 DScale=0 PME-
        Capabilities: [d0] MSI: Enable+ Count=1/1 Maskable- 64bit+
                Address: 00000000fee0100c  Data: 4191
        Capabilities: [e0] Express (v1) Endpoint, MSI 00
                DevCap: MaxPayload 128 bytes, PhantFunc 0, Latency L0s &lt;512ns, L1 unlimited
                        ExtTag- AttnBtn- AttnInd- PwrInd- RBE+ FLReset+
                DevCtl: Report errors: Correctable- Non-Fatal- Fatal- Unsupported-
                        RlxdOrd+ ExtTag- PhantFunc- AuxPwr- NoSnoop+ FLReset-
                        MaxPayload 128 bytes, MaxReadReq 128 bytes
                DevSta: CorrErr+ UncorrErr- FatalErr- UnsuppReq+ AuxPwr+ TransPend-
                LnkCap: Port #0, Speed 2.5GT/s, Width x1, ASPM L0s L1, Latency L0 &lt;4us, L1 &lt;32us
                        ClockPM+ Surprise- LLActRep- BwNot-
                LnkCtl: ASPM Disabled; RCB 64 bytes Disabled- Retrain- CommClk+
                        ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt-
                LnkSta: Speed 2.5GT/s, Width x1, TrErr- Train- SlotClk+ DLActive- BWMgmt- ABWMgmt-
        Capabilities: [100 v1] Advanced Error Reporting
                UESta:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-
                UEMsk:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-
                UESvrt: DLP+ SDES- TLP- FCP+ CmpltTO- CmpltAbrt- UnxCmplt- RxOF+ MalfTLP+ ECRC- UnsupReq- ACSViol-
                CESta:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- NonFatalErr+
                CEMsk:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- NonFatalErr+
                AERCap: First Error Pointer: 00, GenCap- CGenEn- ChkCap- ChkEn-
        Capabilities: [140 v1] Device Serial Number 10-0b-a9-ff-ff-b4-93-2c
        Kernel driver in use: iwlwifi   #设备驱动
        Kernel modules: iwlwifi
</code></pre>

<p>查看该设备的配置空间：</p>

<pre><code># lspci -s 01:00.0 -x 
01:00.0 Network controller: Intel Corporation Centrino Advanced-N 6205 [Taylor Peak] (rev 34)
00: 86 80 82 00 06 04 10 00 34 00 80 02 00 00 00 00
10: 04 00 00 90 00 00 00 00 00 00 00 00 00 00 00 00
20: 00 00 00 00 00 00 00 00 00 00 00 00 86 80 01 13
30: 00 00 00 00 c8 00 00 00 00 00 00 00 ff 01 00 00
</code></pre>

<p>通过 /sys 文件系统可以查看更多信息，/sys/bus/pci/ 目录包含的主要文件：</p>

<ul>
<li>devices：目录，包含所有 PCI 设备的文件夹</li>
<li>drivers ：目录，包含所有 PCI 设备所用的驱动</li>
<li>rescan : 文件，只写，写入一个非零值会导致系统重新扫描所有的 PCI 总线设备</li>
</ul>

<p>在 /sys/bus/pci/devices 下可以查看所有的 PCI 总线设备：</p>

<pre><code>root@WR-IntelligentDevice:/sys/bus/pci/devices# ls -l
total 0
lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:00.0 -&gt; ../../../devices/pci0000:00/0000:00:00.0
lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:14.0 -&gt; ../../../devices/pci0000:00/0000:00:14.0
lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:14.1 -&gt; ../../../devices/pci0000:00/0000:00:14.1
lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:14.2 -&gt; ../../../devices/pci0000:00/0000:00:14.2
lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:14.3 -&gt; ../../../devices/pci0000:00/0000:00:14.3
lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:14.4 -&gt; ../../../devices/pci0000:00/0000:00:14.4
lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:14.5 -&gt; ../../../devices/pci0000:00/0000:00:14.5
lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:14.6 -&gt; ../../../devices/pci0000:00/0000:00:14.6
lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:14.7 -&gt; ../../../devices/pci0000:00/0000:00:14.7
lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:15.0 -&gt; ../../../devices/pci0000:00/0000:00:15.0
lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:15.1 -&gt; ../../../devices/pci0000:00/0000:00:15.1
lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:15.2 -&gt; ../../../devices/pci0000:00/0000:00:15.2
lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:17.0 -&gt; ../../../devices/pci0000:00/0000:00:17.0
lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:17.1 -&gt; ../../../devices/pci0000:00/0000:00:17.1
lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:1f.0 -&gt; ../../../devices/pci0000:00/0000:00:1f.0
lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:01:00.0 -&gt; ../../../devices/pci0000:00/0000:00:17.0/0000:01:00.0
</code></pre>

<p>目录名称的结构是 PCI 域:总线号:设备号:功能号，PCI 域是 Linux 为了容纳更多总线设备而添加的概念。可以看出 <code>0000:01:00.0</code> 是 <code>0000:00:17.0</code> PCI 桥扩展的 PCI Bus #1 下的设备，而其他设备都在 Host bridge 下。进入目录 <code>0000:01:00.0</code>，可以看到 sys 文件系统已经把配置空间解析，并分别显示到各个文件中，主要文件的类型和功能：</p>

<ul>
<li>class：PCI class (ascii, ro)</li>
<li>config：PCI 配置空间 (binary, rw)，可以用 hexdum 命令查看</li>
<li>device    ：PCI device id (ascii, ro)</li>
<li>vendor：PCI vendor id (ascii, ro)</li>
<li>enable：设备是否已经使能，1 表示激活，0 表示禁用 (ascii, rw)</li>
<li>irq：IRQ number (ascii, ro)</li>
<li>remove：从内核中删除该设备(ascii, wo)</li>
<li>resource：PCI 设备分配的内存资源 (ascii, ro)</li>
<li>resource0..N：PCI resource N (binary, mmap, rw[1])</li>
<li>driver：设备驱动（dir, rw)</li>
</ul>

<p>我们可以向 0000:01:00.0/remove 文件写 1 ，删除该设备，再向 0000:00:17.0/rescan 写 1 ，重新扫描添加该设备：</p>

<pre><code>/sys/bus/pci/devices# echo 1 &gt; 0000\:01\:00.0/remove 
/sys/bus/pci/devices# ls 
0000:00:00.0  0000:00:14.2  0000:00:14.5  0000:00:15.0  0000:00:17.0
0000:00:14.0  0000:00:14.3  0000:00:14.6  0000:00:15.1  0000:00:17.1
0000:00:14.1  0000:00:14.4  0000:00:14.7  0000:00:15.2  0000:00:1f.0
/sys/bus/pci/devices# echo 1 &gt; 0000\:00\:17.0/rescan 
/sys/bus/pci/devices# ls 
0000:00:00.0  0000:00:14.3  0000:00:14.7  0000:00:17.0
0000:00:14.0  0000:00:14.4  0000:00:15.0  0000:00:17.1
0000:00:14.1  0000:00:14.5  0000:00:15.1  0000:00:1f.0
0000:00:14.2  0000:00:14.6  0000:00:15.2  0000:01:00.0
</code></pre>

<p>在 driver 目录下访问设备驱动，例如 <code>01:00.0 Network controller</code> 是一个 Wi-Fi 网卡，可以看出它用的驱动是 iwlwifi ：</p>

<pre><code>/sys/bus/pci/devices/0000:01:00.0/driver# ls -l
total 0
lrwxrwxrwx 1 root root    0 Nov 29 10:02 0000:01:00.0 -&gt; ../../../../devices/pci0000:00/0000:00:17.0/0000:01:00.0
--w------- 1 root root 4096 Nov 29 10:02 bind
lrwxrwxrwx 1 root root    0 Nov 29 10:02 module -&gt; ../../../../module/iwlwifi
--w------- 1 root root 4096 Nov 29 10:02 new_id
--w------- 1 root root 4096 Nov 29 10:02 remove_id
--w------- 1 root root 4096 Nov 27 12:02 uevent
--w------- 1 root root 4096 Nov 29 10:02 unbind
</code></pre>

<p>在 module/parameters 可以读取驱动的各项参数：</p>

<pre><code>/sys/bus/pci/devices/0000:01:00.0/driver/module/parametrs# ls -l
total 0
-r--r--r-- 1 root root 4096 Nov 29 10:03 11n_disable
-r--r--r-- 1 root root 4096 Nov 29 10:03 amsdu_size_8K
-r--r--r-- 1 root root 4096 Nov 29 10:03 antenna_coupling
-r--r--r-- 1 root root 4096 Nov 29 10:03 bt_coex_active
-r--r--r-- 1 root root 4096 Nov 29 10:03 fw_restart
-r--r--r-- 1 root root 4096 Nov 29 10:03 led_mode
-r--r--r-- 1 root root 4096 Nov 29 10:03 nvm_file
-r--r--r-- 1 root root 4096 Nov 29 10:03 power_level
-r--r--r-- 1 root root 4096 Nov 29 10:03 power_save
-r--r--r-- 1 root root 4096 Nov 29 10:03 swcrypto
-r--r--r-- 1 root root 4096 Nov 29 10:03 wd_disable
/sys/bus/pci/devices/0000:01:00.0/driver/module/parametrs# cat 11n_disable 
0
</code></pre>

<h3 id="3-2-kernel">3.2. kernel</h3>

<p>Linux 内核通过 CF8/CFC 端口读写 PCI 配置空间，实现函数是 /arch/x86/pci/direct.c 文件的 <code>pci_conf1_read()</code> 和 <code>pci_conf1_write()</code> ：</p>

<pre><code>#define PCI_CONF1_ADDRESS(bus, devfn, reg)  (0x80000000 | ((reg &amp; 0xF00) &lt;&lt; 16) | (bus &lt;&lt; 16) | (devfn &lt;&lt; 8) | (reg &amp; 0xFC))

static int pci_conf1_read(unsigned int seg, unsigned int bus, unsigned int devfn, int reg, int len, u32 *value)
{
    unsigned long flags;

    if (seg || (bus &gt; 255) || (devfn &gt; 255) || (reg &gt; 4095)) {
        *value = -1;
        return -EINVAL;
    }

    raw_spin_lock_irqsave(&amp;pci_config_lock, flags);

    outl(PCI_CONF1_ADDRESS(bus, devfn, reg), 0xCF8);

    switch (len) {
    case 1:
        *value = inb(0xCFC + (reg &amp; 3));
        break;
    case 2:
        *value = inw(0xCFC + (reg &amp; 2));
        break;
    case 4:
        *value = inl(0xCFC);
        break;
    }

    raw_spin_unlock_irqrestore(&amp;pci_config_lock, flags);

    return 0;
}

static int pci_conf1_write(unsigned int seg, unsigned int bus, unsigned int devfn, int reg, int len, u32 value)
{
    unsigned long flags;

    if (seg || (bus &gt; 255) || (devfn &gt; 255) || (reg &gt; 4095))
        return -EINVAL;

    raw_spin_lock_irqsave(&amp;pci_config_lock, flags);

    outl(PCI_CONF1_ADDRESS(bus, devfn, reg), 0xCF8);

    switch (len) {
    case 1:
        outb((u8)value, 0xCFC + (reg &amp; 3));
        break;
    case 2:
        outw((u16)value, 0xCFC + (reg &amp; 2));
        break;
    case 4:
        outl((u32)value, 0xCFC);
        break;
    }

    raw_spin_unlock_irqrestore(&amp;pci_config_lock, flags);

    return 0;
}
</code></pre>

<p>访问 PCIe 扩展的配置空间需要用 <code>pci_conf2_read()</code> 和 <code>pci_conf2_write()</code> 函数。</p>

<h2 id="4-pci-设备的枚举过程">4. PCI 设备的枚举过程</h2>

<p>系统上电后，会采用深度优先算法，从 Host Bridge 开始对所有的 PCI/PCIe 设备进行扫描，其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。这个过程为 PCI 设备枚举。枚举过程中，系统通过配置读事物包来获取下游设备的信息，通过配置写事物包对下游设备进行设置。以下图为例：</p>

<p><img src="/images/2017-11-27/2017-11-27_5.jpeg" alt="" /></p>

<p>PCI 设备体系是一个树形结构，Host Bridge 扩展的总线为 Bus 0 ，然后从左开始向下搜索，每个 Bridge 扩展一条总线，依次以数字顺序从小到大命名 Bus ID ，向下到尽头后退回。如果去掉了上图的 Bus 3 ，后面设备的 Bus ID 都会发生改变，并向前递进。</p>

<p>在 Linux 系统中，可以用 <code>lspci -t</code> 命令查询系统枚举到的 PCI 设备，结果以树形显示依赖关系，例如：</p>

<pre><code>root@localhost:~# lspci -t -v
-[0000:00]-+-00.0  Intel Corporation Atom Processor Z36xxx/Z37xxx Series SoC Transaction Register
           +-02.0  Intel Corporation Atom Processor Z36xxx/Z37xxx Series Graphics &amp; Display
           +-11.0  Intel Corporation Atom Processor Z36xxx/Z37xxx Series SDIO Controller
           +-12.0  Intel Corporation Atom Processor Z36xxx/Z37xxx Series SDIO Controller
           +-13.0  Intel Corporation Atom Processor E3800 Series SATA AHCI Controller
           +-17.0  Intel Corporation Atom Processor E3800 Series eMMC 4.5 Controller
           +-1a.0  Intel Corporation Atom Processor Z36xxx/Z37xxx Series Trusted Execution Engine
           +-1b.0  Intel Corporation Atom Processor Z36xxx/Z37xxx Series High Definition Audio Controller
           +-1c.0-[01]----00.0  Intel Corporation I210 Gigabit Network Connection
           +-1c.1-[02]----00.0  Intel Corporation I210 Gigabit Network Connection
           +-1c.2-[03]----00.0  Intel Corporation Wireless 3165
           +-1c.3-[04]----00.0  Intel Corporation 82574L Gigabit Network Connection
           +-1d.0  Intel Corporation Atom Processor Z36xxx/Z37xxx Series USB EHCI
           +-1f.0  Intel Corporation Atom Processor Z36xxx/Z37xxx Series Power Control Unit
           \-1f.3  Intel Corporation Atom Processor E3800 Series SMBus Controller
root@localhost:~# lspci
00:00.0 Host bridge: Intel Corporation Atom Processor Z36xxx/Z37xxx Series SoC Transaction Register (rev 11)
00:02.0 VGA compatible controller: Intel Corporation Atom Processor Z36xxx/Z37xxx Series Graphics &amp; Display (rev 11)
00:11.0 SD Host controller: Intel Corporation Atom Processor Z36xxx/Z37xxx Series SDIO Controller (rev 11)
00:12.0 SD Host controller: Intel Corporation Atom Processor Z36xxx/Z37xxx Series SDIO Controller (rev 11)
00:13.0 SATA controller: Intel Corporation Atom Processor E3800 Series SATA AHCI Controller (rev 11)
00:17.0 SD Host controller: Intel Corporation Atom Processor E3800 Series eMMC 4.5 Controller (rev 11)
00:1a.0 Encryption controller: Intel Corporation Atom Processor Z36xxx/Z37xxx Series Trusted Execution Engine (rev 11)
00:1b.0 Audio device: Intel Corporation Atom Processor Z36xxx/Z37xxx Series High Definition Audio Controller (rev 11)
00:1c.0 PCI bridge: Intel Corporation Atom Processor E3800 Series PCI Express Root Port 1 (rev 11)
00:1c.1 PCI bridge: Intel Corporation Atom Processor E3800 Series PCI Express Root Port 2 (rev 11)
00:1c.2 PCI bridge: Intel Corporation Atom Processor E3800 Series PCI Express Root Port 3 (rev 11)
00:1c.3 PCI bridge: Intel Corporation Atom Processor E3800 Series PCI Express Root Port 4 (rev 11)
00:1d.0 USB controller: Intel Corporation Atom Processor Z36xxx/Z37xxx Series USB EHCI (rev 11)
00:1f.0 ISA bridge: Intel Corporation Atom Processor Z36xxx/Z37xxx Series Power Control Unit (rev 11)
00:1f.3 SMBus: Intel Corporation Atom Processor E3800 Series SMBus Controller (rev 11)
01:00.0 Ethernet controller: Intel Corporation I210 Gigabit Network Connection (rev 03)
02:00.0 Ethernet controller: Intel Corporation I210 Gigabit Network Connection (rev 03)
03:00.0 Network controller: Intel Corporation Wireless 3165 (rev 81)
04:00.0 Ethernet controller: Intel Corporation 82574L Gigabit Network Connection
</code></pre>

<p>可以看出，Bus 1~Bus 4 是通过 <code>00:1c.0~00:1c.3</code> 四个 Bridge 设备扩展的。</p>

<h2 id="5-参考">5. 参考</h2>

<ul>
<li><a href="https://zhuanlan.zhihu.com/p/26172972" target="_blank">深入PCI与PCIe之一：硬件篇</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26244141" target="_blank">深入PCI与PCIe之二：软件篇</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1458755" target="_blank">PCIe 设备的枚举过程</a></li>
<li><a href="https://en.wikipedia.org/wiki/PCI_configuration_space" target="_blank">PCI configuration space</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/filesystems/sysfs-pci.txt" target="_blank">sysfs-pci.txt</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/ABI/testing/sysfs-bus-pci" target="_blank">sysfs-bus-pci</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Appweb 学习笔记</title>
            <link>https://shaocheng.li/posts/2017/11/24/</link>
            <pubDate>Fri, 24 Nov 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/11/24/</guid>
            <description>1. 概述 Appweb 是一个快速、高效、安全的开源嵌入式 web server ，同时包含了 ESP web 框架和一系列扩展支持，可以极大的缩短开放时间，官网：https://embedthis.com/ ，包含如下组件：
 HTTP web server 程序和库 HTTP client 程序和库 管理和监视进程 ESP web 框架 可选的 CGI、Ejscript、ESP 和 PHP 模块 SSL/TLS 支持包 文档和源码  特性：
 快速开发。Appweb 提供最简单、最低消耗的开发 web 应用方法，它包含了嵌入式 web 应用开发所需的全部特性，极大的缩短了开发时间。 最小的资源需求。Appweb 非常简洁和快速，只需要极小的系统资源，最小只需 2MB 的存储空间，运行时最少只需 1MB 内存。 可定制的开发环境。Appweb 高度模块化，你可以只选择所需的特性，并且支持运行时模块加载和编译时控制。 安全可靠。支持 SSL/TLS，提供最基本的验证，沙盒限制，访问和错误日志。 性能。事件驱动的多线程核心提供了最快的响应，。 标准化。Appweb 支持 HTTP/1.0 、HTTP/1.1 、CGI/1.1 、SSL RFC 2246 、HTTP RFC 2617 。 可移植。Appweb 支持 Linux 、Windows 、Mac OSX ，支持 ARM 、MIPS 、i386/X86/X86_64 、PowerPC 等。  2.</description>
            <content type="html"><![CDATA[

<h2 id="1-概述">1. 概述</h2>

<p>Appweb 是一个快速、高效、安全的开源嵌入式 web server ，同时包含了 ESP web 框架和一系列扩展支持，可以极大的缩短开放时间，官网：<a href="https://embedthis.com/" target="_blank">https://embedthis.com/</a> ，包含如下组件：</p>

<ul>
<li>HTTP web server 程序和库</li>
<li>HTTP client 程序和库</li>
<li>管理和监视进程</li>
<li>ESP web 框架</li>
<li>可选的 CGI、Ejscript、ESP 和 PHP 模块</li>
<li>SSL/TLS 支持包</li>
<li>文档和源码</li>
</ul>

<p><img src="/images/2017-11-24/2017-11-24_1.jpg" alt="" /></p>

<p>特性：</p>

<ul>
<li>快速开发。Appweb 提供最简单、最低消耗的开发 web 应用方法，它包含了嵌入式 web 应用开发所需的全部特性，极大的缩短了开发时间。</li>
<li>最小的资源需求。Appweb 非常简洁和快速，只需要极小的系统资源，最小只需 2MB 的存储空间，运行时最少只需 1MB 内存。</li>
<li>可定制的开发环境。Appweb 高度模块化，你可以只选择所需的特性，并且支持运行时模块加载和编译时控制。</li>
<li>安全可靠。支持 SSL/TLS，提供最基本的验证，沙盒限制，访问和错误日志。</li>
<li>性能。事件驱动的多线程核心提供了最快的响应，。</li>
<li>标准化。Appweb 支持 HTTP/1.0 、HTTP/1.1 、CGI/1.1 、SSL RFC 2246 、HTTP RFC 2617 。</li>
<li>可移植。Appweb 支持 Linux 、Windows 、Mac OSX ，支持 ARM 、MIPS 、i386/X86/X86_64 、PowerPC 等。</li>
</ul>

<h2 id="2-安装">2. 安装</h2>

<p>Appweb 以源码形式在 github 上发布：<a href="https://github.com/embedthis/appweb" target="_blank">https://github.com/embedthis/appweb</a> ，支持的运行环境：</p>

<ul>
<li>Linux — Linux 2.6 with GNU C/C++</li>
<li>Windows — Microsoft Windows 7 with Visual Studio 2010 or later</li>
<li>Mac OS X — Mac OS X 10.8 (Mountain Lion) or later</li>
</ul>

<p>下载后解压，在源码目录下执行 make ，编译完成后生成的文件都在 build 目录下:</p>

<pre><code>~/appweb-7.0.1 $ cd build/linux-x64-default/bin
~/appweb-7.0.1/build/linux-x64-default/bin $ ls
appman           ca.key           libappweb.dylib  libmpr-version.a self.crt
appweb           ec.crt           libesp.dylib     libmpr.dylib     self.key
appweb-esp       ec.key           libhttp.dylib    libpcre.dylib    test.crt
authpass         esp-compile.json libmbedtls.a     makerom          test.key
ca.crt           http             libmpr-mbedtls.a roots.crt        vcvars.bat
</code></pre>

<p>然后执行 <code>make install</code> 安装到本地，安装时执行的脚本是 projects/appweb-linux-default.mk ，二进制文件默认都安装在 /usr/local/lib/appweb/ 目录下。安装完成后会自动启动 appweb 。如果想要部署到其他系统，可以执行 <code>make deploy</code> ，会将所有需要安装的文件都输出到 linux-x64-default 目录下。当然还可以交叉编译，常用系统的编译文件都在 projects 目录下，可以用 ARCH 设置目标机的 CPU ，用 CC、CFLAGS、DFLAGS、LD 和 LDFLAGS 等参数设置自己的交叉编译工具链。卸载可以用 <code>make uninstall</code> 。</p>

<h2 id="3-运行">3. 运行</h2>

<p>安装后，会自动在 /etc/init.d 下新建一个 appweb 服务，appweb 会作为系统守护进程自动启动，错误日志位于 /var/log/appweb/ 目录下：</p>

<p>$ ps -ef | grep appweb
root      6501     1  0 13:44 ?        00:00:00 /usr/local/bin/appman &ndash;daemon &ndash;program /usr/local/bin/appweb &ndash;home /etc/appweb &ndash;pidfile /var/run/appweb.pid run
nobody    6505  6501  0 13:44 ?        00:00:00 /usr/local/bin/appweb &ndash;log stdout:1
 $ sudo lsof -i | grep appweb
appweb    6505 nobody    6u  IPv6 1444273      0t0  TCP *:http (LISTEN)
appweb    6505 nobody    7u  IPv6 1444274      0t0  TCP *:https (LISTEN)</p>

<p>如果发现启动不成功，可以查看一下 /etc/appweb/install.conf 文件，把第一行开头的 -e 去掉，然后重启。启动成后通过浏览器访问主机 IP 即可显示默认页面：</p>

<p><img src="/images/2017-11-24/2017-11-24_2.png" alt="" />
Appweb 提供了一个管理工具 appman ，它可以将 appweb 作为一个守护进程启动，还可以管理 appweb 的运行。appweb 的语法是 <code>appweb  [option]</code> ，可用的选项有：</p>

<ul>
<li>&ndash;config filename，指定配置文件替代默认的 appweb.conf.</li>
<li>&ndash;chroot directory ，改变 Appweb 运行的系统根目录，导致 Appweb 无法访问该目录之外的其他文件。</li>
<li>&ndash;debugger，启动 debug.</li>
<li>&ndash;log logSpec ，指定 log 文件。此选项会覆盖配置文件中的 ErrorLog ，logSpec 的语法是 logName[:logLevel][.maxSize] 。当 log 文件的大小超过 maxSize 时，会将 log 文件备份为 logName.old ，再新建一个 logName 。logLevel 是一个 0~9 的数字，0 表示最少的 log 信息。该选项可以缩写为 -l 。</li>
<li>&ndash;home directory ，指定服务器的根目录，该目录包含 Appweb 的配置文件。</li>
<li>&ndash;name uniqueName ，设置程序名称，当同时运行多个 appweb 实例时，可以为当前程序指定唯一名称。</li>
<li>&ndash;threads ，设置线程号。</li>
<li>&ndash;verbose ，&ndash;log stderr:2 的缩写，可以进一步缩写为 -v 。</li>
<li>&ndash;version ，显示 appweb 版本。</li>
</ul>

<p>如果启动 appweb 时指定了 IP 和端口，就不会去读取默认的 appweb.conf 文件，语法是：</p>

<pre><code>appweb  [IP]:[PORT]  [documents]
</code></pre>

<p>如果没有指定端口，默认会监听 80 端口。如果没有指定 IP，默认会监听所有 IP 。documents 用于指定 web 页面的目录。如果没有指定配置文件，appweb 会使用一个默认的最简配置。</p>

<h2 id="4-配置">4. 配置</h2>

<p>appweb 的配置文件管理着监听的 IP 和端口，要加载的模块，Web 页面的位置，如何记录日志等。置顶的配置文件默认叫做 appweb.conf，允许用 include 语句导入子配置文件。配置文件中每一行设置一个选项，用井号 # 表示注释。一份配置文件是由多种选项构成的：</p>

<ul>
<li>全局选项</li>
<li>Route 选项块</li>
<li>Virtual Host 选项块</li>
<li>条件选项块</li>
</ul>

<p>没有被任何选项块包含的选项就是全局选项，定义一些 appweb 的全局属性。Route 选项块用 <Route "URL"></Route> 标签标识，用于设置特定的 URL，例如：</p>

<pre><code>&lt;Route &quot;/myapp/&quot;&gt;
    SetHandler esp
&lt;/Route&gt;
</code></pre>

<p>它表示以 &ldquo;/myapp/&rdquo; 开头的 URL 请求转给 esp 处理。</p>

<p>Virtual Host 选项块用 <VirtualHost></VirtualHost> 标签标识，用于定义虚拟子服务，将虚拟子服务的内容与 IP 或者域名绑定，例如：</p>

<pre><code>&lt;VirtualHost&gt;
    ServerName www.mycorp.org
    Documents /var/www/mycorp
    ...
&lt;/VirtualHost&gt;
</code></pre>

<p>条件选项块用 <if SYMBOL></if> 标签标识，读取配置文件时会判断 SYMBOL 的值，如果为 true 就会加载这些选项，否则就会忽略，例如：</p>

<pre><code>&lt;if FILE_MODULE&gt;
    LoadModule fileHandler mod_file
&lt;/if&gt;
</code></pre>

<p>appweb 支持两种条件选项块：</p>

<ul>
<li>BLD_DEBUG ：如果 appweb 使能了 DEBUG ，该符号为 true</li>
<li>NAME_MODULE ：如果使能了 NAME_MODULE 模块，该符号为 true</li>
</ul>

<p>整个配置文件是从头到尾被读取的，所有要注意各选项的排列顺序。说有选项的列表：<a href="https://embedthis.com/appweb/doc/users/directives.html" target="_blank">https://embedthis.com/appweb/doc/users/directives.html</a></p>

<h2 id="5-开发">5. 开发</h2>

<p>Appweb 提供了三种应用开发方式：</p>

<ol>
<li>开发额外的模块，由 appweb 程序加载</li>
<li>用 ESP web 框架开发一个应用，有 appweb 程序加载</li>
<li>在自己的程序中使用 Appweb 的 HTTP library 开发应用</li>
</ol>

<p>Appweb 包含了四个可加载的模块：CGI 、ESP 、PHP 和 SSL 。我们可以开发自己的模块，扩展功能，appweb 支持动态加载和静态链接两种方式调用模块，使用 C 语言接口。新建一个模块时，首先要新建一个初始化函数，格式如下：</p>

<pre><code>maNameInit(Http *http, MprModule *module)
</code></pre>

<p>Name 可以替换成模块的名字，第一个字母必须大写，例如 <code>maCgiHandlerInit</code> 可以做为 CgiHandler 模块的初始化接口，appweb 加载  CgiHandler  的时候首先调用这个函数。</p>

<p>新建自己的 Handler ，处理 Http 请求。Handler 通常包含在模块里，然后在配置文件里设置，用 LoadModule 命令加载模块，每一个  handler 对应一种 Http 请求，在 Route 选项块里用  AddHandler 或者 SetHandler 命令设置，例如：</p>

<pre><code>LoadModule myHandler mod_my
&lt;Route /my/&gt;
    SetHandler myHandler
&lt;/Route&gt;
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>用 seafile 自建云存储</title>
            <link>https://shaocheng.li/posts/2017/11/18/</link>
            <pubDate>Sat, 18 Nov 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/11/18/</guid>
            <description>Seafile 是一款开源的企业云盘，注重可靠性和性能。支持 Windows, Mac, Linux, iOS, Android 平台。支持文件同步或者直接挂载到本地访问，国人开发，官方网站：https://www.seafile.com 。
1. 部署 Seafile 服务器 我的云服务器是 Ubuntu Server 16.04.1 LTS 64位 ，新建一个工作目录 ~/seafile ，下载最新的服务器安装包 seafile-server_6.2.3_x86-64.tar.gz 到该目录，然后在该目录下做如下工作：
mkdir installed mv seafile-server_6.2.3_x86-64.tar.gz installed tar xvf installed/seafile-server_6.2.3_x86-64.tar.gz  现在的目录结构如下：
$ tree -L 2 . |-- installed | `-- seafile-server_6.2.3_x86-64.tar.gz |-- seafile-server-6.2.3 | |-- check_init_admin.py | |-- reset-admin.sh | |-- runtime | |-- seaf-fsck.sh | |-- seaf-fuse.sh | |-- seaf-gc.sh | |-- seafile | |-- seafile.</description>
            <content type="html"><![CDATA[

<p>Seafile 是一款开源的企业云盘，注重可靠性和性能。支持 Windows, Mac, Linux, iOS, Android 平台。支持文件同步或者直接挂载到本地访问，国人开发，官方网站：<a href="https://www.seafile.com" target="_blank">https://www.seafile.com</a> 。</p>

<h2 id="1-部署-seafile-服务器">1. 部署 Seafile 服务器</h2>

<p>我的云服务器是 Ubuntu Server 16.04.1 LTS 64位 ，新建一个工作目录 ~/seafile ，下载最新的服务器安装包 seafile-server_6.2.3_x86-64.tar.gz 到该目录，然后在该目录下做如下工作：</p>

<pre><code>mkdir installed
mv seafile-server_6.2.3_x86-64.tar.gz  installed
tar xvf installed/seafile-server_6.2.3_x86-64.tar.gz
</code></pre>

<p>现在的目录结构如下：</p>

<pre><code>$ tree -L 2
.
|-- installed
|   `-- seafile-server_6.2.3_x86-64.tar.gz
|-- seafile-server-6.2.3
|   |-- check_init_admin.py
|   |-- reset-admin.sh
|   |-- runtime
|   |-- seaf-fsck.sh
|   |-- seaf-fuse.sh
|   |-- seaf-gc.sh
|   |-- seafile
|   |-- seafile.sh
|   |-- seahub
|   |-- seahub.sh
|   |-- setup-seafile-mysql.py
|   |-- setup-seafile-mysql.sh
|   |-- setup-seafile.sh
|   `-- upgrade
</code></pre>

<p>安装前先确认已经安装了如下包，也可以安装是根据提示补装：</p>

<pre><code>python 2.7
python-setuptools
python-imaging
python-ldap
python-urllib3
sqlite3
</code></pre>

<p>然后开始安装：</p>

<pre><code>cd seafile-server-6.2.3/
./setup-seafile.sh
</code></pre>

<p>根据提示配置如下选项：</p>

<ul>
<li>seafile server name ，seafile 服务器的名称</li>
<li>seafile server ip or domain ，seafile 服务器的 IP 或者域名</li>
<li>seafile data dir ，seafile 数据存放的目录</li>
<li>seafile fileserver port ，seafile 服务使用的 TCP 端口，默认是 8082</li>
</ul>

<p>安装成功后的目录结构是这样的：</p>

<pre><code>$ tree -L 1
.
|-- ccnet
|-- conf
|-- installed
|-- seafile-server-6.2.3
|-- seafile-server-latest -&gt; seafile-server-6.2.3
|-- seahub-data
`-- seahub.db

6 directories, 1 file
</code></pre>

<h2 id="2-启动-seafile-服务器">2. 启动 Seafile 服务器</h2>

<p>在 seafile-server-latest 目录下执行如下命令：</p>

<ul>
<li>启动 seafile 服务： <code>./seafile.sh start</code></li>
<li>启动 seahub 服务： <code>./seahub.sh start &lt;port&gt;</code> ，默认运行在 8000 端口，第一次启动时会要求新建一个管理员账户</li>
</ul>

<p>服务启动后, 打开浏览器并输入以下地址:</p>

<pre><code>http://&lt;server ip&gt;:8000
</code></pre>

<p>在打开的登录界面上输入之前创建的管理员帐号的用户名/密码即可。如果不想用 8000 端口，先修改 conf/ccnet.conf 文件中的 SERVICE_URL ，将端口号改为你想要的，比如 8001 :</p>

<pre><code>SERVICE_URL = http://&lt;server ip&gt;:8001
</code></pre>

<p>然后用新的端口号重启服务。</p>

<h2 id="3-开机自启动">3. 开机自启动</h2>

<p>创建 seafile 的 systemd 服务文件：</p>

<pre><code>sudo vim /etc/systemd/system/seafile.service
</code></pre>

<p>内容如下，将 ${seafile_dir} 替换为 seafile 安装路径，并且将 user 和 group 指向真正运行 seafile 的用户：</p>

<pre><code>[Unit]
Description=Seafile
# add mysql.service or postgresql.service depending on your database to the line below
After=network.target

[Service]
Type=oneshot
ExecStart=${seafile_dir}/seafile-server-latest/seafile.sh start
ExecStop=${seafile_dir}/seafile-server-latest/seafile.sh stop
RemainAfterExit=yes
User=seafile
Group=seafile

[Install]
WantedBy=multi-user.target
</code></pre>

<p>创建 seahub 的 systemd 服务文件：</p>

<pre><code>sudo vim /etc/systemd/system/seahub.service
</code></pre>

<p>内容如下，将 ${seafile_dir} 替换为 seafile 安装路径，<port> 替换需要的端口，并且将 user 和 group 指向真正运行 seafile 的用户，：</p>

<pre><code>[Unit]
Description=Seafile hub
After=network.target seafile.service

[Service]
# change start to start-fastcgi if you want to run fastcgi
ExecStart=${seafile_dir}/seafile-server-latest/seahub.sh start &lt;port&gt;
ExecStop=${seafile_dir}/seafile-server-latest/seahub.sh stop
User=seafile
Group=seafile
Type=oneshot
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
</code></pre>

<p>使能开机自启动：</p>

<pre><code>sudo systemctl enable seafile.service
sudo systemctl enable seahub.service
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>用 Supervisor 管理进程</title>
            <link>https://shaocheng.li/posts/2017/11/09/</link>
            <pubDate>Thu, 09 Nov 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/11/09/</guid>
            <description>Supervisor 是一个 Python 编写的进程管理工具，可以帮助我们实现进程的启动、关闭和重启，可以对多个进程独立管理，或者分组管理，通常用于 Linux 服务器的进程管理，官方网站 supervisord.org 。有两个主要的组成部分：
 supervisord，运行 Supervisor 时会启动一个进程 supervisord，它负责启动所管理的进程，并将所管理的进程作为自己的子进程来启动，而且可以在所管理的进程出现崩溃时自动重启。 supervisorctl，命令行管理工具，可以用来执行 stop、start、restart 等命令，来对这些子进程进行管理。  1. 安装 可以用 pip 安装：
sudo pip install supervisor  如果是 Ubuntu 系统，也可以用 apt-get ：
sudo apt-get install supervisor  2. 配置 安装成功后，需要手动生成一个配置文件，安装包提供了 echo_supervisord_conf 工具完成这项工作：
sudo echo_supervisord_conf &amp;gt; /etc/supervisord.conf  出去注释部分，一些有用的配置选项：
[unix_http_server] file=/tmp/supervisor.sock ; UNIX socket 文件，supervisorctl 会使用 [supervisord] logfile=/tmp/supervisord.log ; 日志文件，默认是 $CWD/supervisord.log logfile_maxbytes=50MB ; 日志文件大小，超出会 rotate，默认 50MB logfile_backups=10 ; 日志文件保留备份数量默认 10 loglevel=info ; 日志级别，默认 info，其它: debug,warn,trace pidfile=/tmp/supervisord.</description>
            <content type="html"><![CDATA[

<p>Supervisor 是一个 Python 编写的进程管理工具，可以帮助我们实现进程的启动、关闭和重启，可以对多个进程独立管理，或者分组管理，通常用于 Linux 服务器的进程管理，官方网站 <a href="http://supervisord.org" target="_blank">supervisord.org</a> 。有两个主要的组成部分：</p>

<ul>
<li>supervisord，运行 Supervisor 时会启动一个进程 supervisord，它负责启动所管理的进程，并将所管理的进程作为自己的子进程来启动，而且可以在所管理的进程出现崩溃时自动重启。</li>
<li>supervisorctl，命令行管理工具，可以用来执行 stop、start、restart 等命令，来对这些子进程进行管理。</li>
</ul>

<h2 id="1-安装">1. 安装</h2>

<p>可以用 pip 安装：</p>

<pre><code>sudo pip install supervisor
</code></pre>

<p>如果是 Ubuntu 系统，也可以用 apt-get ：</p>

<pre><code>sudo apt-get install supervisor
</code></pre>

<h2 id="2-配置">2. 配置</h2>

<p>安装成功后，需要手动生成一个配置文件，安装包提供了 <code>echo_supervisord_conf</code> 工具完成这项工作：</p>

<pre><code>sudo echo_supervisord_conf &gt; /etc/supervisord.conf
</code></pre>

<p>出去注释部分，一些有用的配置选项：</p>

<pre><code>[unix_http_server]
file=/tmp/supervisor.sock   ; UNIX socket 文件，supervisorctl 会使用

[supervisord]
logfile=/tmp/supervisord.log ; 日志文件，默认是 $CWD/supervisord.log
logfile_maxbytes=50MB        ; 日志文件大小，超出会 rotate，默认 50MB
logfile_backups=10           ; 日志文件保留备份数量默认 10
loglevel=info                ; 日志级别，默认 info，其它: debug,warn,trace
pidfile=/tmp/supervisord.pid ; pid 文件
nodaemon=false               ; 是否在前台启动，默认是 false，即以 daemon 的方式启动
minfds=1024                  ; 可以打开的文件描述符的最小值，默认 1024
minprocs=200                 ; 可以打开的进程数的最小值，默认 200

[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface

[supervisorctl]
serverurl=unix:///tmp/supervisor.sock ; 通过 UNIX socket 连接 supervisord，路径与 unix_http_server 部分的 file 一致

; 包含其他的配置文件
[include]
files = relative/directory/*.ini    ; 可以是 *.conf 或 *.ini
</code></pre>

<p>在这个文件的最底部，可以添加我们要管理的进程。假设有一个定时打印时间的脚本 test.sh ，在 /home/ubuntu/ 目录下：</p>

<pre><code>#!/bin/sh

touch test.log
while true :
do
    date &gt;&gt; /home/ubuntu/test.log
    sleep 10
done
</code></pre>

<p>我们把它添加到 supervisord ，在配置文件中添加：</p>

<pre><code>[program:test]
directory=/home/ubuntu/    ; 程序执行的目录
command=/home/ubuntu/test.sh    ; 执行程序的命令
autostart = true     ; 在 supervisord 启动的时候也自动启动
startsecs = 5        ; 启动 5 秒后没有异常退出，就当作已经正常启动了
autorestart = true   ; 程序异常退出后自动重启
startretries = 3     ; 启动失败自动重试次数，默认是 3
user = leon          ; 用哪个用户启动
redirect_stderr = true  ; 把 stderr 重定向到 stdout，默认 false
stdout_logfile_maxbytes = 20MB  ; stdout 日志文件大小，默认 50MB
stdout_logfile_backups = 20     ; stdout 日志文件备份数
stdout_logfile = /var/log/usercenter_stdout.log      ; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）
</code></pre>

<p>其中 [program:test 中的 test 是应用程序的唯一标识，不能重复。对该程序的所有操作（start, restart 等）都通过名字来实现。要注意的是，Supervisor 只能管理在前台运行的程序，所以如果应用程序有后台运行的选项，需要关闭。配置成功后，就可以启动 supervisord ：</p>

<pre><code>~$ supervisord -c /etc/supervisord.conf
~$ ps -ef | grep super
ubuntu    3667     1  0 16:52 ?        00:00:00 /usr/bin/python /usr/local/bin/supervisord -c /etc/supervisord.conf
~$ ps -ef | grep test
ubuntu    3668  3667  0 16:52 ?        00:00:00 /bin/sh /home/ubuntu/test.sh
</code></pre>

<h2 id="3-管理">3. 管理</h2>

<p>Supervisorctl 是 supervisord 的一个命令行客户端工具，通过它实现对程序的启动和停止，可以单独关闭一个程序：</p>

<pre><code>~$ supervisorctl stop test
test: stopped
</code></pre>

<p>如果要管理所有程序，用保留的名称 all ：</p>

<pre><code>~$ supervisorctl start all
test: started
~$ supervisorctl status test
test                             RUNNING   pid 4277, uptime 0:00:20
</code></pre>

<p>其他的选项：</p>

<pre><code>reread    ＃ 读取有更新（增加）的配置文件，不会启动新添加的程序
update    ＃ 重启配置文件修改过的程序
</code></pre>

<p>除了 supervisorctl 之外，还可以配置 supervisrod 启动 web 管理界面，这个 web 后台使用 Basic Auth 的方式进行身份认证。除了单个进程的控制，还可以配置 group，进行分组管理。经常查看日志文件，包括 supervisord 的日志和各个 pragram 的日志文件，程序 crash 或抛出异常的信息一半会输出到 stderr，可以查看相应的日志文件来查找问题。更多的信息可以查看官方的帮助文档：<a href="http://supervisord.org/index.html" target="_blank">http://supervisord.org/index.html</a></p>

<h2 id="4-开机启动">4. 开机启动</h2>

<p>在 /etc/systemd/system 目录下添加 supervisord.service 文件，内容如下：</p>

<pre><code>cat supervisord.service
[Unit]
Description=supervisord
# add mysql.service or postgresql.service depending on your database to the line below
After=network.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/supervisord -c /etc/supervisord.conf
ExecStop=/usr/local/bin/supervisorctl shutdown
ExecReload=/usr/local/bin/supervisorctl reload
RemainAfterExit=yes
User=ubuntu
Group=ubuntu

[Install]
WantedBy=multi-user.target
</code></pre>

<p>然后执行 <code>systemctl  enable supervisord.service</code> 使能该服务开机启动。</p>
]]></content>
        </item>
        
        <item>
            <title>VScode 使用笔记</title>
            <link>https://shaocheng.li/posts/2017/11/07/</link>
            <pubDate>Tue, 07 Nov 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/11/07/</guid>
            <description>1. Python 开发环境 为 vscode 安装 Python 插件，然后选择 Python 版本：
 通过 shift+command+p 组合键打开命令控制板 选择 Python:Select Workspace Interpreter 选择 Python 版本  2. 在终端打开 vscode 在 zsh 终端里用 vscode 直接打开当前目录，编辑配置文件 ~/.zshrc ，在最后加一行：
alias code=&#39;/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code&#39;  保存后重启终端，找一个项目文件夹，直接打开 vscode ：
$ code .  3. 远程 FTP 同步 ftp-sync 是一个自动将本地工作目录文件同步到远程 FTP/SFTP 服务器的插件。安装后可以通过三个命令完成同步：
 Ftp-sync: Init，在 .vscode 目录下新建一个默认的 ftp-sync 配置文件 Ftp-sync: Sync Local to Remote，同步本地文件到远程服务器 Ftp-sync: Sync Remote to Local，同步远程服务器的文件到本地目录  4.</description>
            <content type="html"><![CDATA[

<h2 id="1-python-开发环境">1. Python 开发环境</h2>

<p>为 vscode 安装 <a href="https://marketplace.visualstudio.com/items?itemName=donjayamanne.python" target="_blank">Python</a> 插件，然后选择 Python 版本：</p>

<ol>
<li>通过 shift+command+p 组合键打开命令控制板</li>
<li>选择 Python:Select Workspace Interpreter</li>
<li>选择 Python 版本</li>
</ol>

<h2 id="2-在终端打开-vscode">2. 在终端打开 vscode</h2>

<p>在 zsh 终端里用 vscode 直接打开当前目录，编辑配置文件 ~/.zshrc ，在最后加一行：</p>

<pre><code>alias code='/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code'
</code></pre>

<p>保存后重启终端，找一个项目文件夹，直接打开 vscode ：</p>

<pre><code>$ code  .
</code></pre>

<h2 id="3-远程-ftp-同步">3. 远程 FTP 同步</h2>

<p>ftp-sync 是一个自动将本地工作目录文件同步到远程 FTP/SFTP 服务器的插件。安装后可以通过三个命令完成同步：</p>

<ul>
<li>Ftp-sync: Init，在 .vscode 目录下新建一个默认的 ftp-sync 配置文件</li>
<li>Ftp-sync: Sync Local to Remote，同步本地文件到远程服务器</li>
<li>Ftp-sync: Sync Remote to Local，同步远程服务器的文件到本地目录</li>
</ul>

<h2 id="4-align-插件">4. Align 插件</h2>

<p>这个插件可以对选中的代码进行对齐操作，选中几行代码，按下 command+control+a 组合键即可。</p>

<h2 id="5-markdown">5. Markdown</h2>

<p>VScode 原生支持 Markdown 预览，快捷键 command+k 再按 v 就可以分屏预览。而 <a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/" target="_blank">Markdown preview enhanced</a> 插件可以提供更好的预览效果和写作体验，并且可以导出各种格式，包括 HTML、PDF、Word、eBook 等。</p>

<h2 id="6-自定义颜色主题">6. 自定义颜色主题</h2>

<p>默认的颜色主题都安装在安装路径下的  <code>resources/app/extensions/</code> 目录下，安装的扩展都放在 <code>C:/Users/[username]/.vscode/extensions/</code> 目录下，我们可以从默认的颜色主题复制一份到扩展安装路径下，然后在此基础上修改。比如复制一份 theme-solarized-dark ，重命名为 theme-solarized-dark-custom 。</p>

<p>如果是 MacOS ，扩展安装目录在 <code>~/.vscode/extensions/</code> 。</p>
]]></content>
        </item>
        
        <item>
            <title>用 pyvenv 创建虚拟环境</title>
            <link>https://shaocheng.li/posts/2017/10/27/</link>
            <pubDate>Fri, 27 Oct 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/10/27/</guid>
            <description>Mac 默认安装的是 Python2.7 ，再安装一个 Python3.6 ，就出现了两个版本共存的问题，不同的项目、不同的程序要用不同的版本，就需要创建虚拟环境，切换版本。Python3 提供了 pyvenv 模块原生支持虚拟环境，
要创建一个虚拟环境，首先决定一个你想要存放的目录，接着运行 pyvenv 后面携带着目录名:
pyvenv tutorial-env  如果目录不存在的话，这将会创建一个 tutorial-env 目录，并且也在目录里面创建一个包含 Python 解释器，标准库，以及各种配套文件的 Python “副本”。之后你必须激活它：
source tutorial-env/bin/activate  激活了虚拟环境会改变你的 shell 提示符，显示你正在使用的虚拟环境，并且修改了环境变量以致运行 python 将会让你得到了特定的 Python 版本，以后用 pip 安装的包都会放在虚拟环境的目录下。例如:
~$ python --version Python 2.7.10 ~$ source tutorial-env/bin/activate ~(tutorial-env) $ python --version Python 3.6.2 ~(tutorial-env) $ pip --version pip 9.0.1 from /Users/lishaocheng/Workspace/py3/lib/python3.6/site-packages (python 3.6)  如果要退回原来的环境，执行 exit 或者再开一个终端即可。
参考：虚拟环境和包</description>
            <content type="html"><![CDATA[<p>Mac 默认安装的是 Python2.7 ，再安装一个 Python3.6 ，就出现了两个版本共存的问题，不同的项目、不同的程序要用不同的版本，就需要创建虚拟环境，切换版本。Python3 提供了 pyvenv 模块原生支持虚拟环境，</p>

<p>要创建一个虚拟环境，首先决定一个你想要存放的目录，接着运行 pyvenv 后面携带着目录名:</p>

<pre><code>pyvenv tutorial-env
</code></pre>

<p>如果目录不存在的话，这将会创建一个 tutorial-env 目录，并且也在目录里面创建一个包含 Python 解释器，标准库，以及各种配套文件的 Python “副本”。之后你必须激活它：</p>

<pre><code>source tutorial-env/bin/activate
</code></pre>

<p>激活了虚拟环境会改变你的 shell 提示符，显示你正在使用的虚拟环境，并且修改了环境变量以致运行 python 将会让你得到了特定的 Python 版本，以后用 pip 安装的包都会放在虚拟环境的目录下。例如:</p>

<pre><code>~$ python --version
Python 2.7.10
~$ source tutorial-env/bin/activate
~(tutorial-env) $ python --version
Python 3.6.2
~(tutorial-env) $ pip --version
pip 9.0.1 from /Users/lishaocheng/Workspace/py3/lib/python3.6/site-packages (python 3.6)
</code></pre>

<p>如果要退回原来的环境，执行 exit 或者再开一个终端即可。</p>

<p>参考：<a href="http://www.pythondoc.com/pythontutorial3/venv.html" target="_blank">虚拟环境和包</a></p>
]]></content>
        </item>
        
        <item>
            <title>用 VPS 自建科学上网</title>
            <link>https://shaocheng.li/posts/2017/10/17/</link>
            <pubDate>Tue, 17 Oct 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/10/17/</guid>
            <description>1. 购买 VPS 推荐 https://www.vultr.com ，注册成功后先充值，Vultr 支持信用卡、比特币和支付宝等，支付宝比较方便：
充值完毕后，点击右上角的蓝色加号购买服务器，然后选择服务器位置、系统和配置，国内推荐东京：
选择 Ubuntu 16.04 系统，$5/月的套餐，可以先购买一个月试用：
使能私有 IP ：
点击左下角的 Deploy Now 完成购买，稍等片刻，安装完成后：
点击服务器名称，进入详情页，记下 IP Address、Username 和 Password ：
现在就可以用 SSH 客户端连接服务器，也可以点击右上第一个图标 View Console ，打开一个 Console 对话框，输入用户名和密码登录：
2. 安装 SSR 有一个一键安装的脚本，项目主页在 https://github.com/teddysun/shadowsocks_install，在服务器上运行如下命令：
wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh chmod +x shadowsocksR.sh ./shadowsocksR.sh 2&amp;gt;&amp;amp;1 | tee shadowsocksR.log  根据提示配置：
 服务器端口：自己设定（如不设定，默认为 8989） 密码：自己设定（如不设定，默认为 teddysun.com） 加密方式：自己设定（如不设定，默认为 aes-256-cfb） 协议（Protocol）：自己设定（如不设定，默认为 origin） 混淆（obfs）：自己设定（如不设定，默认为 plain）  安装完成后，脚本会提示如下,，记住自己的配置：
Congratulations, ShadowsocksR server install completed! Your Server IP :your_server_ip Your Server Port :your_server_port Your Password :your_password Your Protocol :your_protocol Your obfs :your_obfs Your Encryption Method:your_encryption_method Welcome to visit:https://shadowsocks.</description>
            <content type="html"><![CDATA[

<h2 id="1-购买-vps">1. 购买 VPS</h2>

<p>推荐 <a href="https://www.vultr.com" target="_blank">https://www.vultr.com</a> ，注册成功后先充值，Vultr 支持信用卡、比特币和支付宝等，支付宝比较方便：</p>

<p><img src="/images/2017-10-17/2017-10-17_1.png" alt="" />
充值完毕后，点击右上角的蓝色加号购买服务器，然后选择服务器位置、系统和配置，国内推荐东京：</p>

<p><img src="/images/2017-10-17/2017-10-17_2.png" alt="" /></p>

<p>选择 Ubuntu 16.04 系统，$5/月的套餐，可以先购买一个月试用：</p>

<p><img src="/images/2017-10-17/2017-10-17_3.png" alt="" />
使能私有 IP ：</p>

<p><img src="/images/2017-10-17/2017-10-17_4.png" alt="" />
点击左下角的 Deploy Now 完成购买，稍等片刻，安装完成后：</p>

<p><img src="/images/2017-10-17/2017-10-17_5.png" alt="" />
点击服务器名称，进入详情页，记下 IP Address、Username 和 Password ：</p>

<p><img src="/images/2017-10-17/2017-10-17_6.png" alt="" />
现在就可以用 SSH 客户端连接服务器，也可以点击右上第一个图标 View Console ，打开一个 Console 对话框，输入用户名和密码登录：</p>

<p><img src="/images/2017-10-17/2017-10-17_7.png" alt="" /></p>

<h2 id="2-安装-ssr">2. 安装 SSR</h2>

<p>有一个一键安装的脚本，项目主页在 <a href="https://github.com/teddysun/shadowsocks_install" target="_blank">https://github.com/teddysun/shadowsocks_install</a>，在服务器上运行如下命令：</p>

<pre><code>wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh
chmod +x shadowsocksR.sh
./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log
</code></pre>

<p>根据提示配置：</p>

<ul>
<li>服务器端口：自己设定（如不设定，默认为 8989）</li>
<li>密码：自己设定（如不设定，默认为 teddysun.com）</li>
<li>加密方式：自己设定（如不设定，默认为 aes-256-cfb）</li>
<li>协议（Protocol）：自己设定（如不设定，默认为 origin）</li>
<li>混淆（obfs）：自己设定（如不设定，默认为 plain）</li>
</ul>

<p>安装完成后，脚本会提示如下,，记住自己的配置：</p>

<pre><code>Congratulations, ShadowsocksR server install completed!
Your Server IP        :your_server_ip
Your Server Port      :your_server_port
Your Password         :your_password
Your Protocol         :your_protocol
Your obfs             :your_obfs
Your Encryption Method:your_encryption_method

Welcome to visit:https://shadowsocks.be/9.html
Enjoy it!
</code></pre>

<p>ShadowsocksR 已经加入开机自启动，查看运行状态：</p>

<pre><code>~# /etc/init.d/shadowsocks status
ShadowsocksR (pid 28287) is running...
</code></pre>

<p>如果想要卸载，执行：</p>

<pre><code>./shadowsocksR.sh uninstall
</code></pre>

<h2 id="3-客户端">3. 客户端</h2>

<ul>
<li>Windows 客户端：<a href="https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases" target="_blank">https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases</a></li>
<li>Mac 客户端：<a href="https://github.com/shadowsocksr-backup/ShadowsocksX-NG/releases" target="_blank">https://github.com/shadowsocksr-backup/ShadowsocksX-NG/releases</a></li>
</ul>

<h2 id="4-测试">4. 测试</h2>

<p>查看本地 IP 和所在线路 <a href="http://www.ipip.net/ip.html" target="_blank">http://www.ipip.net/ip.html</a> ：</p>

<p><img src="/images/2017-10-17/2017-10-17_8.png" alt="" />
测试各线路 ping 延时 <a href="http://www.ipip.net/ping.php" target="_blank">http://www.ipip.net/ping.php</a> :</p>

<p><img src="/images/2017-10-17/2017-10-17_9.png" alt="" />
路由追踪 <a href="http://www.ipip.net/traceroute.php" target="_blank">http://www.ipip.net/traceroute.php</a> :</p>

<p><img src="/images/2017-10-17/2017-10-17_10.png" alt="" /></p>

<p><img src="/images/2017-10-17/2017-10-17_11.png" alt="" /></p>

<p>另外有一个测试脚本 bench.sh ，<a href="https://teddysun.com/" target="_blank">秋水逸冰</a>大神写的，bench.sh 既是脚本名，同时又是域名，下载执行同步，感觉很屌：</p>

<pre><code>wget -qO- bench.sh | bash
</code></pre>

<p>参考：<a href="https://teddysun.com/444.html" target="_blank">https://teddysun.com/444.html</a></p>

<h2 id="5-加速">5. 加速</h2>

<p>直接访问境外 VPS 的延时普遍很高，有些还不稳定，丢包率飙升。这时需要通过测试，找出连接比较快的大陆节点，然后租一台该节点上的服务器，作为中继加速，最终的线路是：</p>

<pre><code>本地PC  &lt;==&gt; 中继服务器 &lt;==&gt; SSR 代理 &lt;==&gt; FreeInternet
</code></pre>

<p>现在中继服务器上安装 HAProxy ，这是一款 HTTP/TCP 负载均衡器，核心功能就是将前端的大流量请求，分流到后端的各个服务器中。原理与我们要实现的代理中继非常类似。Haproxy 监听特定端口的请求，然后将这个请求转发到后台的某一台服务器的端口上。这里使用它将我们发给它的请求转发给 SSR 服务器。以 Ubuntu 为例：</p>

<pre><code>sudo apt-get install haproxy 
</code></pre>

<p>安装成功后，编辑配置文件 /etc/haproxy/haproxy.cfg ，用如下内容替换 ：</p>

<pre><code>global
    ulimit-n  51200

defaults
    log    global
    mode    tcp
    option    dontlognull
        timeout connect 5000
        timeout client  50000
        timeout server  50000

frontend ss-in
    bind *:relay_server_port
    default_backend ss-out

backend ss-out
    server server1 proxy_server_ip:proxy_server_port maxconn 20480
</code></pre>

<p>relay_server_port 是用于本地与中继服务器B的连接的端口。proxy_server_ip 是 SSR 代理服务器的 IP 地址，proxy_server_port 是 SSR 代理服务器的监听端口。</p>

<p>然后将本地客户端上配置的服务器 IP 和端口改成中继服务器的 IP 和端口即可。</p>

<h2 id="6-参考">6. 参考</h2>

<p><a href="https://ayase.moe/2017/02/01/haproxy-in-proxy-relay/" target="_blank">利用Haproxy进行SS代理中继</a></p>
]]></content>
        </item>
        
        <item>
            <title>Numbers 使用技巧</title>
            <link>https://shaocheng.li/posts/2017/09/23/</link>
            <pubDate>Sat, 23 Sep 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/09/23/</guid>
            <description>1. 自动填充 有时我们需要将一个单元格的内容复制到整行，或者整列，那么我们可以选中单元格，然后拖动边框的黄点即可：
如果想要填充的字母或者数字自动递增，需要先将单元格的数据格式换成文本，然后再拖动黄点：
2. 拷贝样式 Numbers 也有类似微软 Office 的格式刷功能，叫做拷贝/粘贴样式。这个两个功能可以在“格式”菜单栏中找到，可以将它们添加到自定义工具栏中，方便使用：
然后选中一个单元格，拷贝/粘贴样式即可：
3. 减法 Numbers 的公式可以用减号直接实现减法，如下实现了两个时间相减，计算出持续时间：</description>
            <content type="html"><![CDATA[

<h2 id="1-自动填充">1. 自动填充</h2>

<p>有时我们需要将一个单元格的内容复制到整行，或者整列，那么我们可以选中单元格，然后拖动边框的黄点即可：</p>

<p><img src="/images/2017-09-23/2017-09-23_1.gif" alt="" /></p>

<p>如果想要填充的字母或者数字自动递增，需要先将单元格的数据格式换成文本，然后再拖动黄点：</p>

<p><img src="/images/2017-09-23/2017-09-23_2.gif" alt="" /></p>

<h2 id="2-拷贝样式">2. 拷贝样式</h2>

<p>Numbers 也有类似微软 Office 的格式刷功能，叫做拷贝/粘贴样式。这个两个功能可以在“格式”菜单栏中找到，可以将它们添加到自定义工具栏中，方便使用：</p>

<p><img src="/images/2017-09-23/2017-09-23_3.gif" alt="" /></p>

<p>然后选中一个单元格，拷贝/粘贴样式即可：</p>

<p><img src="/images/2017-09-23/2017-09-23_4.gif" alt="" /></p>

<h2 id="3-减法">3. 减法</h2>

<p>Numbers 的公式可以用减号直接实现减法，如下实现了两个时间相减，计算出持续时间：</p>

<p><img src="/images/2017-09-23/2017-09-23_5.gif" alt="" /></p>
]]></content>
        </item>
        
        <item>
            <title>用 iperf 测试网络性能</title>
            <link>https://shaocheng.li/posts/2017/08/01/</link>
            <pubDate>Tue, 01 Aug 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/08/01/</guid>
            <description>iperf 是一个客户端/服务器端工作模式的网络性能测试工具，用于测试 TCP 或者 UDP 的吞吐量，记录延迟、丢包率、MTU等信息。
1. 语法 缺省状态下，iperf 使用 TCP 传输协议，服务器端的语法：
iperf -s -p [port] [ options ]  加 -D 参数可以后台运行。
客户端的语法：
iperf -c [server ip] -p [port] [options]  常用的参数有：
 -f [kmKM] ，分别以 Kbits ， Mbits ， KBytes ， MBytes 格式显示报告，默认是 Mbits 。 -l ，读写缓存区的大小，默认是 8KB 。 -w ，设置 TCP 的窗口大小。 -t ，设置测试时间，默认是 10 秒。 -i ，打印报告的时间间隔，单位是秒。 -o ，输出打印信息到问题。 -u ，设置为 UDP 协议，两端都要加。 -b n[KM] ，设置使用 UDP 协议时的带宽 n bits/sec ，默认是 1Mbit/sec 。  2.</description>
            <content type="html"><![CDATA[

<p>iperf 是一个客户端/服务器端工作模式的网络性能测试工具，用于测试 TCP 或者 UDP 的吞吐量，记录延迟、丢包率、MTU等信息。</p>

<h2 id="1-语法">1. 语法</h2>

<p>缺省状态下，iperf 使用 TCP 传输协议，服务器端的语法：</p>

<pre><code>iperf  -s  -p  [port]  [ options ]
</code></pre>

<p>加 <code>-D</code> 参数可以后台运行。</p>

<p>客户端的语法：</p>

<pre><code>iperf  -c  [server ip]  -p  [port]  [options]
</code></pre>

<p>常用的参数有：</p>

<ul>
<li>-f [kmKM] ，分别以 Kbits ， Mbits ， KBytes ， MBytes 格式显示报告，默认是 Mbits 。</li>
<li>-l ，读写缓存区的大小，默认是 8KB 。</li>
<li>-w ，设置 TCP 的窗口大小。</li>
<li>-t ，设置测试时间，默认是 10 秒。</li>
<li>-i ，打印报告的时间间隔，单位是秒。</li>
<li>-o ，输出打印信息到问题。</li>
<li>-u ，设置为 UDP 协议，两端都要加。</li>
<li>-b n[KM] ，设置使用 UDP 协议时的带宽 n bits/sec ，默认是 1Mbit/sec 。</li>
</ul>

<h2 id="2-测试-tcp-的带宽">2. 测试 TCP 的带宽</h2>

<p>原理比较简单，在客户端和服务端建立三次握手连接后，客户端带宽的大小等于发送的总数据除以发送的总时间。对服务端测得的带宽，则是接收的总数据除以所花时间。服务器端：</p>

<pre><code>$ iperf -s -p 8000
------------------------------------------------------------
Server listening on TCP port 8000
TCP window size: 85.3 KByte (default)
------------------------------------------------------------
[  4] local 10.104.231.137 port 8000 connected with 14.197.98.229 port 65237
[ ID] Interval       Transfer     Bandwidth
[  4]  0.0-10.0 sec  36.8 MBytes  30.7 Mbits/sec
</code></pre>

<p>客户端：</p>

<pre><code>$ iperf -c 118.89.16.224 -p 8000 -i 2 -t 10
------------------------------------------------------------
Client connecting to 118.89.16.224, TCP port 8000
TCP window size:  128 KByte (default)
------------------------------------------------------------
[  5] local 192.168.1.104 port 65237 connected with 118.89.16.224 port 8000
[ ID] Interval       Transfer     Bandwidth
[  5]  0.0- 2.0 sec  9.25 MBytes  38.8 Mbits/sec
[  5]  2.0- 4.0 sec  5.75 MBytes  24.1 Mbits/sec
[  5]  4.0- 6.0 sec  6.50 MBytes  27.3 Mbits/sec
[  5]  6.0- 8.0 sec  8.38 MBytes  35.1 Mbits/sec
[  5]  8.0-10.0 sec  6.75 MBytes  28.3 Mbits/sec
[  5]  0.0-10.0 sec  36.8 MBytes  30.8 Mbits/sec
</code></pre>

<h2 id="3-测试-udp-的性能">3. 测试 UDP 的性能</h2>

<p>客户端可以用 <code>-u</code> 设置 UDP 数据流的速率。客户端发送数据时，将根据客户端提供的速率计算数据报发送之间的时延。</p>

<p>客户端还可以指定发送数据报的大小。每个发送的数据报包含一个 ID 号，用来唯一标识报文，服务器端根据该 ID 号来确定数据报丢失和乱序。</p>

<p>当把 UDP 报文大小设置可以将整个报文放入 IP 层的包内时，那么 UDP 所测得的报文丢失数据即为 IP 层包的丢失数据，这提供了一个有效的测试包丢失情况的方法。</p>

<p>数据报传输延迟抖动 (Jitter)的测试由服务器端完成，客户发送的报文数据包含有发送时间戳，服务器端根据该时间信息和接收到报文的时间戳来计算传输延迟抖动。传输延迟抖动反映传输过程中是否平滑。由于它是一个相对值，所以并不需要客户端和服务器端时间同步。</p>

<p>服务器端：</p>

<pre><code>$ iperf -u -s -p 1080
------------------------------------------------------------
Server listening on UDP port 1080
Receiving 1470 byte datagrams
UDP buffer size:  208 KByte (default)
------------------------------------------------------------
[  3] local 10.104.231.137 port 1080 connected with 14.197.98.229 port 58756
[ ID] Interval       Transfer     Bandwidth        Jitter   Lost/Total Datagrams
[  3]  0.0-20.0 sec  2.50 MBytes  1.05 Mbits/sec   1.030 ms    0/ 1784 (0%)
[  3]  0.0-20.0 sec  1 datagrams received out-of-order
</code></pre>

<p>客户端：</p>

<pre><code>$ iperf -u -c 118.89.16.224 -p 1080 -i 5 -t 20
------------------------------------------------------------
Client connecting to 118.89.16.224, UDP port 1080
Sending 1470 byte datagrams
UDP buffer size: 9.00 KByte (default)
------------------------------------------------------------
[  5] local 192.168.1.104 port 58756 connected with 118.89.16.224 port 1080
[ ID] Interval       Transfer     Bandwidth
[  5]  0.0- 5.0 sec   640 KBytes  1.05 Mbits/sec
[  5]  5.0-10.0 sec   640 KBytes  1.05 Mbits/sec
[  5] 10.0-15.0 sec   640 KBytes  1.05 Mbits/sec
[  5] 15.0-20.0 sec   640 KBytes  1.05 Mbits/sec
[  5]  0.0-20.0 sec  2.50 MBytes  1.05 Mbits/sec
[  5] Sent 1785 datagrams
[  5] Server Report:
[  5]  0.0-20.0 sec  2.50 MBytes  1.05 Mbits/sec   1.030 ms    0/ 1784 (0%)
[  5]  0.0-20.0 sec  1 datagrams received out-of-order
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>netcat 基本用法</title>
            <link>https://shaocheng.li/posts/2017/07/31/</link>
            <pubDate>Mon, 31 Jul 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/07/31/</guid>
            <description>netcat 是一个任意 TCP 和 UDP 连接和监听的工具，有时别名也叫 nc 。可以用于各种 TCP 或 UDP 相关的任务，包括打开 TCP 连接，发送 UDP 数据包，监听任意 TCP 和 UDP 端口，同时支持 IPv4 和 IPv6 。
1. 语法 netcat [option] ip port  常用参数：
 -e ，建立链接后执行外部程序。 -l ，使 netcat 处于监听状态。 -u ，使用 UDP ，缺省状态下是 TCP 协议。 -v ，输出详细信息。 -z ，执行端口扫描。对于 TCP 端口（缺省），尝试在不发送数据的情况下执行连接扫描（完整三路信号握手）。对于 UDP (–u)，缺省情况下会发送空 UDP 包。  2. 端口扫描 用于扫描远程主机的某个端口是否处于监听状态，假设一台服务器的端口情况：
$ netstat -nlp (Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.</description>
            <content type="html"><![CDATA[

<p>netcat 是一个任意 TCP 和 UDP 连接和监听的工具，有时别名也叫 nc 。可以用于各种 TCP 或 UDP 相关的任务，包括打开 TCP 连接，发送 UDP 数据包，监听任意 TCP 和 UDP 端口，同时支持 IPv4 和 IPv6 。</p>

<h2 id="1-语法">1. 语法</h2>

<pre><code>netcat  [option]  ip  port
</code></pre>

<p>常用参数：</p>

<ul>
<li>-e ，建立链接后执行外部程序。</li>
<li>-l ，使 netcat 处于监听状态。</li>
<li>-u ，使用 UDP ，缺省状态下是 TCP 协议。</li>
<li>-v ，输出详细信息。</li>
<li>-z ，执行端口扫描。对于 TCP 端口（缺省），尝试在不发送数据的情况下执行连接扫描（完整三路信号握手）。对于 UDP (–u)，缺省情况下会发送空 UDP 包。</li>
</ul>

<h2 id="2-端口扫描">2. 端口扫描</h2>

<p>用于扫描远程主机的某个端口是否处于监听状态，假设一台服务器的端口情况：</p>

<pre><code>$ netstat -nlp
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:8883            0.0.0.0:*               LISTEN      19908/mosquitto
tcp        0      0 0.0.0.0:8884            0.0.0.0:*               LISTEN      19908/mosquitto
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -
tcp6       0      0 :::8883                 :::*                    LISTEN      19908/mosquitto
tcp6       0      0 :::22                   :::*                    LISTEN      -
</code></pre>

<p>可见 TCP 的 22 、8883 和 8884 端口处于监听状态，在本地 PC 上测试 22 端口的连通性：</p>

<pre><code>$ nc -zv 118.89.16.224 22
Connection to 118.89.16.224 port 22 [tcp/ssh] succeeded!
</code></pre>

<p>连接失败的情况，说明端口没有被监听：</p>

<pre><code>$ nc -zv 118.89.16.224 80
nc: connectx to 118.89.16.224 port 80 (tcp) failed: Connection refused
</code></pre>

<p>如果要扫描 UDP 端口，加上 -u 参数：</p>

<pre><code>$ nc -uvz 118.89.16.224 1080
Connection to 118.89.16.224 port 1080 [udp/*] succeeded!
</code></pre>

<h2 id="3-双向通讯">3. 双向通讯</h2>

<p>在一台主机上开启监听：</p>

<pre><code>$ netcat -l 8000
</code></pre>

<p>在另一台主机上连接</p>

<pre><code>$ nc 118.89.16.224 8000
</code></pre>

<p>之后在一台主机上输入的信息，就会在另一台主机上显示。</p>

<p>使用 UDP 的例子：</p>

<pre><code>$ netcat -lu 1080
$ nc -u 118.89.16.224 1080
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>LeetCode 刷题</title>
            <link>https://shaocheng.li/posts/2017/06/26/</link>
            <pubDate>Mon, 26 Jun 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/06/26/</guid>
            <description>用 LeetCode 练习 Python ，难度都是选择 Easy 。
 1. Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
Example:
Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].</description>
            <content type="html"><![CDATA[

<blockquote>
<p>用 <a href="https://leetcode.com" target="_blank">LeetCode</a> 练习 Python ，难度都是选择 Easy 。</p>
</blockquote>

<h2 id="1-two-sum">1. Two Sum</h2>

<p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>

<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>

<p>Example:</p>

<pre><code>Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
</code></pre>

<p>Answer：</p>

<pre><code>class Solution(object):
def twoSum(self, nums, target):
    &quot;&quot;&quot;
    :type nums: List[int]
    :type target: int
    :rtype: List[int]
    &quot;&quot;&quot;
    for i in range(len(nums)):
        for j in range(i+1,len(nums)):
            if nums[i]+nums[j]==target:
                return [i,j]
</code></pre>

<h2 id="2-reverse-integer">2. Reverse Integer</h2>

<p>Reverse digits of an integer.</p>

<p>Example1: x = 123, return 321
Example2: x = -123, return -321</p>

<p>Note:The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows.</p>

<p>Answer:</p>

<pre><code>class Solution(object):
    def reverse(self, x):
        &quot;&quot;&quot;
        :type x: int
        :rtype: int
        &quot;&quot;&quot;
        temp=abs(x)
        res=0
        while temp&gt;0:
            res=res*10+temp%10
            temp=temp//10
        if x&lt;0:
            res=-res
        if res&gt;2147483647 or res&lt;-2147483648 :
            res=0
        return res
</code></pre>

<h2 id="3-palindrome-number">3. Palindrome Number</h2>

<p>Determine whether an integer is a palindrome. Do this without extra space.</p>

<p>判断一个整数是否是回文数，尽可能的少用额外的内存空间。一个思路是将数字折半，对比两半是否相等。</p>

<p>Answer:</p>

<pre><code>class Solution(object):
    def isPalindrome(self, x):
        &quot;&quot;&quot;
        :type x: int
        :rtype: bool
        &quot;&quot;&quot;
        if x&lt;0 :
            return False
        if x//10==0 :
            return True
        if x%10==0 :
            return False

        s=0
        while x&gt;s :
            s=s*10+x%10
            x=x//10

        if x==s or x==s//10 :
            return True
        else :
            return False
</code></pre>

<p>还有一种方法是转换为字符串，然后从头尾开始对比字符:</p>

<pre><code>class Solution(object):
    def isPalindrome(self, x):
        &quot;&quot;&quot;
        :type x: int
        :rtype: bool
        &quot;&quot;&quot;
        x=str(x)
        l=len(x)
        for i in range(l):
            if x[i] != x[-1-i]:
                return False
        return True
</code></pre>

<p>还可以在数组中利用 Python 的冒号语法，将数字前后颠倒，然后判断是否相同：</p>

<pre><code>class Solution(object):
    def isPalindrome(self, x):
        &quot;&quot;&quot;
        :type x: int
        :rtype: bool
        &quot;&quot;&quot;
        x = str(x)
        if x == x[::-1]:
            return True
        else:
            return False            
</code></pre>

<h2 id="4-roman-to-integer">4. Roman to Integer</h2>

<p>Given a roman numeral, convert it to an integer.</p>

<p>Input is guaranteed to be within the range from 1 to 3999.</p>

<p>Answer:</p>

<pre><code>class Solution(object):
    def romanToInt(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        rtoi={'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000}
        buf=0
        for i in range(len(s)-1):
            if rtoi[s[i]] &lt; rtoi[s[i+1]]:
                buf=buf-rtoi[s[i]]
            else:
                buf=buf+rtoi[s[i]]
        buf=buf+rtoi[s[-1]]
        return buf
</code></pre>

<h2 id="5-longest-common-prefix">5. Longest Common Prefix</h2>

<p>Write a function to find the longest common prefix string amongst an array of strings.</p>

<p>找出字符串数组中的最长公共前缀，比如 array=[&lsquo;abc&rsquo;,&lsquo;abcd&rsquo;,&lsquo;abe&rsquo;]，最长公共前缀就是 &lsquo;ab&rsquo; 。这道题的思路是先找出数组中最短的字符串，长度为 max ，最长公共前缀不可能超过 max ，然后遍历 max 次字符串数组，依次对比前 max 个字符。</p>

<p>Answer:</p>

<pre><code>class Solution(object):
    def longestCommonPrefix(self, strs):
        &quot;&quot;&quot;
        :type strs: List[str]
        :rtype: str
        &quot;&quot;&quot;
        res=''
        strs_len=len(strs)
        if strs_len&lt;1:
            return res
        if strs_len==1:
            return strs[0]

        max=len(strs[0])
        for i in range(strs_len):
            if len(strs[i])&lt;max:
                max=len(strs[i])
        if max&lt;1:
            return res

        flag=0
        for i in range(max):
            for j in range(1,strs_len):
                print i,j
                print strs[j][i]
                if strs[0][i]!=strs[j][i]:
                    flag=1
                    break
            if flag==0:
               res+=strs[0][i]
            else:
               break
        return res
</code></pre>

<h2 id="6-valid-parentheses">6. Valid Parentheses</h2>

<p>Given a string containing just the characters &lsquo;(&rsquo;, &lsquo;)&rsquo;, &lsquo;{&rsquo;, &lsquo;}&rsquo;, &lsquo;[&rsquo; and &lsquo;]&rsquo;, determine if the input string is valid.</p>

<p>The brackets must close in the correct order, &ldquo;()&rdquo; and &ldquo;()[]{}&rdquo; are all valid but &ldquo;(]&rdquo; and &ldquo;([)]&rdquo; are not.</p>

<p>验证括号是否完全匹配。思路是遍历整个字符串，遇到左括号就压栈，遇到右括号就与栈内括号对比，空栈或者不匹配就说明这个字符串无效。</p>

<p>Answer:</p>

<pre><code>class Solution(object):
    def isValid(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: bool
        &quot;&quot;&quot;
        if len(s)&lt;2 or len(s)%2!=0 :
            return False

        a=[['{','[','('],['}',']',')']]
        b={'}':'{',']':'[',')':'('}

        t=[]
        for i in range(len(s)):
            if s[i] in a[0] :
                t.append(s[i])
            else:
                if len(t)==0 :
                    return False
                l=t.pop()
                if l!=b[s[i]] :
                    return False
        if len(t)==0 :
            return True
        else :
            return False
</code></pre>

<h2 id="7-remove-duplicates-from-sorted-array">7. Remove Duplicates from Sorted Array</h2>

<p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p>

<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>

<p>For example,
Given input array nums = [1,1,2],</p>

<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn&rsquo;t matter what you leave beyond the new length.</p>

<p>Answer:</p>

<pre><code>class Solution(object):
    def removeDuplicates(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        i=0
        while True :
            if i&lt;len(nums)-1 :
                if nums[i]==nums[i+1] :
                    nums.pop(i+1)
                else :
                    i+=1
            else :
                break

        return len(nums)
</code></pre>

<h2 id="8-remove-element">8. Remove Element</h2>

<p>Given an array and a value, remove all instances of that value in place and return the new length.</p>

<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>

<p>The order of elements can be changed. It doesn&rsquo;t matter what you leave beyond the new length.</p>

<p>Example:</p>

<p>Given input array nums = [3,2,2,3], val = 3</p>

<p>Your function should return length = 2, with the first two elements of nums being 2.</p>

<p>Answer:</p>

<pre><code>class Solution(object):
    def removeElement(self, nums, val):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type val: int
        :rtype: int
        &quot;&quot;&quot;
        i=0
        while i&lt;len(nums):
            if nums[i]==val :
                nums.pop(i)
            else:
                i+=1
        return len(nums)
</code></pre>

<h2 id="9-implement-strstr">9. Implement strStr()</h2>

<p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>

<p>Answer:</p>

<pre><code>class Solution(object):
    def strStr(self, haystack, needle):
        &quot;&quot;&quot;
        :type haystack: str
        :type needle: str
        :rtype: int
        &quot;&quot;&quot;
        needle_len=len(needle)
        haystack_len=len(haystack)
        if needle_len==0 :
            return 0
        i=0
        while i+needle_len&lt;=haystack_len :
            if needle==haystack[i:i+needle_len] :
                return i
            else :
                i+=1
        return -1
</code></pre>

<p>其实 Python 为字符串提供了一个 <code>find()</code> 方法:</p>

<pre><code> string.find(str,beg=0,end=len(string))
</code></pre>

<p>用于查找字符串 string 内是否包含另一个字符串 str ，如果是返回开始的索引值，否则返回 -1 。</p>

<h2 id="10-search-insert-position">10. Search Insert Position</h2>

<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>

<p>You may assume no duplicates in the array.</p>

<p>Here are few examples.</p>

<pre><code>[1,3,5,6], 5 → 2
[1,3,5,6], 2 → 1
[1,3,5,6], 7 → 4
[1,3,5,6], 0 → 0
</code></pre>

<p>Answer:</p>

<pre><code>class Solution(object):
    def searchInsert(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: int
        &quot;&quot;&quot;
        for i in range(len(nums)) :
            if target&lt;=nums[i] :
                return i
        return len(nums)
</code></pre>

<h2 id="11-count-and-say">11. Count and Say</h2>

<p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p>

<pre><code>1.     1
2.     11
3.     21
4.     1211
5.     111221
</code></pre>

<p><code>1</code> is read off as <code>one 1</code> or <code>11</code>.</p>

<p><code>11</code> is read off as <code>two 1s</code> or <code>21</code>.</p>

<p><code>21</code> is read off as <code>one 2, then one 1</code> or <code>1211</code>.</p>

<p>Given an integer n, generate the nth term of the count-and-say sequence.</p>

<p>Note: Each term of the sequence of integers will be represented as a string.</p>

<p>Example 1:</p>

<pre><code>Input: 1
Output: &quot;1&quot;
</code></pre>

<p>Example 2:</p>

<pre><code>Input: 4
Output: &quot;1211&quot;
</code></pre>

<p>Answer:</p>

<pre><code>class Solution(object):
    def countAndSay(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: str
        &quot;&quot;&quot;
        s='1'
        for i in range(n-1) :
            pre=s[0]
            t=''
            count=0
            for a in s :
                if pre==a :
                    count+=1
                else :
                    t+=str(count)
                    t+=pre
                    count=1
                    pre=a

            t+=str(count)
            t+=pre
            s=t
        return s    
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>Python 对 list 的处理</title>
            <link>https://shaocheng.li/posts/2017/06/25/</link>
            <pubDate>Sun, 25 Jun 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/06/25/</guid>
            <description>list 是一种有序的数据集合，索引从 0 开始，类似 C 语言中的数组。比如定义一个 list ：
&amp;gt;&amp;gt;&amp;gt; array=[2,3,4] &amp;gt;&amp;gt;&amp;gt; print array [2, 3, 4] &amp;gt;&amp;gt;&amp;gt; print array[0] 2  1. 基本操作 获取 list 元素的个数可以用 len() 函数：
&amp;gt;&amp;gt;&amp;gt; len(array) 3  所以，最后一个元素的索引是 len()-1 ，还可以用 -1 做索引，直接获取最后一个元素，以此类推，可以获取倒数第二个，倒数第三个元素：
&amp;gt;&amp;gt;&amp;gt; array[-1] 4 &amp;gt;&amp;gt;&amp;gt; array[-2] 3  追加一个元素:
&amp;gt;&amp;gt;&amp;gt; array.append(5) &amp;gt;&amp;gt;&amp;gt; array [2, 3, 4, 5]  在指定位置插入一个元素：
&amp;gt;&amp;gt;&amp;gt; array.insert(1,9) &amp;gt;&amp;gt;&amp;gt; array [2, 9, 3, 4, 5]  删除某个元素可以用 pop() 函数，参数是元素的索引，不带参数的话，默认删除末尾的元素，返回值是删除的元素的内容：
&amp;gt;&amp;gt;&amp;gt; array.</description>
            <content type="html"><![CDATA[

<p>list 是一种有序的数据集合，索引从 0 开始，类似 C 语言中的数组。比如定义一个 list ：</p>

<pre><code>&gt;&gt;&gt; array=[2,3,4]
&gt;&gt;&gt; print array
[2, 3, 4]
&gt;&gt;&gt; print array[0]
2
</code></pre>

<h2 id="1-基本操作">1. 基本操作</h2>

<p>获取 list 元素的个数可以用 <code>len()</code> 函数：</p>

<pre><code>&gt;&gt;&gt; len(array)
3
</code></pre>

<p>所以，最后一个元素的索引是 <code>len()-1</code> ，还可以用 -1 做索引，直接获取最后一个元素，以此类推，可以获取倒数第二个，倒数第三个元素：</p>

<pre><code>&gt;&gt;&gt; array[-1]
4
&gt;&gt;&gt; array[-2]
3
</code></pre>

<p>追加一个元素:</p>

<pre><code>&gt;&gt;&gt; array.append(5)
&gt;&gt;&gt; array
[2, 3, 4, 5]
</code></pre>

<p>在指定位置插入一个元素：</p>

<pre><code>&gt;&gt;&gt; array.insert(1,9)
&gt;&gt;&gt; array
[2, 9, 3, 4, 5]
</code></pre>

<p>删除某个元素可以用 <code>pop()</code> 函数，参数是元素的索引，不带参数的话，默认删除末尾的元素，返回值是删除的元素的内容：</p>

<pre><code>&gt;&gt;&gt; array.pop()
5
&gt;&gt;&gt; array
[2, 9, 3, 4]
&gt;&gt;&gt; array.pop(1)
9
&gt;&gt;&gt; array
[2, 3, 4]
</code></pre>

<p>获取某个元素的下表,如果有重复的元素，只返回第一个元素的下标：</p>

<pre><code>&gt;&gt;&gt; a=[1,2,3,4,2]
&gt;&gt;&gt; a.index(1)
0
&gt;&gt;&gt; a.index(2)
1
</code></pre>

<h2 id="2-遍历">2. 遍历</h2>

<p>Pytion 提供了一个内置函数 <code>enumerate()</code> ，可用于遍历数据：</p>

<pre><code>enumerate(iterable[, start])
</code></pre>

<p>第一个参数是一个 list ，第二个可选参数允许我们自定义一个计数器，例如 list ：</p>

<pre><code>&gt;&gt;&gt; array=['a','b','c','d']
&gt;&gt;&gt; for c,v in enumerate(array):
...     print c,v
...
0 a
1 b
2 c
3 d
&gt;&gt;&gt; for c,v in enumerate(array,1):
...     print c,v
...
1 a
2 b
3 c
4 d
</code></pre>

<p>如果要从指定索引开始遍历到结尾，可以利用 <code>range()</code> 函数：</p>

<pre><code>&gt;&gt;&gt; array=['a','b','c','d']
&gt;&gt;&gt; for i in range(1,len(array)):
...     print i,array[i]
...
1 b
2 c
3 d
</code></pre>

<h2 id="3-切片">3. 切片</h2>

<p>有时候，我们想要精确的选取 list 中的一部分，Python 提供了优雅的切片语法：</p>

<pre><code>alist[begin🔚step]
</code></pre>

<ul>
<li>begin 表示切片的起始位置，缺省是 list 的开始位置</li>
<li>end 表示切片的结束位置，缺省是 list 的结束位置</li>
<li>step 表示步长，确实是正序的 1 ，逆序用负数表示</li>
</ul>

<p>以字符串 <code>hello</code> 为例，切片语法的坐标如下：</p>

<pre><code>0   1   2   3   4   5
+---+---+---+---+---+
| h | e | l | l | o |
+---+---+---+---+---+
-6  -5  -4  -3  -2  -1
</code></pre>

<p>如果要取中间的 <code>el</code> :</p>

<pre><code>&gt;&gt;&gt; a='hello'
&gt;&gt;&gt; a[1:3:1]
'el'
&gt;&gt;&gt; a[1:3]
'el'
</code></pre>

<p>将字符串逆序：</p>

<pre><code>&gt;&gt;&gt; a[::-1]
'olleh'
&gt;&gt;&gt; a[-1:-6:-1]
'olleh'
</code></pre>

<p>取头尾两个字符：</p>

<pre><code>&gt;&gt;&gt; a[::4]
'ho'
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>Paho JavaScript Client 学习笔记</title>
            <link>https://shaocheng.li/posts/2017/06/13/</link>
            <pubDate>Tue, 13 Jun 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/06/13/</guid>
            <description> Paho JavaScript Client 是一个用 JavaScript 写的，基于浏览器的 MQTT Client 库，用于使用 WebSockets 协议连接 MQTT Broker 。
 官网是 http://www.eclipse.org/paho/clients/js/ GitHub 是 https://github.com/eclipse/paho.mqtt.javascript  1. 安装 通过 git 克隆到本地：
git clone https://github.com/eclipse/paho.mqtt.javascript.git  默认克隆的是 master 分支，是正式发布的版本，远程还有一个 develop 分支，用于开发测试，包含了一个基于 maven 构建的简单客户端，可以用于单元测试。首先要手动检出：
git checkout -b develop remotes/origin/develop  然后再构建测试：
$ mvn $ cd src/tests $ mvn test -Dtest.server=iot.eclipse.com -Dtest.server.port=80 -Dtest.server.path=/ws  </description>
            <content type="html"><![CDATA[

<p>Paho JavaScript Client 是一个用 JavaScript 写的，基于浏览器的 MQTT Client 库，用于使用 WebSockets 协议连接 MQTT Broker 。</p>

<ul>
<li>官网是 <a href="http://www.eclipse.org/paho/clients/js/" target="_blank">http://www.eclipse.org/paho/clients/js/</a></li>
<li>GitHub 是 <a href="https://github.com/eclipse/paho.mqtt.javascript" target="_blank">https://github.com/eclipse/paho.mqtt.javascript</a></li>
</ul>

<h2 id="1-安装">1. 安装</h2>

<p>通过 git 克隆到本地：</p>

<pre><code>git clone https://github.com/eclipse/paho.mqtt.javascript.git
</code></pre>

<p>默认克隆的是 master 分支，是正式发布的版本，远程还有一个 develop 分支，用于开发测试，包含了一个基于 maven 构建的简单客户端，可以用于单元测试。首先要手动检出：</p>

<pre><code>git checkout -b develop remotes/origin/develop
</code></pre>

<p>然后再构建测试：</p>

<pre><code>$ mvn
$ cd src/tests
$ mvn test -Dtest.server=iot.eclipse.com -Dtest.server.port=80 -Dtest.server.path=/ws
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>使用 Python 操作 3G 模块</title>
            <link>https://shaocheng.li/posts/2017/06/01/</link>
            <pubDate>Thu, 01 Jun 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/06/01/</guid>
            <description>以 Telit HE910 模块为例，在 Linux 下的 AT 命令端口是 /dev/ttyACM3 。可以通过 pyserial 库直接读写端口来与模块通信，也可以使用更高级的 python-gsmmodem 。
1. Pyserial 如果要直接发送 AT 指令，需要串口读写库，我们常用的是 pyserial ，Python 2.7 默认没有安装这个库，需要自行下载，参考 https://pypi.python.org/pypi/pyserial/2.7，下面是一个简单的例子：
#!/usr/bin/python import serial ser=serial.Serial(port=&#39;/dev/ttyACM3&#39;, baudrate=115200, bytesize=8, parity=&#39;N&#39;, stopbits=1, timeout=1, xonxoff=False, rtscts=False, dsrdtr=False) cmd=&amp;quot;AT\r&amp;quot; ser.write(cmd.encode()) msg=ser.read(64) print(msg)  保存到文件 atcommand.py ，执行：
~# ./atcommand.py AT OK  2. Python-gsmmodem 2.1. 简介 python-gsmmodem 是一个用于控制 GSM modem 的 Python 包，基于 pyserial ，提供了 API 和一些命令行交互工具。在这里下载，然后安装：https://github.com/faucamp/python-gsmmodem。它的文档在源码的 docs 目录下，Sphinx 格式，你的电脑需要安装 Sphinx ，然后在 docs 目录下执行 make html 命令，就会在 _build 目录下生产 html 格式的文档，在浏览器中打开即可。python-gsmmodem 有如下几个特性：</description>
            <content type="html"><![CDATA[

<p>以 Telit HE910 模块为例，在 Linux 下的 AT 命令端口是 /dev/ttyACM3 。可以通过 pyserial 库直接读写端口来与模块通信，也可以使用更高级的 python-gsmmodem 。</p>

<h2 id="1-pyserial">1. Pyserial</h2>

<p>如果要直接发送 AT 指令，需要串口读写库，我们常用的是 pyserial ，Python 2.7 默认没有安装这个库，需要自行下载，参考 <a href="https://pypi.python.org/pypi/pyserial/2.7" target="_blank">https://pypi.python.org/pypi/pyserial/2.7</a>，下面是一个简单的例子：</p>

<pre><code>#!/usr/bin/python
import serial

ser=serial.Serial(port='/dev/ttyACM3', baudrate=115200, bytesize=8, parity='N', stopbits=1, timeout=1, xonxoff=False, rtscts=False, dsrdtr=False)
cmd=&quot;AT\r&quot;
ser.write(cmd.encode())
msg=ser.read(64)
print(msg)
</code></pre>

<p>保存到文件 atcommand.py ，执行：</p>

<pre><code>~# ./atcommand.py   
AT
OK
</code></pre>

<h2 id="2-python-gsmmodem">2. Python-gsmmodem</h2>

<h3 id="2-1-简介">2.1. 简介</h3>

<p>python-gsmmodem 是一个用于控制 GSM modem 的 Python 包，基于 pyserial ，提供了 API 和一些命令行交互工具。在这里下载，然后安装：<a href="https://github.com/faucamp/python-gsmmodem" target="_blank">https://github.com/faucamp/python-gsmmodem</a>。它的文档在源码的 docs 目录下，Sphinx 格式，你的电脑需要安装 Sphinx ，然后在 docs 目录下执行 <code>make html</code> 命令，就会在 _build 目录下生产 html 格式的文档，在浏览器中打开即可。python-gsmmodem 有如下几个特性：</p>

<ul>
<li>提供了发送短信、查询信号强度等功能的简单方法。</li>
<li>提供了处理 USSD 业务和语音通话的 API 。</li>
<li>通过回调函数接电话、收短信。</li>
<li>支持短信的 PDU 和 Text 模式。</li>
<li>支持跟踪短信状态报告。</li>
<li>在 Python 的异常处理中封装了 AT 指令的错误信息。</li>
<li>直接向模块发送 AT 指令，读取返回值。</li>
<li>提供测试套件。</li>
</ul>

<p>该模块提供了几个工具：</p>

<ul>
<li><p>GSMTerm ：一个简单的串口终端，用于与 GSM modem 通信，内建有 AT 指令帮助。启动后，输入 help 可以获取帮助信息，可以执行 AT 命令，还可以加载外部脚本：</p>

<pre><code>~# gsmterm.py -b 115200 /dev/ttyACM3

GSMTerm connected to /dev/ttyACM3 at 115200bps.
Press CTRL+] or CTRL+D to exit.

GSM&gt; help

== GSMTerm Help ==

Command History: Press the up &amp; down arrow keys to move backwards or forwards through your command history.

Command Completion: Press the TAB key to provide command completion suggestions. Press the TAB key after a command is fully typed (with or without a &quot;=&quot; character) to quickly see its syntax.

Command Documentation: Type a command, followed with two quesetion marks to access its documentation, e.g. &quot;&lt;COMMAND&gt;??&quot;. Alternatively, precede the command with a question mark (&quot;?&lt;COMMAND&gt;&quot;), or type &quot;help &lt;COMMAND&gt;&quot;.

List Available Commands: Type &quot;ls [category]&quot; to list the available AT commands known to GSMTerm for the given category (or all commands if no category is specified).
Type &quot;lscat&quot; to see a list of categories.

Load Script: Type &quot;load &lt;filename&gt;&quot; to load and execute a file containing AT commands, separated by newlines, e.g. &quot;load ./myscript.txt&quot;.

To exit GSMTerm, press CTRL+] or CTRL+D.

GSM&gt; AT
OK              
GSM&gt; AT+CSQ??

Signal Quality (AT+CSQ)

Category: Network Service
Description: This command determines the received signal strength indication (&lt;rssi&gt;) and the channel bit error rate (&lt;ber&gt;) with or without a SIM card inserted
Values: No parameters.
Response Values: 
 &lt;rssi&gt; 0: -113 dBm or less
        1: -111 dBm
        2 to 30: -109 to -53 dBm
        31: -51dBm or greater
        99: not known or not detectable
 &lt;ber&gt; 0...7: as RXQUAL values in the table GSM 05.08
Command Syntax:
 AT+CSQ
</code></pre></li>

<li><p>sendsms.py ：发送短信的命令行脚本，执行 `` 可以获取帮助信息，下面是一个简单的例子：</p>

<pre><code>~# sendsms.py -i /dev/ttyACM3 -b 115200 13824741490
Connecting to GSM modem on /dev/ttyACM3...
Checking for network coverage...

Please type your message and press enter to send it:
&gt; Hello World!

Sending SMS message...
Message sent.
</code></pre></li>

<li><p>identify-modem.py ：用于连接和调试 GSM modem 。</p></li>
</ul>

<p>python-gsmmodem 主要提供了如下几个编程模块：</p>

<ul>
<li>serial_comms ，基于 pyserial ，提供了用于低级别串口通讯的类 SerialComms 。</li>
<li>modem ，提供了几个操作 GSM modem 的类，例如 GsmModem ，SentSms 。</li>
<li>exceptions ，提供了一些额外的方法，比如超时处理，中断处理，供 GsmModem 使用。</li>
<li>pdu ，提供了对短信进行 PDU 编码的方法。</li>
</ul>

<h3 id="2-2-serial-comms">2.2. serial_comms</h3>

<p>serial_comms 的主类是 SerialComms ，使用前先导入：</p>

<pre><code>from serial_comms import GsmModem
</code></pre>

<h3 id="2-3-modem">2.3. modem</h3>

<p>modem 模块的主类是 GsmModem 类，它的父类是 SerialComms ，提供了与 GSM Modem 交互的大部分方法。使用前要先从 modme 模块导入：</p>

<pre><code>from gsmmodem.modem import GsmModem
</code></pre>

<p>GsmModem 类的构造函数：</p>

<pre><code>GsmModem(self, port, baudrate=115200, incomingCallCallbackFunc=None, smsReceivedCallbackFunc=None, smsStatusReportCallback=None)
</code></pre>

<p>参数的含义：</p>

<ul>
<li>port ，设置 AT 指令端口</li>
<li>baudrate ，波特率</li>
<li>incomingCallCallbackFunc ，处理接听电话的回调函数</li>
<li>smsReceivedCallbackFunc ，处理接收短信的回调函数</li>
<li>smsStatusReportCallback ，处理短信状态报告的回调函数</li>
</ul>

<p>新建实例后，要先连接端口，初始化 GSM Modem：</p>

<pre><code>connect(self, pin=None)
</code></pre>

<p>这个函数会打开 AT 指令端口，初始化 GSM Modem 和 SIM 卡。参数 pin 用于设置 SIM 卡内的 PIN 码 ，字符串类型，通常 SIM 卡没有启动 PIN 码锁定，设为 None 即可。如果 SIM 卡需要 PIN 码而这里没有设置，函数会抛出 PinRequiredError 异常。如果 PIN 码设置错误，函数会抛出 IncorrectPinError 异常。相应的，结束时应该调用 <code>close()</code> 关闭串口，这是从 <code>SerialComms</code> 类继承的方法。</p>

<blockquote>
<p>新购买的 SIM 卡背面提示中会写有 PIN 码初始值，也可以在运营商官网查询修改，通常是四位数字。PIN 码的作用是增强 SIM 卡安全性，例如可以在手机上为 SIM 卡启动 PIN 码锁定，这样每次开机都要输入 PIN 码。</p>
</blockquote>

<p>初始化之后，应该确认 GSM Modem 已经成功接入运营商网络。可以调用 <code>waitForNetworkCoverage()</code> ，它会引起阻塞，直到成功入网，或者超时：</p>

<pre><code>waitForNetworkCoverage(self, timeout=None)
</code></pre>

<p>参数 timeout 可以设置超时时间，int 类型，单位是秒。超时会抛出 TimeoutException 异常，如果有其他错误，会抛出 InvalidStateException 。调用结束后会返回当前的信号强度。</p>

<p>还有一个单独的函数，可以获取信号强度：</p>

<pre><code>signalStrength(self)
</code></pre>

<p>返回值是整数，范围在 0~99 表示信号强度，-1 表示未知。</p>

<p>还有一些功能函数，可以获取 Modem 的一些状态，这些函数都是执行相关的 AT 指令，如果要执行其他 AT 指令，可以通过 SerialComms 类提供的 wirte 方法直接向 Modem 发送：</p>

<ul>
<li>manufacturer(self) ，返回 Modem 的厂家信息</li>
<li>model(self) ，返回 Model 的名称</li>
<li>revision(self) ， 返回 Modem 的固件版本</li>
<li>imei(self) ，返回 Modem 的 IMEI 编码</li>
<li>imsi(self) ，返回 SIM 卡的 IMSI 编码</li>
<li>networkName(self) ，返回当前 Modem 所注册的网络的名称</li>
<li>supportedCommands(self) ，返回 Modem 支持的 AT 指令的列表</li>
</ul>

<p>设置短信编码的格式可以调用 <code>smsTextMode()</code> ：</p>

<pre><code>smsTextMode(self, textMode)
</code></pre>

<p>参数 textMode 是布尔型，设为 True 表示 text 格式，否则为 PDU 格式。text 格式是明文传输，不适合传输中文，国内目前都是 PDU 格式，初始化时，已经默认设为 PDU 格式。</p>

<p>发送文本类型的短信可以用 <code>sendSms()</code> 函数：</p>

<pre><code>sendSms(self, destination, text, waitForDeliveryReport=False, deliveryTimeout=15, sendFlash=False)
</code></pre>

<p>参数的含义：</p>

<ul>
<li>destination ，字符串类型，目标手机的电话号码</li>
<li>text ，要发送的文本内容</li>
<li>waitForDeliveryReport ，布尔型，如果设为 True ，函数会阻塞，知道收到短信状态的返回报告</li>
<li>deliveryTimeout ，整数，或者浮点数，当 waitForDeliveryReport=True 时有效，表示阻塞超时时间。</li>
</ul>

<p>如果发送过程过程中出现错误，会抛出 CommandError 异常。如果超时，会抛出 TimeoutException 异常。</p>
]]></content>
        </item>
        
        <item>
            <title>Linux Test Project 学习笔记</title>
            <link>https://shaocheng.li/posts/2017/05/24/</link>
            <pubDate>Wed, 24 May 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/05/24/</guid>
            <description>1. 简介 Linux Test Projec 是一个开源项目，简称 LTP ，致力于提供一套测试工具，用于测试和验证 Linux 内核的功能和稳定性，官网地址：https://linux-test-project.github.io。
2. 安装 安装前要准备 git、gcc、automake、autoconf、m4、bison、byacc、flex 。然后从 github 克隆源码：
$ git clone https://github.com/linux-test-project/ltp.git $ cd ltp  配置、编译、安装，文件都安装在 /opt/ltp/ 目录下。：
$ ../configure $ make all $ make install $ cd /opt/ltp/ $ ls bin IDcheck.sh runltp runltplite.sh runtest scenario_groups share testcases testscripts ver_linux Version  3. 结构说明 整套测试工具分为三大部分：测试脚本、测试驱动和测试用例。测试脚本位于 testscripts/ 目录下，包含了文件系统、磁盘、内核等各种测试项目的脚本；测试驱动位于 bin/ 目录下，主要是一些测试用的辅助脚本，比如 ltp-pan 和 ltp-scanner ；测试用例位于 testcase/ 目录下。其他各目录和文件的功能：
 IDcheck.sh ，检查系统是否缺少执行 LTP 测试套件所需的用户和用户组，如果缺少，就自动创建。 runltp ，执行 LTP 测试套件的脚本。 runltplite.</description>
            <content type="html"><![CDATA[

<h2 id="1-简介">1. 简介</h2>

<p>Linux Test Projec 是一个开源项目，简称 LTP ，致力于提供一套测试工具，用于测试和验证 Linux 内核的功能和稳定性，官网地址：<a href="https://linux-test-project.github.io" target="_blank">https://linux-test-project.github.io</a>。</p>

<h2 id="2-安装">2. 安装</h2>

<p>安装前要准备 git、gcc、automake、autoconf、m4、bison、byacc、flex 。然后从 github 克隆源码：</p>

<pre><code>$ git clone https://github.com/linux-test-project/ltp.git
$ cd ltp
</code></pre>

<p>配置、编译、安装，文件都安装在 /opt/ltp/ 目录下。：</p>

<pre><code>$ ../configure
$ make all
$ make install
$ cd /opt/ltp/
$ ls
bin  IDcheck.sh  runltp  runltplite.sh  runtest  scenario_groups  share  testcases  testscripts  ver_linux  Version
</code></pre>

<h2 id="3-结构说明">3. 结构说明</h2>

<p>整套测试工具分为三大部分：测试脚本、测试驱动和测试用例。测试脚本位于 testscripts/ 目录下，包含了文件系统、磁盘、内核等各种测试项目的脚本；测试驱动位于 bin/ 目录下，主要是一些测试用的辅助脚本，比如 ltp-pan 和 ltp-scanner ；测试用例位于 testcase/ 目录下。其他各目录和文件的功能：</p>

<ul>
<li>IDcheck.sh ，检查系统是否缺少执行 LTP 测试套件所需的用户和用户组，如果缺少，就自动创建。</li>
<li>runltp ，执行 LTP 测试套件的脚本。</li>
<li>runltplite.sh ，用于测试 LTP 安装，也可用于执行单项测试。</li>
<li>runtest ，测试驱动，用户连接测试脚本和测试用例。</li>
<li>share ，测试脚本的使用说明。</li>
<li>ver_linux ，打印当前系统各项信息的脚本。</li>
</ul>

<p>LTP 的执行原理是从一个测试脚本中读取所测条目需要执行的命令行，然后等待该项测试的结束，并记录详细的测试输出。简单地说，LTP 测试套件通过执行测试脚本 runltp (或着 runltplite.sh，testscripts 内的测试脚本），调用驱动程序 ltp-pan 执行 testcases 内的测试项目，输出测试结果，并利用 ltp-scanner 整理数据。默认状态下 ltp-pan 会随机的选择一个命令行来运行，可以指定在同一时间要执行测试的次数。ltp-pan 会记录测试产生的详细的格式复杂的输出，但它不进行数据的整理和统计，数据整理统计的工作由 ltp-scanner 来完成，ltp-scanner 是一个测试结果分析工具，它会理解 ltp-pan 的输出格式，并通过表格的形式总结测试 passed 或 failed 的情况。</p>

<h2 id="测试套件的使用">测试套件的使用</h2>

<p>LTP 提供了两个 runltp 和 runltplite.sh 。runltp 用于验证内核。这个脚本串行地运行一组测试，并报告全部结果。默认地，这个脚本执行：</p>

<ul>
<li>文件系统压力测试。</li>
<li>硬盘 I/O 测试。</li>
<li>内存管理压力测试。</li>
<li>IPC 压力测试。</li>
<li>SCHED 测试。</li>
<li>命令功能的验证测试。</li>
<li>系统调用功能的验证测试。</li>
</ul>

<p>LTP 提供的测试内容不完全写入 runltp ，测试时可以根据需求修改 runltp 并添加内容。</p>
]]></content>
        </item>
        
        <item>
            <title>Paho Python Client 学习笔记</title>
            <link>https://shaocheng.li/posts/2017/05/23/</link>
            <pubDate>Tue, 23 May 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/05/23/</guid>
            <description>Paho 是一个开源的 MQTT 客户端项目，提供多种语言的 MQTT 客户端实现，包括 C、C++、C#、Java、Python、JavaScript 等，完全支持 MQTT v3.1 和 v3.1.1 。Paho Python Client 是它的 Python 语言版本，支持 Python 2.7 和 3.x 。更多特性可以查看 http://www.eclipse.org/paho/clients/python/ ，源码和文档在 https://github.com/eclipse/paho.mqtt.python 。
该项目提供了一个测试用的 MQTT broker ：iot.eclipse.org ，端口 1883 ，无密码。
1. 安装 在 Python 环境中用 pip install paho-mqtt 命令安装，或者下载源码：
git clone https://github.com/eclipse/paho.mqtt.python.git cd org.eclipse.paho.mqtt.python.git python setup.py install  下面是一个简单的例子，连接一个 borker ，订阅系统默认话题，获取 broker 的版本号：
import paho.mqtt.client as mqtt def on_connect(client, userdata, flags, rc): print(&amp;quot;Connected with result code &amp;quot;+str(rc)) client.</description>
            <content type="html"><![CDATA[

<p>Paho 是一个开源的 MQTT 客户端项目，提供多种语言的 MQTT 客户端实现，包括 C、C++、C#、Java、Python、JavaScript 等，完全支持 MQTT v3.1 和 v3.1.1 。Paho Python Client 是它的 Python 语言版本，支持 Python 2.7 和 3.x 。更多特性可以查看 <a href="http://www.eclipse.org/paho/clients/python/" target="_blank">http://www.eclipse.org/paho/clients/python/</a> ，源码和文档在 <a href="https://github.com/eclipse/paho.mqtt.python" target="_blank">https://github.com/eclipse/paho.mqtt.python</a> 。</p>

<p>该项目提供了一个测试用的 MQTT broker ：<code>iot.eclipse.org</code> ，端口 1883 ，无密码。</p>

<h2 id="1-安装">1. 安装</h2>

<p>在 Python 环境中用 <code>pip install paho-mqtt</code> 命令安装，或者下载源码：</p>

<pre><code>git clone https://github.com/eclipse/paho.mqtt.python.git
cd org.eclipse.paho.mqtt.python.git
python setup.py install
</code></pre>

<p>下面是一个简单的例子，连接一个 borker ，订阅系统默认话题，获取 broker 的版本号：</p>

<pre><code>import paho.mqtt.client as mqtt

def on_connect(client, userdata, flags, rc):
    print(&quot;Connected with result code &quot;+str(rc))
    client.subscribe(&quot;$SYS/broker/version&quot;)

def on_message(client, userdata, msg):
    print(msg.topic+&quot; &quot;+str(msg.payload))

client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message

client.connect(&quot;iot.eclipse.org&quot;, 1883, 60)

client.loop_forever()
</code></pre>

<p>保存到 paho-mqtt.py 文件，执行：</p>

<pre><code>$ python paho-mqtt.py
Connected with result code 0
$SYS/broker/version mosquitto version 1.4.10
</code></pre>

<h2 id="2-编程">2. 编程</h2>

<p>paho.mqtt 包提供了三个类，Client、Publish 和 Subscribe。Publish 和 Subscribe 提供了简单的方法，一次性的发送或者接收消息，不会保持连接。Client 包含了新建客户端、连接、订阅、发送、回调函数等方法。通常的编程步骤是新建一个 Client 的实例，然后调用它提供的连接、发布和订阅等方法与 broker 通讯：</p>

<ol>
<li>新建一个 Client 实例</li>
<li>用一个 <code>connect*()</code> 函数连接 broker</li>
<li>用一个 <code>loop*()</code> 函数，维持与 broker 的连接</li>
<li>用 <code>subscribe()</code> 函数订阅一个话题，接收消息</li>
<li>用 <code>publish()</code> 函数发布消息</li>
<li>用 <code>disconnect()</code> 函数断开连接</li>
</ol>

<p>下面主要介绍 Client 提供的方法，使用前先导入：</p>

<pre><code>import paho.mqtt.client as mqtt
</code></pre>

<h3 id="2-1-初始化">2.1. 初始化</h3>

<p>新建一个 Client 实例：</p>

<pre><code>Client(client_id=&quot;&quot;, clean_session=True, userdata=None, protocol=MQTTv311, transport=&quot;tcp&quot;)
</code></pre>

<p>这是 Client 类的构造函数，参数的含义：</p>

<ul>
<li>client_id ，设置客户端的 ID ，应该是一个字符串，连接时向 broker 提交。如果为空，会随机生成一个 id ，此时，clean_session 必须设为 True 。</li>
<li>clean_session ，布尔型，如果为 True ，断开连接时，broker 会清除关于这个 client 的所有信息。如果为 False ，断开连接时，broker 会保留这个客户端的订阅信息和消息队列。</li>
<li>userdata ，用户自定义的数据，可以是任何类型，传递给回调函数。可以用 <code>user_data_set()</code> 函数更新。</li>
<li>protocol ，设置 MQTT 协议的版本，<code>MQTTv31</code> 或者 <code>MQTTv311</code> 。</li>
<li>transport ， 传输协议，默认还是 <code>tcp</code> ，可以设为 <code>websockets</code> 。</li>
</ul>

<p>构造实例：</p>

<pre><code>import paho.mqtt.client as mqtt
mqttc = mqtt.Client()
</code></pre>

<p>可以调用 <code>reinitialise()</code> 重新初始化 Client ：</p>

<pre><code>reinitialise(client_id=&quot;&quot;, clean_session=True, userdata=None)
</code></pre>

<h3 id="2-2-配置">2.2. 配置</h3>

<p>这些函数用来设置 Client 的一些特性，通常在连接 broker 之前调用。</p>

<pre><code>max_inflight_messages_set(self, inflight)
</code></pre>

<p>这个函数可以设置当 QoS&gt;0 时，最多可以存在几条动态消息（已经发送，还没有确认成功的消息）。默认是 20 ，增加这个值会占用更多的内存，但是可以提升吞吐量。</p>

<pre><code>max_queued_messages_set(self, queue_size)
</code></pre>

<p>这个函数可以设置当 QoS&gt;0 时，发送消息队列的最大值，默认是 0 ，表示无限制。当队列满时，旧消息会丢弃。</p>

<pre><code>message_retry_set(retry)
</code></pre>

<p>当 Qos&gt;0 时，如果发送消息后超过一定时间还没有收到确认报文，就要重发消息，这个函数用于设置超时时间，单位是秒。默认是 5 秒，通常不用修改。</p>

<p>配置 SSL 证书验证的函数，必须在 <code>connect*()</code> 函数之前调动。几个参数的含义：</p>

<ul>
<li>ca_certs ，指定 CA 根证书的路径。</li>
<li>certfile,keyfile ，指定客户端私钥和证书的路径。</li>
<li>cert_reqs ，设置客户端对 broker 证书的需求，默认是 ssl.CERT_REQUIRED ，表示 broker 必须提供一个证书。</li>
<li>tls_version ，设置 SSL/TLS 协议的版本，默认是 TLS v1 。</li>
<li>ciphers ，设置本次连接的加密密码，默认是 None 。</li>
</ul>

<p>设置用户名和密码：</p>

<p>username_pw_set(username, password=None)</p>

<p>设置遗嘱：</p>

<pre><code>will_set(topic, payload=None, qos=0, retain=False)
</code></pre>

<p>当这个 client 断开连接时，broker 会发布这个遗嘱消息。参数的含义：</p>

<ul>
<li>topic ，遗嘱消息的话题</li>
<li>payload ，遗嘱消息的内容，字符串类型，如果设为 None ，会发送一条长度为 0 消息。如果设置了 int 或者 float 类型的值，会当做字符串发送，如果你想发送真正的 int 或者 float 值，需要用 <code>struct.pack()</code> 生成消息。</li>
<li>qos ，遗嘱消息的安全等级</li>
<li>retain ，如果设为 True ，遗嘱消息会被设为保留消息</li>
</ul>

<p>如果参数设置错误，函数会抛出 ValueError 异常。</p>

<h3 id="2-3-连接">2.3. 连接</h3>

<p>最基本的连接方法是 <code>connect()</code> ：</p>

<pre><code>connect(host, port=1883, keepalive=60, bind_address=&quot;&quot;)
</code></pre>

<p>连接到 broker ，这是一个阻塞函数，参数的含义：</p>

<ul>
<li>host ，broker 的 hostname 或者 IP</li>
<li>port ，broker 的开放端口，默认是 1883 ，如果使能了 SSL/TLS ，端口可能是 8883</li>
<li>keepalive ，心跳间隔，单位是秒，如果 broker 和 client 在这段时间内没有任何通讯，client 会给 broker 发送一个 ping 消息</li>
<li>bind_address ，如果 client 的本地计算机有多个网络接口，可以用这个参数绑定其中的一个</li>
</ul>

<p>client 调用该函数发起连接后，如果收到 broker 发来的 CONNACK 消息，就会执行 <code>on_connect()</code> 回调函数。除此之外，还有 <code>connect_async()</code> 和 <code>connect_srv()</code> 两种函数可以连接 broker 。<code>connect_async()</code> 需要配合 <code>loop_start()</code> 函数以非阻塞的方式连接 broker。<code>connect_srv()</code> 是从 SRV DNS 获取 broker 的地址，然后再连接。</p>

<p>调用过 <code>connect*()</code> 函数之后，可以调用 <code>reconnect()</code> 用现有的参数重新连接。调用 <code>disconnect()</code> 函数可以从 broker 断开连接，断开连接后，会执行 <code>on_disconnect()</code> 回调函数。</p>

<h3 id="2-4-网络循环">2.4. 网络循环</h3>

<p>网络循环的函数有四种，它们运行在后台，处理收发的消息。最基本的是 <code>loop()</code> ：</p>

<pre><code>loop(timeout=1.0, max_packets=1)
</code></pre>

<p>这个函数会通过 <code>select()</code> 函数阻塞，直到有消息需要收发，阻塞的时间用 timeout 参数设置，不能超过心跳时间 keepalive ，否则你的 client 会定时从 broker 断开。max_packets 参数已经过时，无需设置。</p>

<p>另一个循环函数是 <code>loop_forever()</code> ，它会一直阻塞，直到 client 调用了 <code>disconnect()</code> ，并且，它会自动重连：</p>

<pre><code>loop_forever(timeout=1.0, max_packets=1, retry_first_connection=False)
</code></pre>

<p>timeout 和 max_packets 参数已经过时，无需设置。</p>

<h3 id="2-5-发布">2.5. 发布</h3>

<pre><code>publish(topic, payload=None, qos=0, retain=False)
</code></pre>

<p>向指定话题发送一条消息，参数的含义：</p>

<ul>
<li>topic ，这条消息所属的话题</li>
<li>payload ，消息内容，字符串类型，如果设为 None ，会发送一条长度为 0 消息。如果设置了 int 或者 float 类型的值，会当做字符串发送，如果你想发送真正的 int 或者 float 值，需要用 <code>struct.pack()</code> 生成消息。</li>
<li>qos ，消息的安全等级</li>
<li>retain ，如果设为 Ture ，这条消息会被设为保留消息</li>
</ul>

<p>如果参数设置错误，会抛出 ValueError 异常。消息发送成功后，会执行 <code>on_publish()</code> 回调函数。</p>

<h3 id="2-6-订阅">2.6. 订阅</h3>

<pre><code>subscribe(topic, qos=0)
</code></pre>

<p>向 broker 订阅话题，参数 topic 设置话题名称，qos 设置安全等级。如果只订阅一个话题，直接设置两个参数即可，例如：</p>

<pre><code>subscribe((&quot;my/topic&quot;, 1))
</code></pre>

<p>如果要订阅多个话题，可以将每个话题放在一个元组中，多个话题组成一个列表：</p>

<pre><code>subscribe([(&quot;my/topic&quot;, 0), (&quot;another/topic&quot;, 2)])
</code></pre>

<p>当 broker 确认订阅有效后，client 会执行 <code>on_subscribe()</code> 回调函数。如果要取消订阅某个话题，可以调用 <code>unsubscribe(topic)</code> ，参数是字符串型，如果是取消多个话题，参数应该是一个字符串列表。取消成功的话，会执行 <code>on_unsubscribe()</code> 回调函数。</p>

<h3 id="2-7-回调函数">2.7. 回调函数</h3>

<p>当 broker 对 client 的连接请求做出回应时，会调用 <code>on_connect()</code> 回调函数，可以在该函数中判断连接是否成功:</p>

<pre><code>on_connect(client, userdata, flags, rc)
</code></pre>

<p>参数 client 是当前 client 的实例，userdata 是 <code>Client()</code> 或 <code>userdata_set()</code> 设置的用户数据。flags 是 broker 发送的回应 flags ，字典类型。rc 表示连接结果，整数型，0 表示连接成功，连接失败可能的值有：</p>

<ul>
<li>1 ，错误的协议版本</li>
<li>2 ，无效的 client ID</li>
<li>3 ，服务器不可用</li>
<li>4 ，错误的用户名或密码</li>
<li>5 ，无法验证</li>
</ul>

<p>使用实例：</p>

<pre><code>def on_connect(client, userdata, flags, rc):
    print(&quot;Connection returned result: &quot;+connack_string(rc))

mqttc.on_connect = on_connect
...
</code></pre>

<p>对应的，与 broker 断开连接后，会执行 <code>on_disconnect()</code> 回调函数：</p>

<pre><code>on_disconnect(client, userdata, rc)
</code></pre>

<p>rc 表示断开连接的状态，如果是 0 ，表示是调用了 <code>disconnect()</code> 引起的断开连接，其他结果表示意外断开，比如网络中断。使用实例：</p>

<pre><code>def on_disconnect(client, userdata, rc):
    if rc != 0:
        print(&quot;Unexpected disconnection.&quot;)

mqttc.on_disconnect = on_disconnect
...
</code></pre>

<p>当 client 接收到已订阅的话题的消息时，会调用 <code>on_message()</code> 回调函数，在该函数中判断是哪个话题的消息，并处理消息内容：</p>

<pre><code>on_message(client, userdata, message)
</code></pre>

<p>参数 message 是 MQTTMessage 类的实例，这个类包含的成员有 <code>topic</code> ，<code>payload</code> ，<code>qos</code> ，<code>retain</code> 。使用实例：</p>

<pre><code>def on_message(client, userdata, message):
    print(&quot;Received message '&quot; + str(message.payload) + &quot;' on topic '&quot;
        + message.topic + &quot;' with QoS &quot; + str(message.qos))

mqttc.on_message = on_message
...
</code></pre>

<p>如果要用通配符同时处理多个话题的消息，例如用 sensors/# 匹配 sensors/temperature 和 sensors/humidity 话题，可以用 <code>message_callback_add()</code> 设置回调函数：</p>

<pre><code>message_callback_add(sub, callback)
</code></pre>

<p>参数 sub 是一个使用通配符的话题过滤器，字符串型，用 callback 参数指定回掉函数，与 <code>on_message()</code>  相同的类型。</p>

<p>如果同时设置了 <code>on_message()</code> 和 <code>message_callback_add()</code> 回调函数，会首先寻找合适的 <code>message_callback_add()</code> 定义的话题过滤器，如果没有匹配，才会调用 <code>on_message()</code> 。</p>

<h3 id="2-8-实例">2.8. 实例</h3>

<p>假设 broker 要求提供用户名、密码、证书和密钥，下面是一个简单的 client 例子：</p>

<pre><code>$ cat path-mqtt.py
#!/usr/bin/python

import paho.mqtt.client as mqtt

cafile = &quot;/etc/mosquitto/ca/ca.crt&quot;
certfile = &quot;/home/ubuntu/CA/client.crt&quot;
keyfile = &quot;/home/ubuntu/CA/client.key&quot;
user = &quot;guest&quot;
passwd = &quot;12345678&quot;
server = &quot;localhost&quot;
port = 8883

def on_connect(client, userdata, flags, rc):
    print(&quot;Connected with result code &quot;+str(rc))
    client.subscribe(&quot;$SYS/broker/version&quot;)

def on_message(client, userdata, msg):
    print(msg.topic+&quot; &quot;+str(msg.payload))

client = mqtt.Client()
client.tls_set(cafile,certfile,keyfile)
client.username_pw_set(user,passwd)
client.on_connect = on_connect
client.on_message = on_message

client.connect(server, port, 60)

client.loop_forever()
</code></pre>

<p>执行：</p>

<pre><code>$ ./path-mqtt.py
Connected with result code 0
$SYS/broker/version mosquitto version 1.4.11
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>RSA 加密算法与数字证书</title>
            <link>https://shaocheng.li/posts/2017/05/16/</link>
            <pubDate>Tue, 16 May 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/05/16/</guid>
            <description>1. RSA 加密算法 RSA 是一种非对称加密算法，同时生成一对密钥，分为公钥和私钥，它有几个重要的特点：
 公钥可以向外发布给多人，私钥必须单独保留确保安全 使用私钥加密的信息只能要公钥解密，使用公钥加密的信息只能用私钥解密 密钥越长，被破解的难度越大，可靠性越高，普通用户应使用 1024 位密钥，证书认证机构应该使用 2048 位或以上  RSA 加密算法有两个重要的应用：信息加密和数字签名。
2. 信息加密 如果将 RSA 用于数据加密，必然不希望别人知道数据内容，只有我可以解密，这时需要用公钥加密，私钥解密。例如，我生成了一对密钥，将公钥分给很多人，私钥自己保留，Alice 想要给我发信息时，就可以用这个公钥加密之后发给我，只有我可以用私钥解密。
openssl 集成了多种加密算法和使用工具，生成私钥和相应的公钥：
~$ openssl genrsa -out rsa.key 1024 Generating RSA private key, 1024 bit long modulus .....................++++++ ....++++++ e is 65537 (0x10001) ~$ openssl rsa -in rsa.key -pubout -out rsa_pub.key writing RSA key ~$ cat rsa_pub.key -----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDHZUoPjBXGA4trMaPosiDJkR3x JGfsZRZ7i6bjKjKmocc0umiFcOCFDrP1u4o90lXa/9XVzZ7OUIZSWCaCm/YQDxih oeXTAIPVeCHbfAb9kcE+GjRpCj7VTwN2e96rYyTwBMPdSsDmcdHUAXNJHpA6eST+ 7JE1OHAYGz33AbYhaQIDAQAB -----END PUBLIC KEY-----  假设有个文件 hello ，内容是 hello ，用公钥加密，并生成加密文件，然后再用私钥解密：</description>
            <content type="html"><![CDATA[

<h2 id="1-rsa-加密算法">1. RSA 加密算法</h2>

<p>RSA 是一种非对称加密算法，同时生成一对密钥，分为公钥和私钥，它有几个重要的特点：</p>

<ol>
<li>公钥可以向外发布给多人，私钥必须单独保留确保安全</li>
<li>使用私钥加密的信息只能要公钥解密，使用公钥加密的信息只能用私钥解密</li>
<li>密钥越长，被破解的难度越大，可靠性越高，普通用户应使用 1024 位密钥，证书认证机构应该使用 2048 位或以上</li>
</ol>

<p>RSA 加密算法有两个重要的应用：信息加密和数字签名。</p>

<h2 id="2-信息加密">2. 信息加密</h2>

<p>如果将 RSA 用于数据加密，必然不希望别人知道数据内容，只有我可以解密，这时需要用公钥加密，私钥解密。例如，我生成了一对密钥，将公钥分给很多人，私钥自己保留，Alice 想要给我发信息时，就可以用这个公钥加密之后发给我，只有我可以用私钥解密。</p>

<p>openssl 集成了多种加密算法和使用工具，生成私钥和相应的公钥：</p>

<pre><code>~$ openssl genrsa -out rsa.key 1024
Generating RSA private key, 1024 bit long modulus
.....................++++++
....++++++
e is 65537 (0x10001)
~$ openssl rsa -in rsa.key -pubout -out rsa_pub.key
writing RSA key
~$ cat rsa_pub.key
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDHZUoPjBXGA4trMaPosiDJkR3x
JGfsZRZ7i6bjKjKmocc0umiFcOCFDrP1u4o90lXa/9XVzZ7OUIZSWCaCm/YQDxih
oeXTAIPVeCHbfAb9kcE+GjRpCj7VTwN2e96rYyTwBMPdSsDmcdHUAXNJHpA6eST+
7JE1OHAYGz33AbYhaQIDAQAB
-----END PUBLIC KEY-----
</code></pre>

<p>假设有个文件 hello ，内容是 hello ，用公钥加密，并生成加密文件，然后再用私钥解密：</p>

<pre><code>~$ cat hello
hello
~$ openssl rsautl -encrypt -in hello -inkey rsa_pub.key -pubin -out hello.en
~$ ls
hello       hello.en    rsa.key     rsa_pub.key
~$ cat hello.en
6&amp;'��RM6..o�q?S�R�σk�(7����*����`��/3�H_�i��f��X7&quot;$H�#U�)Y�-�:����\��up
ϸI2�&gt;�Q&quot;����#�a���
                  �0��YB�wF%
~$ openssl rsautl -decrypt -in hello.en -inkey rsa.key -out hello.de
~$ cat hello.de
hello
</code></pre>

<h2 id="3-数字签名">3. 数字签名</h2>

<p>RSA 算法的另一个应用是数字签名。既然是签名，必然不希望别人冒充我，只有我才能发布这个签名，所有要用私钥签名，别人收到后可以公钥验证。数字签名的目的是：</p>

<ol>
<li>证明消息是我发的。</li>
<li>证明消息内容完整，没有被篡改。</li>
</ol>

<p>要实现以上两点，通常的做法是，把原文做一次 Hash（md5 或者 sha1 等），生成的 Hash 值也叫做信息摘要或者指纹，用私钥对这个指纹加密作为签名，将原文和签名一起发布，别人收到后，用公钥解密签名得到一段 Hash 值，如果解密成功，则证明信息是我发的，然后对原文做一次 Hash，将结果与前面那一段 Hash 值对比，如果一致，就证明原文没有被篡改。下图是签名和验证的完整过程：</p>

<p><img src="/images/2017-05-16/2017-05-16_1.png" alt="" /></p>

<p>用 OpenSSL 完成一次签名和验证。首先，使用私钥、sha1 算法，对文件 hello 签名，生成签名文件 sign ：</p>

<pre><code>~$ openssl dgst -sign rsa.key -sha1 -out sign hello
</code></pre>

<p>然后，使用公钥验证签名和原文：</p>

<pre><code>~$ openssl dgst -verify rsa_pub.key -sha1 -signature sign hello
Verified OK
</code></pre>

<h2 id="4-数字证书">4. 数字证书</h2>

<p>由于公钥是公开的，存在被篡改的可能。假如 Alice 本来拥有我的公钥，却被第三方偷偷替换成第三方的公钥，这样第三方就可以冒充我，用他自己私钥生成数字签名，发送给 Alice ，Alice 用公钥验证成功，以为是我的签名，从而被欺骗。</p>

<p>为了应对这种情况，就需要我向证书中心（Certificate Authority，简称 CA ，是一种负责发放和管理数字证书的第三方权威机构）申请一份数字证书，CA 会收集我的公钥和其他相关信息做一个证书，再用它的私钥对证书做数字签名，确保证书不被篡改，二者合在一起即使一份数字证书（Digital Certificate）。以后我写信的时候，在签名的同时，都会附上这张数字证书，Alice 收到后，用 CA 的公钥验证数字签名，确保证书有效，获取我的公钥，然后用公钥去验证数字签名。</p>

<p>这样又带来一个问题，如何获取 CA 的公钥，并保证 CA 公钥的安全？CA 除了给别人签发证书，它们也有自己的证书，证书内含 CA 公钥(明文)和用 CA 私钥生成的数字签名，微软等操作系统厂商会选取一些信用良好且有一定安全认证的 CA ，把这些 CA 的证书默认安装在操作系统里，并设置为操作系统信任的根证书，以 macOS 为例：</p>

<p><img src="/images/2017-05-16/2017-05-16_2.png" alt="" />
以 https 为例，如果某网站的数字证书的签发机构 (CA) 不在操作系统信任列表里，登录时浏览器就会警告，比如 <a href="https://www.12306.cn" target="_blank">https://www.12306.cn</a> ：</p>

<p><img src="/images/2017-05-16/2017-05-16_3.png" alt="" /></p>

<p>现实情况通常更复杂一点，我们不会直接找到根证书签发机构，可能会向一个中级证书签发机构申请证书，而他们自己的证书又通过根 CA 签发，这就形成了一个证书链，浏览器验证证书有效性的时候，也会根据证书中的签发者信息，层层上溯，直到找到受信任的根 CA ，再用相应的公钥向下层层验证。以 google 为例，在 chrome 浏览器中打开 <a href="https://www.google.com.hk" target="_blank">https://www.google.com.hk</a> ，打开开发者工具，点击 Security 标签页中的 View certificate 按钮，就可以看到这个网站的证书详情：</p>

<p><img src="/images/2017-05-16/2017-05-16_4.png" alt="" /></p>

<p>可以看到每层证书的详情，包括签发者，有效期，公钥的内容和算法，证书指纹的内容和算法等。</p>

<p>这里有一个通过 OpenSSL 自建 CA 并颁发证书的脚本：<a href="https://github.com/owntracks/tools/raw/master/TLS/generate-CA.sh" target="_blank">https://github.com/owntracks/tools/raw/master/TLS/generate-CA.sh</a>。</p>

<h2 id="5-参考">5. 参考</h2>

<ul>
<li><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank">数字签名是什么？</a></li>
<li><a href="http://ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank">SSL/TLS 协议运行机制详解</a></li>
<li><a href="http://seanlook.com/2015/01/07/tls-ssl/" target="_blank">SSL/TLS原理详解</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>RaspberryPi 3 使用笔记</title>
            <link>https://shaocheng.li/posts/2017/05/09/</link>
            <pubDate>Tue, 09 May 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/05/09/</guid>
            <description>0. 准备  Raspberry Pi 3 Model B 32GB Class10 TF 卡（官方推荐 8GB 以上）和读卡器 5V2A USB 电源，比如 iPad 电源适配器 microUSB 电源线 HDMI 数据线 显示器 USB 键盘  1. 安装系统 下载 Raspbian jessie lite ：2017-04-10-raspbian-jessie-lite.img ，这是一个官方支持的精简系统，基于 Debian 开发，只有文本界面。
将 TF 卡插入 MacBook ，在终端里用 df 命令可以看到 TF 卡已经被挂载：
[22:16]~/ ❯ df Filesystem 512-blocks Used Available Capacity iused ifree %iused Mounted on /dev/disk1 487830528 299357448 187961080 62% 1687373 4293279906 0% / devfs 377 377 0 100% 654 0 100% /dev map -hosts 0 0 0 100% 0 0 100% /net map auto_home 0 0 0 100% 0 0 100% /home /dev/disk3s1 60612608 226616 60385992 1% 76 4294967203 0% /Volumes/Pi  然后卸载：</description>
            <content type="html"><![CDATA[

<h2 id="0-准备">0. 准备</h2>

<p><img src="/images/2017-05-09/2017-05-09_1.jpg" alt="" /></p>

<ul>
<li>Raspberry Pi 3 Model B</li>
<li>32GB Class10 TF 卡（官方推荐 8GB 以上）和读卡器</li>
<li>5V2A USB 电源，比如 iPad 电源适配器</li>
<li>microUSB 电源线</li>
<li>HDMI 数据线</li>
<li>显示器</li>
<li>USB 键盘</li>
</ul>

<h2 id="1-安装系统">1. 安装系统</h2>

<p>下载 <a href="https://www.raspberrypi.org/downloads/raspbian/" target="_blank">Raspbian jessie lite</a> ：2017-04-10-raspbian-jessie-lite.img ，这是一个官方支持的精简系统，基于 Debian 开发，只有文本界面。</p>

<p>将 TF 卡插入 MacBook ，在终端里用 df 命令可以看到 TF 卡已经被挂载：</p>

<pre><code>[22:16]~/ ❯ df
Filesystem    512-blocks      Used Available Capacity iused      ifree %iused  Mounted on
/dev/disk1     487830528 299357448 187961080    62% 1687373 4293279906    0%   /
devfs                377       377         0   100%     654          0  100%   /dev
map -hosts             0         0         0   100%       0          0  100%   /net
map auto_home          0         0         0   100%       0          0  100%   /home
/dev/disk3s1    60612608    226616  60385992     1%      76 4294967203    0%   /Volumes/Pi
</code></pre>

<p>然后卸载：</p>

<pre><code>[22:39]~/ ❯ diskutil unmount /dev/disk3s1
Volume Pi on disk3s1 unmounted
</code></pre>

<p>使用 dd 命令将系统镜像写入:</p>

<pre><code>[23:43]~/ ❯ sudo dd bs=4m if=2017-04-10-raspbian-jessie-lite.img of=/dev/rdisk3
Password:
309+1 records in
309+1 records out
1297862656 bytes transferred in 112.203648 secs (11567027 bytes/sec)
</code></pre>

<blockquote>
<p>/dev/disk3s1 是分区，/dev/disk3 是块设备，/dev/rdisk3 是原始字符设备</p>
</blockquote>

<p>这样就安装系统好了，再次卸载：</p>

<pre><code>[23:45]~/ ❯ df
Filesystem    512-blocks      Used Available Capacity iused      ifree %iused  Mounted on
/dev/disk1     487830528 299358472 187960056    62% 1687450 4293279829    0%   /
devfs                380       380         0   100%     658          0  100%   /dev
map -hosts             0         0         0   100%       0          0  100%   /net
map auto_home          0         0         0   100%       0          0  100%   /home
/dev/disk3s1       82644     41524     41120    51%       0          0  100%   /Volumes/boot
[23:49]~/ ❯ diskutil unmount /dev/disk3s1
Volume boot on disk3s1 unmounted
</code></pre>

<h2 id="2-第一次启动">2. 第一次启动</h2>

<p>将 TF 卡插入树莓派，连接电源、显示器、键盘，即可启动。启动后输入用户名 pi ，密码 raspberry 。</p>

<h3 id="2-1-配置语言-时区和键盘布局">2.1. 配置语言、时区和键盘布局</h3>

<p>执行 <code>sudo raspi-config</code> ，进入 <code>4 Localisation Options</code> ，对系统进行本地化配置：</p>

<ul>
<li>在 <code>I1 Change Locale</code> 中设置本地语言，取消 <code>en_GB.UTF-8 UTF-8</code> ，选中 <code>en_US.UTF-8 UTF-8</code> 。</li>
<li>在 <code>I2 Change Timezone</code> 中设置时区为 <code>Asia</code> 下的 <code>Shanghai</code> 。</li>
<li>在 <code>I3 Change Keyboard Layout</code> 设置键盘布局，依次选择 <code>Generic 104-key PC</code>  &gt; <code>Other</code> &gt; <code>English (US)</code> &gt; <code>English (US)</code> &gt; <code>The default for the keyboard layout</code> &gt; <code>No compose key</code> 。</li>
<li>在 <code>I4 Change Wi-fi Country</code> 中设置<code>CN China</code></li>
<li>完成配置后，选择 <code>Finish</code> ，根据提示重启系统，如果没有提示，可以执行 <code>sudo reboot</code> 重启系统。</li>
</ul>

<h3 id="2-2-配置-wi-fi">2.2. 配置 Wi-Fi</h3>

<p>执行 <code>wpa_passphrase [ssid] [password]</code> 命令将 Wi-Fi 名称和密码写入配置文件：</p>

<pre><code>pi@raspberrypi:~ $ sudo wpa_passphrase TP-Link_30BBB8 12345678 | sudo tee -a /etc/wpa_supplicant/wpa_supplicant.conf
</code></pre>

<p>重启一下系统，就可以连上 Wi-Fi 了，使用 <code>iwconfig</code> 命令查看连接是否成功，已经获取的 IP ：</p>

<pre><code>pi@raspberrypi:~ $ iwconfig
wlan0     IEEE 802.11bgn  ESSID:&quot;TP-Link_30BBB8&quot;
          Mode:Managed  Frequency:2.412 GHz  Access Point: 8C:A6:DF:0C:7A:09
          Bit Rate=28.8 Mb/s   Tx-Power=31 dBm
          Retry short limit:7   RTS thr:off   Fragment thr:off
          Power Management:on
          Link Quality=44/70  Signal level=-66 dBm
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:2  Invalid misc:0   Missed beacon:0

lo        no wireless extensions.

eth0      no wireless extensions.
pi@raspberrypi:~ $ ifconfig
eth0      Link encap:Ethernet  HWaddr b8:27:eb:11:9b:de
          inet6 addr: fe80::3f3:df2a:426d:ab83/64 Scope:Link
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

wlan0     Link encap:Ethernet  HWaddr b8:27:eb:44:ce:8b
          inet addr:192.168.1.103  Bcast:192.168.1.255  Mask:255.255.255.0
          inet6 addr: fe80::dba8:37ce:716a:a85/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:4429 errors:0 dropped:34 overruns:0 frame:0
          TX packets:160 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:327762 (320.0 KiB)  TX bytes:27347 (26.7 KiB)
</code></pre>

<h3 id="2-3-开启-ssh">2.3. 开启 SSH</h3>

<p>系统默认没有开启 SSH ，需要在 TF 卡的根目录下新建一个空文件 SSH ，这样系统启动时就会启动 SSH ：</p>

<pre><code>pi@raspberrypi:~ $ sudo touch /boot/ssh
pi@raspberrypi:~ $ sudo reboot
</code></pre>

<p>查看 SSH 服务是否启动：</p>

<pre><code>pi@raspberrypi:~ $ systemctl status ssh
● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Mon 2017-04-10 19:16:40 CST; 2min 2s ago
 Main PID: 697 (sshd)
   CGroup: /system.slice/ssh.service
           └─697 /usr/sbin/sshd -D
</code></pre>

<p>在 Mac 的终端里执行 <code>ssh pi@192.168.1.103</code> 登录树莓派。</p>

<blockquote>
<p>可以安装一个 lrzsz ，方便服务器端与客户端的文件传输：<code>sudo apt-get install lrzsz</code></p>
</blockquote>

<h3 id="2-4-更换源">2.4. 更换源</h3>

<p>编辑配置文件：</p>

<pre><code>pi@raspberrypi:~ $ sudo vi /etc/apt/sources.list
</code></pre>

<p>注释掉原地址，添加阿里云的源地址：</p>

<pre><code>deb http://mirrors.aliyun.com/raspbian/raspbian/ wheezy main non-free contrib
deb-src http://mirrors.aliyun.com/raspbian/raspbian/ wheezy main non-free contrib
</code></pre>

<p>保存文件后，更新系统软件：</p>

<pre><code>pi@raspberrypi:~ $ sudo apt-get update
</code></pre>

<p>清华的源速度也不错：</p>

<pre><code>deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ jessie main non-free contrib
deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ jessie main non-free contrib
</code></pre>

<h3 id="2-5-替换-vim">2.5. 替换 Vim</h3>

<p>系统原装的 Vim 超难用，先卸载，再按照新的：</p>

<pre><code>pi@raspberrypi:~ $ sudo apt-get remove vim-common
pi@raspberrypi:~ $ sudo apt-get install vim
</code></pre>

<h3 id="2-6-设置-ssh-证书登录">2.6. 设置 SSH 证书登录</h3>

<p>暴露在外围的密码登录容易受到攻击，而且每次都要输密码，不够方便。真正生产环境中还是使用证书登录。配置需要如下几个步骤。</p>

<ol>
<li><p>生成一对秘钥，一路回车默认生成id_rsa和id_rsa.pub，前者是私钥，放在客户端，后者是公钥，需要放在ssh服务器：</p>

<pre><code>pi@raspberrypi:~ $ ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key (/home/pi/.ssh/id_rsa):
Created directory '/home/pi/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/pi/.ssh/id_rsa.
Your public key has been saved in /home/pi/.ssh/id_rsa.pub.
The key fingerprint is:
63:c8:76:52:c1:14:bc:1b:8b:28:b2:02:7d:86:96:8f pi@raspberrypi
The key's randomart image is:
+---[RSA 2048]----+
|       ++.       |
|        o.       |
|        ..       |
|     . oo        |
| . o .=.S+       |
|o * +..+o.       |
|.+ *             |
|o E .            |
|.                |
+-----------------+
pi@raspberrypi:~ $ cd .ssh/
pi@raspberrypi:~/.ssh $ ls
id_rsa  id_rsa.pub
</code></pre></li>

<li><p>在服务器端将 id_rsa.pub 添加到 authorized_keys ，然后配置 ssh_config</p>

<pre><code>pi@raspberrypi:~/.ssh $ cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
pi@raspberrypi:~ $ vim /etc/ssh/ssh_config    
RSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile  %h/.ssh/authorized_keys
</code></pre></li>

<li><p>把私钥 id_rsa 发送到客户端，由于我是 MacOS ，放在 ~/.ssh/ 目录下，更名为 raspberry_pi ，在 ~/.ssh/config 文件中添加一项配置：</p>

<pre><code>host pi
HostName 192.168.1.103
Port 22
User pi
IdentityFile ~/.ssh/raspberry_pi
</code></pre></li>

<li><p>在客户端使用 <code>ssh pi</code> 即可登录树莓派。</p></li>
</ol>

<h3 id="2-7-系统时间">2.7. 系统时间</h3>

<p>树莓派没有实时时钟，所以每次启动后要用 ntp 对时，否则时间不准。默认设置的 ntp 服务器连接较慢，可以添加一些境内的 ntp 服务器。编辑 /etc/ntp.conf 文件，找到如下两行：</p>

<pre><code># You do need to talk to an NTP server or two (or three).
#server ntp.your-provider.example
</code></pre>

<p>在这行后面添加：</p>

<pre><code>server ntp.fudan.edu.cn iburst
server time.asia.apple.com iburst
server asia.pool.ntp.org iburst
server ntp.nict.jp iburst
server time.nist.gov iburst
</code></pre>

<p>保存后重启 ntpd ：</p>

<pre><code>pi@raspberrypi:~ $ sudo systemctl restart ntp.service
</code></pre>

<h3 id="2-8-配置以太网">2.8. 配置以太网</h3>

<p>树莓派有一个以太网卡 eth0 ，默认是 dhcp 方式自动分配 IP ，要改成静态 IP 需要编辑 /etc/network/interfaces 文件，将 eth0 的配置删除，添加如下内容：</p>

<pre><code>auto eth0
iface eth0 inet static
    address 192.168.5.252
    netmask 255.255.255.0
    gateway 192.168.5.50
    dns-nameservers 192.168.0.99
</code></pre>

<p>保存后重启 network 服务：</p>

<pre><code>pi@raspberrypi:~ $ sudo systemctl restart networking.service
</code></pre>

<h2 id="3-硬件编程开发">3. 硬件编程开发</h2>

<p>树莓派通过 40 pin 排针引出 26 路 GPIO ，输出高电平 3.3V ，部分 GPIO 有复用功能，包括一个两线 I2C ，一个四线 SPI ，一个 UART ，信号定义如下：</p>

<p><img src="/images/2017-05-09/2017-05-09_2.jpg" alt="" /></p>

<p>读写 GPIO 可以用 C 语言或者 Python ，官方推荐的 Python GPIO 是一个小型 Python 库，但是不支持 SPI 、I2C 等 GPIO 的复用功能，使用 C 语言开发的 WiringPi 更受欢迎：<a href="http://wiringpi.com/" target="_blank">http://wiringpi.com/</a> ，它提供了一个 C 语言开发库， API 风格类似 Arduino ，可以访问 GPIO 管脚的所有功能，还提供了一个命令行工具 gpio ，可以直接访问 GPIO 管脚。</p>

<h3 id="3-1-下载安装">3.1. 下载安装</h3>

<p>先按照 git ，然后通过 git 下载源码：</p>

<pre><code>pi@raspberrypi:~ $ sudo apt-get install git
pi@raspberrypi:~ $ git clone git://git.drogon.net/wiringPi
</code></pre>

<p>安装：</p>

<pre><code>pi@raspberrypi:~ $  cd ~/wiringPi
pi@raspberrypi:~ $  ./build
</code></pre>

<p>测试是否安装成功：</p>

<pre><code>pi@raspberrypi:~/wiringPi $ gpio -v
gpio version: 2.44
Copyright (c) 2012-2017 Gordon Henderson
This is free software with ABSOLUTELY NO WARRANTY.
For details type: gpio -warranty

Raspberry Pi Details:
    Type: Pi 3, Revision: 02, Memory: 1024MB, Maker: Sony
    * Device tree is enabled. 
    * --&gt; Raspberry Pi 3 Model B Rev 1.2
    * This Raspberry Pi supports user-level GPIO access.
</code></pre>

<h3 id="3-2-wiringpi-的管脚编码">3.2. WiringPi 的管脚编码</h3>

<p>WiringPi 的 GPIO 管脚编号与连接器上的硬件硬件编号并不一致，获取当前树莓派的 GPIO 管脚描述的方法是使用 gpio 命令：</p>

<pre><code>pi@raspberrypi:~/wiringPi $ gpio readall
 +-----+-----+---------+------+---+---Pi 3---+---+------+---------+-----+-----+
 | BCM | wPi |   Name  | Mode | V | Physical | V | Mode | Name    | wPi | BCM |
 +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+
 |     |     |    3.3v |      |   |  1 || 2  |   |      | 5v      |     |     |
 |   2 |   8 |   SDA.1 |   IN | 1 |  3 || 4  |   |      | 5v      |     |     |
 |   3 |   9 |   SCL.1 |   IN | 1 |  5 || 6  |   |      | 0v      |     |     |
 |   4 |   7 | GPIO. 7 |   IN | 1 |  7 || 8  | 0 | IN   | TxD     | 15  | 14  |
 |     |     |      0v |      |   |  9 || 10 | 1 | IN   | RxD     | 16  | 15  |
 |  17 |   0 | GPIO. 0 |   IN | 0 | 11 || 12 | 0 | IN   | GPIO. 1 | 1   | 18  |
 |  27 |   2 | GPIO. 2 |   IN | 0 | 13 || 14 |   |      | 0v      |     |     |
 |  22 |   3 | GPIO. 3 |   IN | 0 | 15 || 16 | 0 | IN   | GPIO. 4 | 4   | 23  |
 |     |     |    3.3v |      |   | 17 || 18 | 0 | IN   | GPIO. 5 | 5   | 24  |
 |  10 |  12 |    MOSI |   IN | 0 | 19 || 20 |   |      | 0v      |     |     |
 |   9 |  13 |    MISO |   IN | 0 | 21 || 22 | 0 | IN   | GPIO. 6 | 6   | 25  |
 |  11 |  14 |    SCLK |   IN | 0 | 23 || 24 | 1 | IN   | CE0     | 10  | 8   |
 |     |     |      0v |      |   | 25 || 26 | 1 | IN   | CE1     | 11  | 7   |
 |   0 |  30 |   SDA.0 |   IN | 1 | 27 || 28 | 1 | IN   | SCL.0   | 31  | 1   |
 |   5 |  21 | GPIO.21 |   IN | 1 | 29 || 30 |   |      | 0v      |     |     |
 |   6 |  22 | GPIO.22 |   IN | 1 | 31 || 32 | 0 | IN   | GPIO.26 | 26  | 12  |
 |  13 |  23 | GPIO.23 |   IN | 0 | 33 || 34 |   |      | 0v      |     |     |
 |  19 |  24 | GPIO.24 |   IN | 0 | 35 || 36 | 0 | IN   | GPIO.27 | 27  | 16  |
 |  26 |  25 | GPIO.25 |   IN | 0 | 37 || 38 | 0 | IN   | GPIO.28 | 28  | 20  |
 |     |     |      0v |      |   | 39 || 40 | 0 | IN   | GPIO.29 | 29  | 21  |
 +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+
 | BCM | wPi |   Name  | Mode | V | Physical | V | Mode | Name    | wPi | BCM |
 +-----+-----+---------+------+---+---Pi 3---+---+------+---------+-----+-----+
</code></pre>

<p>这个命令会生成一张图片，描述当前树莓派的 GPIO 连接器管脚与 WiringPi 中的管脚编号的映射关系，上图是 Raspberry Pi 3 Model B 型的。</p>

<h3 id="3-3-gpio">3.3. GPIO</h3>

<p>WiringPi 提供了多个初始化函数：</p>

<ul>
<li>int wiringPiSetup (void) ;</li>
<li>int wiringPiSetupGpio (void) ;</li>
<li>int wiringPiSetupPhys (void) ;</li>
<li>int wiringPiSetupSys (void) ;</li>
</ul>

<p>程序开始的时候，必须调用其中一个，且需要 root 权限。通常调用 wiringPiSetup(void) 即可，它的作用是初始化 WiringPi 编程环境和 GPIO 管脚映射。wiringPiSetupGpio(void) 和 wiringPiSetupPhys(void) 会用树莓派的 GPIO 编号或者连接器管脚编号替代 WiringPi 的编号，wiringPiSetupSys(void) 会用 /sys/class/gpio 接口来代替直接访问硬件，也称为 sys 模式，这三个函数都很少使用。</p>

<p>访问 GPIO 主要需要如下函数，这些函数在 sys 模式下都是无效的：</p>

<ul>
<li>void pinMode (int pin, int mode) ;</li>
</ul>

<p>设置某个管脚的模式为 INPUT, OUTPUT, PWM_OUTPUT 或者 GPIO_CLOCK 。只有 wiringPi pin 1 (BCM_GPIO 18) 支持 PWM 输出 ，只有 wiringPi pin 7 (BCM_GPIO 4)  支持 CLOCK 输出。</p>

<ul>
<li>void pullUpDnControl (int pin, int pud) ;</li>
</ul>

<p>设置某个输入管脚的上拉和下拉电阻，PUD_OFF 表示关闭上下拉电阻, PUD_DOWN 表示下拉到地，PUD_UP 表示上拉倒 3.3V ，上下拉电阻大约 50KΩ 。</p>

<ul>
<li>void digitalWrite (int pin, int value) ;</li>
</ul>

<p>向某个输出管脚写值，HIGH 表示高电平， LOW 表示低电平。</p>

<ul>
<li>int digitalRead (int pin) ;</li>
</ul>

<p>读取某个输入管脚的状态，返回 HIGH 表示高电平，LOW 表示低电平。</p>

<h3 id="3-4-spi">3.4. SPI</h3>

<p>编程访问 SPI 前，要用 gpio 加载 SPI 驱动：</p>

<pre><code>gpio load spi
</code></pre>

<p>编辑代码时要包含头文件：</p>

<pre><code>#include &lt;wiringPiSPI.h&gt;
</code></pre>

<p>编译时要手动链接 ： <code>-lwiringPi</code> 。</p>

<h3 id="3-5-uart">3.5. UART</h3>

<h2 id="4-搭建-nas-服务">4. 搭建 NAS 服务</h2>

<h3 id="4-1-硬件配置">4.1. 硬件配置</h3>

<p>准备一块移动硬盘，因为树莓派的 USB 口驱动能力有限，最好用双 USB 口数据线，为移动硬盘独立供电，格式化为 ext4 ，我这里的分区是 sda1 ：</p>

<pre><code>pi@raspberrypi:~ $ sudo fdisk /dev/sda -l

Disk /dev/sda: 149.1 GiB, 160041885696 bytes, 312581808 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x9fd95492

Device     Boot Start       End   Sectors   Size Id Type
/dev/sda1        2048 312581807 312579760 149.1G 83 Linux
</code></pre>

<p>为了让系统启动时自动挂在移动硬盘，需要修改 /etc/fstab 文件，添加 sda1 的配置，记得修改前先备份：</p>

<pre><code>pi@raspberrypi:/etc $ cat fstab
proc            /proc           proc    defaults          0       0
PARTUUID=5b2de8de-01  /boot           vfat    defaults          0       2
PARTUUID=5b2de8de-02  /               ext4    defaults,noatime  0       1
/dev/sda1             /home/pi/nas    ext4    defaults,noatime  0       0
# a swapfile is not a swap partition, no line here
#   use  dphys-swapfile swap[on|off]  for that
</code></pre>

<p>创建挂在目录：</p>

<pre><code>pi@raspberrypi:~ $ mkdir /home/pi/nas
</code></pre>

<p>重启后查看挂载信息：</p>

<pre><code>pi@raspberrypi:~ $ df
Filesystem     1K-blocks    Used Available Use% Mounted on
/dev/root       29787900 1959324  26593012   7% /
devtmpfs          469532       0    469532   0% /dev
tmpfs             473864       0    473864   0% /dev/shm
tmpfs             473864   12260    461604   3% /run
tmpfs               5120       4      5116   1% /run/lock
tmpfs             473864       0    473864   0% /sys/fs/cgroup
/dev/mmcblk0p1     41322   20763     20559  51% /boot
/dev/sda1      153705340   60864 145813600   1% /home/pi/nas
</code></pre>

<h3 id="4-2-文件共享">4.2. 文件共享</h3>

<p>Samba 可以实现树莓派上的文件在局域网内的共享。安装必要的文件：</p>

<pre><code>pi@raspberrypi:~ $  sudo apt-get install samba samba-common-bin -y
</code></pre>

<blockquote>
<p>如果分区是 NTFS 格式，需要安装 NTFS 支持：<code>sudo apt-get install ntfs-3g</code> 。如果是 exFAT 格式，则选用安装 exfat-utils 。</p>
</blockquote>

<p>创建共享文件夹 shares：</p>

<pre><code>pi@raspberrypi:~ $ sudo mkdir  /home/pi/nas/shares
</code></pre>

<p>编辑配置文件 /etc/samba/smb.conf ，替换成如下内容：</p>

<pre><code>[global]
security = user
encrypt passwords = true
guest account = nobody
map to guest = bad user

#======================= Share Definitions =======================
[share]
comment = Guest access shares
path = /home/pi/nas/shares/
browseable = yes
writable = yes
#read only = yes
guest ok = yes
public = yes

[NAS-Data]
comment = Nas data folder
path = /home/pi/nas/
browseable = yes
writable = yes
valid users = root pi
</code></pre>

<p>需要为 samba 添加一个 pi 账户：</p>

<pre><code>pi@raspberrypi:~/nas $ sudo smbpasswd -a pi
New SMB password:
Retype new SMB password:
Added user pi.
</code></pre>

<p>重启 samba 服务，确保启动成功：</p>

<pre><code>pi@raspberrypi:~/nas $ sudo systemctl restart smbd.service
pi@raspberrypi:~/nas $ sudo systemctl status smbd.service
● smbd.service - LSB: start Samba SMB/CIFS daemon (smbd)
   Loaded: loaded (/etc/init.d/smbd)
   Active: active (running) since Mon 2017-04-10 19:17:04 CST; 2s ago
  Process: 5272 ExecStop=/etc/init.d/smbd stop (code=exited, status=0/SUCCESS)
  Process: 5122 ExecReload=/etc/init.d/smbd reload (code=exited, status=0/SUCCESS)
  Process: 5313 ExecStart=/etc/init.d/smbd start (code=exited, status=0/SUCCESS)
   CGroup: /system.slice/smbd.service
           ├─5324 /usr/sbin/smbd -D
           └─5329 /usr/sbin/smbd -D

Apr 10 19:17:04 raspberrypi smbd[5313]: Starting SMB/CIFS daemon: smbd.
Apr 10 19:17:04 raspberrypi systemd[1]: Started LSB: start Samba SMB/CIFS daemon (smbd).
Apr 10 19:17:04 raspberrypi smbd[5324]: [2017/04/10 19:17:04.479386,  0] ../lib/util/become_daemon.c:124(daemon_ready)
Apr 10 19:17:04 raspberrypi smbd[5324]: STATUS=daemon 'smbd' finished starting up and ready to serve connections
</code></pre>

<p>在 MAC 中打开 Finder &gt; 前往 &gt; 网络 ，就可以看到树莓派的共享文件夹，访问 share 共享目录无需密码，而 NAS-Data 需要密码验证：</p>

<p><img src="/images/2017-05-09/2017-05-09_3.png" alt="" /></p>

<h3 id="4-3-ftp-服务器">4.3. FTP 服务器</h3>

<p>在树莓派上安装 vsftpd ：</p>

<pre><code>pi@raspberrypi:~ $ sudo apt-get install vsftpd
</code></pre>

<p>编辑配置文件 /etc/vsftpd.conf ，修改如下选项：</p>

<pre><code>#禁止匿名访问
anonymous_enable=NO  
#设定本地用户可以访问
local_enable=YES
#设定可以进行写操作
write_enable=YES
#设定上传后文件的权限掩码
local_umask=022
#设定根目录
local_root=/home/pi/
</code></pre>

<p>用 ftp 客户端软件登录：</p>

<p><img src="/images/2017-05-09/2017-05-09_4.png" alt="" /></p>

<h2 id="5-移植-uci">5. 移植 UCI</h2>

<p>UCI 是 OpenWRT 的一个配置工具，提供 C 语言 API 和 Shell 命令接口，可以方便的自定义配置文件。uci 的编译需要 CMake ，先安装 CMake ：</p>

<pre><code>pi@raspberrypi:~ $ sudo apt-get install cmake
</code></pre>

<p>安装 libluajit-dev ，否则会出现  <code>lauxlib.h: No such file or directory</code> 这样的错误 :</p>

<pre><code>pi@raspberrypi:~ $ sudo apt-get install libluajit-5.1-dev
</code></pre>

<p>通过 git 下载 uci 的源码包：</p>

<pre><code>pi@raspberrypi:~ $ git clone https://github.com/jkjuopperi/uci.git
</code></pre>

<p>用 pkg-config 查询刚才的 libluajit-dev 的头文件目录：</p>

<pre><code>pi@raspberrypi:~ $ pkg-config --cflags --libs luajit
-I/usr/include/luajit-2.0 -lluajit-5.1
</code></pre>

<p>然后进入 uci 目录，在 CMakeLists.txt 文件中靠前位置添加如下一行，指定头文件目录，否则编译的时候找不到：</p>

<pre><code>INCLUDE_DIRECTORIES(&quot;/usr/include/luajit-2.0/&quot;)
</code></pre>

<p>保存后开始编译安装：</p>

<pre><code>pi@raspberrypi:~/uci $ cmake  .
pi@raspberrypi:~/uci $ make
pi@raspberrypi:~/uci $ sudo make install
[ 27%] Built target uci-static
[ 54%] Built target uci-shared
[ 63%] Built target cli
[ 72%] Built target cli-static
[ 81%] Built target ucimap
[ 90%] Built target ucimap-example
[100%] Built target uci_lua
Install the project...
-- Install configuration: &quot;&quot;
-- Installing: /usr/local/include/uci.h
-- Installing: /usr/local/include/uci_config.h
-- Installing: /usr/local/include/ucimap.h
-- Installing: /usr/local/lib/libuci.so
-- Installing: /usr/local/lib/libuci.a
-- Installing: /usr/local/bin/uci
-- Set runtime path of &quot;/usr/local/bin/uci&quot; to &quot;&quot;
-- Installing: /usr/local/bin/uci-static
-- Installing: /usr/local/lib/lua/5.1/uci.so
-- Set runtime path of &quot;/usr/local/lib/lua/5.1/uci.so&quot; to &quot;&quot;
</code></pre>

<p>安装后需要执行一次 <code>sudo ldconfig -v</code>，否则可能找不到新装的库文件，uci 默认将配置文件放在 /etc/config 目录下，所以新建该目录，执行 uci ，如下表示安装成功：</p>

<pre><code>pi@raspberrypi:~/uci $ uci
Usage: uci [&lt;options&gt;] &lt;command&gt; [&lt;arguments&gt;]

Commands:
        batch
        export     [&lt;config&gt;]
        import     [&lt;config&gt;]
        changes    [&lt;config&gt;]
        commit     [&lt;config&gt;]
        add        &lt;config&gt; &lt;section-type&gt;
        add_list   &lt;config&gt;.&lt;section&gt;.&lt;option&gt;=&lt;string&gt;
        show       [&lt;config&gt;[.&lt;section&gt;[.&lt;option&gt;]]]
        get        &lt;config&gt;.&lt;section&gt;[.&lt;option&gt;]
        set        &lt;config&gt;.&lt;section&gt;[.&lt;option&gt;]=&lt;value&gt;
        delete     &lt;config&gt;[.&lt;section[.&lt;option&gt;]]
        rename     &lt;config&gt;.&lt;section&gt;[.&lt;option&gt;]=&lt;name&gt;
        revert     &lt;config&gt;[.&lt;section&gt;[.&lt;option&gt;]]
        reorder    &lt;config&gt;.&lt;section&gt;=&lt;position&gt;

Options:
        -c &lt;path&gt;  set the search path for config files (default: /etc/config)
        -d &lt;str&gt;   set the delimiter for list values in uci show
        -f &lt;file&gt;  use &lt;file&gt; as input instead of stdin
        -L         do not load any plugins
        -m         when importing, merge data into an existing package
        -n         name unnamed sections on export (default)
        -N         don't name unnamed sections
        -p &lt;path&gt;  add a search path for config change files
        -P &lt;path&gt;  add a search path for config change files and use as default
        -q         quiet mode (don't print error messages)
        -s         force strict mode (stop on parser errors, default)
        -S         disable strict mode
        -X         do not use extended syntax on 'show'
</code></pre>

<h2 id="6-web-开发">6. Web 开发</h2>

<p>使用 Django + Nginx 搭建一个静态站点。</p>

<h3 id="6-1-安装-nginx">6.1. 安装 Nginx</h3>

<p>安装 nginx ，安装后会自动启动：</p>

<pre><code>pi@raspberrypi:~ $ sudo apt-get install nginx
pi@raspberrypi:~ $ systemctl status nginx.service 
â— nginx.service - A high performance web server and a reverse proxy server
   Loaded: loaded (/lib/systemd/system/nginx.service; enabled)
   Active: active (running) since Tue 2017-09-26 22:32:43 CST; 16h ago
 Main PID: 756 (nginx)
   CGroup: /system.slice/nginx.service
           â”œâ”€756 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;
           â”œâ”€757 nginx: worker process
           â”œâ”€758 nginx: worker process
           â”œâ”€759 nginx: worker process
           â””â”€760 nginx: worker process
</code></pre>

<p>通过浏览器访问树莓派的 IP ，可以如下页面：</p>

<p><img src="/images/2017-05-09/2017-05-09_5.png" alt="" /></p>

<h3 id="6-2-安装-django">6.2. 安装 Django</h3>

<p>先安装 pip ：</p>

<pre><code>pi@raspberrypi:~ $ curl  https://bootstrap.pypa.io/get-pip.py -o get-pip.py
pi@raspberrypi:~ $ sudo python  get-pip.py
</code></pre>

<p>然后安装 Django 框架：</p>

<pre><code>pi@raspberrypi:~ $ sudo pip install django
</code></pre>

<h3 id="6-3-安装-uwsgi">6.3. 安装 uWSGI</h3>

<p>安装 python-dev ，否则下一步安装 uwsgi 会失败：</p>

<pre><code>pi@raspberrypi:~ $ sudo apt-get install python-dev
</code></pre>

<p>安装 uwsgi ：</p>

<pre><code>pi@raspberrypi:~ $ sudo pip install uwsgi
</code></pre>

<p>新建一个 test.py 文件，写入如下代码：</p>

<pre><code># test.py
def application(env, start_response):
    start_response('200 OK', [('Content-Type','text/html')])
    return [&quot;Hello uWSGI&quot;] # python2
</code></pre>

<p>保存后执行：</p>

<pre><code>pi@raspberrypi:~ $ uwsgi --http :8000 --wsgi-file test.py
</code></pre>

<p>打开浏览器，访问 <code>http://localhost_ip:8000</code> ，显示 <code>Hello uWSGI</code>，说明 <code>Web client - uWSGI - Python</code> 三个环节是畅通的：</p>

<p><img src="/images/2017-05-09/2017-05-09_6.png" alt="" /></p>
]]></content>
        </item>
        
        <item>
            <title>Linux 串口编程笔记</title>
            <link>https://shaocheng.li/posts/2017/03/27/</link>
            <pubDate>Mon, 27 Mar 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/03/27/</guid>
            <description>1. 串口简介 这里的串口是指美国电子工业联盟（EIA）制定的三种串行数据通信的接口标准， RS-232 、RS-485 和 RS422 ，RS-232 是单端信号全双工，RS-485 是差分信号半双工，RS-422 是差分信号全双工。差分信号的通信速率更高，通信距离更长，RS-232 的通信距离通常小于 15 米，而 RS-485 和 RS-422 可以达到 100 米以上。
以 RS-232 为例，设计之初是用来连接调制解调器做传输之用，也因此它的脚位意义通常也和调制解调器传输有关。RS-232 的设备可以分为数据终端设备（DTE，Data Terminal Equipment, For example, PC）和数据通信设备（DCE，Data Communication Equipment）两类，这种分类定义了不同的线路用来发送和接受信号。一般来说，计算机和终端设备有DTE连接器，调制解调器和打印机有DCE连接器。标准的 232 接口有 25 针，不过常用的是 9 针的 DB-9 接口，信号定义如下：
   脚位 简写 意义 说明     Pin1 DCD Carrier Detect 调制解调器通知电脑有载波被侦测到。   Pin2 RXD Receiver 接收数据。   Pin3 TXD Transmit 发送数据。   Pin4 DTR Data Terminal Ready 电脑告诉调制解调器可以进行传输。   Pin5 GND Ground 地线。   Pin6 DSR Data Set Ready 调制解调器告诉电脑一切准备就绪。   Pin7 RTS Request To Send 电脑要求调制解调器将数据提交。   Pin8 CTS Clear To Send 调制解调器通知电脑可以传数据过来。   Pin9 RI Ring Indicator 调制解调器通知电脑有电话进来。    这个信号说明是从 DTE 设备的角度出发的，TXD、DTR 和 RTS 信号是由 DTE 产生的，RXD、DSR、CTS、DCD 和 RI 信号是由 DCE 产生的。</description>
            <content type="html"><![CDATA[

<h2 id="1-串口简介">1. 串口简介</h2>

<p>这里的串口是指美国电子工业联盟（EIA）制定的三种串行数据通信的接口标准， RS-232 、RS-485 和 RS422 ，RS-232 是单端信号全双工，RS-485 是差分信号半双工，RS-422 是差分信号全双工。差分信号的通信速率更高，通信距离更长，RS-232 的通信距离通常小于 15 米，而 RS-485 和 RS-422 可以达到 100 米以上。</p>

<p>以 RS-232 为例，设计之初是用来连接调制解调器做传输之用，也因此它的脚位意义通常也和调制解调器传输有关。RS-232 的设备可以分为数据终端设备（DTE，Data Terminal Equipment, For example, PC）和数据通信设备（DCE，Data Communication Equipment）两类，这种分类定义了不同的线路用来发送和接受信号。一般来说，计算机和终端设备有DTE连接器，调制解调器和打印机有DCE连接器。标准的 232 接口有 25 针，不过常用的是 9 针的 DB-9 接口，信号定义如下：</p>

<table>
<thead>
<tr>
<th>脚位</th>
<th>简写</th>
<th>意义</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>Pin1</td>
<td>DCD</td>
<td>Carrier Detect</td>
<td>调制解调器通知电脑有载波被侦测到。</td>
</tr>

<tr>
<td>Pin2</td>
<td>RXD</td>
<td>Receiver</td>
<td>接收数据。</td>
</tr>

<tr>
<td>Pin3</td>
<td>TXD</td>
<td>Transmit</td>
<td>发送数据。</td>
</tr>

<tr>
<td>Pin4</td>
<td>DTR</td>
<td>Data Terminal Ready</td>
<td>电脑告诉调制解调器可以进行传输。</td>
</tr>

<tr>
<td>Pin5</td>
<td>GND</td>
<td>Ground</td>
<td>地线。</td>
</tr>

<tr>
<td>Pin6</td>
<td>DSR</td>
<td>Data Set Ready</td>
<td>调制解调器告诉电脑一切准备就绪。</td>
</tr>

<tr>
<td>Pin7</td>
<td>RTS</td>
<td>Request To Send</td>
<td>电脑要求调制解调器将数据提交。</td>
</tr>

<tr>
<td>Pin8</td>
<td>CTS</td>
<td>Clear To Send</td>
<td>调制解调器通知电脑可以传数据过来。</td>
</tr>

<tr>
<td>Pin9</td>
<td>RI</td>
<td>Ring Indicator</td>
<td>调制解调器通知电脑有电话进来。</td>
</tr>
</tbody>
</table>

<p>这个信号说明是从 DTE 设备的角度出发的，TXD、DTR 和 RTS 信号是由 DTE 产生的，RXD、DSR、CTS、DCD 和 RI 信号是由 DCE 产生的。</p>

<p>RS-232 在发送数据时，并不需要另外使用一条传输线来发送同步信号，就能正确的将数据顺利发送到对方，因此叫做“异步传输”，简称UART（Universal Asynchronous Receiver Transmitter），不过必须在每一笔数据的前后都加上同步信号，把同步信号与数据混和之后，使用同一条传输线来传输。比如数据 11001010b 被传输时，数据的前后就需加入 Start(Low）以及 Stop（High）等两个比特，值得注意的是，Start信号固定为一个比特，但 Stop 停止比特则可以是 1、1.5 或者是 2 比特，由收发双方自行选择，但必须保持一致。常见的设置包括波特率、数据位、奇偶校验、停止位和流控制。</p>

<ul>
<li>波特率 (Baud) 表示串口的传输速率叫做波特率，指单位时间内传输符号的个数，在计算机上，通常一个符号就是一个比特，所有可以理解为 bit/s 。因为 5 的 ASCII 码是 01010101b，所以可以发送这个字符，然后用示波器测量出一个 bit 的周期，换算出波特率。典型的波特率是 300, 1200, 2400, 9600, 19200, 115200 等。</li>
<li>数据位 (Data) 表示一个数据帧中数据所占的长度，可以设置 5、6、7 或者 8 bit 。</li>
<li>奇偶校验 (Parity) 用来验证数据的正确性，一般不使用，如果使用，那么既可以做奇校验（Odd Parity）也可以做偶校验（Even Parity）。奇偶校验是通过修改每一发送字节（也可以限制发送的字节）来工作的。</li>
<li>停止位 (Stop)，是在每个字节传输之后发送的，它用来帮助接受信号方硬件重同步，可以设置 1、1.5 或者是 2 bit 。</li>
<li>流控制 (flow control) ，当需要发送握手信号或数据完整性检测时需要制定其他设置。可以使用特定的管脚信号组合 RTS/CTS 和 DTR/DSR ，这叫硬件流控制；或者不使用连接器管脚而在数据流内插入特殊字符 XON/XOFF ，称为软件流控制。</li>
</ul>

<p>RS-232 的逻辑1(mark)的电平为-3～-15V，逻辑0(space)的电平为+3～+15V，注意电平的定义反相了一次。一个典型的数据帧：</p>

<p><img src="/images/2017-03-27/2017-03-27_1.jpg" alt="" /></p>

<h2 id="2-串口操作">2. 串口操作</h2>

<p>Linux 中的串口设备文件通常是 /dev/ttyS0、/dev/ttyS1 &hellip; ，使用 POSIX 终端控制接口编程，串口操作所需的头文件：</p>

<pre><code>#include     &lt;stdio.h&gt;      /*标准输入输出定义*/
#include     &lt;stdlib.h&gt;     /*标准函数库定义*/
#include     &lt;unistd.h&gt;     /*Unix 标准函数定义*/
#include     &lt;fcntl.h&gt;      /*文件控制定义*/
#include     &lt;termios.h&gt;    /*POSIX 终端控制定义*/
#include     &lt;errno.h&gt;      /*错误号定义*/
</code></pre>

<h3 id="2-1-打开串口">2.1. 打开串口</h3>

<p>串口设备也是文件，可以用 <code>open()</code> 函数访问。可能遇到的问题是 Linux 系统禁止普通用户访问设备文件，解决方案包括修改设备文件的访问权限，用 root 用户运行程序，或者改变程序的 owner 。假设任何用户都可以访问设备文件，打开串口的代码如下：</p>

<pre><code>int open_port(void)
{
    int fd; /* File descriptor for the port */
    fd = open(&quot;/dev/ttyS0&quot;, O_RDWR | O_NOCTTY | O_NDELAY);
    if (fd == -1)
        perror(&quot;open_port: Unable to open /dev/ttyS0&quot;);
    else
        fcntl(fd, F_SETFL, 0);
    return (fd);
}
</code></pre>

<p>O_RDWR 表示可读可写；O_NOCTTY 表示不会将这个串口作为该进程的控制终端，如果没有设置这一项，程序会受到键盘控制信号的影响；O_NDELAY 表示无需等待对方串口准备完毕，也就是不会检查 DCD 信号，否则会一直等待 DCD 信号变为 space 。</p>

<h3 id="2-2-读写串口">2.2. 读写串口</h3>

<p>调用 <code>write()</code> 函数向串口写数据即可实现发送：</p>

<pre><code>n = write(fd, &quot;ATZ\r&quot;, 4);
</code></pre>

<p><code>wirte()</code> 函数返回成功发送的字节数，如果发送失败会返回 -1 。</p>

<p>从串口读取数据稍显复杂。当串口配置为 raw 数据模式，如果串口的输入缓存区有数据，<code>read()</code> 函数调用会立即读取并返回；如果输入缓存区没有数据，<code>read()</code> 函数可能会阻塞，等待超时，或者返回错误。可以将 <code>read()</code> 函数设为非阻塞模式：</p>

<pre><code>fcntl(fd, F_SETFL, FNDELAY);
</code></pre>

<p>这样，如果没有收到数据，<code>read()</code> 会立即返回 0 。也可以改回阻塞模式：</p>

<pre><code>fcntl(fd, F_SETFL, 0);
</code></pre>

<h3 id="2-3-关闭串口">2.3. 关闭串口</h3>

<p>调用 <code>close()</code> 函数关闭串口：</p>

<pre><code>close(fd);
</code></pre>

<h3 id="2-4-一个简单的串口收发程序">2.4. 一个简单的串口收发程序</h3>

<p>send.c ，发送一个字符串 “Hello World”。</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

int main(int argc,char **argv)
{
    int fd = 0;
    int ret = 0;
    char *device = &quot;/dev/ttyS0&quot;;
    char send_buf[20] = &quot;Hello World&quot;;
    int send_size = 0;

    fd = open(device,O_RDWR | O_NOCTTY | O_NDELAY ); //打开 ttyS0，默认为阻塞方式
    if (fd == -1)
        perror(&quot;open_port: Unable to open /dev/ttyS0&quot;);
    else
        fcntl(fd, F_SETFL, 0);  

    send_size = strlen(send_buf);
    ret = write(fd,send_buf,send_size+1);  //将字符串结尾的 \0 也发送
    if(ret &lt; send_size)
    {
        printf(&quot;write error\n&quot;);
        return -2;
    }
    printf(&quot;Send %d characters\n&quot;,ret);
    write(fd,&quot;\n&quot;,1);     //最后发送一个换行符

    close(fd);  
    return 0;
}
</code></pre>

<p>recv.c ，接收字符串，read 函数遇到回车或换行符才会返回。</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

int main(int argc,char **argv)
{
    int fd = 0;
    int ret = 0;
    char *device = &quot;/dev/ttyS1&quot;;
    char recv_buf[20];
    int recv_size = 0;

    fd = open(device,O_RDWR | O_NOCTTY | O_NDELAY );  //打开 ttyS1，默认为阻塞方式
    if (fd == -1)
        perror(&quot;open_port: Unable to open /dev/ttyS1&quot;);
    else
        fcntl(fd, F_SETFL, 0);

    recv_size = 20;
    ret = read(fd,recv_buf,recv_size);   //阻塞的读取数据
    if(ret &lt; 0)
    {
        perror(&quot;read error&quot;);
        return -2;
    }
    printf(&quot;Receive %d character: %s\n&quot;,ret,recv_buf);

    close(fd);
    return 0;
}
</code></pre>

<p>Makefile ：</p>

<pre><code>all:send recv

send:send.c
    gcc -Wall -o $@ $&lt;
recv:recv.c
    gcc -Wall -o $@ $&lt;
clean:
    rm -rf send
    rm -rf recv
</code></pre>

<p>连接 ttyS0 和 ttyS1 ，首先执行 recv ，因为是阻塞方式，recv 会一直等待数据。然后在另一个终端执行 send ，接收函数就会显示接收到的字符串。</p>

<h2 id="3-串口配置">3. 串口配置</h2>

<p>配置串口涉及到一个结构和两个函数，需要包含头文件 <code>termios.h</code> :</p>

<pre><code>#include &lt;termios.h&gt;
#define NCCS 32
struct termios {
    tcflag_t c_cflag; //控制选项
    tcflag_t c_iflag; //输入选项
    tcflag_t c_oflag; //输出选项
    tcflag_t c_lflag; //本地选项
    cc_t     c_line;
    cc_t     c_cc[NCCS]; //控制字符
    speed_t  c_ispeed; //输入速率
    speed_t  c_ospeed; //输出速率
};
int tcgetattr(int fd, struct termios *termios_p); //获取当前配置，并保存到 termios_p 中
int tcsetattr(int fd, int option, const struct termios *termios_p); //将 termios_p 写入配置
</code></pre>

<p><code>tcsetattr()</code> 函数的 <code>option</code> 参数可以选择三个常量：</p>

<ul>
<li>TCSANOW    立即写入配置，无需等待数据传输完成</li>
<li>TCSADRAIN  等待数据传输结束后再更改配置</li>
<li>TCSAFLUSH  刷新输入输出缓存，然后再更改配置</li>
</ul>

<h3 id="3-1-控制选项">3.1. 控制选项</h3>

<p><code>c_cflag</code> 成员用于设置波特率、数据位、校验位、停止位和硬件流控制，下面是常用的宏，位于 <code>bits/termios.h</code> 头文件。</p>

<ul>
<li>CBAUD 波特率的位掩码</li>
<li>B4800 4800 baud</li>
<li>B9600 9600 baud</li>
<li>B115200   115,200 baud</li>
<li>EXTA  External rate clock</li>
<li>EXTB  External rate clock</li>
<li>CSIZE 数据位的位掩码</li>
<li>CS5   5 data bits</li>
<li>CS6   6 data bits</li>
<li>CS7   7 data bits</li>
<li>CS8   8 data bits</li>
<li>CSTOPB    2 stop bits (1 otherwise)</li>
<li>CREAD     使能接收</li>
<li>PARENB    使能校验位，默认为偶校验</li>
<li>PARODD    设为奇校验</li>
<li>HUPCL     Hangup (drop DTR) on last close</li>
<li>CLOCAL    Local line - do not change &ldquo;owner&rdquo; of port</li>
<li>LOBLK     Block job control output</li>
<li>CNEW_RTSCTS/CRTSCTS   使能硬件流控制 (某些平台不支持)</li>
</ul>

<p>在传统的POSIX编程中，当不连接一个本地的（通过调制解调器）或者远程的终端（通过调制解调器）时，这里有两个选项应当一直打开，一个是 CLOCAL ，另一个是 CREAD 。这两个选项可以保证你的程序不会变成端口的所有者，而端口所有者必须去处理发散性作业控制和挂断信号，同时还保证了串行接口驱动会读取过来的数据字节。</p>

<p>下面一段代码将设置串口为 9600 8N1 ：</p>

<pre><code>struct termios options;
tcgetattr(fd,&amp;options);

options.c_cflag |= (CLOCAL|CREAD);

options.c_cflag &amp;= ~CBAUD;
options.c_cflag |= B9600;

options.c_cflag &amp;= ~CSIZE;
options.c_cflag |= CS8;

options.c_cflag &amp;= ~PARENB;
options.c_cflag &amp;= ~CSTOPB;

tcsetattr(fd,TCSANOW,&amp;options);
</code></pre>

<p>本地模式</p>

<p><code>c_lflag</code> 用于控制串口驱动怎样控制接收字符。常用的选项用如下几个。</p>

<p>ICANON</p>

<p>用于设置接收字符的处理模式，如果设置了 ICANON 标志，就启动了标准行输入模式，接收的字符会被放入一个缓冲之中，这样可以用交互方式编辑缓冲的内容，直到收到CR(carriage return)或者LF(line feed)字符。进入该模式时，通常需要将 ECHO 和 ECHOE 选项打开：</p>

<pre><code>options.c_lflag |= (ICANON | ECHO | ECHOE);
</code></pre>

<p>如果清除了 ICANON ，就启动了非标准模式。输入字符只是被原封不动的接收。进入该模式时，通常要关闭 ECHO 、ECHOE 和 ISIG 选项：</p>

<pre><code>options.c_lflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG);
</code></pre>

<p>ECHO</p>

<p>使能输入字符回显。设置该标识后，接收到字符后会自动将字符返回到发送端。</p>

<p>下面的程序中，为接收端的串口设置了该标识，发送端 <code>write</code> 之后立即 <code>read</code> ，可以读到回显的字符，回显的字符中有一个 <code>^@</code> ，表示字符串结尾的空字符，这是因为设置了 ECHOCTL 标识，以 <code>^char</code> 的方式回显控制字符。</p>

<p><strong>send.c：</strong></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;termios.h&gt;

int main(int argc,char **argv)
{
    int fd = 0;
    int ret = 0;
    char *device = argv[1];
    char send_buf[20] = &quot;0123456789&quot;;
    int send_size = 0;

    fd = open(device,O_RDWR | O_NOCTTY );
    if(fd&lt;=0)
    {
        printf(&quot;open device error\n&quot;);
        return -1;
    }

    send_size = strlen(send_buf);
    ret = write(fd,send_buf,send_size+1);  
    if(ret &lt; send_size)
    {
        printf(&quot;write error\n&quot;);
        return -2;
    }

    printf(&quot;Send %d characters\n&quot;,ret);
    write(fd,&quot;\n&quot;,1);     

    //读取回显的字符
    ret = 0;
    memset(send_buf,0x00,20);
    ret = read(fd,send_buf,20);
    if(ret &gt; 0)
    {
        printf(&quot;ret = %d\n&quot;,ret);
        printf(&quot;%s\n&quot;,send_buf);
    }   

    close(fd);

    return 0;
}
</code></pre>

<p><strong>read.c：</strong></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;termios.h&gt;

int main(int argc,char **argv)
{
    int fd = 0;
    int ret = 0;
    char *device = argv[1];
    char recv_buf[20];
    int recv_size = 0;
    struct termios options; 

    fd = open(device,O_RDWR | O_NOCTTY );  
    if(fd&lt;=0)
    {
        printf(&quot;open device error\n&quot;);
        return -1;
    }

    tcgetattr(fd,&amp;options);
    options.c_lflag |= ICANON;
    options.c_lflag |= ECHO | ECHOCTL;
    tcsetattr(fd,TCSANOW,&amp;options);

    recv_size = 12;
    ret = read(fd,recv_buf,recv_size);   
    if(ret &lt; 0)
    {
        perror(&quot;read error&quot;);
        return -2;
    }
    printf(&quot;Receive %d character: %s\n&quot;,ret,recv_buf);

    close(fd);

    return 0;
}
</code></pre>

<p>连接 ttyS0 和 ttyS1 ，在第一个终端执行 <code>./read /dev/ttyS0</code>，在第二个终端执行 <code>./send /dev/ttyS1</code> 可以看到如下结果：</p>

<pre><code>Send 11 characters
ret = 13
0123456789^@
</code></pre>

<p>如果清除 ECHOCTL 标识，执行的结果如下：</p>

<pre><code>Send 11 characters
ret = 12
0123456789
</code></pre>

<p><strong>注意，</strong>如果通讯双方都设置了 ECHO 标识，可能会陷入互相回显的死循环。</p>

<p>其他选项</p>

<ul>
<li>ISIG  使能 SIGINTR, SIGSUSP, SIGDSUSP, 和 SIGQUIT 信号</li>
<li>XCASE Map uppercase \lowercase (obsolete)</li>
<li>ECHOE Echo erase character as BS-SP-BS</li>
<li>ECHOK 接收到 kill 字符后回显一个换行符。</li>
<li>ECHONL    回显换行符(0x0A)</li>
<li>NOFLSH    Disable flushing of input buffers after interrupt or quit characters</li>
<li>IEXTEN    Enable extended functions</li>
<li>ECHOPRT   Echo erased character as character erased</li>
<li>ECHOKE    BS-SP-BS entire line on line kill</li>
<li>FLUSHO    Output being flushed</li>
<li>PENDIN    Retype pending input at next read or input char</li>
<li>TOSTOP    Send SIGTTOU for background output</li>
</ul>

<p>输入模式</p>

<p><code>c_iflag</code> 用于控制接收的数据在传递给程序之前的处理方式。</p>

<p>使能奇偶校验</p>

<p>如果在 c_cflag 中设置了奇偶校验位，就要在这里使能奇偶校验：</p>

<pre><code>options.c_iflag |= (INPCK | ISTRIP);
</code></pre>

<p>INPCK 表示使能奇偶校验，ISTRIP 表示将数据中的奇偶校验位剥离。</p>

<p>使能软件流控制</p>

<p>软件流控制可以通过IXON，IXOFF和IXANY常量设置成有效：</p>

<pre><code>options.c_iflag |= (IXON | IXOFF | IXANY);
</code></pre>

<p>XON(start data)和XOFF(stop data)字符在c_cc数组中定义，关于软件流控制的详细内容在后面介绍。</p>

<p>其他选项</p>

<ul>
<li>IGNPAR    Ignore parity errors</li>
<li>PARMRK    Mark parity errors</li>
<li>IXON  Enable software flow control (outgoing)</li>
<li>IXOFF Enable software flow control (incoming)</li>
<li>IXANY Allow any character to start flow again</li>
<li>IGNBRK    Ignore break condition</li>
<li>BRKINT    Send a SIGINT when a break condition is detected</li>
<li>INLCR Map NL to CR</li>
<li>IGNCR Ignore CR</li>
<li>ICRNL Map CR to NL</li>
<li>IUCLC Map uppercase to lowercase</li>
<li>IMAXBEL   Echo BEL on input line too long</li>
</ul>

<p>输出模式</p>

<p><code>c_oflag</code> 用于控制由程序发送的数据在传递给串口或屏幕之前做怎样的处理。很多处理方式和输入模式是相对。</p>

<p>要使用输出模式必须设置 OPOST 标识，否则其他标识都会被忽略，数据会以原始形式发送。</p>

<pre><code>options.c_oflag |= OPOST;
</code></pre>

<ul>
<li>OPOST Postprocess output (not set = raw output)</li>
<li>OLCUC Map lowercase to uppercase</li>
<li>ONLCR Map NL to CR-NL</li>
<li>OCRNL Map CR to NL</li>
<li>NOCR  No CR output at column 0</li>
<li>ONLRET    NL performs CR function</li>
<li>OFILL Use fill characters for delay</li>
<li>OFDEL Fill character is DEL</li>
<li>NLDLY Mask for delay time needed between lines</li>
<li>NL0   No delay for NLs</li>
<li>NL1   Delay further output after newline for 100 milliseconds</li>
<li>CRDLY Mask for delay time needed to return carriage to left column</li>
<li>CR0   No delay for CRs</li>
<li>CR1   Delay after CRs depending on current column position</li>
<li>CR2   Delay 100 milliseconds after sending CRs</li>
<li>CR3   Delay 150 milliseconds after sending CRs</li>
<li>TABDLY    Mask for delay time needed after TABs</li>
<li>TAB0  No delay for TABs</li>
<li>TAB1  Delay after TABs depending on current column position</li>
<li>TAB2  Delay 100 milliseconds after sending TABs</li>
<li>TAB3  Expand TAB characters to spaces</li>
<li>BSDLY Mask for delay time needed after BSs</li>
<li>BS0   No delay for BSs</li>
<li>BS1   Delay 50 milliseconds after sending BSs</li>
<li>VTDLY Mask for delay time needed after VTs</li>
<li>VT0   No delay for VTs</li>
<li>VT1   Delay 2 seconds after sending VTs</li>
<li>FFDLY Mask for delay time needed after FFs</li>
<li>FF0   No delay for FFs</li>
<li>FF1   Delay 2 seconds after sending FFs</li>
</ul>

<p>控制字符</p>

<p>控制字符都是一些字符组合，例如 Ctrl+C 。当用户键入这些组合键时，终端会采取一些特殊的处理方式。termios 结构中的 c_cc 数组成员将控制字符映射到对于的支持函数。控制字符的位置用一个宏定义（即数组下标）。</p>

<p>c_cc 中的控制字符的数组下标：</p>

<table>
    <tr>
        <td>常量</td><td>键</td><td>字符</td><td>描述</td>
    </tr>
    <tr>
        <td>VINTR</td><td>CTRL-C</td><td></td><td></td>
    </tr>
    <tr>
        <td>VQUIT</td><td>CTRL-Z</td><td></td><td></td>
    </tr>
    <tr>
        <td>VERASE</td><td>Backspase</td><td></td><td></td>
    </tr>
    <tr>
        <td>VKILL</td><td>CTRL-U</td><td></td><td></td>
    </tr>
    <tr>
        <td>VEOF</td><td>CTRL-D</td><td></td><td></td>
    </tr>
    <tr>
        <td>VEOL</td><td>CTRL-D</td><td></td><td></td>
    </tr>
    <tr>
        <td>VSTART</td><td>CTRL-Q</td><td></td><td></td>
    </tr>
    <tr>
        <td>VSTOP</td><td>CTRL-S</td><td></td><td></td>
    </tr>
    <tr>
        <td>VTIME</td><td></td><td></td><td></td>
    </tr>
    <tr>
        <td>VMIN</td><td></td><td></td><td></td>
    </tr>
</table>

<p>VTIME 和 VMIN</p>

<p>只有在非标准输入模式或者没有通过open(2)和fcntl(2)函数传递NDELAY选项时，这两个值才有效。二者结合起来控制对输入的读取。</p>

<h2 id="4-流控制">4. 流控制</h2>

<h2 id="5-uart-rs-232-与-ttl">5. UART、RS-232 与 TTL</h2>

<p>逻辑1(mark)的电平为-3～-15V，逻辑0(space)的电平为+3～+15V，注意电平的定义反相了一次。</p>

<h2 id="参考">参考</h2>

<p><a href="https://www.cmrr.umn.edu/~strupp/serial.html" target="_blank">The Serial Programming Guide for POSIX Operating Systems</a></p>
]]></content>
        </item>
        
        <item>
            <title>在 ITerm2 中使用 Zmodem 协议传输文件</title>
            <link>https://shaocheng.li/posts/2017/01/10/</link>
            <pubDate>Tue, 10 Jan 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/01/10/</guid>
            <description>Zmodem 是跨平台的文件传输协议，可以很方便的在不同的操作系统之间接传输文件。lzrsz 是该协议的实现方式：https://ohse.de/uwe/software/lrzsz.html 。安装后，在 Mac 的 ITerm2 中用 SSH 登陆远程的 Linux 主机，然后用 rz 、sz 命令传输文件。
在 Ubuntu 中安装:
$ sudo apt-get install lrzsz  在 Mac 中安装：
$ brew install lrzsz  为方便 ITerm2 中使用，需要下载两个脚本：
cd /usr/local/bin sudo wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-send-zmodem.sh sudo wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-recv-zmodem.sh sudo chmod 777 /usr/local/bin/iterm2-*  然后打开 ITerm2 ，点击 preferences &amp;gt; profiles ，选中 Default ，在右侧的 Advanced 标签页中，点击 Tirggers 框的 Edit 按钮，按如下设置添加两个条目：
   Regular expression Action Parameters Instant     rz waiting to receive.</description>
            <content type="html"><![CDATA[<p>Zmodem 是跨平台的文件传输协议，可以很方便的在不同的操作系统之间接传输文件。lzrsz 是该协议的实现方式：<a href="https://ohse.de/uwe/software/lrzsz.html" target="_blank">https://ohse.de/uwe/software/lrzsz.html</a> 。安装后，在 Mac 的 ITerm2 中用 SSH 登陆远程的 Linux 主机，然后用 rz 、sz 命令传输文件。</p>

<p>在 Ubuntu 中安装:</p>

<pre><code>$ sudo apt-get install lrzsz
</code></pre>

<p>在 Mac 中安装：</p>

<pre><code>$ brew install lrzsz
</code></pre>

<p>为方便 ITerm2 中使用，需要下载两个脚本：</p>

<pre><code>cd /usr/local/bin
sudo wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-send-zmodem.sh
sudo wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-recv-zmodem.sh
sudo chmod 777 /usr/local/bin/iterm2-*
</code></pre>

<p>然后打开 ITerm2 ，点击 preferences &gt; profiles ，选中 Default ，在右侧的 Advanced 标签页中，点击 Tirggers 框的 Edit 按钮，按如下设置添加两个条目：</p>

<table>
<thead>
<tr>
<th>Regular expression</th>
<th>Action</th>
<th>Parameters</th>
<th>Instant</th>
</tr>
</thead>

<tbody>
<tr>
<td>rz waiting to receive.**B0100</td>
<td>Run Silent Coprocess</td>
<td>/usr/local/bin/iterm2-send-zmodem.sh</td>
<td>checked</td>
</tr>

<tr>
<td>**B00000000000000</td>
<td>Run Silent Coprocess</td>
<td>/usr/local/bin/iterm2-recv-zmodem.sh</td>
<td>checked</td>
</tr>
</tbody>
</table>

<p><img src="/images/2017-01-10/2017-01-10_1.png" alt="" /></p>

<p>向远程 Linux 主机发送文件：</p>

<ol>
<li>在 Ubuntu 上执行 rc</li>
<li>在弹出的对话框中选中要发送的文件</li>
<li>等待发送完成</li>
</ol>

<p>接收远程 Linux 发来的文件：</p>

<ol>
<li>在 Ubuntu 上执行 <code>sz filename1 filename2 ...</code></li>
<li>在弹出的对话框中选中接收文件的目录</li>
<li>等待接收完成。</li>
</ol>

<p>iterm2-send-zmodem.sh 内容：</p>

<pre><code>#!/bin/bash
# Author: Matt Mastracci (matthew@mastracci.com)
# AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script
# licensed under cc-wiki with attribution required
# Remainder of script public domain

osascript -e 'tell application &quot;iTerm2&quot; to version' &gt; /dev/null 2&gt;&amp;1 &amp;&amp; NAME=iTerm2 || NAME=iTerm
if [[ $NAME = &quot;iTerm&quot; ]]; then
    FILE=`osascript -e 'tell application &quot;iTerm&quot; to activate' -e 'tell application &quot;iTerm&quot; to set thefile to choose file with prompt &quot;Choose a file to send&quot;' -e &quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;`
else
    FILE=`osascript -e 'tell application &quot;iTerm2&quot; to activate' -e 'tell application &quot;iTerm2&quot; to set thefile to choose file with prompt &quot;Choose a file to send&quot;' -e &quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;`
fi
if [[ $FILE = &quot;&quot; ]]; then
    echo Cancelled.
    # Send ZModem cancel
    echo -e \\x18\\x18\\x18\\x18\\x18
    sleep 1
    echo
    echo \# Cancelled transfer
else
    /usr/local/bin/sz &quot;$FILE&quot; -e -b
    sleep 1
    echo
    echo \# Received $FILE
fi
</code></pre>

<p>iterm2-recv-zmodem.sh 内容：</p>

<pre><code>#!/bin/bash
# Author: Matt Mastracci (matthew@mastracci.com)
# AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script
# licensed under cc-wiki with attribution required
# Remainder of script public domain

osascript -e 'tell application &quot;iTerm2&quot; to version' &gt; /dev/null 2&gt;&amp;1 &amp;&amp; NAME=iTerm2 || NAME=iTerm
if [[ $NAME = &quot;iTerm&quot; ]]; then
    FILE=`osascript -e 'tell application &quot;iTerm&quot; to activate' -e 'tell application &quot;iTerm&quot; to set thefile to choose folder with prompt &quot;Choose a folder to place received files in&quot;' -e &quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;`
else
    FILE=`osascript -e 'tell application &quot;iTerm2&quot; to activate' -e 'tell application &quot;iTerm2&quot; to set thefile to choose folder with prompt &quot;Choose a folder to place received files in&quot;' -e &quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;`
fi

if [[ $FILE = &quot;&quot; ]]; then
    echo Cancelled.
    # Send ZModem cancel
    echo -e \\x18\\x18\\x18\\x18\\x18
    sleep 1
    echo
    echo \# Cancelled transfer
else
    cd &quot;$FILE&quot;
    /usr/local/bin/rz -E -e -b
    sleep 1
    echo
    echo
    echo \# Sent \-\&gt; $FILE
fi
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>Sublime Text 3 常用插件</title>
            <link>https://shaocheng.li/posts/2017/01/07/</link>
            <pubDate>Sat, 07 Jan 2017 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2017/01/07/</guid>
            <description>0. Package Control 用于下载、管理插件的插件，安装方法见项目主页。有时安装后会出现 “There are no packages available for installation” 这样的错误，这是因为无法下载插件资源列表文件。解决方法是在菜单栏中选择 Preferences &amp;gt; Package Settings &amp;gt; Package Control &amp;gt; Settings-User ，在打开的配置文件中添加：
&amp;quot;channels&amp;quot;: [ &amp;quot;https://gist.githubusercontent.com/stanwu/679f8af0c9a43f800974/raw/5e3561bfb8b3ddc92680052c89e73c7dabc92f94/channel_v3.json&amp;quot;, &amp;quot;https://web.archive.org/web/20150905194312/https://packagecontrol.io/channel_v3.json&amp;quot; ],  1. Predawn 一款为Sublime和Atom打造的暗色主题，可以定义Tab的大小，SideBar大小，Find栏大小，并提供主题同款的ICON。
安装后重启 Sublime Text ，通过菜单栏 Preferences -&amp;gt; Settings 打开用户配置文件，添加：
&amp;quot;theme&amp;quot;: &amp;quot;predawn-DEV.sublime-theme&amp;quot;, //软件 UI 主题 &amp;quot;color_scheme&amp;quot;: &amp;quot;Packages/Predawn/predawn.tmTheme&amp;quot;, //编辑器配色 &amp;quot;font_size&amp;quot;: 15, &amp;quot;predawn_findreplace_small&amp;quot;: true, //查找对话框设为最小 &amp;quot;predawn_sidebar_small&amp;quot;: true, //侧边栏设为最小 &amp;quot;predawn_tabs_active_underline&amp;quot;: true, //使能当前标签页高亮 &amp;quot;predawn_tabs_small&amp;quot;: true, //标签页设为最小  更多选项可以在项目主页查看。
2. SideBarFolder 打开的文件夹都太多了，可以用这个来管理，安装后会在菜单栏多一个 Folders 。
3. SideBarEnhancements 扩展右键选项：</description>
            <content type="html"><![CDATA[

<h2 id="0-package-control-https-packagecontrol-io-installation">0. <a href="https://packagecontrol.io/installation" target="_blank">Package Control</a></h2>

<p>用于下载、管理插件的插件，安装方法见项目主页。有时安装后会出现 “There are no packages available for installation” 这样的错误，这是因为无法下载插件资源列表文件。解决方法是在菜单栏中选择 Preferences &gt; Package Settings &gt; Package Control &gt; Settings-User ，在打开的配置文件中添加：</p>

<pre><code>&quot;channels&quot;:
[
   &quot;https://gist.githubusercontent.com/stanwu/679f8af0c9a43f800974/raw/5e3561bfb8b3ddc92680052c89e73c7dabc92f94/channel_v3.json&quot;,
    &quot;https://web.archive.org/web/20150905194312/https://packagecontrol.io/channel_v3.json&quot;
],
</code></pre>

<h2 id="1-predawn-https-github-com-jamiewilson-predawn">1. <a href="https://github.com/jamiewilson/predawn" target="_blank">Predawn</a></h2>

<p>一款为Sublime和Atom打造的暗色主题，可以定义Tab的大小，SideBar大小，Find栏大小，并提供主题同款的ICON。</p>

<p><img src="/images/2017-01-07/2017-01-07_1.jpg" alt="" /></p>

<p>安装后重启 Sublime Text ，通过菜单栏 Preferences -&gt; Settings 打开用户配置文件，添加：</p>

<pre><code>&quot;theme&quot;: &quot;predawn-DEV.sublime-theme&quot;, //软件 UI 主题
&quot;color_scheme&quot;: &quot;Packages/Predawn/predawn.tmTheme&quot;,  //编辑器配色
&quot;font_size&quot;: 15,
&quot;predawn_findreplace_small&quot;: true,   //查找对话框设为最小
&quot;predawn_sidebar_small&quot;: true,     //侧边栏设为最小
&quot;predawn_tabs_active_underline&quot;: true,   //使能当前标签页高亮
&quot;predawn_tabs_small&quot;: true,    //标签页设为最小
</code></pre>

<p>更多选项可以在项目主页查看。</p>

<h2 id="2-sidebarfolder-https-github-com-titobouzout-sidebarfolders">2. <a href="https://github.com/titoBouzout/SideBarFolders" target="_blank">SideBarFolder</a></h2>

<p>打开的文件夹都太多了，可以用这个来管理，安装后会在菜单栏多一个 Folders 。</p>

<p><img src="/images/2017-01-07/2017-01-07_2.jpg" alt="" /></p>

<h2 id="3-sidebarenhancements-https-github-com-titobouzout-sidebarenhancements">3. <a href="https://github.com/titoBouzout/SideBarEnhancements" target="_blank">SideBarEnhancements</a></h2>

<p>扩展右键选项：</p>

<p><img src="/images/2017-01-07/2017-01-07_3.jpg" alt="" /></p>

<h2 id="4-sublimeastyleformatter-http-theo-im-sublimeastyleformatter">4. <a href="http://theo.im/SublimeAStyleFormatter/" target="_blank">SublimeAStyleFormatter</a></h2>

<p>简单好用的代码格式化工具。安装后，对文件点击鼠标右键，会出现格式化选项，可以全文件格式化，也可以对选中的文本格式化：</p>

<p><img src="/images/2017-01-07/2017-01-07_4.jpg" alt="" /></p>

<p>也可以在配置文件中设置快捷键，最好打开保存时自动格式化：</p>

<pre><code>// Auto format on file save
&quot;autoformat_on_save&quot;: true,
</code></pre>

<h2 id="5-terminal-https-github-com-wbond-sublime-terminal">5. <a href="https://github.com/wbond/sublime_terminal" target="_blank">Terminal</a></h2>

<p>在当前文件夹内打开 Terminal 。安装后，对文件或者目录点鼠标右键，会出现 Open Terminal Here&hellip; ：</p>

<p><img src="/images/2017-01-07/2017-01-07_5.jpg" alt="" /></p>

<p>必须在配置文件中设置打开 Terminal 的命令，对于在 Mac OS 中的 iTerm2 打开新的标签页，可以这样设置：</p>

<pre><code>&quot;terminal&quot;: &quot;iTerm.sh&quot;,
&quot;parameters&quot;: [&quot;--open-in-tab&quot;]
</code></pre>

<p>对于 iTerm2 V3 ：</p>

<pre><code>&quot;terminal&quot;: &quot;iTerm2-v3.sh&quot;
</code></pre>

<h2 id="6-alignment-http-wbond-net-sublime-packages-alignment">6. <a href="http://wbond.net/sublime_packages/alignment" target="_blank">Alignment</a></h2>

<p>选中后按 command+control+a 就可以使其按照等号对其:</p>

<p><img src="/images/2017-01-07/2017-01-07_6.jpg" alt="" /></p>

<h2 id="7-c-improved-https-github-com-abusalimov-sublimecimproved">7. <a href="https://github.com/abusalimov/SublimeCImproved" target="_blank">C Improved</a></h2>

<p>C 语言语法高亮插件。安装后打开一个 C 源文件，在菜单栏中选中 C Improved ：</p>

<p><img src="/images/2017-01-07/2017-01-07_7.jpg" alt="" /></p>

<h2 id="8-ctags-https-github-com-sublimetext-ctags">8. <a href="https://github.com/SublimeText/CTags" target="_blank">Ctags</a></h2>

<p>寻找函数和变量的定义。安装插件后还要在系统中安装 Ctags ：</p>

<pre><code>brew install ctags 
</code></pre>

<p>默认安装在 /usr/local/bin/ctags 。在配置文件中添加命令路径和参数：</p>

<pre><code>&quot;command&quot;: &quot;/usr/local/bin/ctags -R&quot;,
</code></pre>

<p>然后在对源码目录右键选择 Rebuild Tags ，生成索引文件：</p>

<p><img src="/images/2017-01-07/2017-01-07_8.jpg" alt="" /></p>

<p>之后再函数上悬停鼠标，就会出现该函数定义的位置，点击可进入：</p>

<p><img src="/images/2017-01-07/2017-01-07_9.jpg" alt="" /></p>

<p>或者右键选择 Navigate to Definition :</p>

<p><img src="/images/2017-01-07/2017-01-07_10.jpg" alt="" /></p>

<p>Jump Back 可以跳回调用处。默认快捷键是 <code>control+shift+左键</code> 跳转到定义处，<code>control+shift+右键</code> 跳回来。</p>

<h2 id="9-made-of-code-themes-https-github-com-kumarnitin-made-of-code-tmbundle">9. <a href="https://github.com/kumarnitin/made-of-code-tmbundle" target="_blank">made-of-code-themes</a></h2>

<p>Markdown 语法高亮配色。下载后解压到包目录下，然后打开一个 Markdown 文件，在菜单中选择语法配置：</p>

<p><img src="/images/2017-01-07/2017-01-07_11.jpg" alt="" /></p>

<p>在打开的 Markdown 配置文件中添加该配色文件的路径：</p>

<p><img src="/images/2017-01-07/2017-01-07_12.jpg" alt="" /></p>

<h2 id="10-omnimarkuppreviewer-http-theo-im-omnimarkuppreviewer">10. <a href="http://theo.im/OmniMarkupPreviewer/" target="_blank">OmniMarkupPreviewer</a></h2>

<p>实时预览 Markdown 文件。对 Markdown 文件右键就会出现在浏览器中预览、导出 HTML 文件等选项：</p>

<p><img src="/images/2017-01-07/2017-01-07_13.jpg" alt="" /></p>

<p>快捷键：</p>

<ul>
<li>command+option+O: Preview Markup in Browser.</li>
<li>command+option+X: Export Markup as HTML.</li>
<li>command+option+C: Copy Markup as HTML.</li>
</ul>

<h2 id="11-fileheader-https-github-com-shiyanhui-fileheader">11. <a href="https://github.com/shiyanhui/FileHeader" target="_blank">FileHeader</a></h2>

<p>自动为源码文件生成头部注释。可以自定义注释内容，自动识别各种语言的文件。</p>

<p><img src="/images/2017-01-07/2017-01-07_14.gif" alt="" /></p>

<h2 id="12-pretty-json-https-packagecontrol-io-packages-pretty-20json">12. <a href="https://packagecontrol.io/packages/Pretty%20JSON" target="_blank">Pretty JSON</a></h2>

<p>格式化 JSON ，用法是选中 JSON 格式的文本，然后按快捷键是 <code>cmd+ctrl+j</code>，也可以直接按快捷键对全文件格式化。</p>

<h2 id="13-html-css-js-prettify-https-github-com-victorporof-sublime-htmlprettify">13. <a href="https://github.com/victorporof/Sublime-HTMLPrettify" target="_blank">HTML-CSS-JS prettify</a></h2>

<p>可以格式化 HTML、CSS 和 JS 文本。安装后，选中需要格式化的文本，按快捷键 <code>cmd+shift+h</code> 即可完成格式化。</p>

<h2 id="参考">参考</h2>

<ul>
<li>Sublime Text：学习资源篇：<a href="http://www.jianshu.com/p/d1b9a64e2e37" target="_blank">http://www.jianshu.com/p/d1b9a64e2e37</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>推荐一款 Markdown 编辑器</title>
            <link>https://shaocheng.li/posts/2016/12/24/</link>
            <pubDate>Sat, 24 Dec 2016 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2016/12/24/</guid>
            <description>Markdown 语法解决了文本编辑时，内容与样式分离的问题，让我们更专注于内容，少在排版上浪费时间。
Cmd Markdown 这款编辑器扩展了 Markdown 语法，实现了很多实用的功能：
 实时同步预览 编程语言高亮，显示行号 支持绘制表格、流程图、甘特图 支持 LaTeX 公式 支持段落批注 支持 Vim 编辑模式 可导出 Html 和 PDF 文件 支持云端同步存储 提供 Linux、Windows、Mac 桌面端编辑器和 Web 端编辑器  </description>
            <content type="html"><![CDATA[<p>Markdown 语法解决了文本编辑时，内容与样式分离的问题，让我们更专注于内容，少在排版上浪费时间。</p>

<p><a href="https://www.zybuluo.com/cmd/" target="_blank">Cmd Markdown</a> 这款编辑器扩展了 Markdown 语法，实现了很多实用的功能：</p>

<ul>
<li>实时同步预览</li>
<li>编程语言高亮，显示行号</li>
<li>支持绘制表格、流程图、甘特图</li>
<li>支持 LaTeX 公式</li>
<li>支持段落批注</li>
<li>支持 Vim 编辑模式</li>
<li>可导出 Html 和 PDF 文件</li>
<li>支持云端同步存储</li>
<li>提供 Linux、Windows、Mac 桌面端编辑器和 Web 端编辑器</li>
</ul>

<p><img src="/images/2016-12-24/2016-12-24_1.png" alt="" /></p>
]]></content>
        </item>
        
        <item>
            <title>Linux Wireless HowTo</title>
            <link>https://shaocheng.li/posts/2016/10/26/</link>
            <pubDate>Wed, 26 Oct 2016 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2016/10/26/</guid>
            <description>这里的无线（Wireless）指无线局域网，它的通用标准是 IEEE 802.11 协议，定义了数据链路层（MAC层）和物理层协议，工作载波的频率为 2.4GHz ，划分了 11 个频道，最新的协议已经有 5GHz 的工作频率。协议的演进方向是 802.11a-&amp;gt;802.11b-&amp;gt;802.11g-&amp;gt;802.11n 。
而 802.11i 是 802.11 的无线安全协议，它的技术实现是 WPA 和 WPA2 ，都是开放秘钥认证方式，都属于 Wi-Fi 联盟，WPA2 是比 WPA 更高级的一种安全方式，RSN 是 WPA2 的别名。PSK 和 802.1X 是两种无线安全实现的方式，PSK 是个人级别的，而 802.1X 是企业级别的，较为复杂，但更安全。TKIP 和 CCMP 是两种数据加密算法，在 WPA 和 WPA2 中都可以使用。而 AES 是 CCMP 算法中的核心算法，且目前来看，是最可靠的加密算法。
Wi-Fi 是一个厂商联盟的标志，目的是建立一个统一的、基于 IEEE 802.11 协议的技术实现。可以简单把 Wi-Fi 设备理解为符合 IEEE 802.11 协议标准的设备。
Linux 系统中的无线网卡通常用到两种模式，一种是 Station 模式，也就是作为普通 Wi-Fi 设备去连接无线路由器；另一种是 AccessPoint（AP）模式，就是让无线网卡作为 Wi-Fi 热点，供其他 Wi-Fi 设备连接，这需要用到 hostapd ，可以参考 http://shaocheng.</description>
            <content type="html"><![CDATA[

<p>这里的无线（Wireless）指无线局域网，它的通用标准是 IEEE 802.11 协议，定义了数据链路层（MAC层）和物理层协议，工作载波的频率为 2.4GHz ，划分了 11 个频道，最新的协议已经有 5GHz 的工作频率。协议的演进方向是 802.11a-&gt;802.11b-&gt;802.11g-&gt;802.11n 。</p>

<p>而 802.11i 是 802.11 的无线安全协议，它的技术实现是 WPA 和 WPA2 ，都是开放秘钥认证方式，都属于 Wi-Fi 联盟，WPA2 是比 WPA 更高级的一种安全方式，RSN 是 WPA2 的别名。PSK 和 802.1X 是两种无线安全实现的方式，PSK 是个人级别的，而 802.1X 是企业级别的，较为复杂，但更安全。TKIP 和 CCMP 是两种数据加密算法，在 WPA 和 WPA2 中都可以使用。而 AES 是 CCMP 算法中的核心算法，且目前来看，是最可靠的加密算法。</p>

<p>Wi-Fi 是一个厂商联盟的标志，目的是建立一个统一的、基于 IEEE 802.11 协议的技术实现。可以简单把 Wi-Fi 设备理解为符合 IEEE 802.11 协议标准的设备。</p>

<p>Linux 系统中的无线网卡通常用到两种模式，一种是 Station 模式，也就是作为普通 Wi-Fi 设备去连接无线路由器；另一种是 AccessPoint（AP）模式，就是让无线网卡作为 Wi-Fi 热点，供其他 Wi-Fi 设备连接，这需要用到 hostapd ，可以参考 <a href="http://shaocheng.li/post/blog/2016-01-01" target="_blank">http://shaocheng.li/post/blog/2016-01-01</a>， 这里主要讲 Station 模式下无线网卡的操作方式。关于无线操作模式：<a href="http://shaocheng.li/post/blog/2012-10-27-wireless-oprating-mode" target="_blank">http://shaocheng.li/post/blog/2012-10-27-wireless-oprating-mode</a> 。</p>

<h2 id="1-硬件和驱动">1. 硬件和驱动</h2>

<p>大部分无线网卡是 pci 设备，以 Intel 6205 为例，在 Fedora 21 中查看：</p>

<pre><code>[root@localhost ~]# lspci
00:00.0 Host bridge: Intel Corporation Atom Processor Z36xxx/Z37xxx Series SoC Transaction Register (rev 0c)
...
01:00.0 Network controller: Intel Corporation Centrino Advanced-N 6205 [Taylor Peak] (rev 34)
04:00.0 Ethernet controller: Intel Corporation 82574L Gigabit Network Connection
[root@localhost ~]# lspci -vk -s 01:00.0
01:00.0 Network controller: Intel Corporation Centrino Advanced-N 6205 [Taylor Peak] (rev 34)
        Subsystem: Intel Corporation Centrino Advanced-N 6205 AGN
        Flags: bus master, fast devsel, latency 0, IRQ 268
        Memory at 90700000 (64-bit, non-prefetchable) [size=8K]
        Capabilities: [c8] Power Management version 3
        Capabilities: [d0] MSI: Enable+ Count=1/1 Maskable- 64bit+
        Capabilities: [e0] Express Endpoint, MSI 00
        Capabilities: [100] Advanced Error Reporting
        Capabilities: [140] Device Serial Number 10-0b-a9-ff-ff-b4-99-00
        Kernel driver in use: iwlwifi
        Kernel modules: iwlwifi
</code></pre>

<p>可以看到它使用的驱动是 iwlwifi ，这是当前 Intel 无线芯片的通用驱动，针对不同的芯片需要不同的固件，固件名称的格式是 iwlwifi-*.ucode ，存放在 /lib/firmware/ 目录下。在这个页面可以查看支持的芯片和固件下载列表：<a href="https://wireless.wiki.kernel.org/en/users/drivers/iwlwifi" target="_blank">https://wireless.wiki.kernel.org/en/users/drivers/iwlwifi</a> 。Linux 内核对无线设备的支持也是分层的结构，最上层面向用户空间的接口标准有两个，nl80211 和 wext ，nl80211 正在逐步替代 wext 。我们可以在 /sys/module/iwlwifi/parameters/ 目录下读取驱动的各项参数：</p>

<pre><code>/sys/module/iwlwifi/parameters# ls -l
total 0
-r--r--r-- 1 root root 4096 Nov 29 10:03 11n_disable
-r--r--r-- 1 root root 4096 Nov 29 10:03 amsdu_size_8K
-r--r--r-- 1 root root 4096 Nov 29 10:03 antenna_coupling
-r--r--r-- 1 root root 4096 Nov 29 10:03 bt_coex_active
-r--r--r-- 1 root root 4096 Nov 29 10:03 fw_restart
-r--r--r-- 1 root root 4096 Nov 29 10:03 led_mode
-r--r--r-- 1 root root 4096 Nov 29 10:03 nvm_file
-r--r--r-- 1 root root 4096 Nov 29 10:03 power_level
-r--r--r-- 1 root root 4096 Nov 29 10:03 power_save
-r--r--r-- 1 root root 4096 Nov 29 10:03 swcrypto
-r--r--r-- 1 root root 4096 Nov 29 10:03 wd_disable
</code></pre>

<p>如果要修改某个参数，需要在 /etc/modprobe.d/ 目录下新建一个 iwlwifi.conf 文件，然后添加选项，比如禁用 11n ：</p>

<pre><code>/etc/modprobe.d# cat iwlwifi.conf 
options iwlwifi 11n_disable=1
</code></pre>

<p>修改后重新加载驱动，或者重启，就可以在 /sys/module/iwlwifi/parameters 目录下验证该选项是否已经被修改：</p>

<pre><code>/sys/module/iwlwifi/parameters# cat 11n_disable 
1
</code></pre>

<p>驱动和固件加载成功后，就会出现设备文件：</p>

<pre><code>[root@localhost ~]# iw dev
phy#0
        Interface wlp1s0
                ifindex 3
                wdev 0x1
                addr 10:0b:a9:b4:99:00
                type managed
</code></pre>

<p>可以看到，这个无线设备的名称是 phy#0 ，接口名称是 wlp1s0 ，addr 段就是 mac 地址，当前的设备类型是 managed ，也就是 station 模式。用 <code>ifconfig -a</code> 也可以看到。</p>

<h2 id="2-iw-工具">2. iw 工具</h2>

<p>iw 是一个管理无线设备的命令行工具，使用 nl80211 接口标准，支持所有最新被添加到 Linux 内核的无线网卡驱动。旧的 iwconfig 工具使用 wext 接口标准。</p>

<p>用 <code>iw list</code> 命令可以列出当前系统中所有无线设备的功能特性。如果要看指定网卡的特性，语法是 <code>iw devicename info</code> ：</p>

<pre><code>[root@localhost ~]# iw phy#0 info
Wiphy phy0
        max # scan SSIDs: 20
        max scan IEs length: 195 bytes
        Coverage class: 0 (up to 0m)
        Device supports RSN-IBSS.
        Supported Ciphers:
                * WEP40 (00-0f-ac:1)
                * WEP104 (00-0f-ac:5)
                * TKIP (00-0f-ac:2)
                * CCMP (00-0f-ac:4)
        Available Antennas: TX 0 RX 0
        Supported interface modes:
                 * IBSS
                 * managed
                 * AP
                 * AP/VLAN
                 * monitor
         ...
        Supported commands:
                 * new_interface
                 * set_interface
                 * new_key
                 * start_ap
                 * new_station
                 * new_mpath
         ...
        software interface modes (can always be added):
                 * AP/VLAN
                 * monitor
         ...
        Device supports TX status socket option.
        Device supports HT-IBSS.
        Device supports scan flush.
</code></pre>

<p>这个信息很长，首先看到最多可以扫描 20 个热点，支持的加密算法是 WEP            、TKIP、CCMP。在 Supported interface modes 段可以看到该网卡支持的模式，包括 AP ，在 software interface modes 可以看到该网卡支持软 AP 。在 Supported commands 段列出了该网卡支持的命令，这些都是 nl80211 接口提供的命令，可以在 Linux 内核的 nl80211.c 文件中看到。</p>

<p>运行 <code>iw dev wlp1s0 scan</code> 可以扫描 Wi-Fi 热点，前题是接口已经激活，可以用 <code>ifconfig wlp1s0 up</code> ，否则会失败：</p>

<pre><code>[root@localhost ~]# iw dev wlp1s0 scan                  
command failed: Network is down (-100)
</code></pre>

<p>以扫描到的一个热点为例：</p>

<pre><code>BSS f4:ec:38:30:bb:b8(on wlp1s0)
        TSF: 2459924068 usec (0d, 00:40:59)
        freq: 2437
        beacon interval: 100 TUs
        capability: ESS Privacy ShortPreamble ShortSlotTime (0x0431)
        signal: -51.00 dBm
        last seen: 1 ms ago
        SSID: TP-LINK_30BBB8
        Supported rates: 1.0* 2.0* 5.5* 11.0* 6.0 9.0 12.0 18.0 
        DS Parameter set: channel 6
        RSN:     * Version: 1
                 * Group cipher: CCMP
                 * Pairwise ciphers: CCMP
                 * Authentication suites: PSK
                 * Capabilities: 1-PTKSA-RC 1-GTKSA-RC (0x0000)
        WPA:     * Version: 1
                 * Group cipher: CCMP
                 * Pairwise ciphers: CCMP
                 * Authentication suites: PSK
        ERP: &lt;no flags&gt;
        ...
</code></pre>

<p>可以读到几个有用的信息，首先是信号强度 signal:-51.00 dBm ，热点的 SSID 是 TP-LINK_30BBB8 ，使用的频道是 6 ，认证方式是
WPA 和 RSN （即 WPA2），秘钥管理算法是 PSK ，加密算法是 CCMP 。</p>

<p>iw 支持手动连接无认证或者 WEP 认证的 Wi-Fi 热点，而不支持 WPA/WPA2 认证热点。如果要加入无认证的热点，执行 <code>iw wlp1s0 connect &lt;SSID&gt;</code> 。对于 WEP 认证的热点，执行 <code>iw wlp1s0 connect &lt;SSID&gt;  [key 0:abcde d:1:6162636465]</code> 。连接成功后，可以设置静态 IP ，也可以用 dhclient 动态获取 IP 和 DNS 。我们很少用 iw 来连接 Wi-Fi ，通常是用 wpa_supplicant 。</p>

<p>还有一个在调试时有用的命令 <code>iw event</code> ，它可以监听 Wi-Fi 连接过程中的所有事件。当启动 wpa_supplicant 去连接一个热点时，可以开启该命令，它会显示完整的连接过程，包括扫描、协商、验证、连接。加一个 -f 选项可以显示连接过程发送的帧，加 -t 选项可以显示每个步骤的时间：</p>

<pre><code>[root@localhost ~]# iw event -t
1478053617.986731: wlp1s0 (phy #0): scan started
1478053619.947956: wlp1s0 (phy #0): scan finished: 2412 2417 2422 2427 2432 2437 2442 2447 2452 2457 2462 2467 2472 5180 5200 5220 5240 5260 5280 5300 5320 5745 5765 5785 5805 5825, &quot;&quot;
1478053619.977751: wlp1s0: new station f4:ec:38:30:bb:b8
1478053619.988617: wlp1s0 (phy #0): auth f4:ec:38:30:bb:b8 -&gt; 10:0b:a9:b4:99:00 status: 0: Successful
1478053620.043766: wlp1s0 (phy #0): assoc f4:ec:38:30:bb:b8 -&gt; 10:0b:a9:b4:99:00 status: 0: Successful
1478053620.043992: wlp1s0 (phy #0): connected to f4:ec:38:30:bb:b8
</code></pre>

<p>查看连接状态：</p>

<pre><code>[root@localhost ~]# iw wlp1s0 link    
Not connected.
[root@localhost ~]# iw wlp1s0 link
Connected to f4:ec:38:30:bb:b8 (on wlp1s0)
        SSID: TP-LINK_30BBB8
        freq: 2437
        RX: 6256 bytes (46 packets)
        TX: 1435 bytes (15 packets)
        signal: -59 dBm
        tx bitrate: 1.0 MBit/s
        bss flags:      short-preamble short-slot-time
        dtim period:    1
        beacon int:     100
</code></pre>

<p>SSID 字段表示当前连接的热点名称。signal 字段表示当前连接热点的信号强度，它是个负数，越接近 0 ，表示信号越好，小于 -113 就基本没信号了。</p>

<p>查看当前无线设备的使用情况，包括进出流量等信息：</p>

<pre><code>[root@localhost ~]# iw dev wlp1s0 station dump   
Station f4:ec:38:30:bb:b8 (on wlp1s0)
        inactive time:  175 ms
        rx bytes:       4635
        rx packets:     31
        tx bytes:       1095
        tx packets:     11
        tx retries:     49
        tx failed:      2
        signal:         -68 dBm
        signal avg:     -64 dBm
        tx bitrate:     1.0 MBit/s
        rx bitrate:     54.0 MBit/s MCS 3 40MHz
        authorized:     yes
        authenticated:  yes
        preamble:       long
        WMM/WME:        yes
        MFP:            no
        TDLS peer:      no
</code></pre>

<p>iw 还有其他选项，可以执行 <code>iw help</code> 查看。</p>

<h2 id="3-wpa-supplicant">3. wpa_supplicant</h2>

<p>wpa_supplicant 是一个命令行式的 Wi-Fi 访问客户端程序，支持 WEP、WPA/WPA2 认证方式，在 Linux 中用于自动连接 Wi-Fi 热点，支持断线后自动重连。同时支持 nl80211 和 wext 两种驱动接口。</p>

<p>常用选项：</p>

<ul>
<li>-B ：让 wpa_supplicant 运行在后台，在 -i 选项前设置。</li>
<li>-c filename ：配置文件的路径，在 -i 选项前设置。</li>
<li>-D ：设置使用的驱动，可选 nl80211 和 wext 等，在 -i 选项前设置。</li>
<li>-i interface ：监听的无线设备接口名称，这里可以设为 wlp1s0 。</li>
<li>-d ：增加调试信息，-dd 可以显示更多。</li>
<li>-t ：在调试信息中加上时间戳。</li>
<li>-f filename ：日志文件的路径。</li>
<li>-P filename ：PID 文件的路径。</li>
<li>-q ：减少调试信息，-qq 可以显示的更少。</li>
<li>-u ：使能 DBus 控制接口。</li>
<li>-N ：如果有多个无线设备，就用 -N 分隔，之后继续设置下一个。例如 <code>wpa_supplicant -c wpa1.conf -i wlan0 -D hostap -N  -c wpa2.conf -i ath0 -D madwifi</code></li>
</ul>

<p>配置文件通常是 /etc/wpa_supplicant/wpa_supplicant.conf ，可以在文件内设置多个 Wi-Fi 热点的连接信息，wpa_supplicant 启动后会自动选择一个最好的网络，依据是认证方式（ WPA/WPA2 优先）和信号强度。如果完整安装了 wpa_supplicant ，在 /usr/share/doc/wpa_supplicant/ 目录下会有一个 wpa_supplicant.conf 文件，里面有各种情况的详细配置和说明。说几个常用的全局配置选项：</p>

<ul>
<li>ctrl_interface=filename ：设置控制接口的路径。如果设置了该参数，wpa_supplicant 会打开一个控制接口，供外部程序管理 wpa_supplicant 。推荐设置为 /var/run/wpa_supplicant ，wpa_supplicant 会在此目录下生成 socket ，用于监听外部程序状态的请求。</li>
<li>ap_scan ：通常设为 1 。由 wpa_supplicant 启动扫描和 AP 选择，如果没有找到与配置文件中相匹配的 AP ，则初始化一个新网络（如果有配置）。另外可选 0 或 2 。</li>
</ul>

<p>每个 Wi-Fi 热点的连接信息都配置在一个 network 段中，几个常用的选项：</p>

<ul>
<li>key_mgmt ：秘钥管理算法，对于 WPA/WPA2 ，根据 Wi-Fi 热点的配置可选 WPA-PSK 和 WPA-EAP 。</li>
<li>ssid ：热点的 ssid 。</li>
<li>psk ：对于 WPA/WPA2 ，密码不能设为明码，需要用 wpa_passphrase 命令生成加密后的 64 位十六进制数，语法是 <code>wpa_passphrase SSID password</code> 。</li>
</ul>

<p>假如现在要连接一个 WPA/WPA2 认证的无线路由器，配置文件如下：</p>

<pre><code>[root@localhost ~]# wpa_passphrase TP-LINK_30BBB8 123456789 
network={
    ssid=&quot;TP-LINK_30BBB8&quot;
    #psk=&quot;123456789&quot;
    psk=b9ea0d09776bd4f4d8099b78ab91d924b97366562d620161a1b4ffb1ac99ae33
}
[root@localhost ~]# cat /etc/wpa_supplicant/wpa_supplicant.conf
ctrl_interface=/var/run/wpa_supplicant
ap_scan=1
network={
        ssid=&quot;TP-LINK_30BBB8&quot;
        key_mgmt=WPA-PSK
        #psk=&quot;123456789&quot;
        psk=b9ea0d09776bd4f4d8099b78ab91d924b97366562d620161a1b4ffb1ac99ae33
}
</code></pre>

<p>对于无许认证的热点，只设置 ssid 即可 ：</p>

<pre><code>network={
    ssid=&quot;MYSSID&quot;
    key_mgmt=NONE
}
</code></pre>

<p>然后执行 wpa_supplicant 开始连接：</p>

<pre><code>[root@localhost ~]# wpa_supplicant -B -Dnl80211 -u -iwlp1s0 -c /etc/wpa_supplicant/wpa_supplicant.conf -f /var/log/wpa_supplicant.log -P /var/run/wpa_supplicant.pid 
</code></pre>

<p>连接过程可以查看 log 文件，连接成功后可以设置静态 IP ，也可以用 dhclient 获得动态 IP 。</p>

<h2 id="4-dhclient">4. dhclient</h2>

<p>DHCP 协议是一种集中管理和自动分配 IP 地址的通信协议，使用 UDP 协议工作。DHCP 使用了租约的概念，即获得的 IP 地址的有效期。一次典型的 DHCP 工作周期分为发现、提供、请求、确认，如图：</p>

<p><img src="/images/2016-10-26/2016-10-26_1.jpg" alt="" /></p>

<p>不再租用 IP 后，客户端应该向 DHCP 服务器发送一个请求以释放 DHCP 资源，并注销其IP地址。详情可以参考<a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E8%AE%BE%E7%BD%AE%E5%8D%8F%E8%AE%AE" target="_blank">动态主机设置协议</a></p>

<p>dhclient 是一个 DHCP 客户端程序，用于从 DHCP 服务器获取动态 IP ，默认支持 IPV4 ，也支持 IPV6 。成功获得 IP 后，程序会驻留在后台。常用的选项有：</p>

<ul>
<li>-lf <lease-file> ：lease 文件的路径，默认是 /var/lib/dhclient/dhclient.leases ，是成功获取 IP 后的数据库。</li>
<li>-pf <pid-file> ：PID 文件的路径，默认是 /var/run/dhclient.pid 。</li>
<li>-cf <config-file> ：配置文件的路径. 默认是 /etc/dhcp/dhclient.conf 。</li>
<li>-sf <script-file> ：网络配置脚本文件的路径。默认是 /sbin/dhclient-script ，成功获取 IP 后会执行该脚本，主要作用是配置 IP 、DNS、和默认路由，还会调用 /etc/dhcp/dhclient.d/ 下的用户自定义脚本。</li>
<li>-q ：保持安静，不输出任何信息。</li>
<li>-timeout <time> ：超时时间，超过这个时间而无法获得 IP 即退出。</li>
<li>-r ：告诉 dhclient 释放获取的 IP ，释放后，后台的 dhclient 会退出。</li>
<li>-d ：让 dhclient 在前台运行。</li>
</ul>

<p>配置文件默认是 /etc/dhcp/dhclient.conf，同目录下还有一个名为 dhclient.d 的文件夹，可以在下面放一些脚本，供 dhclient-script 调用，执行一下获取 IP 后的动作。如果安装了完整的程序，在 /usr/share/doc/dhclient 目录下会有配置文件的例子和 dhclient.d 下脚本文件的说明。</p>

<p>针对 wlp1s0 这个接口写一个简单的配置文件：</p>

<pre><code>timeout 60;
retry 60;
reboot 10;
select-timeout 5;
initial-interval 2;
reject 192.33.137.209;
interface &quot;wlp1s0&quot; {
    send host-name “my_pc&quot;;
    send dhcp-lease-time 3600;
    request subnet-mask, broadcast-address, time-offset, routers,domain-search, domain-name, domain-name-servers, host-name;
    require subnet-mask, domain-name-servers,host-name;
}
</code></pre>

<p>解释一下这些配置选项：</p>

<ul>
<li>timeout ：超时时间，这里设置是 60 秒。从尝试与 DHCP server 联系开始，超过这个时间还没有获得 IP ，就结束这次协商，在重试间隔后再重启协商。</li>
<li>retry ：重试间隔，一次与 DHCP server 协商失败后，经过这个时间后重启协商，默认是五分钟。</li>
<li>reboot ：当 dhclient 启动后，它会首先尝试请求上一次连接该网络时获得的 IP ，如果失败，则经过这个时间后在尝试请求新 IP ，默认是十秒。</li>
<li>select-timeout ：如果有多个 DHCP server 为该网络提供服务，client 可能获得多个 IP 提议，而这些提议有先后顺序，client 会在 select-timeout 时间内接收提议，然后选择最优的（比如上一次获得的 IP ），超过这个时间，就停止接收新提议。默认是零秒，就是直接采用第一个接收到的提议。</li>
<li>initial-interval ：第一次尝试到达服务器和第二次尝试到达服务器的间隔。</li>
<li>reject ：拒绝来自某些 DHCP server 的提议。可以指定某个 IP ，也可以通过子网掩码指定拒绝某个网段，多个 IP 用逗号分隔，例如：<code>reject 192.168.0.0/16, 10.0.0.5;</code> 。</li>
</ul>

<p>设置完全局选项，就可以对网口进行单独设置，这些选项可以在 dhcp-options 的 man 手册中查找。一个配置文件可以为多个网口配置不同的行为，语法是 <code>interface &quot;name&quot; { declarations ... }</code> ，name 就是网口名称，花括号内为它的配置选项：</p>

<ul>
<li>send host-name ：向服务器发送本机的名称。</li>
<li>send dhcp-lease-time ：告诉服务器请求的 IP 租期，这里设置了 3600 秒。</li>
<li>request ：请求服务器向客户端发送指定选项的值，通常不用设置，缺省已经请求了很多必要选项。</li>
<li>require ：列出了必须向服务器发送的选项，以便接收要约，要发送的值用 send 语句设置。没有缺省值。</li>
</ul>

<p>有了配置文件后，执行 <code>dhclient</code> 即可。与 DHCP server 协商成功后，会将获取的 IP 等信息保存到 dhclient.leases 文件，这是 DHCP client 租赁数据库，如果有多条数据，最后一天有效。</p>

<pre><code>[root@localhost ~]# cat /var/lib/dhclient/dhclient.leases 
default-duid &quot;\000\001\000\001\037\234\226n\020\013\251\264\231\000&quot;;
lease {
  interface &quot;wlp1s0&quot;;
  fixed-address 192.168.1.105;
  option subnet-mask 255.255.255.0;
  option routers 192.168.1.1;
  option dhcp-lease-time 7200;
  option dhcp-message-type 5;
  option domain-name-servers 192.168.1.1;
  option dhcp-server-identifier 192.168.1.1;
  renew 1 2016/10/24 08:59:57;
  rebind 1 2016/10/24 09:51:49;
  expire 1 2016/10/24 10:06:49;
}
</code></pre>

<p>然后 dhclient 会调用 dhclient-script 文件，它的作用修改网口 IP 、修改默认路由、替换 /etc/resolv.conf 文件，还会调用 /etc/dhcp/dhclient.d/ 下的用户自定义脚本，详情可以查看 dhclient-script 的 man 手册。</p>

<p>如果要是否释放 IP ，执行 <code>dhclient -r</code> 。</p>

<p>最后补充一点，在目前的 Linux 发行版中，已经有集成化的网卡管理工具，比如 NetworkManager ，可以统一的管理以太网、Wi-Fi、3G等网卡设备，简化了很多步骤，比较方便，当然底层还是调用这些基本的程序。</p>

<h2 id="5-国别代码问题">5. 国别代码问题</h2>

<p>不同的国家和地区对 Wi-Fi 的合法频段有不同的要求，Wi-Fi 模块都支持设置国别代码，使模块使用合法的频段。可以通过 iw 命令读取当前模块设置的国别代码与合法频段：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@localhost:~# iw reg get
country CN: DFS-FCC
	<span style="color:#f92672">(</span><span style="color:#ae81ff">2402</span> - <span style="color:#ae81ff">2482</span> @ <span style="color:#ae81ff">40</span><span style="color:#f92672">)</span>, <span style="color:#f92672">(</span>N/A, <span style="color:#ae81ff">20</span><span style="color:#f92672">)</span>, <span style="color:#f92672">(</span>N/A<span style="color:#f92672">)</span>
	<span style="color:#f92672">(</span><span style="color:#ae81ff">5170</span> - <span style="color:#ae81ff">5250</span> @ <span style="color:#ae81ff">80</span><span style="color:#f92672">)</span>, <span style="color:#f92672">(</span>N/A, <span style="color:#ae81ff">23</span><span style="color:#f92672">)</span>, <span style="color:#f92672">(</span>N/A<span style="color:#f92672">)</span>
	<span style="color:#f92672">(</span><span style="color:#ae81ff">5250</span> - <span style="color:#ae81ff">5330</span> @ <span style="color:#ae81ff">80</span><span style="color:#f92672">)</span>, <span style="color:#f92672">(</span>N/A, <span style="color:#ae81ff">23</span><span style="color:#f92672">)</span>, <span style="color:#f92672">(</span><span style="color:#ae81ff">0</span> ms<span style="color:#f92672">)</span>, DFS
	<span style="color:#f92672">(</span><span style="color:#ae81ff">5735</span> - <span style="color:#ae81ff">5835</span> @ <span style="color:#ae81ff">80</span><span style="color:#f92672">)</span>, <span style="color:#f92672">(</span>N/A, <span style="color:#ae81ff">30</span><span style="color:#f92672">)</span>, <span style="color:#f92672">(</span>N/A<span style="color:#f92672">)</span>
	<span style="color:#f92672">(</span><span style="color:#ae81ff">57240</span> - <span style="color:#ae81ff">59400</span> @ <span style="color:#ae81ff">2160</span><span style="color:#f92672">)</span>, <span style="color:#f92672">(</span>N/A, <span style="color:#ae81ff">28</span><span style="color:#f92672">)</span>, <span style="color:#f92672">(</span>N/A<span style="color:#f92672">)</span>
	<span style="color:#f92672">(</span><span style="color:#ae81ff">59400</span> - <span style="color:#ae81ff">63720</span> @ <span style="color:#ae81ff">2160</span><span style="color:#f92672">)</span>, <span style="color:#f92672">(</span>N/A, <span style="color:#ae81ff">44</span><span style="color:#f92672">)</span>, <span style="color:#f92672">(</span>N/A<span style="color:#f92672">)</span>
	<span style="color:#f92672">(</span><span style="color:#ae81ff">63720</span> - <span style="color:#ae81ff">65880</span> @ <span style="color:#ae81ff">2160</span><span style="color:#f92672">)</span>, <span style="color:#f92672">(</span>N/A, <span style="color:#ae81ff">28</span><span style="color:#f92672">)</span>, <span style="color:#f92672">(</span>N/A<span style="color:#f92672">)</span></code></pre></div>
<p>在 Linux 系统里通常是通过配置文件这种相应的驱动参数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@localhost:~# cat /etc/default/crda
<span style="color:#75715e"># Set REGDOMAIN to a ISO/IEC 3166-1 alpha2 country code so that iw(8) may set</span>
<span style="color:#75715e"># the initial regulatory domain setting for IEEE 802.11 devices which operate</span>
<span style="color:#75715e"># on this system.</span>
#
<span style="color:#75715e"># Governments assert the right to regulate usage of radio spectrum within</span>
<span style="color:#75715e"># their respective territories so make sure you select a ISO/IEC 3166-1 alpha2</span>
<span style="color:#75715e"># country code suitable for your location or you may infringe on local</span>
<span style="color:#75715e"># legislature. See `/usr/share/zoneinfo/zone.tab&#39; for a table of timezone</span>
<span style="color:#75715e"># descriptions containing ISO/IEC 3166-1 alpha2 country codes.</span>

REGDOMAIN<span style="color:#f92672">=</span>CN


root@localhost:~# cat /etc/modprobe.d/iwlwifi.conf
<span style="color:#75715e"># /etc/modprobe.d/iwlwifi.conf</span>
<span style="color:#75715e"># iwlwifi will dyamically load either iwldvm or iwlmvm depending on the</span>
<span style="color:#75715e"># microcode file installed on the system.  When removing iwlwifi, first</span>
<span style="color:#75715e"># remove the iwl?vm module and then iwlwifi.</span>
remove iwlwifi <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span><span style="color:#f92672">(</span>/sbin/lsmod | grep -o -e ^iwlmvm -e ^iwldvm -e ^iwlwifi | xargs /sbin/rmmod<span style="color:#f92672">)</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span><span style="color:#f92672">&amp;&amp;</span> /sbin/modprobe -r mac80211
options iwlwifi lar_disable<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>


root@localhost:~# cat /etc/modprobe.d/cfg80211.conf
options cfg80211 ieee80211_regdom<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;CN&#34;</span></code></pre></div>
<h2 id="参考">参考</h2>

<ul>
<li><a href="https://wireless.wiki.kernel.org" target="_blank">https://wireless.wiki.kernel.org</a></li>
<li>man 手册</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Linux 3G Module HowTo</title>
            <link>https://shaocheng.li/posts/2016/10/25/</link>
            <pubDate>Tue, 25 Oct 2016 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2016/10/25/</guid>
            <description>Linux 中 3G 模块的层次结构：
硬件模块就是 3G 模块，通常通过 USB 总线接入计算机。内核中的 3G 模块驱动可以在应用层生成串行设备，例如 ttyUSB*、ttyACM* 等。3G 模块的拨号连接过程遵循 ppp 协议，它提供了通过串行点对点链路传输数据报的方法，Linux 内核集成了 ppp 协议栈，pppd 程序是 ppp 协议在用户空间的守护进程，chat 程序负责通过串行设备与 pppd 之间的通信。
1. 硬件和驱动 大部分 3G 模块是挂在 USB 总线上，以 Telit HE910 模块为例，这是一个支持 WCDMA ，即联通 3G 的模块 ：
[root@localhost ~]# lsusb Bus 001 Device 006: ID 09da:0260 A4Tech Co., Ltd. KV-300H Isolation Keyboard Bus 001 Device 005: ID 0424:2514 Standard Microsystems Corp. USB 2.0 Hub Bus 001 Device 004: ID 1bc7:0021 Telit Wireless Solutions HE910  Linux 系统包含一个通用的 USB 驱动 CDC_ACM，很多 3G 模块都用它来驱动，HE910 就是这样。驱动加载成功后会创建多个 tty 设备文件，其中两个比较重要：</description>
            <content type="html"><![CDATA[

<p>Linux 中 3G 模块的层次结构：</p>

<p><img src="/images/2016-10-25/2016-10-25_1.jpg" alt="" /></p>

<p>硬件模块就是 3G 模块，通常通过 USB 总线接入计算机。内核中的 3G 模块驱动可以在应用层生成串行设备，例如 ttyUSB*、ttyACM* 等。3G 模块的拨号连接过程遵循 ppp 协议，它提供了通过串行点对点链路传输数据报的方法，Linux 内核集成了 ppp 协议栈，pppd 程序是 ppp 协议在用户空间的守护进程，chat 程序负责通过串行设备与 pppd 之间的通信。</p>

<h2 id="1-硬件和驱动">1. 硬件和驱动</h2>

<p>大部分 3G 模块是挂在 USB 总线上，以 Telit HE910 模块为例，这是一个支持 WCDMA ，即联通 3G 的模块 ：</p>

<pre><code>[root@localhost ~]# lsusb
Bus 001 Device 006: ID 09da:0260 A4Tech Co., Ltd. KV-300H Isolation Keyboard
Bus 001 Device 005: ID 0424:2514 Standard Microsystems Corp. USB 2.0 Hub
Bus 001 Device 004: ID 1bc7:0021 Telit Wireless Solutions HE910
</code></pre>

<p>Linux 系统包含一个通用的 USB 驱动 CDC_ACM，很多 3G 模块都用它来驱动，HE910 就是这样。驱动加载成功后会创建多个 tty 设备文件，其中两个比较重要：</p>

<ul>
<li>/dev/ttyACM0: PPP 连接和 AT 指令的通用接口</li>
<li>/dev/ttyACM3: AT 指令接口</li>
</ul>

<p>不同的模块所用驱动可能不同，具体情况要查看模块的使用手册。Linux 内核要支持 ppp 协议，这已经是现在 Linux 的默认配置。</p>

<h2 id="2-at-指令">2. AT 指令</h2>

<p>对 3G 模块执行 AT 指令用很多方式，最简单的是用 cat 和 echo 命令。例如，在一个终端执行 <code>cat &lt; /dev/ttyACM3</code>，它会持续监听该端口的返回信息，然后在另一个终端用 echo 向 /dev/ttyACM3 发送 AT 指令，在 cat 中就可以看到返回：</p>

<pre><code>#Terminal 1
[root@localhost ~]# cat &lt; /dev/ttyACM3 
OK

#Terminal 2
[root@localhost ~]# echo -en &quot;AT\r&quot; &gt; /dev/ttyACM3
</code></pre>

<p>常用的是 minicom ，可以用于交互调试：</p>

<pre><code>[root@localhost ~]# minicom -D /dev/ttyACM3 -b 115200
Welcome to minicom 2.7                                                                         
OPTIONS: I18n                                                                                  
Compiled on Aug 17 2014, 17:34:01.                                                             
Port /dev/ttyACM3, 15:39:12                                                                    
Press CTRL-A Z for help on special keys                                                        

AT                                                                                             
OK                                                                                             
ATZ                                                                                            
OK                                                                                             
AT+CSQ                                                                                         
+CSQ: 3,3                                                                                      
</code></pre>

<p>还用一个纯命令行工具 comgt ，可以很方便的集成到其他程序中，还支持脚本执行一系列 AT 指令，完成复杂的功能。一般 Linux 系统都没有安装，需要下载编译：<a href="https://sourceforge.net/projects/comgt/" target="_blank">https://sourceforge.net/projects/comgt/</a> 。 这有我写的一篇文档：<a href="http://shaocheng.li/post/blog/2015-09-09" target="_blank">http://shaocheng.li/post/blog/2015-09-09</a></p>

<p>AT 指令分为两部分，一部分是通用标准的指令，各个模块都一样；另一部分是各厂商为自家模块自定义的扩展指令，详细信息可以查看模块的 AT 指令手册。以 HE910 为例，介绍几个常用指令。</p>

<ul>
<li><p>ATZ ，软重启 3G 模块。</p></li>

<li><p>AT+CGMI ，读取模块厂商：</p>

<pre><code>AT+CGMI
Telit
</code></pre></li>

<li><p>AT+CGMM ，读取模块名称：</p>

<pre><code>AT+CGMM
HE910-D
</code></pre></li>

<li><p>AT+CGSN ，读取模块的 IMEI：</p>

<pre><code>AT+CGSN
351579053301782
</code></pre></li>

<li><p>AT+CGMR ，读取模块的固件版本：</p>

<pre><code>AT+CGMR&quot;
12.00.024
</code></pre></li>

<li><p>AT+CIMI ，查询 IMSI 。IMSI 是国际移动用户识别码，储存在 SIM 卡中，每张 SIM 卡都不一样，通常是十五位数字，由三段组成。前三位是国家代码（MCC，中国是 460）。之后的两位或者三位是移动网络代码（MNC)，用于标识不同的运营商网络，中国移动使用 00、02、07（不同的号码可以区分不同的号段），中国联通使用 01、06、09，中国电信使用 03、05、11，更多的可以查看<a href="https://en.wikipedia.org/wiki/Mobile_country_code" target="_blank">这里</a>。最后是用户识别码（MSIN），由运营商自定义。</p>

<pre><code>AT+CIMI
460019048517149
</code></pre></li>

<li><p>AT+CSQ ，获取信号强度，信号强度与是否插 SIM 卡无关：</p>

<pre><code>AT+CSQ
+CSQ: 15,1  
</code></pre>

<p>第一个数字表示信号轻度，取值0~31，数字越大信号越好，99 表示未知或不可检测，换算方式： CSQ 值=（接收信号强度 dBm + 113）/2 ：</p>

<p><img src="~/14-31-06.jpg" alt="" /></p></li>

<li><p>AT+CPIN? ，可以用来查看 SIM 卡是否插好，插好会返回 READY ：</p>

<pre><code>AT+CPIN?
+CPIN: READY
OK
</code></pre></li>

<li><p>AT+CNUM ，查看电话号码，前提是号码已经存储在 SIM 中 ：</p>

<pre><code>AT+CNUM
+CNUM: &quot;&quot;,&quot;+8618589041260&quot;,145        
OK
</code></pre></li>

<li><p>AT+WS46=[<n>] ，选择无线网络,三个数字分别是 2G only、3G only、3G first 。</p></li>
</ul>

<p><img src="/images/2016-10-25/2016-10-25_2.jpg" alt="" /></p>

<ul>
<li><p>AT#PSNT? ，查询当前的网络类型，返回的数据格式是 <code>#PSNT: &lt;mode&gt;,&lt;nt&gt;</code> ：</p>

<pre><code>AT#PSNT?
#PSNT: 0,3

OK
</code></pre>

<p>数据的含义：</p>

<pre><code>&lt;mode&gt;
    0 - PSNT unsolicited result code disabled
    1 - PSNT unsolicited result code enabled
&lt;nt&gt; - network type
    0 - GPRS network
    1 - EGPRS network
    2 - WCDMA network
    3 - HSDPA network
    4 - unknown or not registered.
</code></pre></li>

<li><p>AT#RFSTS ，读取当前的网络状态，数据比较多，具体含义需要查看手册：</p>

<pre><code>AT#RFSTS
#RFSTS: &quot;460 01&quot;,10713,64,-4.5,-89,-80,A53F,02,-128,64,19,4,2,,17030E9,&quot;460010892513284&quot;,&quot;CHN-UNICOM&quot;,3,0

OK
</code></pre></li>
</ul>

<p>AT 指令可能返回错误代码，下面常见错误代码的含义：</p>

<pre><code>CME ERROR: 0    Phone failure
CME ERROR: 1    No connection to phone
CME ERROR: 2    Phone adapter link reserved
CME ERROR: 3    Operation not allowed
CME ERROR: 4    Operation not supported
CME ERROR: 5    PH_SIM PIN required
CME ERROR: 6    PH_FSIM PIN required
CME ERROR: 7    PH_FSIM PUK required
CME ERROR: 10   SIM not inserted
CME ERROR: 11   SIM PIN required
CME ERROR: 12   SIM PUK required
CME ERROR: 13   SIM failure
CME ERROR: 14   SIM busy
CME ERROR: 15   SIM wrong
CME ERROR: 16   Incorrect password
CME ERROR: 17   SIM PIN2 required
CME ERROR: 18   SIM PUK2 required
CME ERROR: 20   Memory full
CME ERROR: 21   Invalid index
CME ERROR: 22   Not found
CME ERROR: 23   Memory failure
CME ERROR: 24   Text string too long
CME ERROR: 25   Invalid characters in text string
CME ERROR: 26   Dial string too long
CME ERROR: 27   Invalid characters in dial string
CME ERROR: 30   No network service
CME ERROR: 31   Network timeout
CME ERROR: 32   Network not allowed, emergency calls only
CME ERROR: 40   Network personalization PIN required
CME ERROR: 41   Network personalization PUK required
CME ERROR: 42   Network subset personalization PIN required
CME ERROR: 43   Network subset personalization PUK required
CME ERROR: 44   Service provider personalization PIN required
CME ERROR: 45   Service provider personalization PUK required
CME ERROR: 46   Corporate personalization PIN required
CME ERROR: 47   Corporate personalization PUK required
CME ERROR: 48   PH-SIM PUK required
CME ERROR: 100  Unknown error
CME ERROR: 103  Illegal MS
CME ERROR: 106  Illegal ME
CME ERROR: 107  GPRS services not allowed
CME ERROR: 111  PLMN not allowed
CME ERROR: 112  Location area not allowed
CME ERROR: 113  Roaming not allowed in this location area
CME ERROR: 126  Operation temporary not allowed
CME ERROR: 132  Service operation not supported
CME ERROR: 133  Requested service option not subscribed
CME ERROR: 134  Service option temporary out of order
CME ERROR: 148  Unspecified GPRS error
CME ERROR: 149  PDP authentication failure
CME ERROR: 150  Invalid mobile class
CME ERROR: 256  Operation temporarily not allowed
CME ERROR: 257  Call barred
CME ERROR: 258  Phone is busy
CME ERROR: 259  User abort
CME ERROR: 260  Invalid dial string
CME ERROR: 261  SS not executed
CME ERROR: 262  SIM Blocked
CME ERROR: 263  Invalid block
CME ERROR: 527  Please wait, and retry your selection later (Specific Modem Sierra)
CME ERROR: 528  Location update failure – emergency calls only (Specific Modem Sierra)
CME ERROR: 529  Selection failure – emergency calls only (Specific Modem Sierra)
CME ERROR: 772  SIM powered down
</code></pre>

<h2 id="3-pppd">3. pppd</h2>

<p>pppd 是 ppp 协议的守护进程，全称点对点协议守护进程。它的 man 手册提供了详细使用说明，这里有中文版：<a href="https://docs.oracle.com/cd/E56344_01/html/E54077/pppd-1m.html" target="_blank">https://docs.oracle.com/cd/E56344_01/html/E54077/pppd-1m.html</a> 。语法是：</p>

<pre><code>pppd [option]
</code></pre>

<p>常用的选项：</p>

<ul>
<li><em>tty_name</em> ：指定用于 ppp 拨号的串行设备，通常是 /dev/ 目录下的 tty 设备，对于 HE910 应该设为 /dev/ttyACM0 。</li>
<li><em>speed</em> : 指定串口波特率，十进制数，常用的有9600、19200、115200、460800。</li>
<li>damand ：仅在有数据通信时启动链路，该选项隐含了 persist 选项。</li>
<li>persist ：连接终止后程序不退出，并尝试重新打开连接，也就是掉线重连。</li>
<li>debug ：启用连接调试工具。如果指定了此选项，则 pppd 将以可阅读格式记录所发送或接收的所有控制包的内容。</li>
<li>dump ：指定此选项后，pppd 会打印所有已经设置的选项的值。</li>
<li>crtscts ：使用硬件流量控制（即 RTS/CTS）来控制串行端口上的数据流。</li>
<li>lock ：为串行设备加锁，确保对设备的独占访问。</li>
<li>user <em>username</em> ：向对等方证明身份的用户名。</li>
<li>password <em>password</em> ： 向对等方证明身份的密码。</li>
<li>defaultroute ：拨号成功完成时，向系统路由表添加一个缺省路由。</li>
<li>usepeerdns ：向对等方请求最多两个 DNS 服务器地址。</li>
<li>nodetach ：设置该选项后，pppd 将保持前台运行，默认是后台运行。</li>
<li>logfile <em>filename</em> ：将日志信息附加到文件 filename 。</li>
<li>connect <em>script</em> ：使用由 script 指定的可执行文件或 shell 命令来设置串行设备。此脚本通常将使用 chat(1M) 程序拨打调制解调器并启动远程 PPP 会话。</li>
<li>disconnect <em>script</em> ：在 pppd 终止链路后，运行由 script 指定的可执行文件或 shell 命令。</li>
<li>call <em>filename</em> ：从 /etc/ppp/peers/ 下的 filename 文件中读取选项。上面这些选项可以在执行命令是设置，也可以放在 /etc/ppp/peers/ 目录下的自定义配置文件中，用 call 选项调用。</li>
<li>local_IP_address:remote_IP_address : 设置本地和/或远程接口 IP 地址。两者都可以省略，但冒号是必需的。IP 地址可以通过主机名来指定，也可以通过十进制点记法来指定，例如：:10.1.2.3。缺省本地地址是系统的第一个 IP 地址，除非提供了 noipdefault 选项。如果未在任何选项中指定远程地址，则将从对等方获取远程地址。因此，在简单情况下，此选项不是必需的。如果通过此选项指定了本地和/或远程 IP 地址，则 pppd 在 IPCP 协商中将不会接受来自对等方的不同值，除非分别指定了 ipcp-accept-local 和/或 ipcp-accept-remote 选项。</li>
<li>noipdefault : 禁用未指定本地 IP 地址时的缺省行为，即通过主机名确定本地 IP 地址（如果可行）。指定了此选项时，对等方在 IPCP 协商期间必须提供本地 IP 地址（除非在命令行上或选项文件中显式指定了该地址）。未指定该选项时，可能被设置缺省地址，而导致拨号失败，比如<code>sent [IPCP ConfReq id=0x2 &lt;addr 192.168.199.152&gt; &lt;ms-dns1 0.0.0.0&gt; &lt;ms-dns2 0.0.0.0&gt;]</code> 。</li>
</ul>

<p>在 /etc/ppp/peers/ 下新建一个配置文件，命名为 wcdma ，内容如下：</p>

<pre><code>/dev/ttyACM0
115200
dump
debug
lcp-echo-failure 3
lcp-echo-interval 3
# user &quot;card&quot;
# password &quot;card&quot;
defaultroute
ipcp-accept-local
ipcp-accept-remote
crtscts
usepeerdns
novj
nobsdcomp
novjccomp
nopcomp
noaccomp
lock
show-password
logfile /var/log/pppd.log
connect &quot;/usr/sbin/chat -v -f /etc/ppp/peers/he910_connect&quot;
</code></pre>

<p>对于 user 和 password ，电信 3G 是有用户名和密码的，移动和联通为空，所以最好不要设置，可以用井号注释掉，曾经遇到过随意设置这两个值后，连接被拒绝的情况。最后启动连接用的是 chat ，负责与 3G 模块的串口通信，拨打运营商的调制解调器，目的是建立 pppd 守护进程和远程 pppd 进程之间的连接，如果程序执行错误，会返回错误状态代码，代码的含义可以在 man 手册中查找。chat 通过 -f 选项指定一个脚本，脚本的内容就是执行一些 AT 指令设置拨号相关参数。这个脚本如何设置也可以在模块软件手册里找到，以 HE910 为例：</p>

<pre><code>[root@localhost ppp]# cat /etc/ppp/peers/he910_connect 
#!/bin/sh
# init
TIMEOUT 30
&quot;&quot; ATZ
# Connection to the network
'' AT+CGDCONT=1,&quot;IP&quot;,&quot;3gnet&quot;
# Dial the number.
OK ATD*99#
# The modem is waiting for the following answer
CONNECT ''
</code></pre>

<ul>
<li>AT+CGDCONT 指令是设置拨号的各项参数，第二个参数是设置 PDP 类型，IP 表示  Internet Protocol ；第三个参数是设置 APN （接入点名称），由运营商决定。</li>
<li>ATD 指令是设置拨号号码，这个值由运营商决定。</li>
<li>CONNECT 指令表示开始拨号，并等待回应。</li>
</ul>

<p>下面是针对不同运营商的各项参数设置列表：</p>

<table>
<thead>
<tr>
<th>运营商（ISP）</th>
<th>APN</th>
<th>拨号号码</th>
<th>用户名</th>
<th>密码</th>
</tr>
</thead>

<tbody>
<tr>
<td>中国联通 WCDMA (China Unicom)</td>
<td>3GNET</td>
<td>*99#</td>
<td>空</td>
<td>空</td>
</tr>

<tr>
<td>中国电信 CDMA2000 (China Telecom) EVDO网络</td>
<td>空</td>
<td>#777</td>
<td>ctnet@mycdma.cn</td>
<td>vnet.mobi</td>
</tr>

<tr>
<td>中国移动 TD-SCDMA (China Mobile)</td>
<td>CMNET</td>
<td>*98*1#</td>
<td>空</td>
<td>空</td>
</tr>

<tr>
<td>中国移动 GPRS (China Mobile)</td>
<td>CMNET</td>
<td>*99***1#</td>
<td>空</td>
<td>空</td>
</tr>
</tbody>
</table>

<blockquote>
<p>4G 模块拨号的设置都没有用户名和密码，拨号号码都用 *99# ，在拨号前要初始化模块，使用 AT^SYSCFG 或者 AT^SYSCFGEX 指令将网络连接顺序设为 LTE 优先。</p>
</blockquote>

<p>设置完毕后，执行 <code>pppd call wcdma</code> ，程序会自动到 /etc/ppp/peers/ 目录下调用名为 wcdma 配置文件，然后开始拨号，整个过程可以在日志文件中查看。拨号成功后会获得 IP 和 DNS ，DNS 保存在 /var/run/ppp/resolv.conf 文件中。之后会调用 /etc/ppp/ip-up 脚本文件 ：</p>

<pre><code>[root@localhost ppp]# cat /etc/ppp/ip-up
#!/bin/bash
# This file should not be modified -- make local changes to
# /etc/ppp/ip-up.local instead

PATH=/sbin:/usr/sbin:/bin:/usr/bin
export PATH

LOGDEVICE=$6
REALDEVICE=$1

[ -f /etc/sysconfig/network-scripts/ifcfg-${LOGDEVICE} ] &amp;&amp; /etc/sysconfig/network-scripts/ifup-post --realdevice ${REALDEVICE} ifcfg-${LOGDEVICE}

/etc/ppp/ip-up.ipv6to4 ${LOGDEVICE}

[ -x /etc/ppp/ip-up.local ] &amp;&amp; /etc/ppp/ip-up.local &quot;$@&quot;

exit 0
</code></pre>

<p>这个脚本先执行了 ifup-post 脚本，作用是配置 IP ，默认路由等网络参数。然后执行了 ip-up.local 脚本，该脚本通常不存在，可以将 /usr/share/doc/ppp/scripts/ip-up.local.add 复制过来改名，这个脚本的作用是，如果在执行 pppd 时设置了 usepeerdns ，就用 /var/run/ppp/resolv.conf 替换当前的 DNS 。</p>

<pre><code>[root@localhost ppp]# cat ip-up.local.add 

#
# This sample code shows you one way to modify your setup to allow automatic
# configuration of your resolv.conf for peer supplied DNS addresses when using
# the `usepeerdns' option.
#
# In my case I just added this to my /etc/ppp/ip-up.local script. You may need to 
# create an executable script if one does not exist.
#
# Nick Walker (nickwalker@email.com)
#
. /etc/sysconfig/network-scripts/network-functions

if [ -n &quot;$USEPEERDNS&quot; -a -f /var/run/ppp/resolv.conf ]; then
        rm -f /var/run/ppp/resolv.prev
        if [ -f /etc/resolv.conf ]; then
                cp /etc/resolv.conf /var/run/ppp/resolv.prev
                rscf=/var/run/ppp/resolv.new
                grep domain /var/run/ppp/resolv.prev &gt; $rscf
                grep search /var/run/ppp/resolv.prev &gt;&gt; $rscf
                if [ -f /var/run/ppp/resolv.conf ]; then
                        cat /var/run/ppp/resolv.conf &gt;&gt; $rscf
                fi
                change_resolv_conf $rscf
                rm -f $rscf
        else
                change_resolv_conf /var/run/ppp/resolv.conf
        fi
fi
</code></pre>

<h2 id="4-wvdial">4. wvdial</h2>

<p>wvdial 是一个智能 ppp 拨号工具，替换了 chat ，简化了拨号的步骤，可以一步实现拨号、启动 pppd 、最终连接互联网。它带有一个配置工具 wvdialconf ，用于探测当前系统中 3G 模块的串口，然后生成一个配置文件 /etc/wvdial.conf 。还是以 HE910 为例，生成的配置文件：</p>

<pre><code>[root@localhost ~]# cat /etc/wvdial.conf 
[Dialer Defaults]
Init2 = ATQ0 V1 E1 S0=0 &amp;C1 &amp;D2 +FCLASS=0
Modem Type = USB Modem
; Phone = &lt;Target Phone Number&gt;
ISDN = 0
; Username = &lt;Your Login Name&gt;
Init1 = ATZ
; Password = &lt;Your Password&gt;
Modem = /dev/ttyACM0
Baud = 460800
</code></pre>

<p>只需要修改账号、密码和拨号号码即可，注意要把前面的分号去掉：</p>

<pre><code>[root@localhost ~]# cat /etc/wvdial.conf 
[Dialer Defaults]
Init2 = ATQ0 V1 E1 S0=0 &amp;C1 &amp;D2 +FCLASS=0
Modem Type = USB Modem
Phone = *99#
ISDN = 0
Username = &quot;card&quot;
Init1 = ATZ
Password = &quot;card&quot;
Modem = /dev/ttyACM0
Baud = 460800 
</code></pre>

<p>配置文件的其他选项可以查看 wvdial.conf 的 man 手册，这些参数最终会传递给 pppd 。然后执行 wvdial ：</p>

<pre><code>[root@localhost ~]# wvdial         
--&gt; WvDial: Internet dialer version 1.61
--&gt; Initializing modem.
--&gt; Sending: ATZ
ATZ
OK
--&gt; Sending: ATQ0 V1 E1 S0=0 &amp;C1 &amp;D2 +FCLASS=0
ATQ0 V1 E1 S0=0 &amp;C1 &amp;D2 +FCLASS=0
OK
--&gt; Modem initialized.
--&gt; Sending: ATDT*99#
--&gt; Waiting for carrier.
ATDT*99#
CONNECT
--&gt; Carrier detected.  Waiting for prompt.
~[7f]}#@!}!}!} }8}&quot;}&amp;} } } } }#}$@#}%}&amp;_}8[14][14]}'}&quot;}(}&quot;[1f]P~
--&gt; PPP negotiation detected.
--&gt; Starting pppd at Thu Nov  3 17:36:51 2016
--&gt; Pid of pppd: 3393
--&gt; Using interface ppp0
--&gt; local  IP address 10.228.54.19
--&gt; remote IP address 10.228.54.19
--&gt; primary   DNS address 210.21.196.6
--&gt; secondary DNS address 221.5.88.88
</code></pre>

<p>默认会自动设置 default route 和 DNS 。如果没有自动替换 DNS ，应该是没有 /etc/ppp/ip-up.local 文件，可以复制一个过来。查看 pppd 进程，看看都执行了哪些参数：</p>

<pre><code>[root@localhost ~]# ps -ef | grep pppd
root       955   954  0 09:02 pts/1    00:00:00 /usr/sbin/pppd 460800 modem crtscts defaultroute usehostname -detach user card noipdefault call wvdial usepeerdns idle 0 logfd 6 remotename 0
root       982   799  0 09:03 pts/0    00:00:00 grep --color=auto pppd
[root@localhost ~]# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         0.0.0.0         0.0.0.0         U     0      0        0 ppp0
192.168.5.0     0.0.0.0         255.255.255.0   U     0      0        0 enp4s0
</code></pre>

<p>这个程序是前台运行的，用 Ctrl-C 键可以退出。</p>
]]></content>
        </item>
        
        <item>
            <title>NetworkManager 使用笔记</title>
            <link>https://shaocheng.li/posts/2016/10/13/</link>
            <pubDate>Thu, 13 Oct 2016 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2016/10/13/</guid>
            <description>NetworkManager 是目前 Linux 系统中提供网络连接管理服务的一套软件，也支持传统的 ifcfg 类型配置文件。核心是 NetworkManager 守护进程，还提供了命令行工具 nmcli ，以及图形界面配置工具。NetworkManager 可用于以下连接类型：以太网、VLAN、网桥、绑定、成组、Wi-Fi、移动宽带（比如移动网络 3G）及 IP-over-InfiniBand。在这些连接类型中，NetworkManager 可配置网络别名、IP 地址、静态路由器、DNS 信息及 VPN 连接以及很多具体连接参数。最后，NetworkManager 通过 D-bus 提供 API，D-Bus 允许应用程序查询并控制网络配置及状态。
启动、停止、查看 NetworkManager 服务：
[root@localhost ~]# systemctl start|stop|restart|status NetworkManager  NetworkManager 的配置文件和脚本保存在 /etc/sysconfig/ 目录中。大多数网络配置信息都保存在这里，VPN、移动宽带及 PPPoE 配置除外，这些配置保存在 /etc/NetworkManager/ 子目录中。例如，接口的具体信息是保存在 /etc/sysconfig/network-scripts/ 目录下的 ifcfg-* 文件中。全局设置使用 /etc/sysconfig/network 文件
在命令行中，可以使用 nmcli 工具与 NetworkManager 进行交互。例如，修改了某个 ifcfg-* 文件后，需要手动载入，可以执行：
[root@localhost ~]# nmcli connection load /etc/sysconfig/network-scripts/ifcfg-ifname  如果要重新载入全部配置文件，可以执行 ：
[root@localhost ~]# nmcli connection reload  可以执行 nmcli help 查看该命令的语法，命令的各种参数都可以用 Tab 键补全。</description>
            <content type="html"><![CDATA[

<p>NetworkManager 是目前 Linux 系统中提供网络连接管理服务的一套软件，也支持传统的 ifcfg 类型配置文件。核心是 NetworkManager 守护进程，还提供了命令行工具 nmcli ，以及图形界面配置工具。NetworkManager 可用于以下连接类型：以太网、VLAN、网桥、绑定、成组、Wi-Fi、移动宽带（比如移动网络 3G）及 IP-over-InfiniBand。在这些连接类型中，NetworkManager 可配置网络别名、IP 地址、静态路由器、DNS 信息及 VPN 连接以及很多具体连接参数。最后，NetworkManager 通过 D-bus 提供 API，D-Bus 允许应用程序查询并控制网络配置及状态。</p>

<p>启动、停止、查看 NetworkManager 服务：</p>

<pre><code>[root@localhost ~]# systemctl start|stop|restart|status NetworkManager
</code></pre>

<p>NetworkManager 的配置文件和脚本保存在 /etc/sysconfig/ 目录中。大多数网络配置信息都保存在这里，VPN、移动宽带及 PPPoE 配置除外，这些配置保存在 /etc/NetworkManager/ 子目录中。例如，接口的具体信息是保存在 /etc/sysconfig/network-scripts/ 目录下的 ifcfg-* 文件中。全局设置使用 /etc/sysconfig/network 文件</p>

<p>在命令行中，可以使用 nmcli 工具与 NetworkManager 进行交互。例如，修改了某个 ifcfg-* 文件后，需要手动载入，可以执行：</p>

<pre><code>[root@localhost ~]# nmcli connection load /etc/sysconfig/network-scripts/ifcfg-ifname
</code></pre>

<p>如果要重新载入全部配置文件，可以执行 ：</p>

<pre><code>[root@localhost ~]# nmcli connection reload
</code></pre>

<p>可以执行 <code>nmcli help</code> 查看该命令的语法，命令的各种参数都可以用 Tab 键补全。</p>

<pre><code>[root@localhost ~]# nmcli help
Usage: nmcli [OPTIONS] OBJECT { COMMAND | help }

OPTIONS
  -t[erse]                                   简洁输出
  -p[retty]                                  美化输出
  -m[ode] tabular|multiline                  输出模式
  -f[ields] &lt;field1,field2,...&gt;|all|common   指定字段输出
  -e[scape] yes|no                           指定分隔符
  -n[ocheck]                                 不检测版本
  -a[sk]                                     询问缺失参数
  -w[ait] &lt;seconds&gt;                          设置超时等待完成操作
  -v[ersion]                                 显示版本
  -h[elp]                                    获得帮助

OBJECT
  g[eneral]       常规管理
  n[etworking]    全面的网络控制
  r[adio]         无线网络管理
  c[onnection]    网络连接管理
  d[evice]        网络设备管理
  a[gent]         网络代理管理
</code></pre>

<p>列出所有的网络设备：</p>

<pre><code>[root@localhost ~]# nmcli device show
GENERAL.DEVICE:                         enp4s0
GENERAL.TYPE:                           ethernet
GENERAL.HWADDR:                         00:1D:F3:51:95:4D
GENERAL.MTU:                            1500
GENERAL.STATE:                          100 (connected)
GENERAL.CONNECTION:                     enp4s0
GENERAL.CON-PATH:                       /org/freedesktop/NetworkManager/ActiveConnection/0
WIRED-PROPERTIES.CARRIER:               on
IP4.ADDRESS[1]:                         ip = 192.168.5.242/24, gw = 0.0.0.0
IP6.ADDRESS[1]:                         ip = fe80::21d:f3ff:fe51:954d/64, gw = ::

GENERAL.DEVICE:                         ttyACM3
GENERAL.TYPE:                           gsm
GENERAL.HWADDR:                         (unknown)
GENERAL.MTU:                            0
GENERAL.STATE:                          30 (disconnected)
GENERAL.CONNECTION:                     --
GENERAL.CON-PATH:                       --

GENERAL.DEVICE:                         lo
GENERAL.TYPE:                           loopback
GENERAL.HWADDR:                         00:00:00:00:00:00
GENERAL.MTU:                            65536
GENERAL.STATE:                          10 (unmanaged)
GENERAL.CONNECTION:                     --
GENERAL.CON-PATH:                       --
</code></pre>

<p>查看所有网络设备的状态：</p>

<pre><code>[root@localhost ~]# nmcli device status 
DEVICE   TYPE      STATE         CONNECTION 
enp4s0   ethernet  connected     enp4s0     
ttyACM3  gsm       disconnected  --         
lo       loopback  unmanaged     --   
</code></pre>

<p>查看所有的网络连接：</p>

<pre><code>[root@localhost ~]# nmcli connection show 
NAME    UUID                                  TYPE            DEVICE 
enp4s0  f056272b-e28a-4e69-8264-af9fccfbf45d  802-3-ethernet  enp4s0
</code></pre>

<p>可以看到，本机有一个以太网卡和一个 3G 网卡，只有以太网使能了连接，3G 网卡处于未连接状态。TYPE 字段表示连接类型，支持的值有：adsl, bond, bond-slave, bridge, bridge-slave, bluetooth, cdma, ethernet, gsm, infiniband, olpc-mesh, team, team-slave, vlan, wifi, wimax。可以在新建或者编辑连接时用 type 参数设置，按 Tab 键查看该列表，或查看 nmcli(1) man page 中的 TYPE_SPECIFIC_OPTIONS 列表。</p>

<p>DEVICE 表示设备名称，如果是以太网或者WiFi，就是用 ifconfig -a 看到的名称。CONNECTION 表示连接名称，这是在连接配置文件的名称，这里的以太网配置文件是 ifcfg-enp4s0 。可以在新建连接时用 con-name 参数设置。</p>

<h2 id="1-以太网">1. 以太网</h2>

<p>新建一个以太网连接，使用动态 IP ：</p>

<pre><code>[root@localhost ~]# nmcli connection add type ethernet con-name connection-name ifname interface-name
</code></pre>

<p>这样会在 /etc/sysconfig/network-scripts/ 目录下生成一个 ifcfg-* 配置文件。使用以下命令激活以太网连接：</p>

<pre><code>[root@localhost ~]# nmcli con up my-office
Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/5)
</code></pre>

<p>用如下命令可以查看该连接的详细信息：</p>

<pre><code>[root@localhost ~]# nmcli connection show enp4s0 
</code></pre>

<h2 id="2-3g-网卡">2. 3G 网卡</h2>

<p>查看这个设备的详情：</p>

<pre><code>[root@localhost ~]# nmcli device show ttyACM3 
GENERAL.DEVICE:                         ttyACM3
GENERAL.TYPE:                           gsm
GENERAL.HWADDR:                         (unknown)
GENERAL.MTU:                            0
GENERAL.STATE:                          30 (disconnected)
GENERAL.CONNECTION:                     --
GENERAL.CON-PATH:                       --
</code></pre>

<p>新建一个 3G 网卡的连接：</p>

<pre><code>[root@localhost ~]# nmcli connection add type gsm ifname ttyACM3 user 3gnet password 3gnet apn 3gnet
Connection 'gsm-ttyACM3' (d15e8860-6dc1-4aa5-b579-b898e651a984) successfully added.
</code></pre>

<p>这会在 /etc/NetworkManager/system-connections/ 下生成一个配置文件，并且会自动连接，生成一个 ppp0 的网络设备：</p>

<pre><code>[root@localhost ~]# cat gsm-ttyACM3 
[connection]
id=gsm-ttyACM3
uuid=7561e339-43b7-4e7f-bc2c-5886b5a97afc
interface-name=ttyACM3
type=gsm

[gsm]
number=*99#
username=3gnet
password=3gnet
apn=3gnet
[root@localhost ~]# nmcli device status 
DEVICE   TYPE      STATE      CONNECTION  
enp4s0   ethernet  connected  enp4s0      
ttyACM3  gsm       connected  gsm-ttyACM3 
ppp0     unknown   connected  ppp0        
lo       loopback  unmanaged  --    
~]# nmcli connection show
NAME         UUID                                  TYPE            DEVICE  
ppp0         9e55469f-b362-4122-8031-aa18360a8d75  generic         ppp0    
gsm-ttyACM3  7561e339-43b7-4e7f-bc2c-5886b5a97afc  gsm             ttyACM3 
enp4s0       f056272b-e28a-4e69-8264-af9fccfbf45d  802-3-ethernet  enp4s0  
</code></pre>

<p>要取消自动连接，需要将 autoconnect 设为 false ：</p>

<pre><code>[root@localhost ~]# nmcli connection modify gsm-ttyACM3 connection.autoconnect false
[root@localhost ~]# cat /etc/NetworkManager/system-connections/gsm-ttyACM3 
[connection]
id=gsm-ttyACM3
uuid=86f38b5b-31e3-4250-8304-c94a8fe7ac29
interface-name=ttyACM3
type=gsm
autoconnect=false

[gsm]
number=*99#
username=3gnet
password=3gnet
apn=3gnet
</code></pre>

<h2 id="3-wifi">3. WiFi</h2>

<p>用如下命令查看可访问的 WiFi 热点：</p>

<pre><code>[root@localhost ~]# nmcli device wifi list 
*  SSID               MODE   CHAN  RATE       SIGNAL  BARS  SECURITY  
   SBSon              Infra  4     54 Mbit/s  84      â–‚â–„â–†â–ˆ  WPA1 WPA2 
   TP-LINK_3          Infra  1     54 Mbit/s  77      â–‚â–„â–†_  WPA2      
   readtime           Infra  1     54 Mbit/s  70      â–‚â–„â–†_  WPA2      
   sbstest            Infra  1     54 Mbit/s  59      â–‚â–„â–†_  WPA1 WPA2 
   Xiaomi             Infra  1     54 Mbit/s  57      â–‚â–„â–†_  WPA2      
   wifi-360           Infra  6     54 Mbit/s  47      â–‚â–„__  WPA2      
</code></pre>

<p>新建一个名为 wifi-con 的 WiFi 连接：</p>

<pre><code>[root@localhost ~]# nmcli connection add con-name wifi-con ifname wlp1s0 type wifi ssid TP-LINK_3
Connection 'wifi-con' (7c5ae676-a2c7-49df-a37b-d93787be2b72) successfully added.    
</code></pre>

<p>设置加密方式为 WPA2 ，并设置密码：</p>

<pre><code>[root@localhost ~]# nmcli connection modify wifi-con wifi-sec.key-mgmt wpa-psk  
[root@localhost ~]# nmcli connection modify wifi-con wifi-sec.psk 87654321
</code></pre>

<p>激活该连接：</p>

<pre><code>[root@localhost ~]# nmcli connection up wifi-con 
Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/3)
[root@localhost ~]# iwconfig 
lo        no wireless extensions.

enp4s0    no wireless extensions.

wlp1s0    IEEE 802.11abgn  ESSID:&quot;TP-LINK_3&quot;  
          Mode:Managed  Frequency:2.412 GHz  Access Point: 64:09:80:64:2F:8E   
          Bit Rate=1 Mb/s   Tx-Power=15 dBm   
          Retry short limit:7   RTS thr:off   Fragment thr:off
          Encryption key:off
          Power Management:off
          Link Quality=44/70  Signal level=-66 dBm  
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:3  Invalid misc:20   Missed beacon:0
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>BitBake 使用笔记</title>
            <link>https://shaocheng.li/posts/2016/09/12/</link>
            <pubDate>Mon, 12 Sep 2016 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2016/09/12/</guid>
            <description>1. 简介 BitBake 是用 Python 写的一个程序，它是 OpenEmbedded 构建系统时使用的生产工具，现在有很多嵌入式系统都是在使用，比如Yocto 、WindRiver Linux 等。它是一个多任务引擎，可以并行执行 shell 和 Python 任务，每个任务单元根据预定义的元数据来管理源码、配置、编译、打包，并最终将每个任务生成的文件集合成为系统镜像。例如要从源码构建一个 Linux 系统，需要搭建一个生产环境，然后依次生成 Grub、Kernel、各种库文件、各种可执行文件，然后集合到一个文件系统里。如果你玩过 LFS ，就会了解这个过程的复杂性。BitBake 存在的意义就是提供了一个高效的工具，将这个过程标准化、流程化。BitBake 与 GNU Make 的关系就像 GNU Make 之于 GCC ，运作方式也类似 GNU Make ，又有很多不同：
 BitBake 根据预先定义的元数据执行任务，这些元数据定义了执行任务所需的变量，执行任务的过程，以及任务之间的依赖关系，它们存储在 recipe(.bb)、append(.bbappend)、configuration(.conf)、include(.inc) 和 class(.bbclass) 文件中。 BitBake 包含一个抓取器，用于从不同的位置获取源码，例如本地文件、源码控制器(git)、网站等。 每一个任务单元的结构通过 recipe 文件描述，描述的信息有依赖关系、源码位置、版本信息、校验和、说明等等。 BitBake 包含了一个 C/S 的抽象概念，可以通过命令行或者 XML-RPC 使用，拥有多种用户接口。  几个概念：
 Recipe 。Recipe 文件是最基本的元数据文件，每个任务单元对应一个 Recipe 文件，后缀是 .bb ，这种文件为 BitBake 提供的信息包括软件包的基本信息（作者、版本、License等）、依赖关系、源码的位置和获取方法、补丁、配置和编译方法、如何打包和安装。 Configuration 。Configuration 文件的后缀是 .conf ，它会在很多地方出现，定义了多种变量，包括硬件架构选项、编译器选项、通用配置选项、用户配置选项。主 Configuration 文件是 bitbake.</description>
            <content type="html"><![CDATA[

<h2 id="1-简介">1. 简介</h2>

<p>BitBake 是用 Python 写的一个程序，它是 OpenEmbedded 构建系统时使用的生产工具，现在有很多嵌入式系统都是在使用，比如Yocto 、WindRiver Linux 等。它是一个多任务引擎，可以并行执行 shell 和 Python 任务，每个任务单元根据预定义的元数据来管理源码、配置、编译、打包，并最终将每个任务生成的文件集合成为系统镜像。例如要从源码构建一个 Linux 系统，需要搭建一个生产环境，然后依次生成 Grub、Kernel、各种库文件、各种可执行文件，然后集合到一个文件系统里。如果你玩过 LFS ，就会了解这个过程的复杂性。BitBake 存在的意义就是提供了一个高效的工具，将这个过程标准化、流程化。BitBake 与 GNU Make 的关系就像 GNU Make 之于 GCC ，运作方式也类似 GNU Make ，又有很多不同：</p>

<ul>
<li>BitBake 根据预先定义的元数据执行任务，这些元数据定义了执行任务所需的变量，执行任务的过程，以及任务之间的依赖关系，它们存储在 recipe(.bb)、append(.bbappend)、configuration(.conf)、include(.inc) 和 class(.bbclass) 文件中。</li>
<li>BitBake 包含一个抓取器，用于从不同的位置获取源码，例如本地文件、源码控制器(git)、网站等。</li>
<li>每一个任务单元的结构通过 recipe 文件描述，描述的信息有依赖关系、源码位置、版本信息、校验和、说明等等。</li>
<li>BitBake 包含了一个 C/S 的抽象概念，可以通过命令行或者 XML-RPC 使用，拥有多种用户接口。</li>
</ul>

<p>几个概念：</p>

<ul>
<li>Recipe 。Recipe 文件是最基本的元数据文件，每个任务单元对应一个 Recipe 文件，后缀是 .bb ，这种文件为 BitBake 提供的信息包括软件包的基本信息（作者、版本、License等）、依赖关系、源码的位置和获取方法、补丁、配置和编译方法、如何打包和安装。</li>
<li>Configuration 。Configuration 文件的后缀是 .conf ，它会在很多地方出现，定义了多种变量，包括硬件架构选项、编译器选项、通用配置选项、用户配置选项。主 Configuration 文件是 bitbake.conf ，以 Yocto 为例，位于 ./poky/meta/conf/bitbake.conf ，其他都在源码树的 conf 目录下。</li>
<li>Classes 。Class 文件的后缀是 .bbclass ，它的内容是元数据文件之间的共享信息。BitBake 源码树都源自一个叫做 base.bbclass 的文件，在 Yocto 中位于 ./poky/meta/classes/base.bbclass ，它会被所有的 recipe 和 class 文件自动包含。它包含了标准任务的基本定义，例如获取、解压、配置、编译、安装、打包，有些定义只是框架，内容是空的。</li>
<li>Layers 。Layer 被用来分类不同的任务单元。某些任务单元有共同的特性，可以放在一个 Layer 下，方便模块化组织元数据，也方便日后修改。例如要定制一套支持特定硬件的系统，可以把与低层相关的单元放在一个 layer 中，这叫做 Board Support Package(BSP) Layer 。</li>
<li>Append 。Append 文件的后缀是 .bbappend ，用于扩展或者覆盖 recipe 文件的信息。BitBake 希望每一个 append 文件都有一个相对应的 recipe 文件，两个文件使用同样的文件名，只是后缀不同，例如 formfactor_0.0.bb 和 formfactor_0.0.bbappend 。命名 append 文件时，可以用百分号（%）来通配 recipe 文件名。例如，一个名为 busybox_1.21.%.bbappend 的 apend 文件可以对应任何名为 busybox_1.21.x.bb 的 recipe 文件进行扩展和覆盖，文件名中的 x 可以为任何字符串，比如 busybox_1.21.1.bb、busybox_1.21.2.bb &hellip; 通常用百分号来通配版本号。</li>
</ul>

<p>BitBake 命令的语法可以执行 bitbake -h 查看。-b 用于指定 recipe 文件，-c 用于指定要执行的任务，如果没有指定任务，会按照 recipe 文件完整的执行一次从获取源码到编译打包的过程。要编译一个名为 foo_1.0.bb 的包，可以执行：</p>

<pre><code>$ bitbake -b foo_1.0.bb                    
</code></pre>

<p>可以不用 -b ，而只写包的名字，不加下划线后的版本号和后缀，简化为：</p>

<pre><code>$ bitbake foo
</code></pre>

<p>如果要执行清除任务：</p>

<pre><code>$ bitbake foo -c clean
</code></pre>

<h2 id="2-工作流程">2. 工作流程</h2>

<p>运行 BitBake 的主要目的是生成一个东西，例如安装包、内核、链接库、或者一个完整的 Linux 系统启动镜像（包括 bootloader、kernel、根文件系统）。当然，你也可以通过使用 bitbake 命令的某些参数，只执行生成过程中的某个步骤，例如编译、获取或清除数据、或者只返回编译环境的信息。</p>

<p>简单说一下使用 BitBake 生成系统镜像的的执行过程。</p>

<h3 id="2-1-分析基本元数据">2.1 分析基本元数据</h3>

<p>基本元数据由多个文件组成，包括 bblayers.conf 文件（定义项目所需的 layers）、每个 layer 的 layer.conf 文件、以及 bitbake.conf 文件。数据内容有如下几类：</p>

<ul>
<li>Recipes：特定软件包的详情。</li>
<li>Class Data：通用构建信息的抽象总结。</li>
<li>Configuration Data：针对特定机器的设置，相当于粘合剂，把所有软件集合到一起。</li>
</ul>

<p>基本元数据都具有全局属性，所有它们对所有的 recipes 都有效。</p>

<p>首先，BitBake 会先搜索当前工作目录下的 conf/bblayers.conf 文件。该文件包含一个 BBLAYERS 变量，它会列出所有项目所需的 layer 的目录。在 BBLAYERS 所列出的 layer 目录中，都会有一个 conf/layer.conf 文件，在这个文件中会有一个 LAYERDIR 变量，它记录了该 layer 的完整路径。这些 layer.conf 文件会自动构建一些关键的变量，例如 BBPATH 和 BBFILES 。BBPATH 记录了 conf 和 classes 目录下的 configuration 和 classes 文件的位置，BBFILES 则用于定位 .bb 和 .bbappdend 文件。如果找不到 bblayers.conf 文件，BitBake 会认为用户已经在环境变量中设置了 BBPATH 和 BBFILES 。</p>

<p>其次，BitBake 会在 BBPATH 记录的位置中寻找 conf/bitbake.conf 文件。该配置文件包含了</p>

<h2 id="参考">参考</h2>

<p><a href="http://www.yoctoproject.org/docs/2.1.1/bitbake-user-manual/bitbake-user-manual.html#bitbake-user-manual" target="_blank">BitBake User Manual</a>
<a href="http://www.kancloud.cn/digest/yocto/138623" target="_blank">Yocto 实用笔记</a></p>
]]></content>
        </item>
        
        <item>
            <title>Start Developing iOS Apps (Swift)</title>
            <link>https://shaocheng.li/posts/2016/05/06/</link>
            <pubDate>Fri, 06 May 2016 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2016/05/06/</guid>
            <description>原文：Start Developing iOS Apps (Swift)
Translated by Bob
2016-05-06
Blog：http://shaocheng.li
1. Get Start 1.1. Jump Right In 这是一个很好的 iPad/iPhone App 开发入门文档。这一系列课程可以逐步指导你写出第一个 App ，包括工具的使用、主要概念和实践。
每一节课都包含一个教程和你需要了解的概念。带领你一步一步创建一个简单的可运行 iOS App 。
在构建 APP 的过程中，你会学习到 iOS App 开发中所需的概念，更深入的理解 Swift 语言，了解到 Xcode 很多有用的特性。
####About The Lessons
在这些课程中，你将构建一个名叫 FoodTracker 的 App 。App 中会显示一份美食列表，包含美食的名称、评价和图片。用户可以添加一个新的美食、删除或者编辑已经存在的美食。添加或者编辑时，会进入一个新的页面，那里可以填写美食的名称、评价和图片。
第一节课是 playground ，playground 是 Xcode 的一种文件，可以让你在编辑代码的同时，立即看到代码执行的结果。其余的课程都是 Xcode project 文件。每节课的结尾提供下载，你可以下载后检查。
####Get the Tools
要开发本课程中的 iOS App ，需要一个 Mac 电脑(OSX 10.10 以上版本），运行最新的 Xcode ，Xcode 包含了设计、开发和调试 iOS App 所需的所有特性。 Xcode 还包含 iOS SDK ，它提供了 iOS 开发中所需的工具、编译器和框架。</description>
            <content type="html"><![CDATA[

<p>原文：<a href="https://developer.apple.com/library/ios/referencelibrary/GettingStarted/DevelopiOSAppsSwift/index.html" target="_blank">Start Developing iOS Apps (Swift)</a></p>

<p>Translated by Bob</p>

<p>2016-05-06</p>

<p>Blog：<a href="http://shaocheng.li" target="_blank">http://shaocheng.li</a></p>

<hr />

<h2 id="1-get-start">1. Get Start</h2>

<h3 id="1-1-jump-right-in">1.1. Jump Right In</h3>

<p>这是一个很好的 iPad/iPhone App 开发入门文档。这一系列课程可以逐步指导你写出第一个 App ，包括工具的使用、主要概念和实践。</p>

<p>每一节课都包含一个教程和你需要了解的概念。带领你一步一步创建一个简单的可运行 iOS App 。</p>

<p>在构建 APP 的过程中，你会学习到 iOS App 开发中所需的概念，更深入的理解 Swift 语言，了解到 Xcode 很多有用的特性。</p>

<p>####About The Lessons</p>

<p>在这些课程中，你将构建一个名叫 FoodTracker 的 App 。App 中会显示一份美食列表，包含美食的名称、评价和图片。用户可以添加一个新的美食、删除或者编辑已经存在的美食。添加或者编辑时，会进入一个新的页面，那里可以填写美食的名称、评价和图片。</p>

<p><img src="/images/2016-05-06/2016-05-06_1.jpg" alt="" /></p>

<p>第一节课是 playground ，playground 是 Xcode 的一种文件，可以让你在编辑代码的同时，立即看到代码执行的结果。其余的课程都是 Xcode project 文件。每节课的结尾提供下载，你可以下载后检查。</p>

<p>####Get the Tools</p>

<p>要开发本课程中的 iOS App ，需要一个 Mac 电脑(OSX 10.10 以上版本），运行最新的 Xcode ，Xcode 包含了设计、开发和调试 iOS App 所需的所有特性。 Xcode 还包含 iOS SDK ，它提供了 iOS 开发中所需的工具、编译器和框架。</p>

<p>本课程使用 Xcode 7.0 和 iOS SDK 9.0 。</p>

<h3 id="1-2-learn-the-essentials-of-swift">1.2. Learn the Essentials of Swift</h3>

<p>####Swift Language</p>

<p><a href="http://wiki.jikexueyuan.com/project/swift/" target="_blank">The Swift Programming Language 中文版</a></p>

<p>####Swift and Cocoa Touch</p>

<p>Cocoa Touch 是开发 iOS App 的框架，Swift 可以与之无缝连接。本节课将帮助你了解怎样在 Swift 语言中使用 Cocoa Touch 。</p>

<p>目前为止，你用到的都是来自 Swift 标准库的数据类型，例如 String 和 Array ：</p>

<pre><code>let sampleString: String = &quot;hello&quot;
let sampleArray: Array = [1, 2, 3.1415, 23, 42]
</code></pre>

<blockquote>
<p>在 Xcode 中，按住 Option 键单击数据类型。</p>
</blockquote>

<p>要开发 iOS App，只有标准库是不够的。最常用的 iOS App 开发框架是 UIKit 。UIKit 包含了大量有用的 UI 类。</p>

<p>要访问 UIKit ，先导入模块：</p>

<pre><code>import UIKit 
</code></pre>

<p>之后就可以用 Swift 语法调用 UIKit 的类型和方法：</p>

<pre><code>let redSquare = UIView(frame: CGRect(x: 0, y: 0, width: 44, height: 44))
redSquare.backgroundColor = UIColor.redColor()
</code></pre>

<p>你会在后面的章节遇到很多 UIKit 的类。</p>

<h2 id="2-building-the-ui">2. Building the UI</h2>

<h3 id="2-1-build-a-basic-ui">2.1. Build a Basic UI</h3>

<p>本节课带你熟悉 Xcode 。你将熟悉 Xcode 项目的结构，并学习如何使用基本的项目控件。通过这节课，你要为 FoodTracker 制作一个简单的 UI ，就像下面这样：</p>

<p><img src="/images/2016-05-06/2016-05-06_2.jpg" alt="" /></p>

<p>####Learning Objectives</p>

<p>这节课的学习目标是：</p>

<ul>
<li>在 Xcode 中新建一个项目。</li>
<li>熟悉项目模板中主要文件的功能。</li>
<li>在 Xcode 中打开文件，并在各个文件之间切换。</li>
<li>在模拟器中运行 App 。</li>
<li>添加、移动 UI 元素，改变元素的尺寸。</li>
<li>编辑 UI 元素的属性。</li>
<li>用缩略图查看和重新布置 UI 元素。</li>
<li>预览 UI 界面。</li>
<li>更加用户设备的大小自动布局 UI 。</li>
</ul>

<p>####Create a New Project</p>

<p>Xcode 包含若干内建的 App 模板，支持常用的集中 iOS App ，例如 Game、Single View Application 。这些模板大部分已经配置好了界面和源码文件，本节课就是从最基础的 Single View Application 模板开始。</p>

<ol>
<li><p>打开 Xcode ，欢迎界面如下：</p>

<p><img src="~/15-22-28.jpg" alt="" /></p>

<p>如果没有出现欢迎界面，而是直接打开了项目窗口，不要紧张，可能之前已经创建或打开过一个项目，直接到一下步，通过菜单栏新建项目即可。</p></li>

<li><p>在欢迎界面点击“Create a new Xcode project”，或者在菜单中选择 File &gt; New &gt; Project 。Xcode 会打开一个新窗口供你选择模板。</p></li>

<li><p>在左边对话框中的 iOS 标签下选择 Application 。</p></li>

<li><p>在主对话框中选择 Single View Application ，然后点击 Next 。</p>

<p><img src="~/16-37-24.jpg" alt="" /></p></li>

<li><p>在新出现的对话框中，设置 App 的名称和其他选项：</p>

<ul>
<li>Product Name: FoodTracker 。App 的名称。</li>
<li>Organization Name: 公司或组织的名称，可以不填。</li>
<li>Organization Identifier: 公司或组织的标识码，可以不填。</li>
<li>Bundle Identifier: 该项是根据前两项的内容自动生成的。</li>
<li>Language: Swift</li>
<li>Devices: Universal 。Universal 表示该 App 可以同时运行在 iPhone 和 iPad 。</li>
<li>Use Core Data: Unselected.</li>
<li>Include Unit Tests: Selected.</li>
<li>Include UI Tests: Unselected.</li>
</ul>

<p><img src="~/16-46-23.jpg" alt="" /></p></li>

<li><p>点击 Next 。</p></li>

<li><p>在出现的对话框中，选择项目保存的位置，点击 Create 。Xcode 会在 workspace 窗口打开新建的项目。</p>

<p><img src="~/21-27-11.jpg" alt="" />
在 wrokspace 窗口，有可能看到一条警告信息 “No code signing identities found” ，意思你还没有用 Xcode 做过 iOS 开放，不要紧，这节课后，这条警告就会消失。</p></li>
</ol>

<p>####Get Familiar with Xcode</p>

<p>Xcode 拥有开放 App 所需的一切。它不仅组织了所有的项目文件，还提供了代码编辑器和 UI 控件，允许你创建和允许 App ，还提供了一个功能强大的调试器。</p>

<p>花一点时间熟悉一下 Xcode workspace 的主界面。界面中的这些区域在接下来的课程中都会用到。不必完全掌握，在后面的课程中遇到时，会有详细讲解。</p>

<p><img src="/images/2016-05-06/2016-05-06_3.jpg" alt="" /></p>

<p>####Run Simulator</p>

<p>由于是基于模板新建的项目，基本的 App 环境以及自动生成了。即使你不写任何代码，也可以直接运行这个 Single View Application 模板。</p>

<p>可以用 Simulator （模拟器）来运行 App ，它可以让你预览 App 运行在设备上的样子和行为交互。</p>

<p>Simulator 可以模拟多种设备，例如各种尺寸的 iPhone、iPad 。本节课使用 iPhone 6 。</p>

<ol>
<li><p>在最上层 Toolbar 中的 Scheme 菜单中选择 iPhone 6 。Scheme 菜单用于设置 App 运行的设备。</p>

<p><img src="~/22-43-30.jpg" alt="" /></p></li>

<li><p>点击左上角的 Run 按钮。</p>

<p><img src="~/22-44-55.jpg" alt="" /></p>

<p>也可以选择 Product &gt; Run ，或者直接按 Command-R 。</p>

<p>如果是第一次运行 App ，Xcode 会询问你是否要打开 Mac 电脑的开发模式。开发模式下会允许 Xcode 访问 debug 特性时不用每次都输入密码。点击 Enable 。</p>

<p><img src="~/22-49-47.jpg" alt="" /></p>

<p>如果你选择了 Don&rsquo;t Enable ，后面就要按提示输入密码。</p></li>

<li><p>观察 Toolbar ，等待构建过程结束。Xcode 会在 Activity viewer 中显示构建过程的信息。</p></li>
</ol>

<p>构建完成后，Simulator 会自动运行。第一次需要花一点时间。</p>

<p>Simulator 在 iPhone 6 模式下打开，然后在模拟出的 iPhone 中启动你的 App 。启动的过程中，会看到 App 的名字。</p>

<p><img src="/images/2016-05-06/2016-05-06_4.jpg" alt="" /></p>

<p>然后，就会看到：</p>

<p><img src="/images/2016-05-06/2016-05-06_5.jpg" alt="" /></p>

<p>现在，这个模板还没有任何内容，只显示一个空白界面。其他的模板会有更复杂的特性。理解各种模板的用途，对开发 App 是很重要的。</p>

<p>快速启动 Simulator 可以选择 Simulator &gt; Quit Simulator ，或者按 Command-Q 。</p>

<p>####Review the Source Code</p>

<p>Single View Application 模板来自于几个源码文件，它们设置了 App 的环境。首先看一下 AppDelegate.swift 文件。</p>

<ol>
<li><p>在 navigator area 中打开 project navigator 。</p>

<p>project navigator 显示了该项目的所有文件。如果你的 project navigator 没有打开，在 navigator selector 中点击最左的按钮，或者选择 View &gt; Navigators &gt; Show Project Navigator 。</p>

<p><img src="~/23-13-49.jpg" alt="" /></p></li>

<li><p>点击 project navigator 中左边的倒三角可以展开所有文件。</p></li>

<li><p>选择 AppDelegate.swift 。Xcode 会在 Editor area 中打开源码文件。</p>

<p><img src="~/23-18-18.jpg" alt="" /></p>

<p>或者双击 AppDelegate.swift ，在一个独立的窗口中打开。</p></li>
</ol>

<p>AppDelegate.swift 文件有两个主要的功能：</p>

<ul>
<li>为 App 提供入口，并运行了一个传递输入事件的循环。这项工作是由 UIApplicationMain 属性(@UIApplicationMain)完成的， 它位于文件开头处. UIApplicationMain 新建了一个 application 对象，它负责管理 App 的整个生命周期和 app delegate 对象。</li>
<li>定义 AppDelegate 类, 它是 app delegate 对象的类型。 app delegate 创建了 App 的窗口，提供了一个响应 App 状态转换的地方。你可以在 AppDelegate 类中写一些自定义的代码。
<br /></li>
</ul>

<p>AppDelegate 类只包含一个属性：window ，app delegate 用这个属性跟踪 App 的窗口。window 是可选类型（optional），所有它可能没有值（nil）。</p>

<pre><code>var window: UIWindow?
</code></pre>

<p>AppDelegate 类还包含了几个重要的方法，这些方法用于 application 对象与 app delegate 进行对话。</p>

<pre><code>func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool
func applicationWillResignActive(application: UIApplication)
func applicationDidEnterBackground(application: UIApplication)
func applicationWillEnterForeground(application: UIApplication)
func applicationDidBecomeActive(application: UIApplication)
func applicationWillTerminate(application: UIApplication)
</code></pre>

<p>当 App 的状态发生变化时——例如启动、转入后台、退出—— application 对象就会调用 AppDelegate 中相应的方法做出回应。无需专门判断这些方法是否被调用，application 对象会帮你完成这个工作。</p>

<p>这些方法模板都是空实现，可以在里面添加自定义的代码，当它们被调用时就会执行。这节课不会用到自定义的 appdelegate 代码，所有不用修改 AppDelegate.swift 文件。</p>

<p>Single View Application 模板还有一个源文件 ViewController.swift 。在项目导航器中选择 ViewController.swift 查看文件内容。</p>

<p><img src="/images/2016-05-06/2016-05-06_6.jpg" alt="" /></p>

<p>这个文件中定义了一个 UIViewController 的子类 ViewController 。这个类继承了 UIViewController 的所有行为。要覆盖或者扩展这些行为，需要重写 UIViewController 中定义的方法（例如 ViewController.swift 中重写了 viewDidLoad() 和 didReceiveMemoryWarning() 方法），或者自定义新的方法。</p>

<p>虽然模板自带了 didReceiveMemoryWarning() 方法，这节课并不会用到，所有删掉它。</p>

<p>现在，你的 ViewController.swift 文件变成了：</p>

<pre><code>import UIKit

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view, typically from a nib.
    }    
}
</code></pre>

<p>稍后会在这个文件中写你自己的代码。</p>

<p>####Open Your Storyboard</p>

<p>现在可以在 storyboard 上工作了。Storyboard 是 App 界面的虚拟表现，它展示了 App 屏幕上显示的内容和内容之间的交互关系。我们用 storyboard 设计 App 的界面和交互流程。你可以在设计过程中清楚的看到 App 的样子和交互关系，并且可以随时做出做出所见即所得的修改。</p>

<p>在项目导航器中选择 Main.storyboard ，Xcode 就会在 Interface Builder 中打开 storyboard 。storyboard 的背景是空白的，可以在上面添加布置各种 UI 元素。</p>

<p><img src="/images/2016-05-06/2016-05-06_7.jpg" alt="" /></p>

<p>现在这个 storyboard 上包含了一个场景，相当于你的 App 显示在手机屏幕上的样子。场景左边的那个箭头叫做 storyboard entry point ，表示这个场景是 App 启动时第一个加载的。现在这个场景只有一个界面，由 view controller 管理。你会学到更多关于 view 和 view controller 的使用规则。</p>

<p>当你在 iPhone 6 模拟器上运行这个 App 时，这个场景上的界面就是最终在设备屏幕上看到的样子。但是会发现，这个场景的大小形状与 iPhone 6 的屏幕尺寸并不匹配。这是因为，这个场景是对于所有可支持设备的一般化表示，最终运行在具体设备上时，会自动调整到合适的尺寸。</p>

<p>####Build the Basic UI</p>

<p>现在可以开始构建基本的界面，做一个添加新菜的功能。</p>

<p>Xcode 提供了一个库，包含了按钮、文本框等可以添加到界面上的元素，还有一些不会显示出来的、定义 App 行为的元素，例如 view controller 和手势识别。</p>

<p>出现在 UI 上元素被称作 view 。它们为用户呈现 App 的内容。view 还有多种內建的行为，包括在屏幕上显示自身，对用户输入做出反应。</p>

<p>iOS 中的 View 对象的类型都是 UIView 或它的子类。很多 UIView 子类都有自己独特的显示方式和行为。现在，我们在场景中添加一个文本域，它属于 UITextField 类。一个文本域允许用户输入一行文本，这里用它来输入一道菜的名字。</p>

<ol>
<li><p>打开对象库（Object library）。</p>

<p>打开对象库的按钮位于右边的 utility area 。如果没有看到对象库，单击它的按钮，库选择条的左起第三个按钮。（或者在菜单中选择 View &gt; Utilities &gt; Show Object Library)</p>

<p><img src="~/19-18-34.jpg" alt="" /></p>

<p>会出现一个列表，列出了每个对象的名字、描述、图标。</p></li>

<li><p>在对象库的 Filter field 中输入 text field 就可以找到它。</p></li>

<li><p>将 text field 对象拖到场景中。</p>

<p><img src="~/19-23-09.jpg" alt="" /></p>

<p>可以在  Editor &gt; Canvas &gt; Zoom 中选择放大或缩小场景。</p></li>

<li><p>把 text field 拖到场景上半部分，左边线对齐的位置。如图：</p>

<p><img src="~/19-28-29.jpg" alt="" /></p>

<p>蓝色的对齐线会帮助你定位。对齐线只有在拖动或改变对象大小是才能看到；当你放开对象时它就消失了。</p></li>

<li><p>如果有必要，单击 text field ，激活 resize handle。</p>

<p>Resize handle 是出现在 UI 元素四周的白色小方框，拖动它可以改变元素的大小。通过单击元素可以该元素的 resize handle 。如下图这样，已经单击选中的元素可以改变大小。</p>

<p><img src="~/20-15-02.jpg" alt="" /></p></li>

<li><p>改变 text field 左右边框的位置，直到出现三条对齐线：左边对齐线、水平方向中心对齐线、右边对齐线。</p>

<p><img src="~/20-20-39.jpg" alt="" /></p></li>
</ol>

<p>尽管场景上已经有了文本域，但是没有 help 信息告诉用户这里应该填什么。用 Text field 的 Placeholder 告诉用户在这里填入菜名。</p>

<ol>
<li><p>在 utility area 中打开 Text field 的属性检查器（Attributes inspector），在这里可以编辑 storyboard 中对象的属性。</p>

<p><img src="~/20-28-12.jpg" alt="" /></p></li>

<li><p>找到 Placeholder ，输入 Enter meal name 。</p></li>

<li><p>按回车键就可以在文本域中看到刚才输入的文本。</p></li>
</ol>

<p>现在的界面是这样的：</p>

<p><img src="/images/2016-05-06/2016-05-06_8.jpg" alt="" /></p>

<p>当用户选中文本域时会显示系统键盘，这里要配置一下系统键盘的属性，</p>

<ol>
<li>选中文本域。</li>
<li>在属性检查器中找到 Return Key 并选择 Done 。这个设置会将键盘的 Return 键改为 Done 键。</li>
<li>在属性检查器中勾选 Auto-enable Return Key 。这样的话，如果文本域中没有输入文本，用户是无法点击 Done 键的，这样可以确保用户不能设置空的菜名。</li>
</ol>

<p>下一步，在场景顶部添加一个标签（UILabel）。标签没有交互，只能显示一段静态文本。为了帮助你理解怎样定义 UI 上元素之间的交互，你要配置这个标签，让它显示用户在文本域中输入的文字。这样可以练习如何获取并处理文本域中的输入信息。</p>

<ol>
<li>在对象库中输入 lable ，快速找到 Label 对象。</li>
<li>把 Label 对象拖到场景中。</li>

<li><p>把标签拖到文本域的左上方位置，左对齐，如图：</p>

<p><img src="~/22-28-54.jpg" alt="" /></p></li>

<li><p>双击标签，输入 Meal Name 。</p></li>

<li><p>按回车键，新文本就会显示在标签中。</p></li>
</ol>

<p>场景变成了这个样子：</p>

<p><img src="/images/2016-05-06/2016-05-06_9.jpg" alt="" /></p>

<p>现在，添加一个按钮（UIButton）。按钮是可交互的，所有，用户可以点击，然后触发定义好的事件。这里我们创建一个重置标签文本的事件。</p>

<ol>
<li>在对象库里输入 button 查找 Button 对象。</li>
<li>把 Button 拖到场景中。</li>

<li><p>将按钮拖到文本域的下方，左对齐，如图：</p>

<p><img src="~/23-56-51.jpg" alt="" /></p></li>

<li><p>双击按钮，输入 Set Default Label Text 。</p></li>

<li><p>按回车显示新文本。</p></li>
</ol>

<p>此时，你的场景变成了这样：</p>

<pre><code>![](~/23-59-04.jpg)
</code></pre>

<p>在 Outline view 中可以看到已经添加到场景中的所有元素，帮助你理解这些元素是如何在场景中布置的。</p>

<ol>
<li><p>在 storyboard 中找到 Outline view 按钮：</p>

<p><img src="~/00-07-24.jpg" alt="" /></p></li>

<li><p>如果没有看到 Outline view ，请单击左下的 Outline view toggle 。 该按钮可以显示或隐藏 Outline view 。</p></li>
</ol>

<p>Outline view 可以让你看清 storyboard 中给个对象的层次关系。在这个等级结构中可看到文本域、标签、按钮。为什么你添加的这些元素都位于 View 下，而不是其他的 view ？</p>

<p>view 不只是显示自己和接受用户输入，它们还可以作为其他 view 的容器。排列在这个等级结构中的 view 称作 view hierarchy 。它定义了 views 之间的布局关系。一个 view 里面的其他 views 叫做 subviews ，它的上一层 view 叫做 superview 。一个 view 可以有多个 subview ，但只能有一个 superview 。</p>

<p><img src="/images/2016-05-06/2016-05-06_10.jpg" alt="" /></p>

<p>通常，每个场景都有自己的 view hierarchy 。每个 view hierarchy 的顶部是一个 content view 。现在这个场景中，content view 就是 View 。你在这个场景中添加的 view 都将是 View 的 subview 。</p>

<p>####Preview Your Interface</p>

<p>定期预览你的 App ，检查一下设计结果是否符合预期。用 assistant editor 可以在主编辑器傍边显示一个子编辑器，可以在这里预览 App 的用户界面。</p>

<ol>
<li><p>点击右上角的 Assistant 按钮打开 assistant editor 。</p>

<p><img src="~/12-51-37.jpg" alt="" /></p></li>

<li><p>如果想要更多的工作空间，可以在右上角的工具条中隐藏 Navigator 和 Utilities ，还可以隐藏 outline view 。</p>

<p><img src="~/12-55-37.jpg" alt="" /></p></li>

<li><p>在 assistant editor 顶部的选择器中选择 Automatic &gt; Preview &gt; Main.storyboard(Preview) 。</p>

<p><img src="~/13-27-47.jpg" alt="" /></p>

<p>在预览中可以看到，文本域的右边没有完全显示，超出了有边框。这是为什么？</p>

<p><img src="~/14-11-42.jpg" alt="" /></p></li>
</ol>

<p>我们构建的是一个可以适应各种尺寸 iPhone 和 iPad 的界面。在 storyboard 中看到的是界面大概的样子。现在，需要设置这个界面上的元素在不同大小的屏幕上该如何调整。例如，当界面缩小到 iPhone 大小时，文本域也要相应的缩小。当界面放大道 iPad 大小时，文本域也要放大。可以用 Auto Layout 设置这些行为。</p>

<p>####Adopt Auto Layout</p>

<p>Auto Layout 是一个强大的布局引擎，可以帮助你轻松的设计兼容布局。你只需要告诉 Auto Layout 想要如何摆放场景中的元素，引擎就会自动以最优的方式实现你的意图。描述你的意图要用到 constraints ，使用它来描述元素的相对位置，元素的大小，元素之间的缩放关系。</p>

<p>配合 Auto Layout 工作的工具是 stack view（UIStackView）。stack view 提供了一个高效的方式在水平或垂直方向排布多个元素。Stack view 让你借助 Auto Layout 的力量，创建可以适应设备方向、屏幕大小、或各种空间变化的 UI 。</p>

<p>可以轻松的将已经存在的 UI 元素包含到一个 stack view ，然后设定必要的限制，使得 stack view 在各种情况下都能正确的显示。</p>

<ol>
<li><p>点击右上角的 Standard 按钮回到主编辑器。</p>

<p><img src="~/15-14-35.jpg" alt="" /></p></li>

<li><p>按住 Shift 键，同时选中文本域、标签和按钮。</p>

<p><img src="~/15-15-43.jpg" alt="" /></p></li>

<li><p>在画布的右下角选择 Stack 按钮。（或者选择 Editor &gt; Embed In &gt; Stack View)</p>

<p><img src="~/15-17-38.jpg" alt="" /></p>

<p>Xcode 会将这些 UI 元素包含到一个 stack view 中。Xcode 会分析现在的布局，计算出这些元素应该沿垂直方向叠放。</p>

<p><img src="~/15-20-15.jpg" alt="" /></p></li>

<li><p>如果有必要，打开 Outline view ，选择 Stack View 对象。</p>

<p><img src="~/15-23-53.jpg" alt="" /></p></li>

<li><p>在属性检查器的 spacing 中输入 12 ，按回车。你会看到 UI 元素的纵向空间被拉长了。</p>

<p><img src="~/22-45-06.jpg" alt="" /></p></li>

<li><p>在画布右下角打开 Pin 菜单。</p>

<p><img src="~/22-59-18.jpg" alt="" /></p></li>

<li><p>在 “Spacing to nearest neighbor” 上方，点击选中两个横向限制和纵向顶部限制。选中后会变成红色。</p>

<p><img src="~/23-05-20.jpg" alt="" /></p>

<p>这些限制表示当前的 stack view 与周边 view 的边缘的距离。选中了 “Constrain to margins”，表示这些距离限制是相对于 margins 的，margins 是外边距，是 view 边缘外的一圈空白。</p></li>

<li><p>在左右两个框中输入 0 ，在上面的框中输入 60 。</p></li>

<li><p>在 Update Frames 下拉菜单中选择 Items of New Constraints 。如下图：</p>

<p><img src="~/23-13-46.jpg" alt="" /></p></li>

<li><p>在 Pin 菜单中点击 Add 3 Constraints 按钮。</p>

<p><img src="~/23-28-41.jpg" alt="" /></p></li>
</ol>

<p>界面就会变成这个样子：</p>

<p><img src="/images/2016-05-06/2016-05-06_11.jpg" alt="" /></p>

<p>你会注意到文本域并没有扩大到场景右边缘，下面解决这个问题。</p>

<ol>
<li>在 storyboard 中选中文本域。</li>

<li><p>在画布的右下角打开 Pin 菜单。</p>

<p><img src="~/23-31-27.jpg" alt="" /></p></li>

<li><p>在 “Spacing to nearest neighbor” 上方，单击选中两个水平方向的限制，它们会变成红色。</p></li>

<li><p>在左右两个框中输入 0 。</p></li>

<li><p>在 Update Frames 下拉菜单中选择 Item of New Constraints ，如图：</p>

<p><img src="~/23-35-30.jpg" alt="" /></p></li>

<li><p>在 Pin 菜单中点击 Add 2 Constraints 按钮。</p>

<p><img src="~/23-36-14.jpg" alt="" /></p></li>

<li><p>选中文本域后，在 utility area 中打开 Size inspector 。你可以在这里编辑对象的大小和位置。</p>

<p><img src="~/21-25-32.jpg" alt="" /></p></li>

<li><p>在 Intrinsic Size 的下拉菜单中选择 Placeholder。它位于 Size inspector 的底部，你要往下翻才能看到。文本域的大小由它的内容决定，通过定义 Intrinsic content size 来设定内容的最小数量，内容用占位符（Placeholder）填充。这时，文本域的内容只是占位符组成的字符串，但是用户输入的内容可以比占位符更长。</p></li>
</ol>

<p>现在场景界面如下：</p>

<p><img src="/images/2016-05-06/2016-05-06_12.jpg" alt="" /></p>

<p>检查时间：在模拟器中运行 App 。文本域完全不会超出屏幕边界了。你可以点击文本域内部，然后用键盘输入一些文本（可以按 Command-K 切换到软键盘）。如果旋转设备（Command-Left 或 Command-Right），或者在另一种设备上运行 App ，文本域会随着屏幕的变化而伸缩到合适的大小。注意，把屏幕横过来的时候状态栏会消失。</p>

<p><img src="/images/2016-05-06/2016-05-06_13.jpg" alt="" /></p>

<p>如果没有得到你期望的结果，可以使用 Auto Layout 调试功能来解决问题。点击 Resolve Auto Layout Issues 图标，选择 Reset to Suggested Constraints ，Xcode 会将界面调整到一个合适的设定。或者点击 Resolve Auto Layout Issues 图标，选择 Clear Constraints，Xcode 会删除 UI 元素的所有限制，然后就可以重新设置。</p>

<p><img src="/images/2016-05-06/2016-05-06_14.jpg" alt="" /></p>

<p>虽然没有在这个场景上做多少工作，但是已经有两基本的 UI 和功能。要确保你的布局是健壮的，并且可扩展，为后面的升级打下坚实的基础。</p>
]]></content>
        </item>
        
        <item>
            <title>晴天钟 Documentation</title>
            <link>https://shaocheng.li/posts/2016/04/06/</link>
            <pubDate>Wed, 06 Apr 2016 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2016/04/06/</guid>
            <description>1. 简介 晴天钟是一系列天气预测产品的总称，它们主要提取于美国国家大气海洋局/气候环境预测局(NOAA/NCEP)的“全球预测系统”(Global Forecast System, GFS)数值模式。由叶泉志开发，目前由中国科学院上海天文台中国天文科普网提供硬件及网络支持。
2. 使用 域名是 http://7timer.org ，IP 访问 http://202.127.24.18/ 。域名不太稳定，通常用 IP 访问 。由于它使用的是 Google 地图，所有要开启翻墙代理，还要选择英文，否则就看不到地图了。
我通常用它来查看天文用途的天气预报。在地图上单击选点，然后选择 ASTRO ：
就可以看到天文用途的三天天气预报：
各种图标的含义：
3. API 有两种 API ：图表 API 和程序 API 。
图表 API 调用图表 API 将会返回类似晴天钟网站所见的预报图表，API 是一个 URL ，返回的图表为PNG格式，直接用浏览器访问如下 URL 即可：
 http://202.127.24.18/v4/bin/astro.php?lon=113.17&amp;amp;lat=23.09&amp;amp;ac=0&amp;amp;lang=en&amp;amp;unit=metric&amp;amp;output=internal&amp;amp;tzshift=0
 可以通过参数来控制返回结果，这些参数的含义：
 lon, lat - 指定地点的经纬度，必须是浮点数。 ac – 高度改正，只对天文用途预报有效。可取 0（默认）、2 或 7。只适用于图表 API。 lang – 语言，en 表示英文，zh-CN 表示中文。只适用于图表 API 。 unit – 公制或英制，metric/imperial 。对程序 API 无效。 output – 可设定为 internal（图表输出）、xml 或 json（程序 API ）。 tzshift – 时区微调，可取 0、1 或 -1。对程序 API 无效。 product – 为程序 API 选择产品，应为 astro（天文用途）, civil, civillight, meteo 或 two 。  程序 API 程序 API 若被成功调用，将会返回一系列数据。这些数据使用 XML 或 JSON 格式封装，其地址分别为：</description>
            <content type="html"><![CDATA[

<h2 id="1-简介">1. 简介</h2>

<p>晴天钟是一系列天气预测产品的总称，它们主要提取于美国国家大气海洋局/气候环境预测局(NOAA/NCEP)的“全球预测系统”(Global Forecast System, GFS)数值模式。由叶泉志开发，目前由中国科学院上海天文台中国天文科普网提供硬件及网络支持。</p>

<h2 id="2-使用">2. 使用</h2>

<p>域名是 <a href="http://7timer.org" target="_blank">http://7timer.org</a> ，IP 访问 <a href="http://202.127.24.18/" target="_blank">http://202.127.24.18/</a> 。域名不太稳定，通常用 IP 访问 。由于它使用的是 Google 地图，所有要开启翻墙代理，还要选择英文，否则就看不到地图了。</p>

<p>我通常用它来查看天文用途的天气预报。在地图上单击选点，然后选择 ASTRO ：</p>

<p><img src="/images/2016-04-06/2016-04-06_1.jpg" alt="" /></p>

<p>就可以看到天文用途的三天天气预报：</p>

<p><img src="/images/2016-04-06/2016-04-06_2.jpg" alt="" /></p>

<p>各种图标的含义：</p>

<p><img src="/images/2016-04-06/2016-04-06_3.jpg" alt="" /></p>

<h2 id="3-api">3. API</h2>

<p>有两种 API ：图表 API 和程序 API 。</p>

<h3 id="图表-api">图表 API</h3>

<p>调用图表 API 将会返回类似晴天钟网站所见的预报图表，API 是一个 URL ，返回的图表为PNG格式，直接用浏览器访问如下 URL 即可：</p>

<blockquote>
<p><a href="http://202.127.24.18/v4/bin/astro.php?lon=113.17&amp;lat=23.09&amp;ac=0&amp;lang=en&amp;unit=metric&amp;output=internal&amp;tzshift=0" target="_blank">http://202.127.24.18/v4/bin/astro.php?lon=113.17&amp;lat=23.09&amp;ac=0&amp;lang=en&amp;unit=metric&amp;output=internal&amp;tzshift=0</a></p>
</blockquote>

<p>可以通过参数来控制返回结果，这些参数的含义：</p>

<ul>
<li>lon, lat - 指定地点的经纬度，必须是浮点数。</li>
<li>ac – 高度改正，只对天文用途预报有效。可取 0（默认）、2 或 7。只适用于图表 API。</li>
<li>lang – 语言，en 表示英文，zh-CN 表示中文。只适用于图表 API 。</li>
<li>unit – 公制或英制，metric/imperial 。对程序 API 无效。</li>
<li>output – 可设定为 internal（图表输出）、xml 或 json（程序 API ）。</li>
<li>tzshift – 时区微调，可取 0、1 或 -1。对程序 API 无效。</li>
<li>product – 为程序 API 选择产品，应为 astro（天文用途）, civil, civillight, meteo 或 two 。</li>
</ul>

<h3 id="程序-api">程序 API</h3>

<p>程序 API 若被成功调用，将会返回一系列数据。这些数据使用 XML 或 JSON 格式封装，其地址分别为：</p>

<blockquote>
<p>XML: <a href="http://202.127.24.18v4/bin/api.pl?lon=118.093&amp;lat=24.468&amp;product=astro&amp;output=xml" target="_blank">http://202.127.24.18v4/bin/api.pl?lon=118.093&amp;lat=24.468&amp;product=astro&amp;output=xml</a>
JSON: <a href="http://202.127.24.18/v4/bin/api.pl?lon=118.093&amp;lat=24.468&amp;product=astro&amp;output=json" target="_blank">http://202.127.24.18/v4/bin/api.pl?lon=118.093&amp;lat=24.468&amp;product=astro&amp;output=json</a></p>
</blockquote>

<p>product 设为 astro 时，会返回天文用途的数据，返回值的含义：</p>

<table>
<thead>
<tr>
<th>变量</th>
<th>返回值</th>
<th>定义</th>
</tr>
</thead>

<tbody>
<tr>
<td>云量</td>
<td>1</td>
<td>0%-6%</td>
</tr>

<tr>
<td></td>
<td>2</td>
<td>6%-19%</td>
</tr>

<tr>
<td></td>
<td>3</td>
<td>19%-31%</td>
</tr>

<tr>
<td></td>
<td>4</td>
<td>31%-44%</td>
</tr>

<tr>
<td></td>
<td>5</td>
<td>44%-56%</td>
</tr>

<tr>
<td></td>
<td>6</td>
<td>56%-69%</td>
</tr>

<tr>
<td></td>
<td>7</td>
<td>69%-81%</td>
</tr>

<tr>
<td></td>
<td>8</td>
<td>81%-94%</td>
</tr>

<tr>
<td></td>
<td>9</td>
<td>94%-100%</td>
</tr>

<tr>
<td>抬升指数</td>
<td>-10</td>
<td>小于-7</td>
</tr>

<tr>
<td></td>
<td>-6</td>
<td>-7至-5</td>
</tr>

<tr>
<td></td>
<td>-4</td>
<td>-5至-3</td>
</tr>

<tr>
<td></td>
<td>-1</td>
<td>-3至0</td>
</tr>

<tr>
<td></td>
<td>2</td>
<td>0至4</td>
</tr>

<tr>
<td></td>
<td>6</td>
<td>4至8</td>
</tr>

<tr>
<td></td>
<td>10</td>
<td>8至11</td>
</tr>

<tr>
<td></td>
<td>15</td>
<td>大于11</td>
</tr>

<tr>
<td>2米气温</td>
<td>-76至60</td>
<td>-76摄氏度至+60摄氏度</td>
</tr>

<tr>
<td>视宁度</td>
<td>1</td>
<td>&lt;0.5&rdquo;</td>
</tr>

<tr>
<td></td>
<td>2</td>
<td>0.5&rdquo;-0.75&rdquo;</td>
</tr>

<tr>
<td></td>
<td>3</td>
<td>0.75&rdquo;-1&rdquo;</td>
</tr>

<tr>
<td></td>
<td>4</td>
<td>1&rdquo;-1.25&rdquo;</td>
</tr>

<tr>
<td></td>
<td>5</td>
<td>1.25&rdquo;-1.5&rdquo;</td>
</tr>

<tr>
<td></td>
<td>6</td>
<td>1.5&rdquo;-2&rdquo;</td>
</tr>

<tr>
<td></td>
<td>7</td>
<td>2&rdquo;-2.5&rdquo;</td>
</tr>

<tr>
<td></td>
<td>8</td>
<td>&gt;2.5&rdquo;</td>
</tr>

<tr>
<td>透明度</td>
<td>1</td>
<td>&lt;0.3</td>
</tr>

<tr>
<td></td>
<td>2</td>
<td>0.3-0.4</td>
</tr>

<tr>
<td></td>
<td>3</td>
<td>0.4-0.5</td>
</tr>

<tr>
<td></td>
<td>4</td>
<td>0.5-0.6</td>
</tr>

<tr>
<td></td>
<td>5</td>
<td>0.6-0.7</td>
</tr>

<tr>
<td></td>
<td>6</td>
<td>0.7-0.85</td>
</tr>

<tr>
<td></td>
<td>7</td>
<td>0.85-1</td>
</tr>

<tr>
<td></td>
<td>8</td>
<td>&gt;1</td>
</tr>

<tr>
<td>2米相对湿度</td>
<td>-4</td>
<td>0%-5%</td>
</tr>

<tr>
<td></td>
<td>-3</td>
<td>5%-10%</td>
</tr>

<tr>
<td></td>
<td>-2</td>
<td>10%-15%</td>
</tr>

<tr>
<td></td>
<td>-1</td>
<td>15%-20%</td>
</tr>

<tr>
<td></td>
<td>0</td>
<td>20%-25%</td>
</tr>

<tr>
<td></td>
<td>1</td>
<td>25%-30%</td>
</tr>

<tr>
<td></td>
<td>2</td>
<td>30%-35%</td>
</tr>

<tr>
<td></td>
<td>3</td>
<td>35%-40%</td>
</tr>

<tr>
<td></td>
<td>4</td>
<td>40%-45%</td>
</tr>

<tr>
<td></td>
<td>5</td>
<td>45%-50%</td>
</tr>

<tr>
<td></td>
<td>6</td>
<td>50%-55%</td>
</tr>

<tr>
<td></td>
<td>7</td>
<td>55%-60%</td>
</tr>

<tr>
<td></td>
<td>8</td>
<td>60%-65%</td>
</tr>

<tr>
<td></td>
<td>9</td>
<td>65%-70%</td>
</tr>

<tr>
<td></td>
<td>10</td>
<td>70%-75%</td>
</tr>

<tr>
<td></td>
<td>11</td>
<td>75%-80%</td>
</tr>

<tr>
<td></td>
<td>12</td>
<td>80%-85%</td>
</tr>

<tr>
<td></td>
<td>13</td>
<td>85%-90%</td>
</tr>

<tr>
<td></td>
<td>14</td>
<td>90%-95%</td>
</tr>

<tr>
<td></td>
<td>15</td>
<td>95%-99%</td>
</tr>

<tr>
<td></td>
<td>16</td>
<td>100%</td>
</tr>

<tr>
<td>10米风速</td>
<td>1</td>
<td>低于0.3米/秒（无风）</td>
</tr>

<tr>
<td></td>
<td>2</td>
<td>0.3-3.4米/秒（1-2级）</td>
</tr>

<tr>
<td></td>
<td>3</td>
<td>3.4-8.0米/秒（3-4级）</td>
</tr>

<tr>
<td></td>
<td>4</td>
<td>8.0-10.8米/秒（5级）</td>
</tr>

<tr>
<td></td>
<td>5</td>
<td>10.8-17.2米/秒（6-7级）</td>
</tr>

<tr>
<td></td>
<td>6</td>
<td>17.2-24.5米/秒（8-9级）</td>
</tr>

<tr>
<td></td>
<td>7</td>
<td>24.5-32.6米/秒（10-11级）</td>
</tr>

<tr>
<td></td>
<td>8</td>
<td>超过32.6米/秒（12级或以上）</td>
</tr>

<tr>
<td>降水类型</td>
<td>snow（雪）、rain（雨）、none（无）</td>
<td></td>
</tr>

<tr>
<td>无效值</td>
<td>-9999</td>
<td>无效值</td>
</tr>
</tbody>
</table>
]]></content>
        </item>
        
        <item>
            <title>Linux 下调试低功耗蓝牙的笔记</title>
            <link>https://shaocheng.li/posts/2016/04/05/</link>
            <pubDate>Tue, 05 Apr 2016 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2016/04/05/</guid>
            <description>蓝牙 4.0 版本推出了低功耗规范，简称 BLE (Bluetooth Low Energy)，很多小型设备，例如小米手环，都是使用低功耗蓝牙。要与这类模块连接，主设备的蓝牙模块必须支持低功耗，例如 intel 2230 ：
现在有一个 BLE 的透传模块，会不断的发出数据，我的主机安装了 Linux ，使用 intel 2230 接收数据。协议栈依然是 BlueZ 。
1. GATT 协议 BLE 连接都是建立在 GATT 协议之上的。介绍 GATT 之前，需要了解 GAP（Generic Access Profile）。它在用来控制设备连接和广播。GAP 使你的设备被其他设备可见，并决定了你的设备是否可以或者怎样与合同设备进行交互。GAP 给设备定义了若干角色，其中主要的两个是：外围设备（Peripheral）和中心设备（Central），外设必须不停的向外广播，让中心设备知道它的存在。中心设备扫描到外设后，发起并建立 GATT 连接。
GATT 连接是独占的，也就是一个 BLE 外设同时只能被一个中心设备连接。一旦外设被连接，它就会马上停止广播。中心设备和外设需要双向通信的话，唯一的方式就是建立 GATT 连接。一个外设只能连接一个中心设备，而一个中心设备可以连接多个外设。GATT 定义 BLE 通信的双方是 C/S 关系，外设作为服务端（Server），也叫从设备（Slave），中心设备是客户端（Client），也叫主设备（Master）。所有的通信事件，都是由 Client 发起请求，Server 作出响应。但 GATT 还有两个特性：notification 和 indication。这意味着 server 可以主动发出通知和指示，使 client 端不用轮询。
GATT 是一个在蓝牙连接之上的发送和接收很短的数据段的通用规范（ATT），这些很短的数据段被称为属性（Attribute）。一个 attribute 由三种元素组成：
 一个16位的句柄（handle） 一个定长的值（value） 一个 UUID，定义了 attribute 的类型，value 的意义完全由 UUID 决定。   attribute 的 handle 具有唯一性，仅用作区分不用的 attribute（因为可能有很多不同的 attribute 拥有相同的 UUID）</description>
            <content type="html"><![CDATA[

<p>蓝牙 4.0 版本推出了低功耗规范，简称 BLE (Bluetooth Low Energy)，很多小型设备，例如小米手环，都是使用低功耗蓝牙。要与这类模块连接，主设备的蓝牙模块必须支持低功耗，例如 intel 2230 ：</p>

<p><img src="/images/2016-04-05/2016-04-05_1.jpg" alt="" /></p>

<p>现在有一个 BLE 的透传模块，会不断的发出数据，我的主机安装了 Linux ，使用 intel 2230 接收数据。协议栈依然是 BlueZ 。</p>

<h2 id="1-gatt-协议">1. GATT 协议</h2>

<p>BLE 连接都是建立在 GATT 协议之上的。介绍 GATT 之前，需要了解 GAP（Generic Access Profile）。它在用来控制设备连接和广播。GAP 使你的设备被其他设备可见，并决定了你的设备是否可以或者怎样与合同设备进行交互。GAP 给设备定义了若干角色，其中主要的两个是：外围设备（Peripheral）和中心设备（Central），外设必须不停的向外广播，让中心设备知道它的存在。中心设备扫描到外设后，发起并建立 GATT 连接。</p>

<p>GATT 连接是独占的，也就是一个 BLE 外设同时只能被一个中心设备连接。一旦外设被连接，它就会马上停止广播。中心设备和外设需要双向通信的话，唯一的方式就是建立 GATT 连接。一个外设只能连接一个中心设备，而一个中心设备可以连接多个外设。GATT 定义 BLE 通信的双方是 C/S 关系，外设作为服务端（Server），也叫从设备（Slave），中心设备是客户端（Client），也叫主设备（Master）。所有的通信事件，都是由 Client 发起请求，Server 作出响应。但 GATT 还有两个特性：notification 和 indication。这意味着 server 可以主动发出通知和指示，使 client 端不用轮询。</p>

<p>GATT 是一个在蓝牙连接之上的发送和接收很短的数据段的通用规范（ATT），这些很短的数据段被称为属性（Attribute）。一个 attribute 由三种元素组成：</p>

<ul>
<li>一个16位的句柄（handle）</li>
<li>一个定长的值（value）</li>
<li>一个 UUID，定义了 attribute 的<strong>类型</strong>，value 的意义完全由 UUID 决定。</li>
</ul>

<blockquote>
<p>attribute 的 handle 具有唯一性，仅用作区分不用的 attribute（因为可能有很多不同的 attribute 拥有相同的 UUID）</p>
</blockquote>

<p>Attribute 只存储在 Server 端，多个 attribute 构成一个 characteristic（特征值），一个或多个 characteristic 构成一个 Service (服务)，一个 BLE 设备可以有多个 Service ，Service 是把数据分成一个个的独立逻辑项。</p>

<p><img src="/images/2016-04-05/2016-04-05_2.jpg" alt="" /></p>

<p>一个 GATT Service 始于 UUID 为 0x2800 的 attribute ，直到下一个 UUID 为 0x2800 的 attribute 为止。范围内的所有 attribute 都属于该服务的。例如，一台有三种服务的设备拥有如下所示的 attribute 布局：</p>

<table>
<thead>
<tr>
<th>Handle</th>
<th>UUID</th>
<th>Description</th>
<th>Value</th>
</tr>
</thead>

<tbody>
<tr>
<td>0x0100</td>
<td>0x2800</td>
<td>Service A definition</td>
<td>0x1816 (UUID)</td>
</tr>

<tr>
<td>&hellip;</td>
<td>&hellip;</td>
<td>Service details</td>
<td>&hellip;</td>
</tr>

<tr>
<td>0x0150</td>
<td>0x2800</td>
<td>Service B definition</td>
<td>0x18xx</td>
</tr>

<tr>
<td>&hellip;</td>
<td>&hellip;</td>
<td>Service details</td>
<td>&hellip;</td>
</tr>

<tr>
<td>0x0300</td>
<td>0x2800</td>
<td>Service C definition</td>
<td>0x18xx</td>
</tr>

<tr>
<td>&hellip;</td>
<td>&hellip;</td>
<td>Service details</td>
<td>&hellip;</td>
</tr>
</tbody>
</table>

<p>handle 具有唯一性，属于 Service B 的 attribute 的 handle 范围肯定落在 0x0151  和 0x02ff 之中。那么，我如何知道一个 Service 是温度检测，还是 GPS 呢？通过读取该 Service 的 attribute 的 value 。UUID 为 0x2800 的 attribute 作为 Service 的起始标志，它的 value 就是该服务的 UUID ，是该服务的唯一标识，表示了该服务的类型。UUID 有 16 bit 的，或者 128 bit 的。16 bit 的 UUID 是官方通过认证的，需要购买，128 bit 是自定义的，这个就可以自己随便设置。</p>

<p>每个 Service 都包含一个或多个 characteristic（特征值）。这些 characteristic 负责存储 Service 的数据和访问权限。每个 Characteristic 用 16 bit 或者 128 bit 的 UUID 唯一标识。例如，一个温度计（service）一般会有一个只读的“温度”characteristic，和一个可读写的“日期时间”characteristic：</p>

<table>
<thead>
<tr>
<th>Handle</th>
<th>UUID</th>
<th>Description</th>
<th>Value</th>
</tr>
</thead>

<tbody>
<tr>
<td>0x0100</td>
<td>0x2800</td>
<td>Thermometer service definition</td>
<td>UUID 0x1816</td>
</tr>

<tr>
<td>0x0101</td>
<td>0x2803</td>
<td>Characteristic: temperature</td>
<td>UUID 0x2A2B,Value handle: 0x0102</td>
</tr>

<tr>
<td>0x0102</td>
<td>0x2A2B</td>
<td>Temperature value</td>
<td>20 degrees</td>
</tr>

<tr>
<td>0x0110</td>
<td>0x2803</td>
<td>Characteristic: date/time</td>
<td>UUID 0x2A08,Value handle: 0x0111</td>
</tr>

<tr>
<td>0x0111</td>
<td>0x2A08</td>
<td>Date/Time</td>
<td>1/1/1980 12:00</td>
</tr>
</tbody>
</table>

<p>可以看到，handle 0x0101 定义了一个“温度” characteristic ，该 characteristic 的 UUID 是 0x2A2B，它的值位于 handle 0x0102 。</p>

<p>除了 value，还可以在 characteristic 的附加 attribute 里获取到其它信息。这些附加的 attribute 称为 descriptor 。例如，当我们我们需要明确温度计的计量单位时，可以通过添加一个 descriptor 来实现：</p>

<table>
<thead>
<tr>
<th>Handle</th>
<th>UUID</th>
<th>Description</th>
<th>Value</th>
</tr>
</thead>

<tbody>
<tr>
<td>0x0100</td>
<td>0x2800</td>
<td>Thermometer service definition</td>
<td>UUID 0x1816</td>
</tr>

<tr>
<td>0x0101</td>
<td>0x2803</td>
<td>Characteristic: temperature</td>
<td>UUID 0x2A2B,Value handle: 0x0102</td>
</tr>

<tr>
<td>0x0102</td>
<td>0x2A2B</td>
<td>Temperature value</td>
<td>20 degrees</td>
</tr>

<tr>
<td>0x0104</td>
<td>0x2A1F</td>
<td>Descriptor: unit</td>
<td>Celsius</td>
</tr>

<tr>
<td>0x0110</td>
<td>0x2803</td>
<td>Characteristic: date/time</td>
<td>UUID 0x2A08,Value handle: 0x0111</td>
</tr>

<tr>
<td>0x0111</td>
<td>0x2A08</td>
<td>Date/Time</td>
<td>1/1/1980 12:00</td>
</tr>
</tbody>
</table>

<p>GATT 知道 handle 0x0104 是属于 characteristic 0x0101 的 descriptor，因为：</p>

<ul>
<li>它不是一个 value attribute，因为 value attribute 已经指明是 handle 0x0102</li>
<li>它刚好在 0x0103..0x010F 的范围内，两个 characteristic 之间</li>
</ul>

<p>每个 service 都可以自定义 desctiptor，GATT 已经预定义了一系列常用的 desctiptor ：</p>

<ul>
<li>数据格式和表达方式</li>
<li>可读性描述</li>
<li>有效范围</li>
<li>扩展属性</li>
</ul>

<p>其中一个很重要的 descriptor 是 client characteristic configuration ，简称 CCC descriptor ，它的 UUID 是 0x2902 ，有一个可读性的 16 位 Value ，低两位已经被占用，用于配置 characteristic 的 notification 和 indication ：</p>

<ul>
<li>Bit 0 设为 1 表示使能 Notification</li>
<li>Bit 1 设为 1 表示使能 Indication<br /></li>
</ul>

<p>对于具有 Notify 属性的 characteristic ，使能 Notification 后，数据发生变化时会主动通知 Client 端，Client 端只要监听即可。</p>

<h2 id="2-linux-中的操作">2. Linux 中的操作</h2>

<p>在 BlueZ 中就要用 <code>hcitool lescan</code> 命令扫描低功耗蓝牙设备：</p>

<pre><code>root@WR-IntelligentDevice:~# hcitool lescan   
LE Scan ...
20:91:48:6B:65:08 (unknown)
20:91:48:6B:65:08 SPP_2091486B6508
</code></pre>

<p><code>gatttool</code> 是用来访问 BLE 设备的命令，用 <code>gatttool -b 20:91:48:6B:65:08 -I</code> 打开一个与远程设备的会话，-I 表示交互模式：</p>

<pre><code>root@WR-IntelligentDevice:~# gatttool -b 20:91:48:6B:65:08 -I
[   ][20:91:48:6B:65:08][LE]&gt; help
help                                           Show this help
exit                                           Exit interactive mode
quit                                           Exit interactive mode
connect         [address [address type]]       Connect to a remote device
disconnect                                     Disconnect from a remote device
primary         [UUID]                         Primary Service Discovery
characteristics [start hnd [end hnd [UUID]]]   Characteristics Discovery
char-desc       [start hnd] [end hnd]          Characteristics Descriptor Discovery
char-read-hnd   &lt;handle&gt; [offset]              Characteristics Value/Descriptor Read by handle
char-read-uuid  &lt;UUID&gt; [start hnd] [end hnd]   Characteristics Value/Descriptor Read by UUID
char-write-req  &lt;handle&gt; &lt;new value&gt;           Characteristic Value Write (Write Request)
char-write-cmd  &lt;handle&gt; &lt;new value&gt;           Characteristic Value Write (No response)
sec-level       [low | medium | high]          Set security level. Default: low
mtu             &lt;value&gt;                        Exchange MTU for GATT/ATT
[   ][20:91:48:6B:65:08][LE]&gt; 
</code></pre>

<p><code>connect</code> 表示连接远程设备，连接成功后，提示符签名的状态会显示 &ldquo;CON&rdquo; :</p>

<pre><code>[   ][20:91:48:6B:65:08][LE]&gt; connect
[CON][20:91:48:6B:65:08][LE]&gt; 
</code></pre>

<p><code>primary</code> 命令会列出远程设备上所有的 Service ，每个服务所在的 handle 范围:</p>

<pre><code>[CON][20:91:48:6B:65:08][LE]&gt; primary 
[CON][20:91:48:6B:65:08][LE]&gt; 
attr handle: 0x0001, end grp handle: 0x000b uuid: 00001800-0000-1000-8000-00805f9b34fb
attr handle: 0x000c, end grp handle: 0x000f uuid: 00001801-0000-1000-8000-00805f9b34fb
attr handle: 0x0010, end grp handle: 0x0017 uuid: 0000fee7-0000-1000-8000-00805f9b34fb
attr handle: 0x0018, end grp handle: 0x001b uuid: 0000fee0-0000-1000-8000-00805f9b34fb
attr handle: 0x001c, end grp handle: 0x0024 uuid: f000ffc0-0451-4000-b000-000000000000
attr handle: 0x0025, end grp handle: 0x002f uuid: 0000ccc0-0000-1000-8000-00805f9b34fb
attr handle: 0x0030, end grp handle: 0xffff uuid: 0000180a-0000-1000-8000-00805f9b34fb
</code></pre>

<p>用 <code>primary fee7</code>  查看 UUID 为 0xfee7 的 Service ，执行 <code>characteristics 0x0010 0x0017</code> 可以发现它有三个 characteristics ：</p>

<pre><code>[CON][20:91:48:28:26:AF][LE]&gt; primary fee7
[CON][20:91:48:28:26:AF][LE]&gt; 
Starting handle: 0x0010 Ending handle: 0x0017
[CON][20:91:48:28:26:AF][LE]&gt; characteristics 0x0010 0x0017
[CON][20:91:48:28:26:AF][LE]&gt; 
handle: 0x0011, char properties: 0x20, char value handle: 0x0012, uuid: 0000fec8-0000-1000-8000-00805f9b34fb
handle: 0x0014, char properties: 0x0a, char value handle: 0x0015, uuid: 0000fec7-0000-1000-8000-00805f9b34fb
handle: 0x0016, char properties: 0x02, char value handle: 0x0017, uuid: 0000fec9-0000-1000-8000-00805f9b34fb
</code></pre>

<p>char properties 表示 characteristic 的属性，char value handle 表示 characteristic 的值所在的 attribute 的 handle 。下面是 characteristic properties 的说明：</p>

<p><img src="/images/2016-04-05/2016-04-05_3.jpg" alt="" /></p>

<p>现在远程设备上有一个透传服务是 0xFEE0, 传输数据的特征值是 0xFEE1 ，可以用如下方式查看：</p>

<pre><code>[CON][20:91:48:6B:65:08][LE]&gt; primary 0xfee0
[CON][20:91:48:6B:65:08][LE]&gt; 
Starting handle: 0x0018 Ending handle: 0x001b
[CON][20:91:48:6B:65:08][LE]&gt; characteristics  0x0018 0x001b       
[CON][20:91:48:6B:65:08][LE]&gt; 
handle: 0x0019, char properties: 0x14, char value handle: 0x001a, uuid: 0000fee1-0000-1000-8000-00805f9b34fb
[CON][20:91:48:6B:65:08][LE]&gt; char-desc 0x0018 0x001b
[CON][20:91:48:6B:65:08][LE]&gt; 
handle: 0x0018, uuid: 2800
handle: 0x0019, uuid: 2803
handle: 0x001a, uuid: fee1
handle: 0x001b, uuid: 2902
</code></pre>

<p>首先执行 <code>primary 0xfee0</code> ，发现该服务包含 handle 0x0018 到 handle 0x001b 之间的 attribute 。然后用 <code>characteristics  0x0018 0x001b</code> 发现该服务有一个 characteristic ，它的值在 handle 0x001a ，属性是 0x14 ，表示可写无回复/通知（Write without response/Notify）。最后用 <code>char-desc 0x0018 0x001b</code> 列出该特征值的所有 Descriptor ，最后一个 UUID 为 0x2902 ，是一个 CCC Descriptor ，读取它当前的值：</p>

<pre><code>[CON][20:91:48:28:26:AF][LE]&gt; char-read-hnd 0x001b
[CON][20:91:48:28:26:AF][LE]&gt; 
Characteristic value/descriptor: 00 00
</code></pre>

<blockquote>
<p>通过 handle 读写的好处是准确，因为 handle 具有唯一性。如果执行 <code>char-read-uuid 0x2902</code> ，就会发现列出了很多个 attribute 。</p>
</blockquote>

<p>当前的值是 0 ，这个 characteristic 的属性是 Notify ，所以要向 handle 0x001b 写入 0x0100 （X86 是小端），使能 Notify ，然后就会不停的收到数据：</p>

<pre><code>[CON][20:91:48:28:26:AF][LE]&gt; char-write-req 0x001b 0100
[CON][20:91:48:28:26:AF][LE]&gt; Characteristic value was written successfully

Notification handle = 0x001a value: 41 47 3a 20 37 30 34 38 20 37 30 39 35 20 36 30 20 2d 31 37 
[CON][20:91:48:28:26:AF][LE]&gt; 
Notification handle = 0x001a value: 20 2d 32 31 33 20 39 34 36 20 2d 39 33 30 20 2d 31 39 36 20 
[CON][20:91:48:28:26:AF][LE]&gt; 
Notification handle = 0x001a value: 39 33 38 20 2d 39 33 30 0a 41 47 3a 20 37 30 34 31 20 37 31 
[CON][20:91:48:28:26:AF][LE]&gt; 
</code></pre>

<p>在非交互模式下，用 <code>--listen</code> 选项启动监听模式来接收通知：</p>

<pre><code>root@WR-IntelligentDevice:~# gatttool -b 20:91:48:28:26:AF --char-write-req --handle=0x001b --value=0100 --listen
Characteristic value was written successfully
Notification handle = 0x001a value: 32 30 37 32 20 35 33 32 39 20 34 32 39 35 20 41 47 3a 20 2d 
Notification handle = 0x001a value: 32 30 37 36 20 35 33 32 36 20 34 33 30 30 20 41 47 3a 20 2d 
Notification handle = 0x001a value: 32 30 37 38 20 35 33 32 37 20 34 33 30 35 20 41 47 3a 20 2d 
</code></pre>

<h2 id="3-参考">3. 参考</h2>

<p><a href="https://learn.adafruit.com/introduction-to-bluetooth-low-energy?view=all" target="_blank">Introduction to Bluetooth Low Energy</a>
<a href="http://www.jaredwolff.com/blog/get-started-with-bluetooth-low-energy/" target="_blank">Get started with Bluetooth Low Energy</a>
<a href="https://developer.bluetooth.org/gatt/Pages/default.aspx" target="_blank">GATT Specifications</a>
<a href="https://epxx.co/artigos/bluetooth_gatt.html" target="_blank">Bluetooth: ATT and GATT</a></p>
]]></content>
        </item>
        
        <item>
            <title>BlueZ 蓝牙编程笔记</title>
            <link>https://shaocheng.li/posts/2016/03/23/</link>
            <pubDate>Wed, 23 Mar 2016 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2016/03/23/</guid>
            <description>1. 简介 BlueZ 是 Linux 官方的蓝牙协议栈，官网地址： 。
BlueZ 的代码由两个部分组成：内核代码和用户空间程序。内核代码包括驱动和核心协议栈，用户空间程序包括应用程序接口和操作蓝牙设备的工具。BlueZ 的体系结构如下图：
我使用的版本是 bluez-4.101 。
2. 扫描 下面这个例程展示了搜索蓝牙设备的过程，并显示设备名称和地址。
//samplescan.c #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;bluetooth/bluetooth.h&amp;gt; #include &amp;lt;bluetooth/hci.h&amp;gt; #include &amp;lt;bluetooth/hci_lib.h&amp;gt; int main(int argc, char **argv) { inquiry_info *ii = NULL; int max_rsp, num_rsp; int dev_id, sock, len, flags; int i; char addr[19] = { 0 }; char name[248] = { 0 }; dev_id = hci_get_route(NULL); sock = hci_open_dev( dev_id ); if (dev_id &amp;lt; 0 || sock &amp;lt; 0) { perror(&amp;quot;opening socket&amp;quot;); exit(1); } len = 8; max_rsp = 255; flags = IREQ_CACHE_FLUSH; ii = (inquiry_info*)malloc(max_rsp * sizeof(inquiry_info)); num_rsp = hci_inquiry(dev_id, len, max_rsp, NULL, &amp;amp;ii, flags); if( num_rsp &amp;lt; 0 ) perror(&amp;quot;hci_inquiry&amp;quot;); for (i = 0; i &amp;lt; num_rsp; i++) { ba2str(&amp;amp;(ii+i)-&amp;gt;bdaddr, addr); memset(name, 0, sizeof(name)); if (hci_read_remote_name(sock, &amp;amp;(ii+i)-&amp;gt;bdaddr, sizeof(name), name, 0) &amp;lt; 0) strcpy(name, &amp;quot;[unknown]&amp;quot;); printf(&amp;quot;%s %s\n&amp;quot;, addr, name); } free( ii ); close( sock ); return 0; }  编译 gcc -o simplescan simplescan.</description>
            <content type="html"><![CDATA[

<h2 id="1-简介">1. 简介</h2>

<p>BlueZ 是 Linux 官方的蓝牙协议栈，官网地址：<www.bluez.org> 。</p>

<p>BlueZ 的代码由两个部分组成：内核代码和用户空间程序。内核代码包括驱动和核心协议栈，用户空间程序包括应用程序接口和操作蓝牙设备的工具。BlueZ 的体系结构如下图：</p>

<p><img src="/images/2016-03-23/2016-03-23_1.jpg" alt="" /></p>

<p>我使用的版本是 bluez-4.101 。</p>

<h2 id="2-扫描">2. 扫描</h2>

<p>下面这个例程展示了搜索蓝牙设备的过程，并显示设备名称和地址。</p>

<pre><code>//samplescan.c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;bluetooth/bluetooth.h&gt;
#include &lt;bluetooth/hci.h&gt;
#include &lt;bluetooth/hci_lib.h&gt;

int main(int argc, char **argv)
{
    inquiry_info *ii = NULL;
    int max_rsp, num_rsp;
    int dev_id, sock, len, flags;
    int i;
    char addr[19] = { 0 };
    char name[248] = { 0 };

    dev_id = hci_get_route(NULL);
    sock = hci_open_dev( dev_id );
    if (dev_id &lt; 0 || sock &lt; 0) {
        perror(&quot;opening socket&quot;);
        exit(1);
    }

    len  = 8;
    max_rsp = 255;
    flags = IREQ_CACHE_FLUSH;
    ii = (inquiry_info*)malloc(max_rsp * sizeof(inquiry_info));

    num_rsp = hci_inquiry(dev_id, len, max_rsp, NULL, &amp;ii, flags);
    if( num_rsp &lt; 0 ) perror(&quot;hci_inquiry&quot;);

    for (i = 0; i &lt; num_rsp; i++) {
        ba2str(&amp;(ii+i)-&gt;bdaddr, addr);
        memset(name, 0, sizeof(name));
        if (hci_read_remote_name(sock, &amp;(ii+i)-&gt;bdaddr, sizeof(name), 
            name, 0) &lt; 0)
        strcpy(name, &quot;[unknown]&quot;);
        printf(&quot;%s  %s\n&quot;, addr, name);
    }

    free( ii );
    close( sock );
    return 0;
}
</code></pre>

<p>编译 <code>gcc -o simplescan simplescan.c -lbluetooth</code></p>

<p>bdaddr_t 是存储蓝牙设备地址的基本数据结构：</p>

<pre><code>typedef struct {
    uint8_t b[6];
} __attribute__((packed)) bdaddr_t; 
</code></pre>

<p>BlueZ 中的所有蓝牙地址都存放在 bdaddr_t ，同时提供了两个函数用于地址字符串与 bdaddr_t 之间的转换：</p>

<pre><code>int str2ba( const char *str, bdaddr_t *ba );
int ba2str( const bdaddr_t *ba, char *str );
</code></pre>

<p>地址字符串的结构应该是 <code>XX:XX:XX:XX:XX:XX</code> ，XX 是一个十六进制数，str2ba 函数将它转换到 6 Byte 的 bdaddr_t 中。ba2str 的作用相反。</p>
]]></content>
        </item>
        
        <item>
            <title>核桃</title>
            <link>https://shaocheng.li/posts/2016/02/23/</link>
            <pubDate>Tue, 23 Feb 2016 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2016/02/23/</guid>
            <description>朦胧中，好像醒了。
抬眼看窗外，天还黑，
拿起手机，才五点。
隐约听到什么声音，应该是楼上吧，
持续不断，越来越清晰…
这声音让我想起去年养过的一只猫。
有天晚上，不知道它从哪弄来一个核桃，自己扑着玩儿，核桃在地板上滚来滚去，格楞楞地响…
我清醒了，等了一会儿，那声音还在，就在我家里。
起床，穿鞋，来到客厅，声音消失了…
我打开所有房间的灯，在厨房的地板上，发现了一个核桃。
……
我家从没买过核桃，那个核桃被猫滚到了床底下，后来猫走了，核桃一直留在那。</description>
            <content type="html"><![CDATA[<p>朦胧中，好像醒了。</p>

<p>抬眼看窗外，天还黑，</p>

<p>拿起手机，才五点。</p>

<p>隐约听到什么声音，应该是楼上吧，</p>

<p>持续不断，越来越清晰…</p>

<p>这声音让我想起去年养过的一只猫。</p>

<p>有天晚上，不知道它从哪弄来一个核桃，自己扑着玩儿，核桃在地板上滚来滚去，格楞楞地响…</p>

<p>我清醒了，等了一会儿，那声音还在，就在我家里。</p>

<p>起床，穿鞋，来到客厅，声音消失了…</p>

<p>我打开所有房间的灯，在厨房的地板上，发现了一个核桃。</p>

<p>……</p>

<p>我家从没买过核桃，那个核桃被猫滚到了床底下，后来猫走了，核桃一直留在那。</p>

<p><img src="/images/2016-02-23/2016-02-23_1.jpg" alt="" /></p>
]]></content>
        </item>
        
        <item>
            <title>Logrotate</title>
            <link>https://shaocheng.li/posts/2016/01/21/</link>
            <pubDate>Thu, 21 Jan 2016 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2016/01/21/</guid>
            <description>在 Linux 系统中存在各种日志文件，例如保存启动信息和内核信息的 /var/log/dmesg ，保存系统日志的 /var/log/syslog 等。如果连续运行时间太长，这些日志会越来越大，最终占据太多系统空间。所以，我们需要定期清理系统日志。Logrotate 的主要功能就是定时将旧的日志文件归档，同时创建一个新的空的日志文件，归档的文件可以选择压缩或者发送到指定的邮箱，这个过程叫做轮替（rotate）：
Logrotate 是基于 cron 运行的，他的脚本是 /etc/cron.daily/logrotate :
#!/bin/sh /usr/sbin/logrotate /etc/logrotate.conf EXITVALUE=$? if [ $EXITVALUE != 0 ]; then /usr/bin/logger -t logrotate &amp;quot;ALERT exited abnormally with [$EXITVALUE]&amp;quot; fi exit 0   cron 用于设置周期性被执行的指令，是运行在后台的守护进程。
 Logrotate 的主配置文件是 /etc/logrotate.conf ：
# see &amp;quot;man logrotate&amp;quot; for details # rotate log files weekly weekly # keep 4 weeks worth of backlogs rotate 4 # create new (empty) log files after rotating old ones create # use date as a suffix of the rotated file dateext # uncomment this if you want your log files compressed #compress # RPM packages drop log rotation information into this directory include /etc/logrotate.</description>
            <content type="html"><![CDATA[<p>在 Linux 系统中存在各种日志文件，例如保存启动信息和内核信息的 /var/log/dmesg ，保存系统日志的 /var/log/syslog 等。如果连续运行时间太长，这些日志会越来越大，最终占据太多系统空间。所以，我们需要定期清理系统日志。Logrotate 的主要功能就是定时将旧的日志文件归档，同时创建一个新的空的日志文件，归档的文件可以选择压缩或者发送到指定的邮箱，这个过程叫做轮替（rotate）：</p>

<p><img src="/images/2016-01-21/2016-01-21_1.jpg" alt="" /></p>

<p>Logrotate 是基于 cron 运行的，他的脚本是 /etc/cron.daily/logrotate :</p>

<pre><code>#!/bin/sh

/usr/sbin/logrotate /etc/logrotate.conf
EXITVALUE=$?
if [ $EXITVALUE != 0 ]; then
    /usr/bin/logger -t logrotate &quot;ALERT exited abnormally with [$EXITVALUE]&quot;
fi
exit 0
</code></pre>

<blockquote>
<p>cron 用于设置周期性被执行的指令，是运行在后台的守护进程。</p>
</blockquote>

<p>Logrotate 的主配置文件是 /etc/logrotate.conf ：</p>

<pre><code># see &quot;man logrotate&quot; for details
# rotate log files weekly
weekly

# keep 4 weeks worth of backlogs
rotate 4

# create new (empty) log files after rotating old ones
create

# use date as a suffix of the rotated file
dateext

# uncomment this if you want your log files compressed
#compress

# RPM packages drop log rotation information into this directory
include /etc/logrotate.d

# no packages own wtmp and btmp -- we'll rotate them here
/var/log/wtmp {
    monthly
    create 0664 root utmp
        minsize 1M
    rotate 1
}

/var/log/btmp {
    missingok
    monthly
    create 0600 root utmp
    rotate 1
}

# system-specific logs may be also be configured here.
</code></pre>

<p>其中，以 # 开头的都是注释。<code>include /etc/logrotate.d</code> 之前的是默认配置，全局有效。之后以花括号包围的是针对单个文件的配置，这里的配置项会覆盖默认配置。配置项的含义：</p>

<ul>
<li>weekly 表示每周对日志文件进行一次轮替，类似的可选项还有 monthly （每月一次，通常是每月的第一天），daily（每天一次） 。</li>
<li>rotate 4 表示保留最近四次的归档，之前的全部清除。</li>
<li>create 表示轮替后立即创建新的空的日志文件，它可以带三个参数：mode owner group ，分别表示新文件的权限、所有者和用户组，例如 create 0600 root utmp。</li>
<li>dateext 表示为归档后的文件名添加日期信息，日期的格式由 dateformat 选项设置。</li>
<li>compress 表示压缩归档文件，注释掉这个配置项就表示不压缩。</li>
</ul>

<p>另外，在 /etc/logrotate.d/ 目录下的配置文件会被读入到 /etc/logrotate.d ，我们自行添加的配置文件都可以放在这里。</p>
]]></content>
        </item>
        
        <item>
            <title>Openemu on Mac</title>
            <link>https://shaocheng.li/posts/2016/01/10/</link>
            <pubDate>Sun, 10 Jan 2016 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2016/01/10/</guid>
            <description>Openemu 是一款多功能游戏机模拟器软件，可以在 Mac 上模拟多种游戏机，从早期的 GBA 到索尼的 PSP ，有了它，我就可以在 Mac 上玩超级马里奥顶蘑菇了。
你可以在官网 Openemu.org 下载，解压后即可运行。模拟器没有自带游戏，可以在 Homebrew 中浏览下载，但是可选择的并不多。另一个网站 emuparadise.me 提供了大量的游戏 ROM ，我在这里可以搜索马里奥：
然后下载、解压，将游戏 ROM 拖拽到模拟器界面即可完成安装。</description>
            <content type="html"><![CDATA[<p>Openemu 是一款多功能游戏机模拟器软件，可以在 Mac 上模拟多种游戏机，从早期的 GBA 到索尼的 PSP ，有了它，我就可以在 Mac 上玩超级马里奥顶蘑菇了。</p>

<p><img src="/images/2016-01-10/2016-01-10_1.png" alt="" /></p>

<p>你可以在官网 <a href="http://openemu.org" target="_blank">Openemu.org</a> 下载，解压后即可运行。模拟器没有自带游戏，可以在 Homebrew 中浏览下载，但是可选择的并不多。另一个网站 <a href="http://www.emuparadise.me/" target="_blank">emuparadise.me</a> 提供了大量的游戏 ROM ，我在这里可以搜索马里奥：</p>

<p><img src="/images/2016-01-10/2016-01-10_2.png" alt="" /></p>

<p>然后下载、解压，将游戏 ROM 拖拽到模拟器界面即可完成安装。</p>

<p><img src="/images/2016-01-10/2016-01-10_3.png" alt="" /></p>
]]></content>
        </item>
        
        <item>
            <title>lsof 命令入门</title>
            <link>https://shaocheng.li/posts/2016/01/08/</link>
            <pubDate>Fri, 08 Jan 2016 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2016/01/08/</guid>
            <description>以前只是用 lsof 命令查看某个文件被那些进程打开了，直到看了这篇文章：An lsof Primer ，展示了 lsof 强大的一面。网上有很多翻译，找不到原始版本了，我修改了一些地方。
 lsof 是系统管理/安全的高级工具（über-tool）。大多数时候，我用它来获取系统中与网络连接相关的信息，但那只是这个强大有小众的命令的第一步。将这个工具称之为 lsof 真是名副其实，因为它是指“列出打开的文件（lists openfiles）”。切记，在 Unix 中一切（包括网络套接字）都是文件。
有趣的是，lsof 也是有着最多开关的 Linux/Unix 命令之一。它有那么多的开关，许多选项支持使用 - 和 + 前缀。
usage: [-?abhlnNoOPRstUvV] [+|-c c] [+|-d s] [+D D] [+|-f[cgG]] [-F [f]] [-g [s]] [-i [i]] [+|-L [l]] [+|-M] [-o [o]] [-p s] [+|-r [t]] [-S [t]] [-T [t]] [-u s] [+|-w] [-x [fl]] [--] [names]  如你所见，lsof 有着实在是令人惊讶的选项数量。你可以使用它来获得系统上的设备信息，了解指定的用户在指定的地点正在碰什么东西，甚至是一个进程正在使用什么文件或网络连接。
对于我，lsof 替代了 netstat 和 ps 的全部工作。它带来那些工具的所有功能，而且要比那些工具还多得多。那么，让我们来看看它的一些基本能力吧。</description>
            <content type="html"><![CDATA[

<blockquote>
<p>以前只是用 lsof 命令查看某个文件被那些进程打开了，直到看了这篇文章：<a href="https://danielmiessler.com/study/lsof/" target="_blank">An lsof Primer</a> ，展示了 lsof 强大的一面。网上有很多翻译，找不到原始版本了，我修改了一些地方。</p>
</blockquote>

<p>lsof 是系统管理/安全的高级工具（über-tool）。大多数时候，我用它来获取系统中与网络连接相关的信息，但那只是这个强大有小众的命令的第一步。将这个工具称之为 lsof 真是名副其实，因为它是指“列出打开的文件（lists openfiles）”。切记，在 Unix 中一切（包括网络套接字）都是文件。</p>

<p>有趣的是，lsof 也是有着最多开关的 Linux/Unix 命令之一。它有那么多的开关，许多选项支持使用 - 和 + 前缀。</p>

<pre><code>usage: [-?abhlnNoOPRstUvV] [+|-c c] [+|-d s] [+D D] [+|-f[cgG]]
 [-F [f]] [-g [s]] [-i [i]] [+|-L [l]] [+|-M] [-o [o]]
 [-p s] [+|-r [t]] [-S [t]] [-T [t]] [-u s] [+|-w] [-x [fl]] [--] [names]
</code></pre>

<p>如你所见，lsof 有着实在是令人惊讶的选项数量。你可以使用它来获得系统上的设备信息，了解指定的用户在指定的地点正在碰什么东西，甚至是一个进程正在使用什么文件或网络连接。</p>

<p>对于我，lsof 替代了 netstat 和 ps 的全部工作。它带来那些工具的所有功能，而且要比那些工具还多得多。那么，让我们来看看它的一些基本能力吧。</p>

<h2 id="1-关键选项">1. 关键选项</h2>

<p>理解一些关于 lsof 工作方式的关键点是很重要的。最重要的是，当你给它传递选项时，默认行为是对结果进行“或”运算。因此，如果你正是用 -i 来拉出一个端口列表，同时又用 -p 来拉出一个进程列表，那么默认情况下你会获得两者的结果。</p>

<p>下面这些需要牢记：</p>

<ul>
<li>默认 : 没有选项时，lsof 列出活跃进程的所有打开文件</li>
<li>组合 : 可以将选项组合到一起，如-abc，但要注意哪些选项需要参数</li>
<li>-a : 结果进行“与”运算（而不是“或”）</li>
<li>-l : 在输出显示用户 ID 而不是用户名</li>
<li>-h : 获得帮助信息</li>
<li>-t : 仅获取进程 ID</li>
<li>-U : 获取 UNIX 套接字地址</li>
<li>-F : 格式化输出结果，用于其它命令。可以通过多种方式格式化，如 <code>-F pcfn</code>（用于进程 id、命令名、文件描述符、文件名，并以空终止）</li>
</ul>

<h2 id="2-获取网络信息">2. 获取网络信息</h2>

<p>正如我所说的，我主要用 lsof 获取关于系统和网络交互的信息。这里提供了关于此信息的一些主题。</p>

<h3 id="2-1-使用-i-显示所有连接">2.1. 使用 <code>-i</code> 显示所有连接</h3>

<p>有些人喜欢用 netstat 来获取网络连接，但是我更喜欢使用 lsof 来进行此项工作。获取的信息以很直观的方式呈现，我仅仅只需改变我的语法，就可以通过同样的命令来获取更多信息。</p>

<pre><code># lsof -i 
COMMAND  PID USER   FD   TYPE DEVICE SIZE NODE NAME
dhcpcd 6061 root 4u IPv4 4510 UDP *:bootpc
sshd 7703 root 3u IPv6  6499 TCP *:ssh (LISTEN)
sshd 7892 root 3u IPv6  6757 TCP 10.10.1.5:ssh-&gt;192.168.1.5:49901 (ESTABLISHED)
</code></pre>

<h3 id="2-2-使用-i-6-仅获取-ipv6-流量">2.2. 使用 <code>-i 6</code> 仅获取 IPv6 流量</h3>

<pre><code># lsof -i 6
</code></pre>

<h3 id="2-3-仅显示-tcp-连接-同理可获得-udp-连接">2.3. 仅显示 TCP 连接（同理可获得 UDP 连接）</h3>

<p>可以通过在 -i 后提供对应的协议来仅仅显示 TCP 或者 UDP 连接信息。</p>

<pre><code># lsof -iTCP
COMMAND  PID USER   FD   TYPE DEVICE SIZE NODE NAME
sshd 7703 root 3u IPv6 6499 TCP *:ssh (LISTEN)
sshd 7892 root 3u IPv6 6757 TCP 10.10.1.5:ssh-&gt;192.168.1.5:49901 (ESTABLISHED)
</code></pre>

<h3 id="2-4-使用-i-port-来显示与指定端口相关的网络信息">2.4. 使用 <code>-i:port</code> 来显示与指定端口相关的网络信息</h3>

<p>你也可以通过端口搜索，这对于要找出什么阻止了另外一个应用绑定到指定端口实在是太棒了。</p>

<pre><code># lsof -i :22
COMMAND  PID USER   FD   TYPE DEVICE SIZE NODE NAME
sshd 7703 root 3u  IPv6 6499 TCP *:ssh (LISTEN)
sshd 7892 root 3u  IPv6 6757 TCP 10.10.1.5:ssh-&gt;192.168.1.5:49901 (ESTABLISHED)
</code></pre>

<h3 id="2-5-使用-host-来显示指定到指定主机的连接">2.5. 使用 <code>@host</code> 来显示指定到指定主机的连接</h3>

<p>这对于你在检查是否开放连接到网络中或互联网上某个指定主机的连接时十分有用。</p>

<pre><code># lsof -i@172.16.12.5
sshd 7892 root 3u IPv6 6757 TCP 10.10.1.5:ssh-&gt;172.16.12.5:49901 (ESTABLISHED)
</code></pre>

<h3 id="2-6-使用-host-port-显示基于主机与端口的连接">2.6. 使用 <code>@host:port</code> 显示基于主机与端口的连接</h3>

<p>你也可以组合主机与端口的显示信息。</p>

<pre><code># lsof -i@172.16.12.5:22
sshd 7892 root 3u IPv6 6757 TCP 10.10.1.5:ssh-&gt;172.16.12.5:49901 (ESTABLISHED)
</code></pre>

<h3 id="2-7-找出监听端口">2.7. 找出监听端口</h3>

<p>找出正等候连接的端口。</p>

<pre><code># lsof -i -sTCP:LISTEN
</code></pre>

<p>也可以用 grep 筛选出信。</p>

<pre><code># lsof -i | grep -i LISTEN
iTunes     400 daniel   16u  IPv4 0x4575228  0t0 TCP *:daap (LISTEN)
</code></pre>

<h3 id="2-8-找出已建立的连接">2.8. 找出已建立的连接</h3>

<p>你也可以显示任何已经连接的连接。</p>

<pre><code># lsof -i -sTCP:ESTABLISHED
</code></pre>

<p>也可以通过 grep 筛选。</p>

<pre><code># lsof -i | grep -i ESTABLISHED
firefox-b 169 daniel  49u IPv4 0t0 TCP 1.2.3.3:1863-&gt;1.2.3.4:http (ESTABLISHED)
</code></pre>

<h2 id="3-用户信息">3. 用户信息</h2>

<p>你也可以获取各种用户的信息，以及它们在系统上正干着的事，包括它们的网络活动、对文件的操作等。</p>

<h3 id="3-1-使用-u-显示指定用户打开了什么">3.1. 使用 -u 显示指定用户打开了什么</h3>

<pre><code># lsof -u daniel
-- snipped --
Dock 155 daniel  txt REG   14,2   2798436   823208 /usr/lib/libicucore.A.dylib
Dock 155 daniel  txt REG   14,2   1580212   823126 /usr/lib/libobjc.A.dylib
Dock 155 daniel  txt REG   14,2   2934184   823498 /usr/lib/libstdc++.6.0.4.dylib
Dock 155 daniel  txt REG   14,2    132008   823505 /usr/lib/libgcc_s.1.dylib
Dock 155 daniel  txt REG   14,2    212160   823214 /usr/lib/libauto.dylib
-- snipped --
</code></pre>

<h3 id="3-2-使用-u-user-来显示除指定用户以外的其它所有用户所做的事情">3.2. 使用 <code>-u user</code> 来显示除指定用户以外的其它所有用户所做的事情</h3>

<pre><code># lsof -u ^daniel
-- snipped --
Dock 155 jim  txt REG   14,2   2798436   823208 /usr/lib/libicucore.A.dylib
Dock 155 jim  txt REG   14,2   1580212   823126 /usr/lib/libobjc.A.dylib
Dock 155 jim  txt REG   14,2   2934184   823498 /usr/lib/libstdc++.6.0.4.dylib
Dock 155 jim  txt REG   14,2    132008   823505 /usr/lib/libgcc_s.1.dylib
Dock 155 jim  txt REG   14,2    212160   823214 /usr/lib/libauto.dylib
-- snipped --
</code></pre>

<h3 id="3-3-杀死指定用户所做的一切事情">3.3. 杀死指定用户所做的一切事情</h3>

<p>可以消灭指定用户运行的所有东西，这真不错。</p>

<pre><code># kill -9 `lsof -t -u daniel`
</code></pre>

<h2 id="4-命令和进程">4. 命令和进程</h2>

<p>可以查看指定程序或进程由什么启动，这通常会很有用，而你可以使用lsof通过名称或进程ID过滤来完成这个任务。下面列出了一些选项：</p>

<h3 id="4-1-使用-c-查看指定的命令正在使用的文件和网络连接">4.1. 使用 <code>-c</code> 查看指定的命令正在使用的文件和网络连接</h3>

<pre><code># lsof -c syslog-ng
COMMAND    PID USER   FD   TYPE     DEVICE    SIZE       NODE NAME
syslog-ng 7547 root  cwd    DIR    3,3    4096   2 /
syslog-ng 7547 root  rtd    DIR    3,3    4096   2 /
syslog-ng 7547 root  txt    REG    3,3  113524  1064970 /usr/sbin/syslog-ng
-- snipped --
</code></pre>

<h3 id="4-2-使用-p-查看指定进程id已打开的内容">4.2. 使用 <code>-p</code> 查看指定进程ID已打开的内容</h3>

<pre><code># lsof -p 10075
-- snipped --
sshd    10068 root  mem    REG    3,3   34808 850407 /lib/libnss_files-2.4.so
sshd    10068 root  mem    REG    3,3   34924 850409 /lib/libnss_nis-2.4.so
sshd    10068 root  mem    REG    3,3   26596 850405 /lib/libnss_compat-2.4.so
sshd    10068 root  mem    REG    3,3  200152 509940 /usr/lib/libssl.so.0.9.7
sshd    10068 root  mem    REG    3,3   46216 510014 /usr/lib/liblber-2.3
sshd    10068 root  mem    REG    3,3   59868 850413 /lib/libresolv-2.4.so
sshd    10068 root  mem    REG    3,3 1197180 850396 /lib/libc-2.4.so
sshd    10068 root  mem    REG    3,3   22168 850398 /lib/libcrypt-2.4.so
sshd    10068 root  mem    REG    3,3   72784 850404 /lib/libnsl-2.4.so
sshd    10068 root  mem    REG    3,3   70632 850417 /lib/libz.so.1.2.3
sshd    10068 root  mem    REG    3,3    9992 850416 /lib/libutil-2.4.so
-- snipped --
</code></pre>

<h3 id="4-3-使-t-选项只返回-pid">4.3. 使 <code>-t</code> 选项只返回 PID</h3>

<pre><code># lsof -t -c Mail
350
</code></pre>

<h2 id="5-文件和目录">5. 文件和目录</h2>

<p>通过查看指定文件或目录，你可以看到系统上所有正与其交互的资源——包括用户、进程等。</p>

<p>显示与指定目录交互的所有一切</p>

<pre><code># lsof /var/log/messages/
COMMAND    PID USER   FD   TYPE DEVICE   SIZE   NODE NAME
syslog-ng 7547 root    4w   REG    3,3 217309 834024 /var/log/messages
</code></pre>

<p>显示与指定文件交互的所有一切</p>

<pre><code># lsof /home/daniel/firewall_whitelist.txt
</code></pre>

<h2 id="6-高级用法">6. 高级用法</h2>

<p>与 tcpdump 类似，当你开始组合查询时，它就显示了它强大的功能。</p>

<h3 id="6-1-显示-daniel-连接到-1-1-1-1-所做的一切">6.1. 显示 daniel 连接到 1.1.1.1 所做的一切</h3>

<pre><code># lsof -u daniel -i @1.1.1.1
bkdr   1893 daniel 3u  IPv6 3456 TCP 10.10.1.10:1234-&gt;1.1.1.1:31337 (ESTABLISHED)
</code></pre>

<h3 id="6-2-同时使用-t-和-c-选项以给进程发送-hup-信号">6.2. 同时使用 <code>-t</code> 和 <code>-c</code> 选项以给进程发送 HUP 信号</h3>

<pre><code># kill -HUP `lsof -t -c sshd`
</code></pre>

<h3 id="6-3-显示某个端口范围内打开的连接">6.3. 显示某个端口范围内打开的连接</h3>

<pre><code># lsof -i @fw.google.com:2150=2180
</code></pre>

<h2 id="7-结尾">7. 结尾</h2>

<p>本入门教程只是管窥了 lsof 功能的一斑，要查看完整参考，运行 man lsof 命令或查看在线版本。希望本文对你有所助益，也随时欢迎你的评论和指正。</p>

<p>lsof手册页：<a href="http://www.netadmintools.com/html/lsof.man.html" target="_blank">http://www.netadmintools.com/html/lsof.man.html</a></p>
]]></content>
        </item>
        
        <item>
            <title>hostapd HOWTO</title>
            <link>https://shaocheng.li/posts/2016/01/01/</link>
            <pubDate>Fri, 01 Jan 2016 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2016/01/01/</guid>
            <description>1. About hostapd 是一个运行在 Linux 用户空间的 daemon 程序，它可以将 IEEE 802.11 无线网卡切换为 AP 模式，也就是实现软 AP 功能，并提供 IEEE 802.1X/WPA/WPA2/EAP/RADIUS 的认证服务。它使用 nl80211 接口与内核进行通信，支持基于 mac80211 框架的无线驱动。下面是 Linux 的无线网络架构：
 IEEE 802.11 是现在的无线局域网通用的标准，我们通常把它与 Wi-Fi 混为一谈。 mac80211 是 Linux 内核的 802.11 无线设备驱动框架，intel 的无线网卡驱动 iwlwifi 就是基于这个框架。 cfg80211 是 Linux 内核中配置和管理 802.11 无线设备的接口，与 FullMAC 驱动, mac80211 驱动一起工作。 nl80211 和 wext 是两种面向用户空间的接口标准，用于在用户空间配置和管理 802.11 无线设备，内核的 cfg80211 一起工作，目前两种标准同时存在于内核中，nl80211 正在逐步替代 wext ，hostapd 只支持 nl80211 。  iw 就是一个使用 nl80211 接口的命令，用它可以查看和配置无线网卡，支持 nl80211 标准，不支持老的 wext 标准。用 iw list 可以获取当前无线网卡的全部特性，在 Supported interface modes 和 software interface modes 中看到无线网卡是否支持 AP 模式，已经 AP 类型：</description>
            <content type="html"><![CDATA[

<h2 id="1-about">1. About</h2>

<p>hostapd 是一个运行在 Linux 用户空间的 daemon 程序，它可以将 IEEE 802.11 无线网卡切换为 AP 模式，也就是实现软 AP 功能，并提供 IEEE 802.1X/WPA/WPA2/EAP/RADIUS 的认证服务。它使用 nl80211 接口与内核进行通信，支持基于 mac80211 框架的无线驱动。下面是 Linux 的无线网络架构：</p>

<p><img src="/images/2016-01-01/2016-01-01_1.jpg" alt="" /></p>

<ul>
<li>IEEE 802.11 是现在的无线局域网通用的标准，我们通常把它与 Wi-Fi 混为一谈。</li>
<li>mac80211 是 Linux 内核的 802.11 无线设备驱动框架，intel 的无线网卡驱动 iwlwifi 就是基于这个框架。</li>
<li>cfg80211 是 Linux 内核中配置和管理 802.11 无线设备的接口，与 FullMAC 驱动, mac80211 驱动一起工作。</li>
<li>nl80211 和 wext 是两种面向用户空间的接口标准，用于在用户空间配置和管理 802.11 无线设备，内核的 cfg80211 一起工作，目前两种标准同时存在于内核中，nl80211 正在逐步替代 wext ，hostapd 只支持 nl80211 。</li>
</ul>

<p>iw 就是一个使用 nl80211 接口的命令，用它可以查看和配置无线网卡，支持 nl80211 标准，不支持老的 wext 标准。用 <code>iw list</code> 可以获取当前无线网卡的全部特性，在 Supported interface modes 和 software interface modes 中看到无线网卡是否支持 AP 模式，已经 AP 类型：</p>

<pre><code>root@WR-IntelligentDevice:~# iw list
Wiphy phy0
    ......
    Supported interface modes:
             * IBSS
             * managed
             * AP
             * AP/VLAN
             * monitor
             * P2P-client
             * P2P-GO
    software interface modes (can always be added):
             * AP/VLAN
             * monitor
     ......
</code></pre>

<p>用 ethtool 工具可以确定网卡使用的驱动：</p>

<pre><code>root@WR-IntelligentDevice:~# ethtool -i wlan0
driver: iwlwifi
version: 3.4.91-WR5.0.1.24_standard_IDP-
firmware-version: 18.168.6.1
bus-info: 0000:01:00.0
supports-statistics: yes
supports-test: no
supports-eeprom-access: no
supports-register-dump: no
supports-priv-flags: no    
</code></pre>

<p>查看连接在 AP 上的终端：</p>

<pre><code>root@WR-IntelligentDevice:~# iw dev wlan0 station dump 
Station bc:6c:21:6e:04:c3 (on wlan0)
        inactive time:  20 ms
        rx bytes:       159304
        rx packets:     2076
        tx bytes:       4368817
        tx packets:     3068
        tx retries:     293
        tx failed:      2
        signal:         -41 dBm
        signal avg:     -40 dBm
        tx bitrate:     54.0 MBit/s
        authorized:     yes
        authenticated:  yes
        preamble:       short
        WMM/WME:        no
        MFP:            no
        TDLS peer:              no
</code></pre>

<h2 id="2-配置">2. 配置</h2>

<p>hostapd 的配置文件是 /etc/hostapd.conf ，这个文件里有详细的配置说明，下面是一些常用选项。</p>

<h3 id="2-1-无线接口">2.1. 无线接口</h3>

<ul>
<li>interface：无线网卡的设备节点名称，就是 iwconfig 看到的名称，例如 wlan0 。</li>
<li>bridge：指定所处网桥，对于一个同时接入公网、提供内部网和无线接入的路由器来说，设定网桥很有必要 。</li>
<li>driver：设定无线驱动，我这里是 nl80211 。</li>
</ul>

<h3 id="2-2-无线环境">2.2. 无线环境</h3>

<ul>
<li>ssid：这个无线接入点对外显示的名称 。</li>
<li>hw_mode：指定802.11协议，a = IEEE 802.11a, b = IEEE 802.11b, g = IEEE 802.11g 。这个选项是根据硬件特性设置的，g 是最常用的设置，它向下兼容 b 。</li>
<li>channel：设定信道，必须是 hw_mode 指定协议能够支持的信道。信道的选择应该避免与同区域内的其他 AP 的信道产生重叠，这与 802.11 标准的信道划分有关，在 802.11b/g 中，83.5MHz 的带宽划分了 14 个信道，相邻的多个信道存在频率重叠，整个频段内只有 1、6、11 ，三个信道互不干扰。</li>
</ul>

<p><img src="/images/2016-01-01/2016-01-01_2.jpg" alt="" /></p>

<h3 id="2-3-认证与加密">2.3. 认证与加密</h3>

<ul>
<li>ignore_broadcast_ssid: 使能/禁止广播 SSID 。</li>
<li>macaddr_acl：可选，指定 MAC 地址过滤规则，0 表示除禁止列表外都允许，1 表示除允许列表外都禁止，2 表示使用外部 RADIUS 服务器。</li>
<li>accept_mac_file：指定 MAC 允许列表文件路径。</li>
<li>deny_mac_file：指定 MAC 禁止列表文件路径。</li>
<li>auth_algs: 指定认证算法，低两位有效，0 表示禁止，1 表示使能。bit0 表示开放系统认证（OSA），bit1 表示共享密钥认证（SKA），如果设为 3 ，表示两种认证方式都支持。</li>
<li>wpa: 指定加密算法，低两位有效，0 表示禁止，1 表示使能。bit0 表示 wpa，bit1 表示 wpa2 ，如果设为 3 ，表示 WPA/WPA2 加密方式。</li>
<li>wpa_passphrase: 共享秘钥，就是我们连接 Wi-Fi 时输入的密码。</li>

<li><p>wpa_psk：对共享秘钥加密后的 64 位十六进制数。可以通过 wpa_passphrase 命令获得：</p>

<pre><code>root@WR-IntelligentDevice:~# wpa_passphrase             
usage: wpa_passphrase &lt;ssid&gt; [passphrase]

If passphrase is left out, it will be read from stdin
root@WR-IntelligentDevice:~# wpa_passphrase  TP-Link  password
network={
    ssid=&quot;TP-Link&quot;
    #psk=&quot;password&quot;
    psk=895b209c4c7ff1ea45d079eb5b04155cc1793669c6dc08470157c23fa6532694
}
</code></pre></li>

<li><p>wpa_key_mgmt: 指定秘钥管理算法，可选 WPA-PSK 和 WPA-EAP 。</p></li>

<li><p>wpa_pairwise: WPA 的加密选项，可选 TKIP 和 CCMP 。</p></li>

<li><p>rsn_pairwise: WPA2 和 RSN 的加密选项，可选 TKIP 和 CCMP 。</p></li>
</ul>

<p>关于认证算法：</p>

<ul>
<li><p>开放系统认证（Open system authentication）</p>

<p>开放系统认证是缺省使用的认证机制，也是最简单的认证算法，即不认证。如果认证类型设置为开放系统认证，则所有请求认证的客户端都会通过认证。开放系统认证包括两个步骤：第一步是无线客户端发起认证请求，第二步AP确定无线客户端是否通过无线链路认证并回应认证结果。如果认证结果为“成功”，那么客户端成功通过了AP的链路认证。</p>

<p><img src="~/10-32-32.jpg" alt="" /></p></li>

<li><p>共享密钥认证（shared key authentication）</p>

<p>共享密钥认证是除开放系统认证以外的另外一种链路认证机制。共享密钥认证需要客户端和设备端配置相同的共享密钥。共享密钥认证的认证过程为：客户端先向AP发送认证请求，AP端会随机产生一个Challenge（即一个字符串）发送给客户端；客户端会将接收到Challenge加密后再发送给AP；AP接收到该消息后，对该消息解密，然后对解密后的字符串和原始字符串进行比较。如果相同，则说明客户端通过了Shared Key链路认证；否则Shared Key链路认证失败。</p>

<p><img src="~/10-33-09.jpg" alt="" /></p></li>
</ul>

<h2 id="3-运行">3. 运行</h2>

<pre><code>root@WR-IntelligentDevice:/etc# hostapd -h
hostapd v2.3
User space daemon for IEEE 802.11 AP management,
IEEE 802.1X/WPA/WPA2/EAP/RADIUS Authenticator
Copyright (c) 2002-2014, Jouni Malinen &lt;j@w1.fi&gt; and contributors

usage: hostapd [-hdBKtv] [-P &lt;PID file&gt;] [-e &lt;entropy file&gt;] \
         [-g &lt;global ctrl_iface&gt;] [-G &lt;group&gt;] \
         &lt;configuration file(s)&gt;

options:
   -h   show this usage
   -d   show more debug messages (-dd for even more)
   -B   run daemon in the background
   -e   entropy file
   -g   global control interface path
   -G   group for control interfaces
   -P   PID file
   -K   include key data in debug messages
   -t   include timestamps in some debug messages
   -v   show hostapd version
</code></pre>

<p>分享一个在 Ubuntu 12.04 下设置无线 AP 的脚本 <a href="https://gist.github.com/dashohoxha/5767262" target="_blank">install_wifi_access_point.sh</a> ，内容如下：</p>

<pre><code>#!/bin/bash
### Setup a wifi Access Point on Ubuntu 12.04 (or its derivatives).

### make sure that this script is executed from root
if [ $(whoami) != 'root' ]
then
    echo &quot;
This script should be executed as root or with sudo:
    sudo $0
&quot;
    exit 1
fi

##############################################################
## Check whether the wireless card supports Access Point mode
##############################################################

### make sure that iw is installed
apt-get -y install iw

### check that AP is supported
supports_access_point=$(iw list | sed -n -e '/* AP$/p')
if [ &quot;$supports_access_point&quot; = '' ]
then
    echo &quot;AP is not supported by the driver of the wireless card.&quot;
    echo &quot;This script does not work for this driver.&quot;
    exit 1
fi

##############################################################
##  Setup and host a network
##############################################################

### install hostapd
apt-get -y install hostapd

### it should not start automatically on boot
update-rc.d hostapd disable

### get ssid and password
ssid=$(hostname --short)
read -p &quot;The name of your hosted network (SSID) [$ssid]: &quot; input
ssid=${input:-$ssid}
password='1234567890'
read -p &quot;The password of your hosted network [$password]: &quot; input
password=${input:-$password}

### get wifi interface
rfkill unblock wifi   # enable wifi in case it is somehow disabled (thanks to Darrin Wolf for this tip)
wifi_interface=$(lshw -quiet -c network | sed -n -e '/Wireless interface/,+12 p' | sed -n -e '/logical name:/p' | cut -d: -f2 | sed -e 's/ //g')

### create /etc/hostapd/hostapd.conf
cat &lt;&lt;EOF &gt; /etc/hostapd/hostapd.conf
interface=$wifi_interface
driver=nl80211
ssid=$ssid
hw_mode=g
channel=1
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
wpa=3
wpa_passphrase=$password
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP
EOF

### modify /etc/default/hostapd
cp -n /etc/default/hostapd{,.bak}
sed -i /etc/default/hostapd \
    -e '/DAEMON_CONF=/c DAEMON_CONF=&quot;/etc/hostapd/hostapd.conf&quot;'

################################################
## Set up DHCP server for IP address management
################################################

### make sure that the DHCP server is installed
apt-get -y install isc-dhcp-server

### it should not start automatically on boot
update-rc.d isc-dhcp-server disable

### set the INTERFACES on /etc/default/isc-dhcp-server
cp -n /etc/default/isc-dhcp-server{,.bak}
sed -i /etc/default/isc-dhcp-server \
    -e &quot;/INTERFACES=/c INTERFACES=\&quot;$wifi_interface\&quot;&quot;

### modify /etc/dhcp/dhcpd.conf
cp -n /etc/dhcp/dhcpd.conf{,.bak}
sed -i /etc/dhcp/dhcpd.conf \
    -e 's/^option domain-name/#option domain-name/' \
    -e 's/^option domain-name-servers/#option domain-name-servers/' \
    -e 's/^default-lease-time/#default-lease-time/' \
    -e 's/^max-lease-time/#max-lease-time/'

sed -i /etc/dhcp/dhcpd.conf \
    -e '/subnet 10.10.0.0 netmask 255.255.255.0/,+4 d'
cat &lt;&lt;EOF &gt;&gt; /etc/dhcp/dhcpd.conf
subnet 10.10.0.0 netmask 255.255.255.0 {
        range 10.10.0.2 10.10.0.16;
        option domain-name-servers 8.8.4.4, 208.67.222.222;
        option routers 10.10.0.1;
}
EOF

#################################################
## Create a startup script
#################################################

cat &lt;&lt;EOF &gt; /etc/init.d/wifi_access_point
#!/bin/bash

ext_interface=\$(ip route | grep default | cut -d' ' -f5)

function stop_wifi_ap {
    ### stop services dhcpd and hostapd
    service isc-dhcp-server stop
    service hostapd stop

    ### disable IP forwarding
    echo 0 &gt; /proc/sys/net/ipv4/ip_forward
    iptables -t nat -D POSTROUTING -s 10.10.0.0/16 -o \$ext_interface -j MASQUERADE 2&gt;/dev/null

    ### remove the static IP from the wifi interface
    if grep -q 'auto $wifi_interface' /etc/network/interfaces
    then
        sed -i /etc/network/interfaces -e '/auto $wifi_interface/,\$ d'
        sed -i /etc/network/interfaces -e '\$ d'
    fi

    ### restart network manager to takeover wifi management
    service network-manager restart
}

function start_wifi_ap {
    stop_wifi_ap
    sleep 3

    ### see: https://bugs.launchpad.net/ubuntu/+source/wpa/+bug/1289047/comments/8
    nmcli nm wifi off
    rfkill unblock wlan

    ### give a static IP to the wifi interface
    ip link set dev $wifi_interface up
    ip address add 10.10.0.1/24 dev $wifi_interface

    ### protect the static IP from network-manger restart
    echo &gt;&gt; /etc/network/interfaces
    echo 'auto $wifi_interface' &gt;&gt; /etc/network/interfaces
    echo 'iface $wifi_interface' inet static &gt;&gt; /etc/network/interfaces
    echo 'address 10.10.0.1' &gt;&gt; /etc/network/interfaces
    echo 'netmask 255.255.255.0' &gt;&gt; /etc/network/interfaces

    ### enable IP forwarding
    echo 1 &gt; /proc/sys/net/ipv4/ip_forward
    iptables -t nat -A POSTROUTING -s 10.10.0.0/16 -o \$ext_interface -j MASQUERADE

    ### start services dhcpd and hostapd
    service hostapd start
    service isc-dhcp-server start
}

### start/stop wifi access point
case &quot;\$1&quot; in
    start) start_wifi_ap ;;
    stop)  stop_wifi_ap  ;;
esac
EOF

chmod +x /etc/init.d/wifi_access_point

### make sure that it is stopped on boot
sed -i /etc/rc.local \
    -e '/service wifi_access_point stop/ d'
sed -i /etc/rc.local \
    -e '/^exit/ i service wifi_access_point stop'


### display usage message
echo &quot;
======================================

Wifi Access Point installed.

You can start and stop it with:
    service wifi_access_point start
    service wifi_access_point stop

&quot;
</code></pre>

<h2 id="4-参考">4. 参考</h2>

<ul>
<li><a href="https://wireless.wiki.kernel.org/en/users/Documentation/hostapd" target="_blank">https://wireless.wiki.kernel.org/en/users/Documentation/hostapd</a></li>
<li><a href="http://blog.csdn.net/myarrow/article/details/7930131" target="_blank">http://blog.csdn.net/myarrow/article/details/7930131</a></li>
<li><a href="http://www.cnblogs.com/zhuwenger/archive/2011/03/11/1980294.html" target="_blank">http://www.cnblogs.com/zhuwenger/archive/2011/03/11/1980294.html</a></li>
<li><a href="https://github.com/hotice/AP-Hotspot" target="_blank">https://github.com/hotice/AP-Hotspot</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Git 笔记</title>
            <link>https://shaocheng.li/posts/2015/12/29/</link>
            <pubDate>Tue, 29 Dec 2015 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2015/12/29/</guid>
            <description>1. 配置 git 的全局配置文件是用户目录下的 .gitconfig 文件。设置用户信息：
git config [--global] user.name &amp;quot;[name]&amp;quot; git config [--global] user.email &amp;quot;[email address]&amp;quot;  2. 创建新仓库  在当前目录下创建新仓库 git init 克隆远程服务器上的仓库 git clone [url]  创建新仓库时会生成 .git 文件夹，包含了该仓库的所有配置文件。
3. 工作流 源码目录称为工作区 workspace ,本地仓库叫做 Repository ，远程仓库叫做 Remote ，在本地仓库和工作区之间存在一个暂存区 Index 。通常的工作流程是修改源码、放入暂存区、提交到仓库、推送到远程服务器：
4. 添加 add  添加当前目录的所有文件到暂存区 git add . 添加指定文件到暂存区 git add [file1] [file2] ... 添加指定目录到暂存区，包括子目录 git add [dir]  5. 删除 delete  删除工作区文件，并且将这次删除放入暂存区 git rm [file1] [file2] .</description>
            <content type="html"><![CDATA[

<h2 id="1-配置">1. 配置</h2>

<p>git 的全局配置文件是用户目录下的 .gitconfig 文件。设置用户信息：</p>

<pre><code>git config [--global] user.name &quot;[name]&quot;
git config [--global] user.email &quot;[email address]&quot;
</code></pre>

<h2 id="2-创建新仓库">2. 创建新仓库</h2>

<ul>
<li>在当前目录下创建新仓库 <code>git init</code></li>
<li>克隆远程服务器上的仓库 <code>git clone [url]</code></li>
</ul>

<p>创建新仓库时会生成 .git 文件夹，包含了该仓库的所有配置文件。</p>

<h2 id="3-工作流">3. 工作流</h2>

<p>源码目录称为工作区 workspace ,本地仓库叫做 Repository ，远程仓库叫做 Remote ，在本地仓库和工作区之间存在一个暂存区 Index 。通常的工作流程是修改源码、放入暂存区、提交到仓库、推送到远程服务器：</p>

<p><img src="/images/2015-12-29/2015-12-29_1.jpg" alt="" /></p>

<h2 id="4-添加-add">4. 添加 add</h2>

<ul>
<li>添加当前目录的所有文件到暂存区 <code>git add .</code></li>
<li>添加指定文件到暂存区 <code>git add [file1] [file2] ...</code></li>
<li>添加指定目录到暂存区，包括子目录 <code>git add [dir]</code></li>
</ul>

<h2 id="5-删除-delete">5. 删除 delete</h2>

<ul>
<li>删除工作区文件，并且将这次删除放入暂存区 <code>git rm [file1] [file2] ...</code></li>
<li>停止追踪指定文件，但该文件会保留在工作区 <code>git rm --cached [file]</code></li>
<li>改名文件，并且将这个改名放入暂存区 <code>git mv [file-original] [file-renamed]</code></li>
</ul>

<h2 id="6-提交-commit">6. 提交 commit</h2>

<ul>
<li>提交暂存区到仓库区 <code>git commit -m [message]</code></li>
<li>提交暂存区的指定文件到仓库区 <code>git commit [file1] [file2] ... -m [message]</code></li>
<li>提交工作区自上次commit之后的变化，直接到仓库区 <code>git commit -a</code></li>
<li>提交时显示所有diff信息 <code>git commit -v</code></li>
<li>使用一次新的commit，替代上一次提交，如果代码没有任何新变化，则用来改写上一次commit的提交信息 <code>git commit --amend -m [message]</code></li>
</ul>

<p>commit 之后，就会在 git 记录中形成一个新的版本。</p>

<h2 id="7-查看信息">7. 查看信息</h2>

<ul>
<li>显示工作区中有变更的文件 <code>git status</code></li>
<li>显示当前分支的版本历史 <code>git log</code></li>
<li>显示版本历史，以及每次 commit 发生变更的文件 <code>git log --stat</code></li>
<li>显示某次提交的元数据和内容变化 <code>git show [commit]</code></li>
<li>显示某次提交发生变化的文件 <code>git show --name-only [commit]</code></li>
<li>显示某次提交时，某个文件的内容 <code>git show [commit]:[filename]</code></li>
<li>显示工作区相对暂存区的差异 <code>git diff</code></li>
<li>显示工作区相对暂存区，那些文件文件被改动了 <code>git diff --stat</code></li>
<li>显示暂存区相对上一个commit的差异 <code>git diff --cached [file]</code></li>
<li>显示工作区相对当前分支最新commit之间的差异 <code>git diff HEAD</code></li>
<li>显示两个分支之间的差异 <code>git diff [commit] [commit]</code></li>
<li>显示两个分支之间的差异 <code>git diff [first-branch] [second-branch]</code></li>
</ul>

<h2 id="8-回退">8. 回退</h2>

<ul>
<li>恢复暂存区的指定文件到工作区 <code>git checkout [file]</code></li>
<li>恢复某个commit的指定文件到工作区 <code>git checkout [commit] [file]</code></li>
<li>恢复上一个commit的所有文件到工作区 <code>git checkout .</code></li>
<li>重置暂存区的指定文件到上一次commit保持一致，但工作区不变 <code>git reset [file]</code></li>
<li>重置当期分支的 HARD 、暂存区、工作区到指定的 commit <code>git reset --hard [commit]</code></li>
<li>重置当前分支的 HARD、暂存区到指定的 commit ，但工作区不变 <code>git reset –soft [commit]</code></li>
</ul>

<h2 id="9-远程同步">9. 远程同步</h2>

<ul>
<li>上传本地指定分支到远程仓库 <code>git push [remote] [branch]</code></li>
<li>下载远程仓库的所有变动 <code>git fetch [remote]</code></li>
</ul>

<h2 id="10-补丁">10. 补丁</h2>

<p>将 <code>git diff</code> 输出的信息保存到文件，就是一个标准补丁，要生成 git 专用补丁，需要 <code>git format-patch</code> 命令：</p>

<ul>
<li>将最后一个 commit 生成补丁 <code>git format-patch -1</code></li>
<li>将最后两个 commit 分别生成补丁 <code>git format-patch -2</code></li>
</ul>

<p>用 <code>git apply</code> 应用补丁文件，它只会修改工作区，还要手动提交：</p>

<ul>
<li>应用一个 git 补丁并检查是否成功 <code>git apply --check [patch file]</code></li>
</ul>

<h2 id="13-版本号">13.  版本号</h2>

<p>版本号以小写字母 v 开头，格式是：主版本号.次版本号-修订版本号-SHA 。</p>

<p>大的功能变更升级主版本号，小的功能变更升级次版本号，正式发布前的主版本号可以是 0 ，这样第一次发布时的版本号就是 v1.0。修订版本号不涉及功能更新，它是指上次标记主次版本号之后的修复 Bug 次数。每次重新标记主次版本号之后，修订版本号重置。SHA 是本次 commit 的 SHA 值的前几位</p>

<p>主版本号和次版本号需要用 git tag 标记，而修订次数和 SHA 可以由 git 自动记录。举例，一次本地 commit 之后，使用 git tag 为本次提交标记版本号：</p>

<pre><code>$ git log
commit d3b0c251d0546194659a7a121f6404b9e28b1229
Author: lishaocheng &lt;lishaocheng@*.com.cn&gt;
Date:   Fri Nov 18 15:42:49 2016 +0800

v1.0 release

$ git tag -a v1.0 -m &quot;v1.0 release&quot;
</code></pre>

<p>查看当前版本号：</p>

<pre><code>$ git describe
v1.0
$ git describe --long
v1.0-0-gd3b0c25
</code></pre>

<p>第一次发布，没有修订，所以修订版本号为 0 。SHA 中的 g 是 git 的缩写，后面本次 commit 的 SHA 值前几位。 推送时使用 &ndash;tags 带上所有的本地标签：</p>

<pre><code>$ git push --tags origin master
Counting objects: 9, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (7/7), done.
Writing objects: 100% (9/9), 445.64 KiB | 0 bytes/s, done.
Total 9 (delta 0), reused 0 (delta 0)
To 192.168.5.253:lishaocheng/ftp_transfer.git
   95105d6..d3b0c25  master -&gt; master
 * [new tag]         v1.0 -&gt; v1.0
</code></pre>

<p>如果发现了 Bug ，需要修改，就 clone 到本地，修改后 commit ，然后查看版本号：</p>

<pre><code>$ git describe
v1.0-1-g740c0c4
</code></pre>

<p>修订版本号变成了 1 ，SHA 变成了本次的 commit 。然后推送：</p>

<pre><code>$ git push --tags origin master
</code></pre>

<h2 id="12-参考">12. 参考</h2>

<ul>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank">Git 简明指南</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank">常用 Git 命令清单</a></li>
<li><a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank">图解 Git</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>学习 Swift&amp;iOS</title>
            <link>https://shaocheng.li/posts/2015/11/30/</link>
            <pubDate>Mon, 30 Nov 2015 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2015/11/30/</guid>
            <description> Swift  The Swift Programming Language 中文版 如果没有苹果电脑，可用 swift 在线编译器 使用 Playground 快速练习 Swift 语法  </description>
            <content type="html"><![CDATA[

<h2 id="swift">Swift</h2>

<ul>
<li><a href="http://wiki.jikexueyuan.com/project/swift/" target="_blank">The Swift Programming Language 中文版</a></li>
<li>如果没有苹果电脑，可用 <a href="http://swiftstub.com/" target="_blank">swift 在线编译器</a></li>
<li><a href="https://www.aswifter.com/2015/07/23/learn-swift-with-playground-summary/" target="_blank">使用 Playground 快速练习 Swift 语法</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Linux IPv6 HOWTO</title>
            <link>https://shaocheng.li/posts/2015/11/27/</link>
            <pubDate>Fri, 27 Nov 2015 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2015/11/27/</guid>
            <description>1. What is IPv6 IPv6 是为了解决 IPv4 地址资源日渐枯竭的问题，使用的是 128bit 地址，可以提供更多的地址空间。IPv6 地址以 16bit 为一组，每组用冒号隔开，可以分为八组，每组以 4 个十六进制数表示，共 32 个十六进制数，例如 2001:0db8:85a3:08d3:1319:8a2e:0370:7344 是一个合法的 IPv6 地址，它又可以分为两个逻辑部分：一个 64 位的网络前缀和一个 64 位的主机地址。
IPv6 中的 loopback interface 定义为 0000:0000:0000:0000:0000:0000:0000:0001 ，也可以表示为 ::1 ，因为每组中的前导 0 可以省略，一对连续的冒号表示多组 0 ，一个 IPv6 地址中允许出现一对连冒号。
IPv4 位址可以很容易的转化为 IPv6 格式。如果 IPv4 的一个地址为135.75.43.52（十六进制为 0x874B2B34 ），它可以被转化为0000:0000:0000:0000:0000:ffff:874B:2B34 或者 ::ffff:874B:2B34 。同时，还可以使用混合符号（IPv4-compatible address），则地址可以为 ::ffff:135.75.43.52 。
2. Linux support 首先需要内核支持，2.6 之后的内核都支持 IPv6 ，在 3.x 版本中，通常默认已经编译入内核：
如果 IPv6 编译成了模块，可以用 modprobe ipv6 命令加载。内核支持后就可以在 /proc 文件系统中看到 if_net6 文件：</description>
            <content type="html"><![CDATA[

<h2 id="1-what-is-ipv6">1. What is IPv6</h2>

<p>IPv6 是为了解决 IPv4 地址资源日渐枯竭的问题，使用的是 128bit 地址，可以提供更多的地址空间。IPv6 地址以 16bit 为一组，每组用冒号隔开，可以分为八组，每组以 4 个十六进制数表示，共 32 个十六进制数，例如 <code>2001:0db8:85a3:08d3:1319:8a2e:0370:7344</code>  是一个合法的 IPv6 地址，它又可以分为两个逻辑部分：一个 64 位的网络前缀和一个 64 位的主机地址。</p>

<p>IPv6 中的 loopback interface 定义为 <code>0000:0000:0000:0000:0000:0000:0000:0001</code> ，也可以表示为 <code>::1</code> ，因为每组中的前导 0 可以省略，一对连续的冒号表示多组 0 ，一个 IPv6 地址中允许出现一对连冒号。</p>

<p>IPv4 位址可以很容易的转化为 IPv6 格式。如果 IPv4 的一个地址为<code>135.75.43.52</code>（十六进制为 0x874B2B34 ），它可以被转化为<code>0000:0000:0000:0000:0000:ffff:874B:2B34</code> 或者 <code>::ffff:874B:2B34</code> 。同时，还可以使用混合符号（IPv4-compatible address），则地址可以为 <code>::ffff:135.75.43.52</code> 。</p>

<h2 id="2-linux-support">2. Linux support</h2>

<p>首先需要内核支持，2.6 之后的内核都支持 IPv6 ，在 3.x 版本中，通常默认已经编译入内核：</p>

<p><img src="/images/2015-11-27/2015-11-27_1.jpg" alt="" /></p>

<p>如果 IPv6 编译成了模块，可以用 <code>modprobe ipv6</code> 命令加载。内核支持后就可以在 /proc 文件系统中看到 if_net6 文件：</p>

<p><img src="/images/2015-11-27/2015-11-27_2.jpg" alt="" /></p>

<p>要将网口配置成 IPv6 ，也需要配置命令支持 IPv6 ，可以用如下命令检查 ifconfig 是否支持 IPv6 :</p>

<pre><code>~# ifconfig -? 2&gt;&amp; 1 | grep -qw 'inet6' &amp;&amp; echo &quot;utility 'ifconfig' is IPv6-ready&quot;
</code></pre>

<p>检查 route 是否支持 IPv6 :</p>

<pre><code>~# route -? 2&gt;&amp; 1 | grep -qw 'inet6' &amp;&amp; echo &quot;utility 'route' is IPv6-ready&quot;
</code></pre>

<h2 id="3-configuration">3. Configuration</h2>

<p>为网口添加一个 IPv6 地址 ：</p>

<p><img src="/images/2015-11-27/2015-11-27_3.jpg" alt="" /></p>

<p>可以用 del 参数删除 ：<code>ifconfig eth0 inet6 del 2001:0db8:0:f101::1/64</code></p>

<h2 id="4-test">4. Test</h2>

<p>可以用 IPv6 可以用 ping6 命令，例如测试 loopback interface ：</p>

<p><img src="/images/2015-11-27/2015-11-27_4.jpg" alt="" /></p>

<p>ping6 的 -I 参数可以指定网口，例如要测试 eth0 可以用 <code>ping6 -I eth0  fe80::2e0:18ff:fe90:9205</code> 。</p>

<p>测试路由的 traceroute 命令也有 IPv6 版本： traceroute6 。</p>

<h2 id="5-参考">5. 参考</h2>

<p><a href="http://tldp.org/HOWTO/Linux+IPv6-HOWTO/index.html" target="_blank">http://tldp.org/HOWTO/Linux+IPv6-HOWTO/index.html</a></p>
]]></content>
        </item>
        
        <item>
            <title>Linux 下调试蓝牙模块的笔记</title>
            <link>https://shaocheng.li/posts/2015/10/22/</link>
            <pubDate>Thu, 22 Oct 2015 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2015/10/22/</guid>
            <description>1. 蓝牙简介 蓝牙是一种支持设备短距离通信的无线电技术，使用 2.4GHz 频段，数据速率为1Mbps 。采用时分复用方案实现全双工传输。
蓝牙技术将设备分为两种：主设备和从设备。
蓝牙主设备的特点：主设备一般具有输入端。在进行蓝牙匹配操作时，用户通过输入端可输入随机的匹配密码来将两个设备匹配。蓝牙手机、安装有蓝牙模块的 PC 等都是主设备。（例如：蓝牙手机和蓝牙 PC 进行匹配时，用户可在蓝牙手机上任意输入一组数字，然后在蓝牙PC上输入相同的一组数字，来完成这两个设备之间的匹配。）
蓝牙从设备特点：从设备一般不具备输入端。因此从设备在出厂时，在其蓝牙芯片中，固化有一个4位或6位数字的匹配密码。蓝牙耳机等都是从设备。（例如：蓝牙 PC 与蓝牙耳机匹配时，用户将蓝牙耳机上的匹配密码输入到蓝牙 PC 上，完成匹配。）
蓝牙设备的呼叫过程：
 蓝牙主端设备发起呼叫，首先是查找，找出周围处于可被查找的蓝牙设备，此时从端设备需要处于可被查找状态。 主端设备找到从端蓝牙设备后，与从端蓝牙设备进行配对，此时需要输入从端设备的 PIN 码。 配对完成后，从端蓝牙设备会记录主端设备的信任信息，此时主端即可向从端设备发起呼叫，根据应用不同，可能是ACL数据链路呼叫或SCO语音链路呼叫，已配对的设备在下次呼叫时，不再需要重新配对。 已配对的设备，做为从端的蓝牙耳机也可以发起建链请求，但做数据通讯的蓝牙模块一般不发起呼叫。 链路建立成功后，主从两端之间即可进行双向的数据通讯。在通信状态下，主端和从端设备都可以发起断链，断开蓝牙链路。  蓝牙协议栈：
 RFCOMM 叫做电缆替代协议，它在蓝牙基带协议上仿真 RS-232 控制和数据信号，为使用串行线传送机制的上层协议（如 OBEX ）提供服务。 OBEX 叫做对象交换协议，采用简单的和自发的方式交换目标，用于传输文件。  2. Linux 对蓝牙的支持 2.6 之后的内核都提供了蓝牙支持，通常都已经是默认的设置：
[*] Networking support ---&amp;gt; [CONFIG_NET] &amp;lt;/M&amp;gt; Bluetooth subsystem support ---&amp;gt; [CONFIG_BT] &amp;lt;*/M&amp;gt; RFCOMM protocol support [CONFIG_BT_RFCOMM] [*] RFCOMM TTY support [CONFIG_BT_RFCOMM_TTY] &amp;lt;*/M&amp;gt; BNEP protocol support [CONFIG_BT_BNEP] [*] Multicast filter support [CONFIG_BT_BNEP_MC_FILTER] [*] Protocol filter support [CONFIG_BT_BNEP_PROTO_FILTER] &amp;lt;*/M&amp;gt; HIDP protocol support [CONFIG_BT_HIDP] Bluetooth device drivers ---&amp;gt; (Select the appropriate drivers for your Bluetooth hardware) &amp;lt;*/M&amp;gt; RF switch subsystem support ---&amp;gt; [CONFIG_RFKILL]  Linux 官方的蓝牙协议栈是 BlueZ ，BlueZ 包括 ： * HCI Core * HCI UART, USB and Virtual HCI device drivers * L2CAP module * Configuration and testing utilities</description>
            <content type="html"><![CDATA[

<h2 id="1-蓝牙简介">1. 蓝牙简介</h2>

<p>蓝牙是一种支持设备短距离通信的无线电技术，使用 2.4GHz 频段，数据速率为1Mbps 。采用时分复用方案实现全双工传输。</p>

<p>蓝牙技术将设备分为两种：主设备和从设备。</p>

<p>蓝牙主设备的特点：主设备一般具有输入端。在进行蓝牙匹配操作时，用户通过输入端可输入随机的匹配密码来将两个设备匹配。蓝牙手机、安装有蓝牙模块的 PC 等都是主设备。（例如：蓝牙手机和蓝牙 PC 进行匹配时，用户可在蓝牙手机上任意输入一组数字，然后在蓝牙PC上输入相同的一组数字，来完成这两个设备之间的匹配。）</p>

<p>蓝牙从设备特点：从设备一般不具备输入端。因此从设备在出厂时，在其蓝牙芯片中，固化有一个4位或6位数字的匹配密码。蓝牙耳机等都是从设备。（例如：蓝牙 PC 与蓝牙耳机匹配时，用户将蓝牙耳机上的匹配密码输入到蓝牙 PC 上，完成匹配。）</p>

<p>蓝牙设备的呼叫过程：</p>

<ol>
<li>蓝牙主端设备发起呼叫，首先是查找，找出周围处于可被查找的蓝牙设备，此时从端设备需要处于可被查找状态。</li>
<li>主端设备找到从端蓝牙设备后，与从端蓝牙设备进行配对，此时需要输入从端设备的 PIN 码。</li>
<li>配对完成后，从端蓝牙设备会记录主端设备的信任信息，此时主端即可向从端设备发起呼叫，根据应用不同，可能是ACL数据链路呼叫或SCO语音链路呼叫，已配对的设备在下次呼叫时，不再需要重新配对。</li>
<li>已配对的设备，做为从端的蓝牙耳机也可以发起建链请求，但做数据通讯的蓝牙模块一般不发起呼叫。</li>
<li>链路建立成功后，主从两端之间即可进行双向的数据通讯。在通信状态下，主端和从端设备都可以发起断链，断开蓝牙链路。</li>
</ol>

<p>蓝牙协议栈：</p>

<p><img src="/images/2015-10-22/2015-10-22_1.jpg" alt="" /></p>

<ul>
<li>RFCOMM 叫做电缆替代协议，它在蓝牙基带协议上仿真 RS-232 控制和数据信号，为使用串行线传送机制的上层协议（如 OBEX ）提供服务。</li>
<li>OBEX 叫做对象交换协议，采用简单的和自发的方式交换目标，用于传输文件。</li>
</ul>

<h2 id="2-linux-对蓝牙的支持">2. Linux 对蓝牙的支持</h2>

<p>2.6 之后的内核都提供了蓝牙支持，通常都已经是默认的设置：</p>

<pre><code>[*] Networking support ---&gt;                [CONFIG_NET]
  &lt;/M&gt; Bluetooth subsystem support ---&gt;    [CONFIG_BT]
    &lt;*/M&gt; RFCOMM protocol support          [CONFIG_BT_RFCOMM]
    [*]   RFCOMM TTY support               [CONFIG_BT_RFCOMM_TTY]
    &lt;*/M&gt; BNEP protocol support            [CONFIG_BT_BNEP]
    [*]   Multicast filter support         [CONFIG_BT_BNEP_MC_FILTER]
    [*]   Protocol filter support          [CONFIG_BT_BNEP_PROTO_FILTER]
    &lt;*/M&gt; HIDP protocol support            [CONFIG_BT_HIDP]
        Bluetooth device drivers ---&gt;
          (Select the appropriate drivers for your Bluetooth hardware)

  &lt;*/M&gt; RF switch subsystem support ---&gt;   [CONFIG_RFKILL]
</code></pre>

<p>Linux 官方的蓝牙协议栈是 BlueZ ，BlueZ 包括 ：
* HCI Core
* HCI UART, USB and Virtual HCI device drivers
* L2CAP module
* Configuration and testing utilities</p>

<p>BlueZ 包提供了蓝牙编程库和各种工具：</p>

<ul>
<li>bccmd : is used to issue BlueCore commands to Cambridge Silicon Radio devices.</li>
<li>bluemoon : is a Bluemoon configuration utility.</li>
<li>bluetoothctl : is the interactive Bluetooth control program.</li>
<li>bluetoothd : is the Bluetooth daemon.</li>
<li>btmon : provides access to the Bluetooth subsystem monitor infrastructure for reading HCI traces.</li>
<li>ciptool : is used to set up, maintain, and inspect the CIP configuration of the Bluetooth subsystem in the Linux kernel.</li>
<li>hciattach : is used to attach a serial UART to the Bluetooth stack as HCI transport interface.</li>
<li>hciconfig : is used to configure Bluetooth devices.</li>
<li>hcidump : reads raw HCI data coming from and going to a Bluetooth device and prints to screen commands, events and data in a human-readable form.</li>
<li>hcitool : is used to configure Bluetooth connections and send some special command to Bluetooth devices.</li>
<li>hex2hcd : is used to convert a file needed by Broadcom devices to hcd (Broadcom bluetooth firmware) format.</li>
<li>l2ping : is used to send a L2CAP echo request to the Bluetooth MAC address given in dotted hex notation.</li>
<li>l2test : is L2CAP testing program.</li>
<li>rctest : is used to test RFCOMM communications on the Bluetooth stack.</li>
<li>rfcomm : is used to set up, maintain, and inspect the RFCOMM configuration of the Bluetooth subsystem in the Linux kernel.</li>
<li>sdptool : is used to perform SDP queries on Bluetooth devices.</li>
<li>libbluetooth.so : contains the BlueZ 4 API functions.</li>
</ul>

<p>安装了 BlueZ 之后，配置文件都在 /etc/bluetooth 目录下。</p>

<h2 id="3-在-linux-中配置蓝牙">3. 在 Linux 中配置蓝牙</h2>

<p>使用的模块是 Intel 2330 ，同时支持 WIFI 和 Bluetooth 。调试前应该先下载模块的固件 iwlwifi-2030-6.ucode ，放入系统的 /lib/fireware 目录下，系统加载驱动 iwlwifi 时会自动查找。使用的系统是 yocto linux ，运行在 Intel Quark 平台的主板。</p>

<p>系统启动后可以查看设备：</p>

<pre><code>root@WR-IntelligentDevice:~# lsusb
Bus 001 Device 002: ID 0424:2514 Standard Microsystems Corp. USB 2.0 Hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
Bus 001 Device 003: ID 8087:07da Intel Corp. 
</code></pre>

<p>应该加载的驱动：</p>

<pre><code>root@WR-IntelligentDevice:~# lsmod | grep bt
bluetooth             200527  6 rfcomm,hidp,btusb
btusb                  11506  0 
</code></pre>

<p>如果驱动加载成功，会出现蓝牙的设备节点，使用 hciconfig 命令查看：</p>

<pre><code>root@WR-IntelligentDevice:~# hciconfig -a
hci0:   Type: BR/EDR  Bus: USB
        BD Address: 00:15:00:A1:E3:83  ACL MTU: 310:10  SCO MTU: 64:8
        DOWN 
        RX bytes:495 acl:0 sco:0 events:22 errors:0
        TX bytes:369 acl:0 sco:0 commands:22 errors:0
        Features: 0xff 0xff 0x8f 0xfe 0xdb 0xff 0x5b 0x87
        Packet type: DM1 DM3 DM5 DH1 DH3 DH5 HV1 HV2 HV3 
        Link policy: RSWITCH HOLD SNIFF PARK 
        Link mode: SLAVE ACCEPT 
</code></pre>

<p>可以看到设备的状态是 DOWN ，表示蓝牙还没有启动。手动启动蓝牙，可以看到蓝牙状态变为 UP RUNNING ，而且是从设备：</p>

<pre><code>root@WR-IntelligentDevice:~# hciconfig hci0 up
root@WR-IntelligentDevice:~# hciconfig -a 
hci0:   Type: BR/EDR  Bus: USB
        BD Address: 00:15:00:A1:E3:83  ACL MTU: 310:10  SCO MTU: 64:8
        UP RUNNING 
        RX bytes:990 acl:0 sco:0 events:44 errors:0
        TX bytes:738 acl:0 sco:0 commands:44 errors:0
        Features: 0xff 0xff 0x8f 0xfe 0xdb 0xff 0x5b 0x87
        Packet type: DM1 DM3 DM5 DH1 DH3 DH5 HV1 HV2 HV3 
        Link policy: RSWITCH HOLD SNIFF PARK 
        Link mode: SLAVE ACCEPT 
        Name: 'PC Controller App v1.4'
        Class: 0x000000
        Service Classes: Unspecified
        Device Class: Miscellaneous, 
        HCI Version: 4.0 (0x6)  Revision: 0x1ebd
        LMP Version: 4.0 (0x6)  Subversion: 0xfc00
        Manufacturer: Intel Corp. (2)
</code></pre>

<p>更好的方法是用 bluetoothd 启动蓝牙， bluetoothd 是一个守护进程，启动时会根据 /etc/bluetooth/ 下的配置文件初始化蓝牙，直接执行 <code>bluetoothd</code> 。</p>

<h3 id="3-1-连接手机蓝牙">3.1 连接手机蓝牙</h3>

<p>打开手机的蓝牙，测试用的是小米手机。这里要注意一点，手机上的蓝牙在打开后会有一段时间处于可检测状态，也就是其他蓝牙设备可以扫描到它，之后会关闭可检测性，这段时间的长短通常可以设置，有的手机在熄屏时也会关闭蓝牙的可检测性。</p>

<p>然后扫描一下周边的蓝牙设备：</p>

<pre><code>root@WR-IntelligentDevice:~# hcitool scan
Scanning ...
        A2:CF:49:FD:99:AF       MI-ONE Plus
</code></pre>

<blockquote>
<p>scan 用于扫描经典蓝牙设备，如果是低功耗蓝牙设备（BLE），例如手环之类，要 用 lescan 选项，调试 BLE 设备要用 gatttool 工具。</p>
</blockquote>

<p>测试能否连通：</p>

<pre><code>root@WR-IntelligentDevice:~# l2ping -i hci0 -c 4 A2:CF:49:FD:99:AF
Ping: A2:CF:49:FD:99:AF from 00:15:00:A1:E3:83 (data size 44) ...
44 bytes from A2:CF:49:FD:99:AF id 0 time 25.03ms
44 bytes from A2:CF:49:FD:99:AF id 1 time 25.32ms
44 bytes from A2:CF:49:FD:99:AF id 2 time 26.96ms
44 bytes from A2:CF:49:FD:99:AF id 3 time 27.06ms
4 sent, 4 received, 0% loss
</code></pre>

<p>利用 SDP 协议，我们还可以查看每个设备都有功能，能提供什么服务，每种基于 RFCOMM 的服务都使用某种协议，占据哪个“频道 (channel)”，这是使用服务时的一个重要参数，先看看自己：</p>

<pre><code>root@WR-IntelligentDevice:~# sdptool browse local
Browsing FF:FF:FF:00:00:00 ...
Service Name: SIM Access Server
Service RecHandle: 0x10000
Service Class ID List:
  &quot;SIM Access&quot; (0x112d)
  &quot;Generic Telephony&quot; (0x1204)
Protocol Descriptor List:
  &quot;L2CAP&quot; (0x0100)
  &quot;RFCOMM&quot; (0x0003)
    Channel: 8
Profile Descriptor List:
  &quot;SIM Access&quot; (0x112d)
    Version: 0x0101

Service Name: Headset Audio Gateway
Service RecHandle: 0x10001
Service Class ID List:
  &quot;Headset Audio Gateway&quot; (0x1112)
  &quot;Generic Audio&quot; (0x1203)
Protocol Descriptor List:
  &quot;L2CAP&quot; (0x0100)
  &quot;RFCOMM&quot; (0x0003)
    Channel: 12
Profile Descriptor List:
  &quot;Headset&quot; (0x1108)
    Version: 0x0102

Service Name: Hands-Free Audio Gateway
Service RecHandle: 0x10002
Service Class ID List:
  &quot;Handsfree Audio Gateway&quot; (0x111f)
  &quot;Generic Audio&quot; (0x1203)
Protocol Descriptor List:
  &quot;L2CAP&quot; (0x0100)
  &quot;RFCOMM&quot; (0x0003)
    Channel: 13
Profile Descriptor List:
  &quot;Handsfree&quot; (0x111e)
    Version: 0x0105

Service Name: Audio Source
Service RecHandle: 0x10003
Service Class ID List:
  &quot;Audio Source&quot; (0x110a)
Protocol Descriptor List:
  &quot;L2CAP&quot; (0x0100)
    PSM: 25
  &quot;AVDTP&quot; (0x0019)
    uint16: 0x102
Profile Descriptor List:
  &quot;Advanced Audio&quot; (0x110d)
    Version: 0x0102

Service Name: AVRCP TG
Service RecHandle: 0x10004
Service Class ID List:
  &quot;AV Remote Target&quot; (0x110c)
Protocol Descriptor List:
  &quot;L2CAP&quot; (0x0100)
    PSM: 23
  &quot;AVCTP&quot; (0x0017)
    uint16: 0x103
Profile Descriptor List:
  &quot;AV Remote&quot; (0x110e)
    Version: 0x0104

Service Name: AVRCP CT
Service RecHandle: 0x10005
Service Class ID List:
  &quot;AV Remote&quot; (0x110e)
Protocol Descriptor List:
  &quot;L2CAP&quot; (0x0100)
    PSM: 23
  &quot;AVCTP&quot; (0x0017)
    uint16: 0x103
Profile Descriptor List:
  &quot;AV Remote&quot; (0x110e)
    Version: 0x0100

Service Name: Dial-Up Networking
Service RecHandle: 0x10006
Service Class ID List:
  &quot;Dialup Networking&quot; (0x1103)
  &quot;Generic Networking&quot; (0x1201)
Protocol Descriptor List:
  &quot;L2CAP&quot; (0x0100)
  &quot;RFCOMM&quot; (0x0003)
    Channel: 1
Profile Descriptor List:
  &quot;Dialup Networking&quot; (0x1103)
    Version: 0x0100
</code></pre>

<p>再看看手机的蓝牙服务：</p>

<pre><code>root@WR-IntelligentDevice:~# sdptool browse  A2:CF:49:FD:99:AF 
Browsing A2:CF:49:FD:99:AF ...
Service RecHandle: 0x10000
Service Class ID List:
  &quot;PnP Information&quot; (0x1200)
Profile Descriptor List:
  &quot;PnP Information&quot; (0x1200)
    Version: 0x0102

Service Name: Audio Source
Service RecHandle: 0x10001
Service Class ID List:
  &quot;Audio Source&quot; (0x110a)
Protocol Descriptor List:
  &quot;L2CAP&quot; (0x0100)
    PSM: 25
  &quot;AVDTP&quot; (0x0019)
    uint16: 0x102
Profile Descriptor List:
  &quot;Advanced Audio&quot; (0x110d)
    Version: 0x0102

Service Name: AVRCP TG
Service RecHandle: 0x10002
Service Class ID List:
  &quot;AV Remote Target&quot; (0x110c)
Protocol Descriptor List:
  &quot;L2CAP&quot; (0x0100)
    PSM: 23
  &quot;AVCTP&quot; (0x0017)
    uint16: 0x103
Profile Descriptor List:
  &quot;AV Remote&quot; (0x110e)
    Version: 0x0100

Service Name: Voice Gateway
Service RecHandle: 0x10003
Service Class ID List:
  &quot;Handsfree Audio Gateway&quot; (0x111f)
  &quot;Generic Audio&quot; (0x1203)
Protocol Descriptor List:
  &quot;L2CAP&quot; (0x0100)
  &quot;RFCOMM&quot; (0x0003)
    Channel: 10
Profile Descriptor List:
  &quot;Handsfree&quot; (0x111e)
    Version: 0x0105

Service Name: Voice Gateway
Service RecHandle: 0x10004
Service Class ID List:
  &quot;Headset Audio Gateway&quot; (0x1112)
  &quot;Generic Audio&quot; (0x1203)
Protocol Descriptor List:
  &quot;L2CAP&quot; (0x0100)
  &quot;RFCOMM&quot; (0x0003)
    Channel: 11
Profile Descriptor List:
  &quot;Headset&quot; (0x1108)
    Version: 0x0102

Service Name: OBEX Object Push
Service RecHandle: 0x10005
Service Class ID List:
  &quot;OBEX Object Push&quot; (0x1105)
Protocol Descriptor List:
  &quot;L2CAP&quot; (0x0100)
  &quot;RFCOMM&quot; (0x0003)
    Channel: 12
  &quot;OBEX&quot; (0x0008)
Profile Descriptor List:
  &quot;OBEX Object Push&quot; (0x1105)
    Version: 0x0100

Service Name: OBEX Phonebook Access Server
Service RecHandle: 0x10006
Service Class ID List:
  &quot;Phonebook Access - PSE&quot; (0x112f)
Protocol Descriptor List:
  &quot;L2CAP&quot; (0x0100)
  &quot;RFCOMM&quot; (0x0003)
    Channel: 19
  &quot;OBEX&quot; (0x0008)
Profile Descriptor List:
  &quot;Phonebook Access&quot; (0x1130)
    Version: 0x0100
</code></pre>

<p>使用 openobex 包提供的 obex_test 工具，在 yocto 的官网可以下载到 recipes 文件和补丁。或者在下载源码：<a href="https://github.com/zuckschwerdt/openobex" target="_blank">https://github.com/zuckschwerdt/openobex</a></p>

<h3 id="3-2-连接蓝牙耳机">3.2 连接蓝牙耳机</h3>

<p>先启动本地的蓝牙服务并配置：</p>

<pre><code>root@WR-IntelligentDevice:~# bluetoothd
root@WR-IntelligentDevice:~# hciconfig hci0 noencrypt
root@WR-IntelligentDevice:~# hciconfig hci0 piscan
root@WR-IntelligentDevice:~# hciconfig hci0 name &quot;bluez4&quot;
root@WR-IntelligentDevice:~# hciconfig hci0 pageto 65535
</code></pre>

<p>然后启动蓝牙耳机，使之处于可检测状态，然后扫描：</p>

<pre><code>root@WR-IntelligentDevice:~# hcitool scan
Scanning ...
        50:C9:71:AA:E0:AE       JABRA EASYGO
</code></pre>

<p>准备一个 test.wav 的音频文件，然后用如下脚本测试蓝牙耳机：</p>

<pre><code>#!/bin/sh
local mac=&quot;50:C9:71:AA:E0:AE&quot;
local asoundconf=&quot;/etc/asound.conf&quot;

#add service    
sdptool add a2snk
sdptool add a2src
sdptool add avrct
sdptool add avrtg
sdptool add hf
sdptool add hs

echo &quot;&quot; &gt;&gt; $asoundconf
echo &quot;pcm.bluetooth{&quot; &gt;&gt; $asoundconf
echo &quot;    type bluetooth&quot; &gt;&gt; $asoundconf
echo &quot;    device $mac&quot; &gt;&gt; $asoundconf
echo &quot;    profile \&quot;hifi\&quot;&quot; &gt;&gt; $asoundconf
echo &quot;}&quot; &gt;&gt; $asoundconf

echo &quot;Bind to $mac ...&quot;
simple-agent hci0 $mac || {
    echo &quot;simple-agent failed!&quot;
    exit 1
}

echo &quot;Connect $mac ...&quot;
bluez-test-audio connect $mac || {
    echo &quot;audio connect failed!&quot;
    exit 1
}

echo &quot;Connection result ...&quot;
hcitool con

echo &quot;Play audio ...&quot;
aplay -D bluetooth ./test.wav
</code></pre>

<p>正常情况会打印如下信息，蓝牙耳机可以听到音频内容：</p>

<pre><code>Audio sink service registered
Audio source service registered
Remote control service registered
Remote target service registered
Handsfree service registered
Headset service registered
Bind to 50:C9:71:AA:E0:AE ...
Release
New device (/org/bluez/3319/hci0/dev_50_C9_71_AA_E0_AE)
Connect 50:C9:71:AA:E0:AE ...
Connection result ...
Connections:
        &lt; ACL 50:C9:71:AA:E0:AE handle 34 state 1 lm MASTER AUTH ENCRYPT 
Play audio ...
Playing WAVE './test.wav' : Signed 16 bit Little Endian, Rate 44100 Hz, Stereo
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>Linux 命令行下的 3G 模块配置工具 comgt</title>
            <link>https://shaocheng.li/posts/2015/09/09/</link>
            <pubDate>Wed, 09 Sep 2015 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2015/09/09/</guid>
            <description>comgt帮助文档
comgt 是一个 GPRS/EDGE/3G/HSDPA 和 3G/GPRS 模块配置工具。它更像是一个脚本语言解释器，通过调用内建、或者外部脚本与 GPRS 和 3G 模块通讯。
语法 comgt -d device -ehstvVx script
参数  -d device ：指定模块的通讯口，例如 /dev/ttyUSB2 或 /dev/modem -e ：打开串口通信的 echo -h ：显示帮助信息 -s ：在外部脚本执行前，不要运行内建的默认脚本 -t ：使用备用线路终端 -v ：运行详细模式，会显示详细的通讯过程 -V ：显示版本信息 -x ：将内建和外部脚本中的波特率 115200 改为 57600  内建脚本  comgt ：运行默认的内建脚本。如果运行 comgt 时没有指定任何脚本，例如 comgt -d /dev/ttyS1 ,它会依次执行几个内建的脚本 PIN 、reg、sig 。 comgt help ：列出所有帮助信息。 comgt info ：列出当前模块的配置。 comgt sig ：获取信号强度。 comgt reg ：显示注册状态。 comgt 3G ：将模块设为 3G only (UMTS/HSDPA) 模式。 comgt 2G ：将模块设为 2G only (GSM/GPRS/EDGE) 模式。 comgt 3G2G ：将模块设为 3G preferred (UMTS/HSDPA and GSM/GPRS/EDGE) 模式  外部脚本 以 sendmsg.</description>
            <content type="html"><![CDATA[

<p><a href="http://manpages.ubuntu.com/manpages/natty/man1/comgt.1.html" target="_blank">comgt帮助文档</a></p>

<p>comgt 是一个 GPRS/EDGE/3G/HSDPA 和 3G/GPRS 模块配置工具。它更像是一个脚本语言解释器，通过调用内建、或者外部脚本与 GPRS 和 3G 模块通讯。</p>

<h2 id="语法">语法</h2>

<p>comgt -d device -ehstvVx script</p>

<h2 id="参数">参数</h2>

<ul>
<li>-d device ：指定模块的通讯口，例如 /dev/ttyUSB2 或 /dev/modem</li>
<li>-e ：打开串口通信的 echo</li>
<li>-h ：显示帮助信息</li>
<li>-s ：在外部脚本执行前，不要运行内建的默认脚本</li>
<li>-t ：使用备用线路终端</li>
<li>-v ：运行详细模式，会显示详细的通讯过程</li>
<li>-V ：显示版本信息</li>
<li>-x ：将内建和外部脚本中的波特率 115200 改为 57600</li>
</ul>

<h2 id="内建脚本">内建脚本</h2>

<ul>
<li>comgt ：运行默认的内建脚本。如果运行 comgt 时没有指定任何脚本，例如 <code>comgt -d /dev/ttyS1</code> ,它会依次执行几个内建的脚本 PIN 、reg、sig 。</li>
<li>comgt help ：列出所有帮助信息。</li>
<li>comgt info ：列出当前模块的配置。</li>
<li>comgt sig ：获取信号强度。</li>
<li>comgt reg ：显示注册状态。</li>
<li>comgt 3G ：将模块设为 3G only (UMTS/HSDPA) 模式。</li>
<li>comgt 2G ：将模块设为 2G only (GSM/GPRS/EDGE) 模式。</li>
<li>comgt 3G2G ：将模块设为 3G preferred (UMTS/HSDPA and GSM/GPRS/EDGE) 模式</li>
</ul>

<h2 id="外部脚本">外部脚本</h2>

<p>以 sendmsg.gcom 为例，该脚本实现了发送短信的功能：</p>

<pre><code>opengt
    set com 115200n81
    set comecho off
    set senddelay 0.02
    waitquiet 0.2 0.2
    flash 0.1

:start
    send &quot;AT+CMGF=1^m&quot;
    get 1 &quot;&quot; $s
    print $s
    send &quot;AT+CSCS=GSM^m&quot;
    get 1 &quot;&quot; $s
    print $s
    send &quot;AT+CSMP=17,168,0,0^m&quot;
    get 1 &quot;&quot; $s
    print $s
    print &quot;Input message:\n&quot;
    input $m
    send &quot;AT+CMGS=+8613824741490^m&quot;
    send  $m+&quot;^Z&quot;
    get 1 &quot;&quot; $s
    print $s

:continue
    exit 0
</code></pre>

<p>opengt 段用于设置串口的各项参数,之后会一次执行 start 段的命令，这里涉及到几个常用的命令：</p>

<ul>
<li>send : 向串口发送字符串。这个字符应该以 <code>^m</code> 结尾，表示一个回车符。几个字符串可以用加号连接。有时一个 AT 命令后会等待用户输入，比如 <code>AT+CMGS</code> 后会等待输入短信内容，此时继续调用 send 命令即可。<code>^Z</code> 表示 Ctrl+Z 组合键。</li>
<li>input : 等待用户输入，输入的字符串放入变量 $x 中。</li>
<li>print : 在终端打印一行字符串。</li>
<li>get : 获取串口返回从字符串。语法是 <code>get timeout &quot;terminators&quot; $string</code></li>
</ul>

<p>执行该脚本：</p>

<pre><code>gcom -d /dev/ttyUSB2 -s sendmsg.gcom
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>用 Python 解析 GPS 轨迹数据</title>
            <link>https://shaocheng.li/posts/2015/09/08/</link>
            <pubDate>Tue, 08 Sep 2015 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2015/09/08/</guid>
            <description>常见的 GPS 数据文件格式有 GPS、CVS、KML 等，这些数据格式本身并不复杂，基本都是对坐标点的集合，大部分 GPS 记录仪都支持多种格式的数据文件的导入和导出。但是有时还是需要做格式转换，比如 Google Earth 只支持 KML 格式导入。所以，我准备做一个 GPS 数据格式转换工具，使用 Python，做一个基于命令行的工具。
1. GPX GPX（GPS eXchange Format，GPS交换格式）是一个XML格式，它可以用来描述路点、轨迹、路程。这个格式是免费的，可以在不需要付任何许可费用的前提下使用。它的标签保存位置，海拔和时间。
在GPX中，一个没有顺序关系的点集合，叫路点。一个有顺序的点的集合叫轨迹或者路程。轨迹是一个人曾经走过的记录，路程是一个建议的下一步要走的地方。所以，一般来讲，轨迹里的点，包含时间信息，路程里的点，没有时间信息。
最小的一个GPX文件，仅仅包含一个经纬度坐标的点，其它的都是可选的。
GPX 1.1 : http://www.topografix.com/GPX/1/1/
2. CSV CSV （Comma-Separated Values，逗号分隔值） 文件格式并没有通用的标准，其文件以纯文本形式存储表格数据（数字和文本）。纯文本意味着该文件是一个字符序列，不含必须像二进制数字那样被解读的数据。CSV 文件由任意数目的记录组成，记录间以某种换行符分隔；每条记录由字段组成，字段间的分隔符是其它字符或字符串，最常见的是逗号或制表符。CSV 文件是纯文本文件，但是可以直接用 Office Excel 软件打开。
下图是一个 CSV 格式的 GPS 轨迹数据文件，每条记录有三个字段，分别表示经度、纬度、海拔。（注：北纬为正，南纬为负，东经为正，西经为负）
对 CSV 数据读写可以直接调用 Python 的 csv 模块 ：https://docs.python.org/2/library/csv.html
csv 模块定义了如下几个函数：
 csv.reader(csvfile, dialect=&amp;lsquo;excel&amp;rsquo;, **fmtparams)
改函数会遍历 csvfile 中的每一行，然后返回一个 reader 对象， csvfile 可以是任何支持 iterator 协议的对象，每次调用它的 next() 方法都会返回一个字符串。
  3.</description>
            <content type="html"><![CDATA[

<p>常见的 GPS 数据文件格式有 GPS、CVS、KML 等，这些数据格式本身并不复杂，基本都是对坐标点的集合，大部分 GPS 记录仪都支持多种格式的数据文件的导入和导出。但是有时还是需要做格式转换，比如 Google Earth 只支持 KML 格式导入。所以，我准备做一个 GPS 数据格式转换工具，使用 Python，做一个基于命令行的工具。</p>

<h2 id="1-gpx">1. GPX</h2>

<p>GPX（GPS eXchange Format，GPS交换格式）是一个XML格式，它可以用来描述路点、轨迹、路程。这个格式是免费的，可以在不需要付任何许可费用的前提下使用。它的标签保存位置，海拔和时间。</p>

<p>在GPX中，一个没有顺序关系的点集合，叫路点。一个有顺序的点的集合叫轨迹或者路程。轨迹是一个人曾经走过的记录，路程是一个建议的下一步要走的地方。所以，一般来讲，轨迹里的点，包含时间信息，路程里的点，没有时间信息。</p>

<p>最小的一个GPX文件，仅仅包含一个经纬度坐标的点，其它的都是可选的。</p>

<p>GPX 1.1 : <a href="http://www.topografix.com/GPX/1/1/" target="_blank">http://www.topografix.com/GPX/1/1/</a></p>

<h2 id="2-csv">2. CSV</h2>

<p>CSV （Comma-Separated Values，逗号分隔值） 文件格式并没有通用的标准，其文件以纯文本形式存储表格数据（数字和文本）。纯文本意味着该文件是一个字符序列，不含必须像二进制数字那样被解读的数据。CSV 文件由任意数目的记录组成，记录间以某种换行符分隔；每条记录由字段组成，字段间的分隔符是其它字符或字符串，最常见的是逗号或制表符。CSV 文件是纯文本文件，但是可以直接用 Office Excel 软件打开。</p>

<p>下图是一个 CSV 格式的 GPS 轨迹数据文件，每条记录有三个字段，分别表示经度、纬度、海拔。（注：北纬为正，南纬为负，东经为正，西经为负）</p>

<p><img src="/images/2015-09-08/2015-09-08_1.jpg" alt="" /></p>

<p>对 CSV 数据读写可以直接调用 Python 的 csv 模块 ：<a href="https://docs.python.org/2/library/csv.html" target="_blank">https://docs.python.org/2/library/csv.html</a></p>

<p>csv 模块定义了如下几个函数：</p>

<ul>
<li><p>csv.reader(csvfile, dialect=&lsquo;excel&rsquo;, **fmtparams)</p>

<p>改函数会遍历 csvfile 中的每一行，然后返回一个 reader 对象， csvfile 可以是任何支持 iterator 协议的对象，每次调用它的 next() 方法都会返回一个字符串。</p></li>
</ul>

<h2 id="3-kml">3. KML</h2>

<p>KML 也是基于 XML 语法的标记语言，是 Google Earth 特有的格式，它不仅可以记录 GPS 轨迹，还可以标记很多地理数据，包括点、线、面、多边形、多面体等等。</p>
]]></content>
        </item>
        
        <item>
            <title>可自定义的 Mac 桌面扩展 Übersicht</title>
            <link>https://shaocheng.li/posts/2015/08/29/</link>
            <pubDate>Sat, 29 Aug 2015 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2015/08/29/</guid>
            <description>Keep an eye on what is happening on your machine and in the World
 http://tracesof.net/uebersicht/
At a Glance Übersicht lets you run system commands and display their output on your desktop in little containers, called widgets. Widgets are written using HTML5, which means they
 are easy to write and customize can show data in tables, charts, graphs &amp;hellip; you name it can react to different screen sizes  The following screenshots give you a glimpse of Übersicht in action:</description>
            <content type="html"><![CDATA[

<blockquote>
<p>Keep an eye on what is happening on your machine and in the World</p>
</blockquote>

<p><a href="http://tracesof.net/uebersicht/" target="_blank">http://tracesof.net/uebersicht/</a></p>

<h2 id="at-a-glance">At a Glance</h2>

<p>Übersicht lets you run system commands and display their output on your desktop in little containers, called widgets. Widgets are written using HTML5, which means they</p>

<ul>
<li>are easy to write and customize</li>
<li>can show data in tables, charts, graphs &hellip; you name it</li>
<li>can react to different screen sizes</li>
</ul>

<p>The following screenshots give you a glimpse of Übersicht in action:</p>

<p><img src="/images/2015-08-29/2015-08-29_1.jpg" alt="" /></p>

<h2 id="rolling-your-own">Rolling your own</h2>

<p>Widgets are written in CoffeeScript or plain JavaScript. A minimal widget, written in CoffeeScript looks like this:</p>

<pre><code>command: &quot;echo Hello World!&quot;

refreshFrequency: 5000 # ms

render: (output) -&gt;
    &quot;&lt;h1&gt;#{output}&lt;/h1&gt;&quot;

style: &quot;&quot;&quot;
    left: 20px
    top: 20px
    color: #fff
&quot;&quot;&quot;
</code></pre>

<p>Please visit the GitHub page for the full documentation : <a href="https://github.com/felixhageloh/uebersicht" target="_blank">https://github.com/felixhageloh/uebersicht</a></p>
]]></content>
        </item>
        
        <item>
            <title>获得 IP 所在地的网站 freegeoip.net</title>
            <link>https://shaocheng.li/posts/2015/08/22/</link>
            <pubDate>Sat, 22 Aug 2015 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2015/08/22/</guid>
            <description>About http://freegeoip.net provides a public HTTP API for software developers to search the geolocation of IP addresses. It uses a database of IP addresses that are associated to cities along with other relevant information like time zone, latitude and longitude.
You&amp;rsquo;re allowed up to 10,000 queries per hour by default. Once this limit is reached, all of your requests will result in HTTP 403, forbidden, until your quota is cleared.</description>
            <content type="html"><![CDATA[

<h2 id="about">About</h2>

<p><a href="http://freegeoip.net" target="_blank">http://freegeoip.net</a> provides a public HTTP API for software developers to search the geolocation of IP addresses. It uses a database of IP addresses that are associated to cities along with other relevant information like time zone, latitude and longitude.</p>

<p>You&rsquo;re allowed up to 10,000 queries per hour by default. Once this limit is reached, all of your requests will result in HTTP 403, forbidden, until your quota is cleared.</p>

<p>The freegeoip web server is free and open source so if the public service limit is a problem for you, download it and run your own instance.</p>

<h2 id="api">API</h2>

<p>The HTTP API takes GET requests in the following schema:</p>

<pre><code>freegeoip.net/{format}/{IP_or_hostname}
</code></pre>

<p>Supported formats are: csv, xml, json and jsonp. If no IP or hostname is provided, then your own IP is looked up.</p>

<h2 id="examples">Examples</h2>

<ul>
<li><p>CSV</p>

<pre><code>freegeoip.net/csv/8.8.8.8
</code></pre></li>

<li><p>XML</p>

<pre><code>freegeoip.net/xml/4.2.2.2
</code></pre></li>

<li><p>JSON</p>

<pre><code>freegeoip.net/json/github.com
</code></pre></li>
</ul>

<p>要获取本机的公网 IP 可以用 <a href="http://httpbin.org" target="_blank">http://httpbin.org</a> 提供的服务。在 Linux 中只需 <code>curl http://httpbin.org/ip</code> 即可返回本机的公网 IP         ：</p>

<pre><code>~$ curl http://httpbin.org/ip
{
    &quot;origin&quot;: &quot;218.18.232.122&quot;
}
</code></pre>

<p>其他类似功能的网站还有：</p>

<ul>
<li><a href="http://ip-api.com/" target="_blank">http://ip-api.com/</a></li>
<li><a href="https://ipstack.com/" target="_blank">https://ipstack.com/</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>MQTT 协议和 mosquitto</title>
            <link>https://shaocheng.li/posts/2015/08/11/</link>
            <pubDate>Tue, 11 Aug 2015 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2015/08/11/</guid>
            <description>1. MQTT 介绍 http://mqtt.org/
MQTT 是一个轻型协议，使用基于 TCP/IP 协议的发布/订阅消息转发模式，专门用于机器对机器 (M2M) 通信。 MQTT 协议的中心是 MQTT 服务器或代理 (broker) ，支持发布程序和订阅程序进行访问，如下图所示：
用户可以使用 MQTT 构建一个传感器网络，其中各种传感器都能够以其传感器独有的消息形式发布传感器值。 订阅程序能够订阅不同的消息，以据此采取措施。 MQTT 代理将处理从发布程序到订阅程序的转发消息。
如果已经有了一个 broker ，可以直接用 MQTT 客户端软件测试。这里有一个跨平台的 MQTT 客户端 MQTT.fx 。
2. Mosquitto mosquitto 是一个开源的 MQTT broker ，目前支持 v3.1 和 v3.1.1 协议 ，同时提供了一个 C 语言动态链接库 libmosquitto ，用于实现 mqtt 客户端：
http://mosquitto.org/documentation/
下载 mosquitto-1.4.2.tar.gz 后，解压，然后执行 make ，make install 。即可得到几个二进制可执行文件：
 mosquitto : mqtt broker mosquitto_passwd : 管理 mosquitto 密码文件的命令行工具 mosquitto_sub : mqtt 订阅者程序 mosquitto_pub ： mqtt 发布者程序  相关的配置文件安装在 /etc/mosquitto/ 目录下。在 Ubuntu 下可以直接安装 sudo apt-get install mosquitto 。</description>
            <content type="html"><![CDATA[

<h2 id="1-mqtt-介绍">1. MQTT 介绍</h2>

<p><a href="http://mqtt.org/" target="_blank">http://mqtt.org/</a></p>

<p>MQTT 是一个轻型协议，使用基于 TCP/IP 协议的发布/订阅消息转发模式，专门用于机器对机器 (M2M) 通信。 MQTT 协议的中心是 MQTT 服务器或代理 (broker) ，支持发布程序和订阅程序进行访问，如下图所示：</p>

<p><img src="/images/2015-08-11/2015-08-11_1.jpg" alt="" /></p>

<p>用户可以使用 MQTT 构建一个传感器网络，其中各种传感器都能够以其传感器独有的消息形式发布传感器值。 订阅程序能够订阅不同的消息，以据此采取措施。 MQTT 代理将处理从发布程序到订阅程序的转发消息。</p>

<p>如果已经有了一个 broker ，可以直接用 MQTT 客户端软件测试。这里有一个跨平台的 MQTT 客户端 <a href="https://mqttfx.jensd.de" target="_blank">MQTT.fx</a> 。</p>

<h2 id="2-mosquitto">2. Mosquitto</h2>

<p>mosquitto 是一个开源的 MQTT broker ，目前支持 v3.1 和 v3.1.1 协议 ，同时提供了一个 C 语言动态链接库 libmosquitto ，用于实现 mqtt 客户端：</p>

<p><a href="http://mosquitto.org/documentation/" target="_blank">http://mosquitto.org/documentation/</a></p>

<p>下载 mosquitto-1.4.2.tar.gz 后，解压，然后执行 make ，make install 。即可得到几个二进制可执行文件：</p>

<ul>
<li>mosquitto : mqtt broker</li>
<li>mosquitto_passwd : 管理 mosquitto 密码文件的命令行工具</li>
<li>mosquitto_sub : mqtt 订阅者程序</li>
<li>mosquitto_pub ： mqtt 发布者程序</li>
</ul>

<p>相关的配置文件安装在 /etc/mosquitto/ 目录下。在 Ubuntu 下可以直接安装 <code>sudo apt-get install mosquitto</code> 。</p>

<p>现在测试一下客户端和服务端程序。为了测试方便，将客户端和服务端程序都在本机，使用 localhost 连接。执行 <code>mosquitto -v</code> 启动 broker ，-v 参数表示打印出运行信息，可以看到默认使用的端口是1883 :</p>

<p><img src="/images/2015-08-11/2015-08-11_2.jpg" alt="" /></p>

<blockquote>
<p>如果你的系统出现如下问题，就需要添加一个 mosquitto 用户：</p>
</blockquote>

<p><img src="/images/2015-08-11/2015-08-11_3.jpg" alt="" /></p>

<p>可以使用 systemd 让 mosquitto 自动启动，添加如下配置文件：</p>

<pre><code>ubuntu@VM-231-137-ubuntu:/etc/systemd/system$ cat mosquitto.service
[Unit]
Description=Mosquitto MQTT Broker
ConditionPathExists=/etc/mosquitto/mosquitto.conf
After=network.target

[Service]
ExecStart=/usr/local/sbin/mosquitto -c /etc/mosquitto/mosquitto.conf
ExecReload=/bin/kill -HUP $MAINPID
User=mosquitto
Restart=on-failure
RestartSec=10

[Install]
WantedBy=multi-user.target
</code></pre>

<p>然后在第二个终端启动订阅者程序: <code>mosquitto_sub -h localhost -t test -v</code>，用 -h 参数指定服务器 IP ，用 -t 参数指定订阅的话题。</p>

<p>在第三个终端启动发布者程序: <code>mosquitto_pub -h localhost -t test -m &quot;Hello world&quot;</code>，用 -m 参数指定要发布的信息内容，然后在订阅者的终端就可以看到由 broker 推送的信息：</p>

<p><img src="/images/2015-08-11/2015-08-11_4.jpg" alt="" /></p>

<p>在 broker 的终端也可以看到处理信息的过程：</p>

<p><img src="/images/2015-08-11/2015-08-11_5.jpg" alt="" /></p>

<p>mosquitto 语法是</p>

<pre><code>mosquitto [-c config file] [ -d | --daemon ] [-p port number] [-v]
</code></pre>

<ul>
<li>-c 是指定配置文件的路径，默认不需要配置文件。</li>
<li>-d 表示作为守护进程运行在后台。</li>
<li>-p 用来指定监听的端口，默认是 1883 ，使用 TCP 连接，如果要使用 UDP 连接，需要设为 1884。</li>
<li>-v 表示生成详细的运行日志，等价于配置文件中将 log_type 设为 all 。</li>
</ul>

<p>mosquitto 默认是不需要配置文件的，它会对所有的选项采用默认值，比如用户名和密码。默认不需要用户名和密码，如果需要，可以用 mosquitto_passwd 新建用户和密码，并管理，语法是：</p>

<pre><code>mosquitto_passwd [ -c | -D ] passwordfile username
mosquitto_passwd -b passwordfile username password
mosquitto_passwd -U passwordfile
</code></pre>

<ul>
<li>-c 表示新建一个密码文件，如果文件已经存在，会被覆盖，用户名中不能包含冒号，因为密码文件中用户名和密码是用冒号隔开的。执行之后会要求设置密码，输入内容不可见，密码以加密 hash 值的方式存储在密码文件中。</li>
<li>-D 表示删除用户名。</li>
<li>-b 表示在命令行中，以明文方式设置密码。</li>
<li>-U 用来将密码文件中的明文密码改成加密格式。如果文件中的密码已经是 hash 值，千万不要用这个选项，否则它会对 hash 值再做一次运算，然后修改密码文件。</li>
</ul>

<p>设好密码后，在配置文件中设置 <code>allow_anonymous false</code> 再用 <code>password_file</code> 指定密码文件的路径就可以使用了。配置文件可以放在任何位置，只要 mosquitt 能找到它。配置文件中，每一行设置一个选项，选项名称和值用空格隔开，用井号可以注释。安装好的 mosquitto 在 /etc/mosquitto/ 目录下有配置文件和密码文件的例子，复制一份皆可使用：</p>

<pre><code>$ ls /etc/mosquitto/
aclfile.example  mosquitto.conf.example  pskfile.example  pwfile.example
</code></pre>

<p>客户端可以通过订阅 $SYS 层的主题来获取 broker 的信息，这些主题每 sys_interval 秒更新一次，如果 sys_interval 设为 0 则不会发送，标记为 static 的主题只会为每个订阅者发送一次。如果是在命令行中使用，要用反斜杠把 $SYS 作为普通字符串传递给客户端，否则 $SYS 会被当做环境变量来处理。</p>

<ul>
<li>$SYS/broker/bytes/received ，broker 从启动开始收到的总字节数。</li>
<li>$SYS/broker/bytes/sent ，broker 从启动开始发送的总字节数。</li>
<li>$SYS/broker/clients/connected, $SYS/broker/clients/active (不建议使用)，当前连接的客户端数目。</li>
<li>$SYS/broker/clients/expired ，由于 persistent_client_expiration 选项过期而断开的客户端数量。</li>
<li>$SYS/broker/clients/disconnected, $SYS/broker/clients/inactive (不建议使用)，所有断开的已注册客户端（包括清除进程）的数量。</li>
<li>$SYS/broker/clients/maximum ，过去所有时间所连接的最大客户端数量（从服务器开机开始）。</li>
<li>$SYS/broker/clients/total ，所有连接过的客户端数量(包括活跃的客户端和已经断开的客户端数量)。</li>
<li>$SYS/broker/connection/# ，当代理服务器被配置为桥接模式的时候, 通常做法是提供一种状态话题来只是连接的状态，这个话题默认为 $SYS/broker/connection/， 如果数值为1，证明连接是活跃的,为0证明连接不活跃. 查看桥接一节来获取更多信息。</li>
<li>$SYS/broker/heap/current size ，mosquitto 当前使用的最大内存，请注意，由于编译时候的选择这个话题可能不可用。</li>
<li>$SYS/broker/heap/maximum size ，mosquitto 曾经使用的最大内存，请注意，由于编译时候的选择这个话题可能不可用。</li>
<li>$SYS/broker/load/connections/+ ，不同的时间间隔内代理服务器收到连接数据包的平均数量， 最后的+可以为 5分钟、10分钟、15分钟。</li>
<li>$SYS/broker/load/bytes/received/+ ，不同的时间间隔内代理服务器收到的平均比特数， 最后的+可以为 5分钟、10分钟、15分钟。</li>
<li>$SYS/broker/load/bytes/sent/+ ，不同的时间间隔内代理服务器发送的平均比特数， 最后的+可以为 5分钟、10分钟、15分钟。</li>
<li>$SYS/broker/load/messages/received/+ ，不同的时间间隔内代理服务器收到各种类型数据包的平均数量， 最后的+可以为 5分钟、10分钟、15分钟。</li>
<li>$SYS/broker/load/messages/sent/+ ，不同的时间间隔内代理服务器发送各种类型数据包的平均数量， 最后的+可以为 5分钟、10分钟、15分钟。</li>
<li>$SYS/broker/load/publish/dropped/+ ，不同的时间间隔内代理服务器发布数据包丢失的数量， 最后的+可以为 5分钟、10分钟、15分钟。</li>
<li>$SYS/broker/load/publish/received/+ ，不同的时间间隔内代理服务器发布数据包被收到的平均数量， 最后的+可以为 5分钟、10分钟、15分钟。</li>
<li>$SYS/broker/load/publish/sent/+ ，不同的时间间隔内代理服务器发布的数据包被发送的平均数量， 最后的+可以为 5分钟、10分钟、15分钟。</li>
<li>$SYS/broker/load/sockets/+ ，不同的时间间隔内代理服务器打开socket连接平均数量， 最后的+可以为 5分钟、10分钟、15分钟。</li>
<li>$SYS/broker/messages/inflight ，具有QoS&gt;0正在等待的确认消息的数量。</li>
<li>$SYS/broker/messages/received ，从代理服务器开机开始收到的消息总数。</li>
<li>$SYS/broker/messages/sent ，从服务器开机开始所发送的各种类型消息的总数。</li>
<li>$SYS/broker/messages/stored ，在消息存储机制中保留的消息总数，包括客户端保留消息和持久客户端的队列消息。</li>
<li>$SYS/broker/publish/messages/dropped ， 由于队列机制或者传输限制所丢弃数据包的数量. 参照mosquitto.conf 的 max_inflight_messages 和 max_queued_messages 选项获取更多解释。</li>
<li>$SYS/broker/publish/messages/received ，从代理服务器开机开始发布的信息被收到总数。</li>
<li>$SYS/broker/publish/messages/sent ，从代理服务器开机开始发布的信息总数。</li>
<li>$SYS/broker/retained messages/count ，代理服务器中活跃的保留消息的总数。</li>
<li>$SYS/broker/subscriptions/count ，代理服务器中活跃的订阅的总数。</li>
<li>$SYS/broker/timestamp ，代理服务器编译的时间戳. Static.</li>
<li>$SYS/broker/uptime ，服务器合计在线时间（以秒计）。</li>
<li>$SYS/broker/version ，代理服务器版本. Static.</li>
</ul>

<h2 id="3-安全性">3. 安全性</h2>

<p>MQTT 协议没有对安全性设置强制标准，只是在第五章提出了建议，提供合适的安全功能是实现者的责任。默认情况下，mosquitto 不需要任何验证，用户可以匿名连接。如果设置了 allow_anonymous false ，客户端必须提供正确的用户名和密码进行验证，连接时应该将用户名和密码加密传输，否则有被拦截的危险。此外，mosquitto 还提供基于 SSL/TLS 证书的安全验证，使用 OpenSSL 作为 SSL/TLS 的实现。</p>

<h3 id="3-1-ssl-tls">3.1. SSL/TLS</h3>

<p>我们可以通过这个脚本<a href="https://github.com/owntracks/tools/raw/master/TLS/generate-CA.sh" target="_blank">https://github.com/owntracks/tools/raw/master/TLS/generate-CA.sh</a> 自建 CA 并颁发证书：</p>

<pre><code>$ wget https://github.com/owntracks/tools/raw/master/TLS/generate-CA.sh .
$ ./generate-CA.sh
</code></pre>

<p>生成的文件：</p>

<ul>
<li>ca.crt ，CA 根证书</li>
<li>localhost.crt ，mosquitto 服务器上的证书</li>
<li>localhost.key ，mosquitto 服务器上的密钥</li>
</ul>

<p>将这三个文件复制到 /etc/mosquitto/certificates/ 目录下。然后修改配置文件，开启 SSL/TLS ：</p>

<pre><code>port 8883
cafile /etc/mosquitto/certificates/ca.crt
certfile /etc/mosquitto/certificates/localhost.crt
keyfile /etc/mosquitto/certificates/localhost.key
require_certificate true
</code></pre>

<p>启动 mosquitto :</p>

<pre><code>$ mosquitto -c /etc/mosquitto/mosquitto.conf -v
1495335112: mosquitto version 1.4.11 (build date 2017-05-20 17:44:03+0800) starting
1495335112: Config loaded from /etc/mosquitto/mosquitto.conf.
1495335112: Opening ipv4 listen socket on port 8883.
1495335112: Opening ipv6 listen socket on port 8883.
</code></pre>

<p>再用根证书为客户端生成密钥和证书：</p>

<pre><code>$ openssl genrsa -out client.key 2048
$ openssl req -new -out client.csr  -key ./client.key
$ openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAserial ./ca.srl -out client.crt -days 3650 -addtrust clientAuth
</code></pre>

<p>将根证书 ca.crt 、客户端密钥 client.key 、证书 client.crt 发送给客户端，本地测试的话，直接连接 localhost :</p>

<pre><code>$ mosquitto_sub -h localhost -p 8883 -t \$SYS/broker/bytes/\# -v --cafile ca.crt  --cert client.crt --key client.key
$SYS/broker/bytes/received 0
$SYS/broker/bytes/sent 0
</code></pre>

<p>如果设置了 <code>require_certificate false</code> ，就是 SSL 单向认证，客户端只需提供 cafile，也无需设置 &ndash;cert 和 &ndash;key 。如果设置了 <code>allow_anonymous false</code> ，还要提供用户名和密码，否则会客户端会报错：</p>

<pre><code>$ mosquitto_sub -h localhost -p 8883 -t \$SYS/broker/bytes/\# -v --cafile ca.crt  --cert client.crt --key client.key
Connection Refused: not authorised.
</code></pre>

<h3 id="3-2-websockets-with-ssl-tls">3.2. WebSockets with SSL/TLS</h3>

<p>mosquitto 编译时默认是不支持 WebSockets 的，需要在 config.mk 中将 <code>WITH_LIBWEBSOCDETS:=no</code> 改为 yes 。在配置文件中追加 WebSockets 的选项，并加上用户名和密码：</p>

<pre><code>listener 8884
protocol websockets
password_file /etc/mosquitto/mosquitto.password
</code></pre>

<p>然后重启 mosquitto 。可以在 <a href="http://www.hivemq.com/demos/websocket-client/" target="_blank">http://www.hivemq.com/demos/websocket-client/</a> 页面测试，这是一个 Websockets Client 。输入 mosquitto 服务器的 IP 、端口、用户名和密码，即可连接，然后添加订阅话题：</p>

<p><img src="/images/2015-08-11/2015-08-11_6.jpg" alt="" /></p>

<h2 id="4-libmosquitto-库">4. libmosquitto 库</h2>

<p>关于客户端的编程可以参考 mosquitto_sub 和 mosquitto_pub 的源码。libmosquitto API 文档：<a href="http://mosquitto.org/api/files/mosquitto-h.html" target="_blank">http://mosquitto.org/api/files/mosquitto-h.html</a></p>

<h3 id="4-1-获取库版本">4.1. 获取库版本</h3>

<p>libmosquitto 是 C 语言共享库，可以创建 MQTT 客户端程序。所有的 API 函数都有 <code>mosquitto_</code> 前缀。</p>

<pre><code>int mosquitto_lib_version(int *major,int *minor,int *revision);
</code></pre>

<p>获取库的版本信息，返回到三个参数中。</p>

<h3 id="4-2-初始化和清除">4.2. 初始化和清除</h3>

<pre><code>int mosquitto_lib_init();    
int mosquitto_lib_cleanup();     
</code></pre>

<p>使用 libmosquitto 库函数前，要先调用 <code>mosquitto_lib_init()</code> 初始化；使用 libmosquitto 库后，要调用 <code>mosquitto_lib_cleanup()</code> 完成清除工作。</p>

<h3 id="4-3-构建和释放客户端">4.3. 构建和释放客户端</h3>

<pre><code>struct mosquitto *mosquitto_new(const char *id, bool clean_session, void *userdata);     
</code></pre>

<p>新建一个 mosquitto 客户端实例。调用成功时，返回一个 struct mosquitto 指针，失败时返回 NULL 指针，并产生错误代码，可以用 <code>mosquitto_strerror()</code> 函数获取错误代码的含义。第一个参数需要传递一个字符串作为 client ID ，如果设为 NULL ，会自动生成一个随机 ID 。第二个参数是布尔型，如果设为 false ，当 client 断开连接后，broker 会保留该 client 的订阅和消息，直到再次连接成功；如果设为 true ，client 断开连接后，broker 会将所有的订阅和消息删除。第三个参数是传递给回调函数的用户数据。</p>

<p>释放一个 mosquitto 客户端对象：</p>

<pre><code>void mosquitto_destroy(struct mosquitto *mosq);  
</code></pre>

<p>还用一个函数 <code>mosquitto_reinitialise()</code> 可以重新初始化一个已经存在的客户端实例。</p>

<h3 id="4-4-验证和编码">4.4. 验证和编码</h3>

<p>如果 broker 要求提供用户名和密码，可以通过函数设置提供，用户名和密码都是通过字符串传递的：</p>

<pre><code>int mosquitto_username_pw_set(  struct mosquitto *  mosq,
                                const char *username,
                                const char *password
                            );
</code></pre>

<h3 id="4-5-发布">4.5. 发布</h3>

<pre><code>int mosquitto_publish(  struct mosquitto *mosq,
                        int *mid,
                        const char *topic,
                        int payloadlen,
                        const void *payload,
                        int qos,
                        bool retain 
                     );
</code></pre>

<p>发布一个消息。第一个参数是 client 实例。第二个参数要指向一个整数，不能为 NULL ，它会被当做这个消息的 ID 。payloadlen 表示消息的长度，*playload 表示消息的内容。 qos 表示服务质量，retain 表示是否保留信息，详细含义可以查看 MQTT 协议的 3.1 节，对 PUBLISH 控制报文的详细描述。</p>

<h3 id="4-6-订阅">4.6. 订阅</h3>

<pre><code>int mosquitto_subscribe( struct mosquitto *mosq,
                            int *mid,
                            const char *sub,
                            int qos 
                        );
</code></pre>

<p>向 broker 发送 SUBSCRIBE 报文请求订阅一个话题。第一个参数是 client 实例。第二个参数如果不为 NULL ，函数会把它作为该话题消息的 ID ，它可以用于订阅回调函数。第三个参数是话题名称。第四个参数是向 broker 请求的服务质量：
* 0 表示最多分发一次，消息的分发依赖于底层网络的能力。接收者不会发送响应，发送者也不会重试。消息可能送达一次也可能根本没送达。
* 1 表示确保消息至少送达一次，需要发布者和订阅者双方在报文中确认，可能重复。
* 2 表示仅分发一次，这是最高等级的服务质量，消息丢失和重复都是不可接受的。使用这个服务质量等级会有额外的开销。</p>

<p>调用成功会返回 MOSQ_ERR_SUCCESS ，但这不代表订阅成功。关于消息质量的详情可以查看 MQTT 协议的 4.3 节。</p>

<p>取消订阅的函数是：</p>

<pre><code>int mosquitto_unsubscribe( struct mosquitto *mosq,
                            int *mid,
                            const char *sub,
                        );
</code></pre>

<h3 id="4-7-遗嘱">4.7. 遗嘱</h3>

<p>简单的说，当 broker 检测到网络故障、客户端异常等问题，需要关闭某个客户端的连接时，可以向该客户端发布一条消息，叫做遗嘱消息。默认是没有遗嘱消息的，需要用函数设置遗嘱消息的话题、内容、服务质量等，在连接时由客户端告诉 broker ：</p>

<pre><code>int mosquitto_will_set(struct   mosquitto *mosq,
                        const char *topic,
                        int payloadlen,
                        const void *payload,
                        int qos,
                        bool retain
                        );
</code></pre>

<p>该函数必须在 <code>mosquitto_connect()</code> 之前调用。对应的清除遗嘱的函数是：</p>

<pre><code>int mosquitto_will_clear(struct mosquitto *mosg);
</code></pre>

<h3 id="4-8-连接和断开">4.8. 连接和断开</h3>

<pre><code>int mosquitto_connect(  struct mosquitto *mosq,
                            const char *host,
                            int port,
                            int keepalive,
                            );
</code></pre>

<p>连接一个 broker 。第一个参数是 client 实例。第二个参数是 broker 的 IP 或者 hostname 。第三参数是连接的端口，通常是 1883 。第四个参数是保持连接的时间间隔，单位是秒，关于这个参数的详细含义可以查看 MQTT 协议的 CONNECT  报文格式。连接成功会返回 MOSQ_ERR_SUCCESS 。</p>

<p>该函数还有一些扩展，比如可以绑定本地网络接口的 <code>mosquitto_connect_bind</code> 。如果调用了这两个函数连接 broker ，就必须使用 <code>mosquitto_loop()</code> 或者 <code>mosquitto_loop_forever()</code> 启动网络循环。还有一些非阻塞的连接函数，例如 <code>mosquitto_connect_async()</code>，调用它们的时候，必须使用 <code>mosquitto_loop_start()</code> 启动网络循环。断开连接可以调用 <code>int mosquitto_disconnect(struct mosquitto *mosq)</code> ，此外还有重连函数 <code>mosquitto_reconnect()</code>。</p>

<h3 id="4-9-网络循环">4.9. 网络循环</h3>

<pre><code>int mosquitto_loop(struct mosquitto *mosq,
                    int timeout,
                    int max_packets
                    );
</code></pre>

<p>客户端主网络循环，必须调用该函数来保持 client 和 broker 之间的通讯。收到或者发送消息时，它会调用相应的回调函数处理。当 QoS&gt;0 时，它还会尝试重发消息。第一个参数是 client 实例。timeout 是阻塞等待时间，单位是微妙，设为 0 表示立即返回，设为负数表示使用默认值 1000ms 。max_packets 目前没有使用，设为 1 即可。</p>

<p>通常不会直接调用 <code>mosquitto_loop()</code> 。如果程序里只会运行一个 MQTT client 的循环，可以调用 <code>mosquitto_loop_forever()</code> ，参数完全相同:</p>

<pre><code>int mosquitto_loop_forever(struct mosquitto *mosq,
                    int timeout,
                    int max_packets
                    );
</code></pre>

<p>它会在一个阻塞的无限循环里调用 <code>mosquitto_loop()</code> ，如果从服务器掉线了，它会自动重连。直到在某个回调函数中调用了 <code>mosquito_disconnect()</code> ，该函数才会返回。</p>

<p>另一种方法是使用 <code>mosquitto_loop_start()</code> ，调用一次就会新建一个线程，在线程里不停的调用 <code>mosquitto_loop()</code> 来处理网络信息。</p>

<p>如果要将 mosquitto 客户端操作与您自己的 <code>select()</code> 调用集成，请使用 <code>mosquitto_socket()</code>，<code>mosquitto_loop_read()</code>，<code>mosquitto_loop_write()</code> 和 <code>mosquitto_loop_misc()</code> 函数。</p>

<h3 id="4-10-回调函数">4.10. 回调函数</h3>

<p>设置不同的回调函数，<code>mosquitt_loop()</code> 会根据不同的情况，调用相应的回掉函数。</p>

<p>####确认连接回调函数</p>

<pre><code>void mosquitto_connect_callback_set(struct mosquitto *mosq, 
    void (*on_connect)(struct mosquitto *mosq, void *obj, int rc)
    );
</code></pre>

<p>当 client 请求连接后，broker 会回应一条 CONNECK 消息（确认连接请求），client 收到后会调用回调函数。我们可以在这个回调函数里判断连接是否成功，成功后再调用 <code>mosquitto_subscribe()</code> 订阅话题，可以依次订阅多个话题。第一个参数是用 <code>mosquitto_new()</code> 函数新建的 client 实例。第二个参数是回调函数。回调函数的三个参数：</p>

<ul>
<li>mosq ，client 实例</li>
<li>obj ， <code>mosquitto_new()</code> 函数提供的用户数据</li>
<li>rc ，broker 回应的代码，0 表示连接成功，其他值表示拒绝连接，可以用 <code>mosquitto_connack_string()</code> 函数获取代码的含义。</li>
</ul>

<p>####断开连接回调函数</p>

<pre><code>void mosquitto_disconnect_callback_set(struct mosquitto *mosq,
        void (*on_disconnect)(struct mosquitto *mosq, void *obj, int rc)
        );
</code></pre>

<p>当 client 与 broker 断开连接后，会调用这里设置的函数。回调函数中的 rc 表示断开连接的原因，0 表示 client 调用了 <code>mosquitt_disconnect()</code> ，其他值都表示未知原因。我们可以在这个函数里判断客户端是否意外掉线。</p>

<p>####消息回调函数</p>

<pre><code>void mosquitto_message_callback_set( struct mosquitto *mosq,
    void (*on_message)(struct mosquitto *mosq, void *obj, const struct mosquitto_message *message)
);
</code></pre>

<p>当 client 收到 broker 发来的消息时会调用它。第一个参数是 client 实例。第二个参数是回调函数，它的第二个参数是 <code>mosquitto_new()</code> 函数提供的用户数据。第三个参数保存了收到的消息，回掉函数退出后这个指针指向的内存就会被释放，它的定义是：</p>

<pre><code>struct mosquitto_message{
    int mid;
    char *topic;  //消息话题
    void *payload;  //消息内容，MQTT 中叫做有效载荷
    int payloadlen;  //消息的长度，单位是字节
    int qos;  //服务质量
    bool retain;  //是否保留消息
};
</code></pre>

<p>qos 和 retain 的详细含义可以查看 MQTT 协议的 3.1 节，对 PUBLISH 控制报文的详细描述。</p>

<p>####订阅回调函数</p>

<pre><code>void mosquitto_subscribe_callback_set(struct mosquitto *mosq,
        void (*on_subscribe)(struct mosquitto *mosq, void *obj, int mid, int qos_count, const int *granted_qos)
        );
</code></pre>

<p>broker 收到订阅请求后，会向 client 发送一个 SUBACK 报文作为回应，client 收到后就会调用这里设置的函数，可以在回调函数里判断订阅是否成功。回调函数中， mid 表示消息 ID ，granted_qos 指向一个数组，里面存放的是每一个已经批准的订阅的 QoS ，qos_count 表示 granted_qos 数组的大小。</p>

<p>####取消订阅回调函数</p>

<pre><code>void mosquitto_unsubscribe_callback_set(struct mosquitto *mosq,
        void (*on_unsubscribe)(struct mosquitto *mosq, void *obj, int mid)
        );
</code></pre>

<p>broker 收到取消订阅的请求后，会想 client 发送一个 UNSUBACK 报文作为回应，client 收到后就会调用这里设置的函数。</p>

<p>####日志回调函数</p>

<pre><code>void mosquitto_log_callback_set(struct mosquitto *mosq,
        void (*on_log)(struct mosquitto *mosq, void *obj, int level, const char *str)
        );
</code></pre>

<p>当 libmosquitto 产生日志信息时会调用这里设置的函数，我们可以在回调函数中打印这些日志。level 表示日志信息的等级，包括 MOSQ_LOG_INFO、MOSQ_LOG_NOTICE、MOSQ_LOG_WARNING、MOSQ_LOG_ERR 和 MOSQ_LOG_DEBUG 。str 是日志信息的内容。</p>

<h2 id="5-后记">5. 后记</h2>

<p>其实，目前可选的 MQTT Borker 很多，除了 mosquitto ，还有 Apache Apollo，支持多种协议，还有国人开发 <a href="http://emqtt.io" target="_blank">emqtt</a>，号称是百万级分布式开源物联网MQTT消息服务器。还有一个跟好用的 MQTT client —— paho ，也是开源产品，支持多种语言，包括 C 、C++、Python、Java、JavaScript 等。</p>

<h2 id="6-参考">6. 参考</h2>

<ul>
<li><a href="https://www.gitbook.com/book/mcxiaoke/mqtt-cn" target="_blank">MQTT 协议中文版</a></li>
<li><a href="http://dataguild.org/?p=6817" target="_blank">MQTT 入门篇</a></li>
<li><a href="http://dataguild.org/?p=6846" target="_blank">MQTT 进阶篇</a></li>
<li><a href="http://dataguild.org/?p=6866" target="_blank">MQTT 安全篇</a></li>
<li><a href="http://dataguild.org/?p=6957" target="_blank">MQTT 实战篇</a></li>
<li><a href="http://qinfei.lexinsmart.com/2015/09/mosquitto协议之-mosquitto8-the-broker/" target="_blank">mosquitto 协议之 mosquitto(8) – the broker</a></li>
<li><a href="http://www.steves-internet-guide.com/mosquitto-tls/" target="_blank">Mosquitto SSL Configuration</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Python 的多线程</title>
            <link>https://shaocheng.li/posts/2015/07/27/</link>
            <pubDate>Mon, 27 Jul 2015 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2015/07/27/</guid>
            <description>Python 的标准库提供了两个模块支持多线程：thread 和 threading ，thread 是低级模块，threading 是对 thread 进行了封装的高级模块，通常直接用 threading 模块。
threading 库：https://docs.python.org/2/library/threading.html
1. 创建线程 threading 模块定义了 Thread 对象，创建一个线程就是创建一个 Thread 实例，用 name 参数指定线程的名称，用 target 参数指定该线程执行的函数。然后调用 start() 方法开始执行，join() 方法的作用是等待线程结束，它可以带一个参数，表示超时时间：
import threading,time def loop(): print &amp;quot;this a thread&amp;quot; n=0 while n&amp;lt;5: print &amp;quot;n = %d&amp;quot; %(n) n=n+1 time.sleep(1) print &amp;quot;thread exit&amp;quot; print &amp;quot;thread running...&amp;quot; t=threading.Thread(target=loop) t.start() t.join() print &amp;quot;thread ended&amp;quot;  我们还可以通过创建自己的线程类来使用多线程，这个类需要继承 threading.Thread ,然后重写 Thread 对象的 run() 方法，run() 方法就是这个线程要实现的功能，调用 start() 方法就会执行 run() ，例如：</description>
            <content type="html"><![CDATA[

<p>Python 的标准库提供了两个模块支持多线程：thread 和 threading ，thread 是低级模块，threading 是对 thread 进行了封装的高级模块，通常直接用 threading 模块。</p>

<p>threading 库：<a href="https://docs.python.org/2/library/threading.html" target="_blank">https://docs.python.org/2/library/threading.html</a></p>

<h2 id="1-创建线程">1. 创建线程</h2>

<p>threading 模块定义了 Thread 对象，创建一个线程就是创建一个 Thread 实例，用 name 参数指定线程的名称，用 target 参数指定该线程执行的函数。然后调用 start() 方法开始执行，join() 方法的作用是等待线程结束，它可以带一个参数，表示超时时间：</p>

<pre><code>import threading,time

def loop():
        print &quot;this a thread&quot;
        n=0
        while n&lt;5:
                print &quot;n = %d&quot; %(n)
                n=n+1
                time.sleep(1)
        print &quot;thread exit&quot;

print &quot;thread running...&quot;
t=threading.Thread(target=loop)
t.start()
t.join()
print &quot;thread ended&quot;
</code></pre>

<p>我们还可以通过创建自己的线程类来使用多线程，这个类需要继承 threading.Thread ,然后重写 Thread 对象的 run() 方法，run() 方法就是这个线程要实现的功能，调用 start() 方法就会执行 run() ，例如：</p>

<pre><code>import threading,time

class my_thread(threading.Thread):
        def __init__(self,t_name):
                self.n=0
                threading.Thread.__init__(self,name=t_name)
        def run(self):
                while self.n&lt;5:
                        print self.getName(),&quot;:&quot;,self.n
                        self.n=self.n+1
                        time.sleep(1)

def main():
        t=my_thread('thread_a')
        t.start()
        t.join()

if __name__=='__main__':
        main()
</code></pre>

<p>输出结果是：</p>

<pre><code>thread_a : 0
thread_a : 1
thread_a : 2
thread_a : 3
thread_a : 4
</code></pre>

<p>threading 提供了一个属性 deamon ，默认值是 False ，表示这个线程不是守护线程，当主线程退出时，该线程也会退出。如果设为 True ，这个线程就是守护线程，当主线程退出时，该线程可以继续运行。</p>

<h2 id="2-线程同步">2. 线程同步</h2>

<p>当多个线程访问共享资源时，需要实现线程间的同步，threading 提供了多个对象实现不同的同步功能。</p>

<h3 id="2-1-lock">2.1 Lock</h3>

<p>Lock 对象是最基本的同步方式，相当于互斥锁。使用时，先创建一个锁，然后在访问共享资源时调用 acquire() 方法获取锁，访问完毕再调用 release() 方法释放锁。</p>

<p>acquire() 方法有一个参数 blocking ，默认值为 True ，表示该函数会阻塞，直到获取锁；如果设为 False ，表示非阻塞，函数会立即返回。</p>

<p>release() 方法会释放当前的锁，如果这个锁本来就没被获取，会抛出 ThreadError 异常；</p>

<pre><code>import threading,time

n=0
lock=threading.Lock()

def add_num():
        global n
        while True:
                lock.acquire()
                n=n+1
                n=n-1
                print n
                lock.release()
                time.sleep(1)

print &quot;thread running...&quot;
t1=threading.Thread(target=add_num)
t2=threading.Thread(target=add_num)
t1.start()
t2.start()
t1.join()
t2.join()
print &quot;thread ended&quot;
</code></pre>

<h3 id="2-2-rlock">2.2 RLock</h3>

<p>Lock 锁是不能嵌套申请的，否则必然死锁。Threading 模块提供了另一个对象 RLock ，可重入的互斥锁。该对象内部维护了一个 Lock 对象和一个引用计数，记录 acquire 的次数，可以多次 acquire ，acquire 和 release 必须严格配对，所有的 acquire 最后必须都 release 。</p>

<pre><code>import threading,time

n=0
lock=threading.RLock()

def add_num():
        global n
        while True:
                if lock.acquire():
                        n=n+1
                        print &quot;1 &quot;,n
                        if lock.acquire():
                                n=n-1
                                print &quot;2 &quot;,n
                        lock.release()
                lock.release()
                time.sleep(1)

print &quot;thread running...&quot;

t=threading.Thread(target=add_num)
t.start()
t.join()

print &quot;thread ended&quot;
</code></pre>

<h3 id="2-3-condition">2.3 Condition</h3>

<p>Condition 可以称为条件变量。它的构造函数需要一个 Lock 对象作为参数，如果没有这个参数，Condition 将在内部自行创建一个 Rlock 对象，所有它依然可以调用 acquire() 和 release() 方法。它还提供了 wait() 和 notify() 方法。</p>

<p>当一个线程用 acquire() 获取了一个条件变量，可以调用 wait() 使线程放弃这个锁，进入阻塞状态，直到其他线程用同一个条件变量的 notify() 方法唤醒它。wait() 方法有一个 timeout 参数可以设置阻塞超时。notify() 方法的参数 n 表示唤醒 n 个线程，默认值是 1 。如果是调用 notifyAll() 方法，将会唤醒该条件变量上阻塞的所有线程。</p>

<p>下面是一个生产者和消费者的例程：</p>

<pre><code>import threading

x=0
con = threading.Condition()  

class Producer(threading.Thread):  
    def __init__(self, t_name):  
        threading.Thread.__init__(self, name=t_name)  
    def run(self):  
        global x  
        con.acquire()  
        if x &gt; 0:  
            con.wait()  
        else:  
            for i in range(5):  
                x=x+1  
                print &quot;producing...&quot; + str(x)  
            con.notify()  
        print x  
        con.release()  


class Consumer(threading.Thread):  
    def __init__(self, t_name):  
        threading.Thread.__init__(self, name=t_name)  
    def run(self):  
        global x  
        con.acquire()  
        if x == 0:  
            print 'consumer wait...'  
            con.wait()  
        else:  
            for i in range(5):  
                x=x-1  
                print &quot;consuming...&quot; + str(x)  
            con.notify()  
        print x  
        con.release()  

print 'start consumer'  
c=Consumer('consumer')  
print 'start producer'  
p=Producer('producer')  
p.start()  
c.start()  
p.join()  
c.join()  
print x  
</code></pre>

<h2 id="3-timer">3. Timer</h2>

<p>Timer 是 Thread 的子类，可以实现定时执行某个函数的功能。Timer 的构造方法如下：</p>

<pre><code>class threading.Timer(interval, function, args=[], kwargs={})
</code></pre>

<p>fuction 会在 Timer 启动后 interval 秒开始执行，args 和 kwargs 表示传入 fuction 的参数和可变参数。构造了 Timer 的实例后，可以直接调用 start() 方法启动 Timer 。调用 cancel() 方法可以停止 Timer ，并停止 Timer 启动的函数。</p>

<p>下面这个例程会在启动 Timer 后 5 秒是执行 hello 函数：</p>

<pre><code>import threading

def hello(arg):
        print &quot;Hello World&quot;
        print arg

t=threading.Timer(5,hello,[&quot;Yes&quot;])
t.start()
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>Python 对 JSON 的处理</title>
            <link>https://shaocheng.li/posts/2015/07/21/</link>
            <pubDate>Tue, 21 Jul 2015 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2015/07/21/</guid>
            <description>1.什么是 JSON JSON 介绍：http://json.org/json-zh.html
JSON 是 JavaScript 对象表示法语法的子集，是一种轻量级的数据交换格式。一个 JSON 对象是 “名称:值” 对的无序集合，用花括号包含，“名称:值” 对包含一个字段名称（在双引号中），然后跟一个冒号，最后是值，例如：
{ &amp;quot;name&amp;quot;: &amp;quot;sample_app&amp;quot;, &amp;quot;cmd&amp;quot;: [&amp;quot;python&amp;quot;, &amp;quot;$MOD/sample.py&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;$MOD/init.cfg&amp;quot;], &amp;quot;depends&amp;quot;: [&amp;quot;modbus_USBV0&amp;quot;, &amp;quot;cloud_client&amp;quot;, &amp;quot;defaultdb&amp;quot;], &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot; }  这里的值可以是：
 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） 对象（在花括号中） null  2.json 库 Python 提供了 json 库（https://docs.python.org/2/library/json.html），可以完成对 JSON 对象的编解码（encoding and decoding），就是 JSON 对象转换为 Python 的数据结构，或者逆过程：
   JSON Python     Object dict   string string   number int,long,float   array list,tuple   true True   false False   null None    基本操作 dumps 方法可以将 Python 数据转换为 JSON 格式的字符串，然后返回，例如：</description>
            <content type="html"><![CDATA[

<h2 id="1-什么是-json">1.什么是 JSON</h2>

<p>JSON 介绍：<a href="http://json.org/json-zh.html" target="_blank">http://json.org/json-zh.html</a></p>

<p>JSON 是 JavaScript 对象表示法语法的子集，是一种轻量级的数据交换格式。一个 JSON 对象是 “名称:值” 对的无序集合，用花括号包含，“名称:值” 对包含一个字段名称（在双引号中），然后跟一个冒号，最后是值，例如：</p>

<pre><code>{
    &quot;name&quot;: &quot;sample_app&quot;,
    &quot;cmd&quot;: [&quot;python&quot;, &quot;$MOD/sample.py&quot;, &quot;-c&quot;, &quot;$MOD/init.cfg&quot;],
    &quot;depends&quot;: [&quot;modbus_USBV0&quot;, &quot;cloud_client&quot;, &quot;defaultdb&quot;],
    &quot;version&quot;: &quot;1.0.0&quot;
}
</code></pre>

<p>这里的值可以是：</p>

<ul>
<li>数字（整数或浮点数）</li>
<li>字符串（在双引号中）</li>
<li>逻辑值（true 或 false）</li>
<li>数组（在方括号中）</li>
<li>对象（在花括号中）</li>
<li>null</li>
</ul>

<h2 id="2-json-库">2.json 库</h2>

<p>Python 提供了 json 库（<a href="https://docs.python.org/2/library/json.html" target="_blank">https://docs.python.org/2/library/json.html</a>），可以完成对 JSON 对象的编解码（encoding and decoding），就是 JSON 对象转换为 Python 的数据结构，或者逆过程：</p>

<table>
<thead>
<tr>
<th>JSON</th>
<th>Python</th>
</tr>
</thead>

<tbody>
<tr>
<td>Object</td>
<td>dict</td>
</tr>

<tr>
<td>string</td>
<td>string</td>
</tr>

<tr>
<td>number</td>
<td>int,long,float</td>
</tr>

<tr>
<td>array</td>
<td>list,tuple</td>
</tr>

<tr>
<td>true</td>
<td>True</td>
</tr>

<tr>
<td>false</td>
<td>False</td>
</tr>

<tr>
<td>null</td>
<td>None</td>
</tr>
</tbody>
</table>

<h3 id="基本操作">基本操作</h3>

<p>dumps 方法可以将 Python 数据转换为 JSON 格式的字符串，然后返回，例如：</p>

<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; obj={ 'name':'Bob', 'data':(1,3) }
&gt;&gt;&gt; encodedjson=json.dumps(obj)
&gt;&gt;&gt; print obj
{'data': (1, 3), 'name': 'Bob'}
&gt;&gt;&gt; print encodedjson
{&quot;data&quot;: [1, 3], &quot;name&quot;: &quot;Bob&quot;}
&gt;&gt;&gt; print type(encodedjson)
&lt;type 'str'&gt;
</code></pre>

<p>从输出结果看，元组转换为了数组，字符串改成了双引号。</p>

<p>loads 方法可以将 JSON 格式的字符串转换为 Python 的 dict 结构，例如：</p>

<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; jsoncode='{ &quot;name&quot;:&quot;Bob&quot;,&quot;data&quot;:[1,2,3] }'
&gt;&gt;&gt; obj=json.loads(jsoncode)
&gt;&gt;&gt; print obj
{u'data': [1, 2, 3], u'name': u'Bob'}
&gt;&gt;&gt; print type(obj)
&lt;type 'dict'&gt;
&gt;&gt;&gt; print obj['name']
Bob
</code></pre>

<p>转换后的字符串前都带有 u 字符，表示这个字符串是 Unicode 编码，并不会影响 dict 的使用。</p>

<h3 id="encoders-and-decoders">Encoders and Decoders</h3>

<p>json 模块提供了两个子类 JSONDecoder 和 JSONEncoder ，负责 JSON 的解码和编码。</p>

<p>JSONDecoder 是解码器，提供了两种方法：</p>

<ul>
<li>decode(s) ，将 JSON 结构的字符串 s 转换为 Python 结构，并返回。</li>
<li>raw_decode(s) ， 同样是解码，但是会返回两个值，第一个是解码后的 Python 结构，第二个值表示解码结束时，走到了 s 的哪个位置，这个方法适用于 s 的末尾有无效数据的情况。</li>
</ul>

<p>例如：</p>

<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; file=open(&quot;package.cfg&quot;)
&gt;&gt;&gt; text=file.read()
&gt;&gt;&gt; print text
{
        &quot;name&quot;: &quot;sample_app&quot;,
        &quot;cmd&quot;: [&quot;python&quot;, &quot;$MOD/sample.py&quot;, &quot;-c&quot;, &quot;$MOD/init.cfg&quot;],
        &quot;depends&quot;: [&quot;modbus_USBV0&quot;, &quot;cloud_client&quot;, &quot;defaultdb&quot;],
        &quot;version&quot;: &quot;1.0.0&quot;
}

hello

&gt;&gt;&gt; obj,raw=json.JSONDecoder().raw_decode(text)
&gt;&gt;&gt; print obj   
{u'depends': [u'modbus_USBV0', u'cloud_client', u'defaultdb'], u'cmd': [u'python', u'$MOD/sample.py', u'-c', u'$MOD/init.cfg'], u'name': u'sample_app', u'version': u'1.0.0'}
&gt;&gt;&gt; print raw
166
&gt;&gt;&gt; obj=json.JSONDecoder().decode(text)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;/usr/lib/python2.7/json/decoder.py&quot;, line 369, in decode
    raise ValueError(errmsg(&quot;Extra data&quot;, s, end, len(s)))
ValueError: Extra data: line 8 column 1 - line 9 column 1 (char 168 - 174)
</code></pre>

<p>package.cfg 的末尾有无效的字符 hello ，用 raw_decode() 可以忽略并解码，用 decode() 就会报错。</p>

<p>JSONEncoder 是编码器，提供了 encode(o) 方法，可以将 Python 结构 o 转换为 JSON 结构的字符串，并返回。</p>
]]></content>
        </item>
        
        <item>
            <title>Linux 系统中的时间</title>
            <link>https://shaocheng.li/posts/2015/07/01/</link>
            <pubDate>Wed, 01 Jul 2015 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2015/07/01/</guid>
            <description>1. 时区 Linux 系统中通过 /etc/localtime 文件设置系统时区，所有的时区文件在 /usr/share/zoneinfo/ 目录下
如果要修改时区，直接将 /usr/share/zoneinfo/ 下的相应时区文件复制到 /etc/ 下，改名为 localtime 即可。
2. 系统时间的显示和设置 常用的显示或设置系统时间的命令是 date 。
直接执行 date 就可以显示当前的日期时间和时区，如果要格式化显示，需要用加号指定格式化参数，例如按 “年-月-日 时:分:秒”当前时间：
~# date +&amp;quot;%Y-%m-%d %H:%M:%S&amp;quot; 2015-07-01 11:00:40  设置时间需要用 -s 参数，例如：
~# date -s &amp;quot;20150701 12:03:00&amp;quot; Wed Jul 1 12:03:00 HKT 2015  查看硬件时钟的时间用 hwclock命令：
~# hwclock Wed Jul 1 11:09:54 2015 -0.127600 seconds  将系统时间写入硬件时钟：
~# hwclock --systohc  读取硬件时钟设置系统时间：
~# hwclock --hctosys  3.</description>
            <content type="html"><![CDATA[

<h2 id="1-时区">1. 时区</h2>

<p>Linux 系统中通过 /etc/localtime 文件设置系统时区，所有的时区文件在 /usr/share/zoneinfo/ 目录下</p>

<p>如果要修改时区，直接将 /usr/share/zoneinfo/ 下的相应时区文件复制到 /etc/ 下，改名为 localtime 即可。</p>

<h2 id="2-系统时间的显示和设置">2. 系统时间的显示和设置</h2>

<p>常用的显示或设置系统时间的命令是 date 。</p>

<p>直接执行 date 就可以显示当前的日期时间和时区，如果要格式化显示，需要用加号指定格式化参数，例如按 “年-月-日 时:分:秒”当前时间：</p>

<pre><code>~# date  +&quot;%Y-%m-%d  %H:%M:%S&quot;  
2015-07-01 11:00:40
</code></pre>

<p>设置时间需要用 -s 参数，例如：</p>

<pre><code>~# date  -s  &quot;20150701 12:03:00&quot;  
Wed Jul  1 12:03:00 HKT 2015
</code></pre>

<p>查看硬件时钟的时间用 hwclock命令：</p>

<pre><code>~# hwclock
Wed Jul  1 11:09:54 2015  -0.127600 seconds
</code></pre>

<p>将系统时间写入硬件时钟：</p>

<pre><code>~# hwclock --systohc
</code></pre>

<p>读取硬件时钟设置系统时间：</p>

<pre><code>~# hwclock --hctosys
</code></pre>

<h2 id="3-c语言的时间转换">3. C语言的时间转换</h2>

<p>C语言对时间的处理函数大部分在 <code>&lt;time.h&gt;</code> 头文件。</p>

<p>函数 time 会返回从 ”1970 年 1 月 1 日 0 点“ 到当前的秒数，如果参数 t 不为空，也会存储在该指针指向的内存里。失败会返回 -1 。函数原型：</p>

<pre><code>time_t time(time_t *t);
</code></pre>

<p>time 返回的时间可读性不好，如果要看到类似 ”2014 年 12 月 7 日“  这样的显示，需要将其转换。用 localtime 函数可以将 time_t 类型转换为本地时间，存储在 tm 结构中：</p>

<pre><code>struct tm
{
    int tm_sec; /* Seconds (0-60) */
    int tm_min; /* Minutes (0-59) */
    int tm_hour; /* Hours (0-23) */
    int tm_mday; /* Day of the month (1-31) */
    int tm_mon; /* Month (0-11) */
    int tm_year; /* Year since 1900 */
    int tm_wday; /* Day of the week (Sunday = 0)*/
    int tm_yday; /* Day in the year (0-365; 1 Jan = 0)*/
    int tm_isdst; /* Daylight saving time flag
     &gt; 0: DST is in effect;
     = 0: DST is not effect;
     &lt; 0: DST information not available */
};

struct tm *localtime(const time_t *timep);
</code></pre>

<p>tm 结构的格式就很清晰了，还可以进一步将这个结构按照指定的格式转换为字符串，这需要 strftime 函数：</p>

<pre><code>size_t strftime(char *outstr, size_t maxsize, const char *format, const struct tm *timeptr);
</code></pre>

<p>strftime 会将 timeptr 结构按照 format 指定的格式转换为字符串，并存储在 outstr 中。maxsize 指定 outstr 的字节数。format 的常用格式命令有 ：</p>

<pre><code>%y 不带世纪的十进制年份（值从0到99）
%Y 带世纪部分的十制年份
%m 十进制表示的月份
%B 月份的全称
%b 月份的简写
%d 十进制表示的每月的第几天
%H 24小时制的小时
%I 12小时制的小时
%M 十时制表示的分钟数
%S 十进制的秒数
%x 标准的日期串
%X 标准的时间串
</code></pre>

<p>获取系统时间并格式化显示的例程：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main ()
{
        time_t sys_time;
        struct tm * local_time;
        char time_buf[30];

        time(&amp;sys_time);
        local_time=localtime(&amp;sys_time);
        strftime(time_buf,30,&quot;%Y-%m-%d %H:%M:%S&quot;,local_time);

        printf(&quot;NOW:%s\n&quot;,time_buf);
        return 0;
}
</code></pre>

<p>该程序的输出：</p>

<pre><code>NOW:2015-07-01 11:53:59
</code></pre>

<h2 id="4-c语言的时间测量">4. C语言的时间测量</h2>

<p>C语言提供了 gettimeofday 函数，它会返回从 1970 年 1 月 1 日 0 点到现在的时间，精确到微秒，保存在 timeval 结构中，函数原型：</p>

<pre><code>#include &lt;sys/time.h&gt;
int gettimeofday(struct timeval *tv, struct timezone *tz);

struct timeval 
{
    time_t      tv_sec;     /* seconds */
    suseconds_t tv_usec;    /* microseconds */
};
</code></pre>

<blockquote>
<p>注：第二个参数已经废止，传入 NULL 即可。</p>
</blockquote>

<p>例如，计算输出 Hello world 的耗时：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;sys/time.h&gt;

int main ()
{
    struct timeval start_time,end_time;

    gettimeofday(&amp;start_time,NULL);
    printf(&quot;Hello world\n&quot;);
    gettimeofday(&amp;end_time,NULL);

    printf(&quot;%ld s %ld us\n&quot;,end_time.tv_sec-start_time.tv_sec,end_time.tv_usec-start_time.tv_usec);
    return 0;
}
</code></pre>

<p>该程序的输出：</p>

<pre><code>Hello world
0 s 41 us
</code></pre>

<h2 id="5-计时器">5. 计时器</h2>

<p>要定时执行某段代码，最简单的方法是用 sleep 函数，它会使进程挂起一段时间，单位是秒，更精确的睡眠需要调用 usleep 函数，它单位是微秒 。</p>

<p>更好的方法是使用 POSIX Timer 。POSIX  Timer 可以为一个进程设置多个计时器，时间到达后，可以通过信号或其他方式通知进程，最高可以达到纳秒级别的精度。</p>

<p>涉及的函数：</p>

<ul>
<li>timer_create ：创建一个新的 Timer；并且指定定时器到时通知机制</li>
<li>timer_delete ：删除一个 Timer</li>
<li>timer_gettime ：Get the time remaining on a POSIX.1b interval timer</li>
<li>timer_settime ：开始或者停止某个定时器。</li>
<li>timer_getoverrun ：获取丢失的定时通知个数。</li>
</ul>

<h3 id="创建-timer">创建 Timer</h3>

<p>使用 Posix Timer 的基本流程很简单，首先调用 timer_create 函数创建一个 Timer。函数原型：</p>

<pre><code>int timer_create(clockid_t clockid, struct sigevent *sevp, timer_t *timerid);
</code></pre>

<p>创建的时候需要指定该 Timer 的一些特性，比如 clock ID。clock ID 即 Timer 的种类，可以为如下任意一种：</p>

<ul>
<li>CLOCK_REALTIME ：Settable system-wide real-time clock；</li>
<li>CLOCK_MONOTONIC   ：Nonsettable monotonic clock</li>
<li>CLOCK_PROCESS_CPUTIME_ID  ：Per-process CPU-time clock</li>
<li>CLOCK_THREAD_CPUTIME_ID   ：Per-thread CPU-time clock</li>
</ul>

<p>CLOCK_REALTIME 时间是系统保存的时间，即可以由 date 命令显示的时间，该时间可以重新设置。比如当前时间为上午 10 点 10 分，Timer 打算在 10 分钟后到时。假如 5 分钟后，我用 date 命令修改当前时间为 10 点 10 分，那么 Timer 还会再等十分钟到期，因此实际上 Timer 等待了 15 分钟。假如您希望无论任何人如何修改系统时间，Timer 都严格按照 10 分钟的周期进行触发，那么就可以使用 CLOCK_MONOTONIC。</p>

<p>CLOCK_PROCESS_CPUTIME_ID 的含义与 setitimer 的 ITIMER_VIRTUAL 类似。计时器只记录当前进程所实际花费的时间；比如还是上面的例子，假设系统非常繁忙，当前进程只能获得 50%的 CPU 时间，为了让进程真正地运行 10 分钟，应该到 10 点 30 分才允许 Timer 到期。</p>

<p>CLOCK_THREAD_CPUTIME_ID 以线程为计时实体，当前进程中的某个线程真正地运行了一定时间才触发 Timer。</p>

<p>timer_create 的第二个参数 struct sigevent 用来设置定时器到时时的通知方式。该数据结构如下：</p>

<pre><code>struct sigevent
{
    int sigev_notify; /* Notification method */
    int sigev_signo; /* Notification signal */
    union sigval sigev_value; /* Data passed with  notification */
    void (*sigev_notify_function) (union sigval);   
    /* Function used for thread notification (SIGEV_THREAD) */
    void *sigev_notify_attributes;
    /* Attributes for notification thread  (SIGEV_THREAD) */
    pid_t sigev_notify_thread_id;
    /* ID of thread to signal (SIGEV_THREAD_ID) */
};
union sigval
{         
    int   sival_int;    /* Integer value */
    void   *sival_ptr;    /* Pointer value */
};
</code></pre>

<p>其中 sigev_notify 表示通知方式，有如下几种：</p>

<ul>
<li>SIGEV_NONE    ：定时器到期时不产生通知。。。</li>
<li>SIGEV_SIGNAL   ：定时器到期时将给进程投递一个信号，用 sigev_signo 指定信号值。</li>
<li>SIGEV_THREAD  ：定时器到期时将启动新的线程进行需要的处理</li>
<li>SIGEV_THREAD_ID ：（仅针对 Linux)定时器到期时将向指定线程发送信号。</li>
</ul>

<p>如果采用 SIGEV_NONE 方式，使用者必须调用timer_gettime 函数主动读取定时器已经走过的时间。类似轮询。</p>

<p>如果采用 SIGEV_SIGNAL 方式，使用者可以选择使用什么信号，用 sigev_signo 表示信号值，比如 SIG_ALARM。</p>

<p>如果使用 SIGEV_THREAD 方式，则需要设置 sigev_notify_function，当 Timer 到期时，将使用该函数作为入口启动一个线程来处理信号；sigev_value 保存了传入 sigev_notify_function 的参数。sigev_notify_attributes 如果非空，则应该是一个指向 pthread_attr_t 的指针，用来设置线程的属性（比如 stack 大小,detach 状态等）。</p>

<p>SIGEV_THREAD_ID 通常和 SIGEV_SIGNAL 联合使用，这样当 Timer 到期时，系统会向由 sigev_notify_thread_id 指定的线程发送信号，否则可能进程中的任意线程都可能收到该信号。这个选项是 Linux 对 POSIX 标准的扩展，目前主要是 GLibc 在实现 SIGEV_THREAD 的时候使用到，应用程序很少会需要用到这种模式。</p>

<h3 id="启动-timer">启动 Timer</h3>

<p>创建 Timer 之后，便可以调用 timer_settime() 函数指定定时器的时间间隔，并启动了。函数原型：</p>

<pre><code>int timer_settime(timer_t timerid, int flags,
const struct itimerspec *new_value,
struct itimerspec * old_value);
</code></pre>

<p>new_value 和 old_value 都是 struct itimerspec 数据结构：</p>

<pre><code>struct itimerspec
{
     struct timespec it_interval; //定时器周期值
     struct timespec it_value; //定时器到期值
};
struct timespec
{
    time_t   tv_sec;  //秒
    long     tv_nsec;  //纳秒
};
</code></pre>

<p>启动和停止 Timer 都可以通过设置 new_value 来实现：</p>

<ul>
<li>new_value-&gt;it_interval 为定时器的周期值，比如 1 秒，表示定时器每隔 1 秒到期；</li>
<li>new_value-&gt;it_value 如果大于 0，表示启动定时器，Timer 将在 it_value 这么长的时间过去后到期，此后每隔 it_interval 便到期一次。如果 it_value 为 0，表示停止该 Timer。</li>
</ul>

<p>有些时候，应用程序会先启动用一个时间间隔启动定时器，随后又修改该定时器的时间间隔，这都可以通过修改 new_value 来实现；假如应用程序在修改了时间间隔之后希望了解之前的时间间隔设置，则传入一个非 NULL 的 old_value 指针，这样在 timer_settime() 调用返回时，old_value 就保存了上一次 Timer 的时间间隔设置。多数情况下我们并不需要这样，便可以简单地将 old_value 设置为 NULL，忽略它。</p>

<h3 id="例程">例程</h3>

<p>下面这个例程使用 SIGEV_THREAD 方式的 timer ，每隔两秒调用一次 timer_thread 函数，将 counter 加一，并打印。主函数等待 counter 等于 5 时退出。</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;
#include &lt;signal.h&gt;

int counter = 0;

void timer_thread(union sigval val)
{
    counter++;
    printf(&quot;counter = %d\n&quot;,counter);
}
int main ()
{
    int ret = 0;
    timer_t timer_id;
    struct sigevent se;
    struct itimerspec ts;

    se.sigev_notify=SIGEV_THREAD;
    se.sigev_notify_function = timer_thread;
    se.sigev_notify_attributes = NULL;

    ret = timer_create(CLOCK_MONOTONIC,&amp;se,&amp;timer_id);
    if(ret&lt;0)
    {
        perror(&quot;timer create failed\n&quot;);
        return -1;
    }

    ts.it_value.tv_sec = 2;
    ts.it_value.tv_nsec = 0;
    ts.it_interval.tv_sec = 2;
    ts.it_interval.tv_nsec = 0;

    ret = timer_settime(timer_id,0,&amp;ts,NULL);
    if(ret&lt;0)
    {
        perror(&quot;timer set failed\n&quot;);
        return -1;
    }

    printf(&quot;...start\n&quot;);
    while(counter&lt;5)
    {
        sleep(1);
    }

    return 0;
}
</code></pre>

<p>编译时要带 -lrt 参数，该程序的输出是：</p>

<pre><code>~# gcc test.c -Wall -lpthread  -lrt -o test
~# ./test 
...start
counter = 1
counter = 2
counter = 3
counter = 4
counter = 5
</code></pre>

<h2 id="参考">参考</h2>

<p><a href="http://www.ibm.com/developerworks/cn/linux/1307_liuming_linuxtime1/" target="_blank">浅析 Linux 中的时间编程和实现原理</a></p>
]]></content>
        </item>
        
        <item>
            <title>Python 学习资料</title>
            <link>https://shaocheng.li/posts/2015/06/13/</link>
            <pubDate>Sat, 13 Jun 2015 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2015/06/13/</guid>
            <description> 基础教程：  廖雪峰的 Python 2.7 教程 ：http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000 Python 标准库 ： http://python.usyiyi.cn/python_278/library/index.html  网络编程：  Python Socket 网络编程 ：http://www.jianshu.com/p/49750ca1589d Sockets programming in Python ：http://www.ibm.com/developerworks/linux/tutorials/l-pysocks/ Python TCP Communication ：https://wiki.python.org/moin/TcpCommunication  数据库  SQLite 教程 ：http://www.w3cschool.cc/sqlite/sqlite-tutorial.html  Pillow  Pillow 快速入门 ：http://pillow-cn.readthedocs.org/zh_CN/latest/handbook/tutorial.html Pillow Tutorial ：https://pillow.readthedocs.org/handbook/tutorial.html#cutting-pasting-and-merging-images Pillow Reference ：https://pillow.readthedocs.org/reference/index.html  Requests  Python Requests的安装与简单运用 ：http://www.zhidaow.com/post/python-requests-install-and-brief-introduction Python Requests 1.1.0 快速上手： http://requests-docs-cn.readthedocs.org/zh_CN/latest/user/quickstart.html  爬虫  Python 爬虫系列教程 ：http://cuiqingcai.com/1052.html Scrapy 框架文档 ：http://scrapy-chs.readthedocs.org/zh_CN/0.24/index.html  </description>
            <content type="html"><![CDATA[

<h2 id="基础教程">基础教程：</h2>

<ul>
<li>廖雪峰的 Python 2.7 教程 ：<a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000" target="_blank">http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000</a></li>
<li>Python 标准库 ： <a href="http://python.usyiyi.cn/python_278/library/index.html" target="_blank">http://python.usyiyi.cn/python_278/library/index.html</a></li>
</ul>

<h2 id="网络编程">网络编程：</h2>

<ul>
<li>Python Socket 网络编程 ：<a href="http://www.jianshu.com/p/49750ca1589d" target="_blank">http://www.jianshu.com/p/49750ca1589d</a></li>
<li>Sockets programming in Python ：<a href="http://www.ibm.com/developerworks/linux/tutorials/l-pysocks/" target="_blank">http://www.ibm.com/developerworks/linux/tutorials/l-pysocks/</a></li>
<li>Python TCP Communication ：<a href="https://wiki.python.org/moin/TcpCommunication" target="_blank">https://wiki.python.org/moin/TcpCommunication</a></li>
</ul>

<h2 id="数据库">数据库</h2>

<ul>
<li>SQLite 教程 ：<a href="http://www.w3cschool.cc/sqlite/sqlite-tutorial.html" target="_blank">http://www.w3cschool.cc/sqlite/sqlite-tutorial.html</a></li>
</ul>

<h2 id="pillow">Pillow</h2>

<ul>
<li>Pillow 快速入门 ：<a href="http://pillow-cn.readthedocs.org/zh_CN/latest/handbook/tutorial.html" target="_blank">http://pillow-cn.readthedocs.org/zh_CN/latest/handbook/tutorial.html</a></li>
<li>Pillow Tutorial ：<a href="https://pillow.readthedocs.org/handbook/tutorial.html#cutting-pasting-and-merging-images" target="_blank">https://pillow.readthedocs.org/handbook/tutorial.html#cutting-pasting-and-merging-images</a></li>
<li>Pillow Reference ：<a href="https://pillow.readthedocs.org/reference/index.html" target="_blank">https://pillow.readthedocs.org/reference/index.html</a></li>
</ul>

<h2 id="requests">Requests</h2>

<ul>
<li>Python Requests的安装与简单运用 ：<a href="http://www.zhidaow.com/post/python-requests-install-and-brief-introduction" target="_blank">http://www.zhidaow.com/post/python-requests-install-and-brief-introduction</a></li>
<li>Python Requests 1.1.0 快速上手： <a href="http://requests-docs-cn.readthedocs.org/zh_CN/latest/user/quickstart.html" target="_blank">http://requests-docs-cn.readthedocs.org/zh_CN/latest/user/quickstart.html</a></li>
</ul>

<h2 id="爬虫">爬虫</h2>

<ul>
<li>Python 爬虫系列教程 ：<a href="http://cuiqingcai.com/1052.html" target="_blank">http://cuiqingcai.com/1052.html</a></li>
<li>Scrapy 框架文档 ：<a href="http://scrapy-chs.readthedocs.org/zh_CN/0.24/index.html" target="_blank">http://scrapy-chs.readthedocs.org/zh_CN/0.24/index.html</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Libmodbus 编程说明</title>
            <link>https://shaocheng.li/posts/2015/05/24/</link>
            <pubDate>Sun, 24 May 2015 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2015/05/24/</guid>
            <description>项目主页：http://libmodbus.org
程序中必须包含头文件，编译时连接到 libmodbus ：
#include &amp;lt;modbus.h&amp;gt; cc `pkg-config --cflags --libs libmodbus` files  在程序中使用 libmodbus 主要是如下几个步骤。
1. 新建环境 新建一个 libmodbus 环境，如果是串口连接的modbus设备，用 modbus_new_rtu() 函数，如果是tcp连接的modbus 设备，用 modbus_new_tcp() 函数。如果新建成功会返回一个 struct modbus_t 指针，以后我们操作modbus设备，就是对这个指针进行操作；失败返回空指针。
一个物理接口可以连接多个 modbus 从设备，每个modbus 从设备有自己独立的 ID， 叫做”从设备编号“，是一个整数。所有要用 modbus_set_slave() 函数为 modbus_t 结构设置从设备编号，表示要连接的是哪个 modbus 设备。
释放一个 libmodbus 环境，用 modbus_free() 函数。
2. 连接 新建成功后，就可以建立连接，用 modbus_connect() 函数。 关闭连接用 modbus_class() 函数。 刷新连接用 modbus_flush() 函数。
3. 读写 连接成功后，可以调用相关函数对modbus设备进行操作。
4. 相关函数说明  新建一个 RTU 类型的 libmodbus 环境，返回一个 modbus_t 结构</description>
            <content type="html"><![CDATA[

<p>项目主页：<a href="http://libmodbus.org" target="_blank">http://libmodbus.org</a></p>

<p>程序中必须包含头文件，编译时连接到 libmodbus ：</p>

<pre><code>#include &lt;modbus.h&gt;
cc `pkg-config --cflags --libs libmodbus` files
</code></pre>

<p>在程序中使用 libmodbus 主要是如下几个步骤。</p>

<h2 id="1-新建环境">1. 新建环境</h2>

<p>新建一个 libmodbus 环境，如果是串口连接的modbus设备，用 modbus_new_rtu() 函数，如果是tcp连接的modbus 设备，用 modbus_new_tcp() 函数。如果新建成功会返回一个 struct modbus_t 指针，以后我们操作modbus设备，就是对这个指针进行操作；失败返回空指针。</p>

<p>一个物理接口可以连接多个 modbus 从设备，每个modbus 从设备有自己独立的 ID， 叫做”从设备编号“，是一个整数。所有要用 modbus_set_slave() 函数为 modbus_t 结构设置从设备编号，表示要连接的是哪个 modbus 设备。</p>

<p>释放一个 libmodbus 环境，用 modbus_free() 函数。</p>

<h2 id="2-连接">2. 连接</h2>

<p>新建成功后，就可以建立连接，用 modbus_connect() 函数。
关闭连接用 modbus_class() 函数。
刷新连接用 modbus_flush() 函数。</p>

<h2 id="3-读写">3. 读写</h2>

<p>连接成功后，可以调用相关函数对modbus设备进行操作。</p>

<h2 id="4-相关函数说明">4. 相关函数说明</h2>

<ul>
<li><p>新建一个 RTU 类型的 libmodbus 环境，返回一个 modbus_t 结构</p>

<pre><code>modbus_t *modbus_new_rtu(const char *device, int baud, char parity, int data_bit, int stop_bit); 
</code></pre></li>

<li><p>新建一个 TCP 类型 的 libmodbus 环境 ，返回一个 modbus_t 结构</p>

<pre><code>modbus_t *modbus_new_tcp(const char *ip, int port);
</code></pre></li>

<li><p>设置 slave id ，返回值 EINVAL 表示 slave 值无效</p>

<pre><code>int modbus_set_slave(modbus_t *ctx, int slave); 
</code></pre></li>

<li><p>使能 debug</p>

<pre><code>void modbus_set_debug(modbus_t *ctx, int boolean);
</code></pre>

<p>如果 boolean 为 true ，会使能 ctx 的 debug 标志位，在 stdout 和 stderr 上显示 modbus message ，例如 ：</p>

<pre><code>[00][14][00][00][00][06][12][03][00][6B][00][03]
Waiting for a confirmation…
&lt;00&gt;&lt;14&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;09&gt;&lt;12&gt;&lt;03&gt;&lt;06&gt;&lt;02&gt;&lt;2B&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;
</code></pre></li>

<li><p>设置故障恢复模式</p>

<pre><code>int modbus_set_error_recovery(modbus_t *ctx,modbus_error_recovery_mode error_recovery); 
</code></pre>

<p>参数 error_recovery 可以设置0，或者如下的值：</p>

<p>MODBUS_ERROR_RECOVERY_LINK</p></li>

<li><p>建立一个 modbus 连接。返回0表示成功。失败返回 -1</p>

<pre><code>int modbus_connect(modbus_t *ctx);
</code></pre></li>

<li><p>释放一个 modbus_t 结构。</p>

<pre><code>void modbus_free(modbus_t *ctx);
</code></pre></li>

<li><p>function id 0x01</p>

<pre><code>int modbus_read_bits(modbus_t *ctx, int addr, int nb, uint8_t *dest);
</code></pre>

<p>使用 modbus 功能码 0x01 ，从 addr 读取连续的 nb 个状态位，结果放在 *dest 指向的数组，每个状态位占用一个数组元素，状态为 TRUE 或 FALSE 。成功返回 0 ，失败返回 -1 。</p></li>

<li><p>function id 0x02</p>

<pre><code>int modbus_read_input_bits(modbus_t *ctx, int addr, int nb, uint8_t *dest);
</code></pre>

<p>使用 modbus 功能码 0x02 ，从 addr 读取 nb 个输入状态位，结果放在 *dest 指向的数组，每个状态位占用一个素组元素，状态为 TRUE 或 FALSE 。成功返回 0 ，失败返回 -1 。</p></li>

<li><p>function id 0x03</p>

<pre><code>int modbus_read_registers(modbus_t *ctx, int addr, int nb, uint16_t *dest);
</code></pre>

<p>使用 modbus 功能码 0x03 ，从 addr 地址开始，读取连续的 nb 个寄存器的值，一个寄存器是两个字节。结果存放在 dest 。返回读取寄存器的个数，失败返回 -1 。</p>

<blockquote>
<p>设备上的地址是从 1 开始的，modbus是从0开始寻址，如果要读取1的数据，addr应该设为0.</p>
</blockquote></li>

<li><p>function id 0x05</p>

<pre><code>int modbus_write_bit(modbus_t *ctx, int addr, int status);
</code></pre>

<p>使用 modbus 功能码 0x05 ，向 addr 写一个状态：TRUE 或 FALSE ，成功会返回 0 ，失败返回 -1 。</p></li>

<li><p>function id 0x0F</p>

<pre><code>int modbus_write_bits(modbus_t *ctx, int addr, int nb, const uint8_t *src);
</code></pre>

<p>使用 modbus 功能码 0x0F ，将 *src 指向的数组写入从 addr 开始的 nb 个状态位，数组元素的值应该是 TRUE 或 FALSE ，每个元素对应一个状态位。成功会返回 0 ，失败返回 -1 。</p></li>

<li><p>function id 0x06</p>

<pre><code>int modbus_write_register(modbus_t *ctx, int addr, int value);
</code></pre>

<p>使用 modbus 功能码 0x06 ，将 value 写入地址为 addr 的一个寄存器中。成功会返回 1 ，失败返回 -1 。</p></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>C 语言日志函数库 zlog</title>
            <link>https://shaocheng.li/posts/2015/02/06/</link>
            <pubDate>Fri, 06 Feb 2015 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2015/02/06/</guid>
            <description> 项目主页：http://hardysimpson.github.io/zlog/ 下载地址：https://github.com/HardySimpson/zlog/releases 中文使用手册：http://hardysimpson.github.io/zlog/UsersGuide-CN.html  下载后解压安装：
[21:15]Workspace/ ❯ tar xvf zlog-latest-stable.tar.gz [21:16]Workspace/ ❯ cd zlog-latest-stable [21:17]zlog-latest-stable/ ❯ make  </description>
            <content type="html"><![CDATA[<ul>
<li>项目主页：<a href="http://hardysimpson.github.io/zlog/" target="_blank">http://hardysimpson.github.io/zlog/</a></li>
<li>下载地址：<a href="https://github.com/HardySimpson/zlog/releases" target="_blank">https://github.com/HardySimpson/zlog/releases</a></li>
<li>中文使用手册：<a href="http://hardysimpson.github.io/zlog/UsersGuide-CN.html" target="_blank">http://hardysimpson.github.io/zlog/UsersGuide-CN.html</a></li>
</ul>

<p>下载后解压安装：</p>

<pre><code>[21:15]Workspace/ ❯ tar xvf zlog-latest-stable.tar.gz 
[21:16]Workspace/ ❯ cd zlog-latest-stable 
[21:17]zlog-latest-stable/ ❯ make
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>科学上网利器 Shadowsocks</title>
            <link>https://shaocheng.li/posts/2015/01/20/</link>
            <pubDate>Tue, 20 Jan 2015 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2015/01/20/</guid>
            <description>Shadowsocks 可以为浏览器，支持代理服务器的软件（例如 Dropbox）提供代理服务。
首先购买一个付费的 Shadowsocks 服务账号，推荐 https://shadowsocks.com，不限流量，速度还不错。购买后会提供多个可用的服务器地址，端口，密码和加密方式。
欢迎使用我的推广链接：https://portal.shadowsocks.com/aff.php?aff=424
下载 OS X 客户端：ShadowsocksX。安装后启动，选择 “打开服务器设定” ：
添加服务器，输入服务商提供的域名，端口，密码：
然后就可以科学上网了。客户端已经集成了 GFWList ，可以自动识别访问地址，墙内地址走国内路径，墙外地址走代理服务器。可以添加多个服务器，感觉日本的节点速度更快。
Dropbox 已经完全被墙，修改 hosts 也无法连接，只能用代理。打开 “首选项” ，在“网络”标签中选择 “代理服务器设置”，手动设置服务器类型为 SOCK5 ，服务器地址 127.0.0.1 ，端口 1080：
点击 “更新”，Dropbox 就复活了。</description>
            <content type="html"><![CDATA[<p>Shadowsocks 可以为浏览器，支持代理服务器的软件（例如 Dropbox）提供代理服务。</p>

<p>首先购买一个付费的 Shadowsocks 服务账号，推荐 <a href="https://shadowsocks.com" target="_blank">https://shadowsocks.com</a>，不限流量，速度还不错。购买后会提供多个可用的服务器地址，端口，密码和加密方式。</p>

<p>欢迎使用我的推广链接：<a href="https://portal.shadowsocks.com/aff.php?aff=424" target="_blank">https://portal.shadowsocks.com/aff.php?aff=424</a></p>

<p>下载 OS X 客户端：<a href="https://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-Help" target="_blank">ShadowsocksX</a>。安装后启动，选择 “打开服务器设定” ：</p>

<p><img src="/images/2015-01-20/2015-01-20_1.JPG" alt="" /></p>

<p>添加服务器，输入服务商提供的域名，端口，密码：</p>

<p><img src="/images/2015-01-20/2015-01-20_2.JPG" alt="" /></p>

<p>然后就可以科学上网了。客户端已经集成了 GFWList ，可以自动识别访问地址，墙内地址走国内路径，墙外地址走代理服务器。可以添加多个服务器，感觉日本的节点速度更快。</p>

<p>Dropbox 已经完全被墙，修改 hosts 也无法连接，只能用代理。打开 “首选项” ，在“网络”标签中选择 “代理服务器设置”，手动设置服务器类型为 SOCK5 ，服务器地址 127.0.0.1 ，端口 1080：</p>

<p><img src="/images/2015-01-20/2015-01-20_3.JPG" alt="" /></p>

<p>点击 “更新”，Dropbox 就复活了。</p>
]]></content>
        </item>
        
        <item>
            <title>Today Scripts —— 通过脚本打造自己的通知栏部件</title>
            <link>https://shaocheng.li/posts/2015/01/10/</link>
            <pubDate>Sat, 10 Jan 2015 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2015/01/10/</guid>
            <description>OS X Yosemite 新增了一个通知中心，可以在上面放一些小部件。而 Today Script 这个小部件可以让你写自己的脚本，在通知栏显示自己想要的东西。
 主页：https://github.com/SamRothCA/Today-Scripts 脚本列表：https://github.com/SamRothCA/Today-Scripts/wiki  在主页上点击下载链接，下载一个压缩包：Today-Scripts.tar.gz，解压得到 Today Scripts.app ，放到应用程序文件夹内，然后打开。在通知中心就会出现 Scripts :
点击加号，把它添加到通知栏。按照提示，点击右上角的 Info 图标来添加一个脚本：
添加一个显示当前月份的命令：
cal | grep --before-context 6 --after-context 6 --color -e &amp;quot; $(date +%e)&amp;quot; -e &amp;quot;^$(date +%e)&amp;quot;  记得写上标题：
效果如下：</description>
            <content type="html"><![CDATA[<p>OS X Yosemite 新增了一个通知中心，可以在上面放一些小部件。而 Today Script 这个小部件可以让你写自己的脚本，在通知栏显示自己想要的东西。</p>

<ul>
<li>主页：<a href="https://github.com/SamRothCA/Today-Scripts" target="_blank">https://github.com/SamRothCA/Today-Scripts</a></li>
<li>脚本列表：<a href="https://github.com/SamRothCA/Today-Scripts/wiki" target="_blank">https://github.com/SamRothCA/Today-Scripts/wiki</a></li>
</ul>

<p>在主页上点击下载链接，下载一个压缩包：Today-Scripts.tar.gz，解压得到 Today Scripts.app ，放到应用程序文件夹内，然后打开。在通知中心就会出现 Scripts :</p>

<p><img src="/images/2015-01-10/2015-01-10_1.JPG" alt="" /></p>

<p>点击加号，把它添加到通知栏。按照提示，点击右上角的 Info 图标来添加一个脚本：</p>

<p><img src="/images/2015-01-10/2015-01-10_2.JPG" alt="" /></p>

<p>添加一个显示当前月份的命令：</p>

<pre><code>cal | grep --before-context 6 --after-context 6 --color -e &quot; $(date +%e)&quot; -e &quot;^$(date +%e)&quot;
</code></pre>

<p>记得写上标题：</p>

<p><img src="/images/2015-01-10/2015-01-10_3.JPG" alt="" /></p>

<p>效果如下：</p>

<p><img src="/images/2015-01-10/2015-01-10_4.JPG" alt="" /></p>
]]></content>
        </item>
        
        <item>
            <title>Lua语言学习笔记</title>
            <link>https://shaocheng.li/posts/2015/01/07/</link>
            <pubDate>Wed, 07 Jan 2015 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2015/01/07/</guid>
            <description>Lua （英语发音：/ˈluːə/）是一种轻量级的脚本语言，可以方便的嵌入到其他语言中，很易学习。它是用C语言编写的。广泛应用于游戏和 web 开发中。据说 Adobe Photoshop Lightroom 中 50% 的代码是有 Lua 写的。我学习这个语言是因为目前的项目要用到 LuCI 。
 Lua 的主页：http://www.lua.org 中国开发者论坛：http://www.luaer.cn Lua 程序设计：http://book.luaer.cn Lua 在线手册：http://manual.luaer.cn 酷壳的 Lua 简明教程：http://coolshell.cn/articles/10739.html  1.Hello World Mac 平台默认已经安装了 Lua , 直接执行 lua 就可以进入它的 shell , 首先输出一个 Hello World , 语法很像 C , 结尾有没有分号都可以：
[18:54]~/ ❯ lua Lua 5.2.3 Copyright (C) 1994-2013 Lua.org, PUC-Rio &amp;gt; print(&amp;quot;Hello World&amp;quot;) Hello World &amp;gt;  也可以写一个脚本文件，直接执行：
[18:57]Workspace/ ❯ cat test.lua #!/usr/local/bin/lua print(&amp;quot;Hello World&amp;quot;) [18:57]Workspace/ ❯ .</description>
            <content type="html"><![CDATA[

<p>Lua （英语发音：/ˈluːə/）是一种轻量级的脚本语言，可以方便的嵌入到其他语言中，很易学习。它是用C语言编写的。广泛应用于游戏和 web 开发中。据说 Adobe Photoshop Lightroom 中 50% 的代码是有 Lua 写的。我学习这个语言是因为目前的项目要用到 LuCI 。</p>

<ul>
<li>Lua 的主页：<a href="http://www.lua.org" target="_blank">http://www.lua.org</a></li>
<li>中国开发者论坛：<a href="http://www.luaer.cn" target="_blank">http://www.luaer.cn</a></li>
<li>Lua 程序设计：<a href="http://book.luaer.cn" target="_blank">http://book.luaer.cn</a></li>
<li>Lua 在线手册：<a href="http://manual.luaer.cn" target="_blank">http://manual.luaer.cn</a></li>
<li>酷壳的 Lua 简明教程：<a href="http://coolshell.cn/articles/10739.html" target="_blank">http://coolshell.cn/articles/10739.html</a></li>
</ul>

<h2 id="1-hello-world">1.Hello World</h2>

<p>Mac 平台默认已经安装了 Lua , 直接执行 lua 就可以进入它的 shell , 首先输出一个 Hello World , 语法很像 C , 结尾有没有分号都可以：</p>

<pre><code>[18:54]~/ ❯ lua
Lua 5.2.3  Copyright (C) 1994-2013 Lua.org, PUC-Rio
&gt; print(&quot;Hello World&quot;)
Hello World
&gt; 
</code></pre>

<p>也可以写一个脚本文件，直接执行：</p>

<pre><code>[18:57]Workspace/ ❯ cat test.lua 
#!/usr/local/bin/lua
print(&quot;Hello World&quot;)
[18:57]Workspace/ ❯ ./test.lua 
Hello World
</code></pre>

<h2 id="2-基本语法">2.基本语法</h2>

<h3 id="注释">注释</h3>

<p>两个减号是行注释，两个减号加方括号是块注释：</p>

<pre><code>#!/usr/local/bin/lua
--行注释
--[[
块注释
--]]
print(&quot;Hello World&quot;)
</code></pre>

<h3 id="数据类型和变量">数据类型和变量</h3>

<p>Lua 支持动态数据类型，定义变量时无需声明类型，几个基本的数据类型有：</p>

<ul>
<li>字符串，用引号包含，单引号和双引号都可以；Lua 还支持 C 语言类型的转义字符，例如 \n 换行，\r 回车</li>
<li>实数，Lua 的数只有 double 型，64 bits 浮点数</li>
<li>布尔，true 和 false</li>
<li>空，Lua 的空类型用 nil 表示，没有声明过的变量就是 nil</li>
</ul>

<p><img src="/images/2015-01-07/2015-01-07_1.JPG" alt="" /></p>

<blockquote>
<p>type 是一个函数，它会返回数据的类型</p>
</blockquote>

<p>Lua 中的变量分为全局变量和局部变量，未加说明的都是全局变量，用 local 关键字定义局部变量 ：</p>

<pre><code>theGlobalVar = 50
local theLocalVar = &quot;local variable&quot;
</code></pre>

<h3 id="表达式">表达式</h3>

<p>Lua 的表达式由数字，字符串，变量，运算符组成，运算符分为几个类别，和 C 语言很像：</p>

<ul>
<li>数学运算符：+-*/^ (加减乘除幂），- (负号），这些运算符只能用于实数</li>
<li>关系运算符：&lt; ，&gt; ，&lt;= ，&gt;= ，== ，还有一个 ~= 表示不等；比较结果返回 true 或 false ；如果两个值的类型不同，那么一定是不等的，nil 之和自己相等；比较字符串时，是按照字母的顺序进行的</li>
<li>逻辑运算符：and , or , not ；not 只会返回 true 和 false，除了 false 和 nil ，其他都是 true ，所以 <code>not nil</code> 就是 ture。and 和 or 返回的结果不是 true 或 false，而是和操作数有关：<code>a and b</code> &ndash; 如果a为false，则返回a，否则返回b；<code>a or  b</code> &ndash; 如果a为true，则返回a，否则返回b</li>
<li>连接运算符：..(两个点)，用于连接字符串，如果操作符是数字，会连接后转为字符串。</li>
</ul>

<h3 id="控制语句">控制语句</h3>

<p>if 语句</p>

<pre><code>if conditions then
    then-part
end;

if conditions then
    then-part
else
    else-part
end;

if conditions then
    then-part
elseif conditions then
    elseif-part
..       ---&gt;多个elseif
else
    else-part
end;
</code></pre>

<p>while 循环</p>

<pre><code>while condition do
    statements;
end;
</code></pre>

<p>for 循环</p>

<pre><code>for var=exp1,exp2,exp3 do
    loop-part
end
</code></pre>

<p>exp1 是初始值，exp2 是终止值，exp3是每一步的间隔，如果exp3，默认是1，例如：</p>

<p><img src="/images/2015-01-07/2015-01-07_2.JPG" alt="" /></p>

<h3 id="函数">函数</h3>

<p>函数的定义以 function 关键字开头，以 end 结尾，可以返回多个值。</p>

<p>Lua 有个特别的语法，就是可以一行为多个变量赋值，那么多个返回值就可以依次赋给多个变量。如果值的数量比变量多，多余的会舍弃；如果变量比值多，后面的变量会被赋 nil 。</p>

<p><img src="/images/2015-01-07/2015-01-07_3.JPG" alt="" /></p>
]]></content>
        </item>
        
        <item>
            <title>2014-12-31</title>
            <link>https://shaocheng.li/posts/2014/12/31/</link>
            <pubDate>Wed, 31 Dec 2014 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2014/12/31/</guid>
            <description>2014年的最后一天了
这一年，得到了一些，失去了很多，赚了一点钱，虚度了很多美好的时光。在某个突然醒来的黎明，就在想，应该把生命中最好的时光留给最爱的人，这比什么都重要。
这一年的最后一个月，我在这个城市买了一套房子，人生中的第一套房。12月2日晚上11点，在合同上写下自己的名字，回来的路上下着小雨。
这一年的日志写的太少，可能是因为我没学到什么东西，希望明年会好一点。</description>
            <content type="html"><![CDATA[<p>2014年的最后一天了</p>

<p>这一年，得到了一些，失去了很多，赚了一点钱，虚度了很多美好的时光。在某个突然醒来的黎明，就在想，应该把生命中最好的时光留给最爱的人，这比什么都重要。</p>

<p>这一年的最后一个月，我在这个城市买了一套房子，人生中的第一套房。12月2日晚上11点，在合同上写下自己的名字，回来的路上下着小雨。</p>

<p>这一年的日志写的太少，可能是因为我没学到什么东西，希望明年会好一点。</p>
]]></content>
        </item>
        
        <item>
            <title>在 Linux 中使用 amixer 设置 Input source</title>
            <link>https://shaocheng.li/posts/2014/10/26/</link>
            <pubDate>Sun, 26 Oct 2014 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2014/10/26/</guid>
            <description>电脑的音频输入通常有两个通道：Mic 和 Line in。Mic就是麦克风，Line in 用于连接未经放大的模拟音频信号，例如 Mp3 播放器的耳机插孔，可以将其连接到 PC 的 Line in 插孔。
Linux 上只要用 alsa 管理声卡，它还提供很多工具，alsamixer用于配置音频的各个参数，基于文本下的图形界面。
在命令行输入 alsamixer 就可以启动它的界面，然后按 F6 就可以看到当前系统的网卡，每个网卡都由一个独立的数字 ID ：
这里的网卡是 HDA Intel，ID 是 0。
amixer 是 alsamixer 的命令行模式。
先看看 amixer 的语法：
用 amixer -c 0 scontrols 就可以看到 ID 为 0 的网卡的所有可配置接口：
用 scontents 可以查看这些接口的详细内容，包括可选的选项和当前的选项：
用 sget 可以查看某个接口的详细信息，然后有 sset 就可以设置：
如上图所示，Input source 有三个通道可选：Mic ，Front Mic，Line。Line 就表示 Line in 。用 sset 设置具体通道后，就可以用 arecord 对相应通道录音。</description>
            <content type="html"><![CDATA[<p>电脑的音频输入通常有两个通道：Mic 和 Line in。Mic就是麦克风，Line in 用于连接未经放大的模拟音频信号，例如 Mp3 播放器的耳机插孔，可以将其连接到 PC 的 Line in 插孔。</p>

<p>Linux 上只要用 alsa 管理声卡，它还提供很多工具，alsamixer用于配置音频的各个参数，基于文本下的图形界面。</p>

<p>在命令行输入 alsamixer 就可以启动它的界面，然后按 F6 就可以看到当前系统的网卡，每个网卡都由一个独立的数字 ID ：</p>

<p><img src="/images/2014-10-26/2014-10-26_1.PNG" alt="" /></p>

<p>这里的网卡是 HDA Intel，ID 是 0。</p>

<p>amixer 是 alsamixer 的命令行模式。</p>

<p>先看看 amixer 的语法：</p>

<p><img src="/images/2014-10-26/2014-10-26_2.PNG" alt="" /></p>

<p>用 amixer -c 0 scontrols 就可以看到 ID 为 0 的网卡的所有可配置接口：</p>

<p><img src="/images/2014-10-26/2014-10-26_3.PNG" alt="" /></p>

<p>用 scontents 可以查看这些接口的详细内容，包括可选的选项和当前的选项：</p>

<p><img src="/images/2014-10-26/2014-10-26_4.PNG" alt="" /></p>

<p>用 sget 可以查看某个接口的详细信息，然后有 sset 就可以设置：</p>

<p><img src="/images/2014-10-26/2014-10-26_5.PNG" alt="" /></p>

<p>如上图所示，Input source 有三个通道可选：Mic ，Front Mic，Line。Line 就表示 Line in 。用 sset 设置具体通道后，就可以用 arecord 对相应通道录音。</p>
]]></content>
        </item>
        
        <item>
            <title>个性化定制地图 —— Mapbox</title>
            <link>https://shaocheng.li/posts/2014/10/09/</link>
            <pubDate>Thu, 09 Oct 2014 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2014/10/09/</guid>
            <description>Mapbox 想要构建世界上最漂亮的地图。支持多种平台，可以免费创建并定制个性化的地图，实现非常绚丽的效果。
 主页：http://www.mapbox.com 这里有一个介绍：http://www.pingwest.com/demo/mapbox  定制自己的地图 首先要注册一个账号，然后在主页面上方点击 Project ，进入到如下界面，点击 Create project 就可以新建一个自己的地图。
我新建了一个 My First Map 。点击它，就可以进入编辑界面，左上方是定制地图所需的工具：
Style 这个标签用来设置地图的样式，包括：
 Color ：设置街道，绿地，建筑，水在地图上显示的颜色。 Baselayer ：设置地图的基本图层，有街道地图，地形图和卫星图。 Language ：设置地图的语言，Localized 表示本地语言。  Data 这个标签用来向地图添加自定义的数据，包括：
 Marker ：点状标记。 Line ：线，轨迹。 Poygon ：一块图形，或者区域。  另外，点击下方的 import ，可以导入 csv 、kml 、gpx 格式的数据文件。
Project 这个标签中可以设置地图名称和描述，还可以在此下载和分享地图。
 Info ：Data 栏可以选择下载 GeoJSON 或 KML 格式的地图文件。Map ID 是这个地图的唯一标识符，用于开发。Share 栏是该地图的分享链接。Embed 是该地图嵌入 Web 页面的代码，下面可以选择页面中是否显示放大缩小，搜索和分享链接按钮。 Settings ：设置地图名称和描述。 Advanced ：这里有两个选项，选中 Save current map position 后，通过分享的地图会显示现在所选的位置和大小。选中 Hind Project frome public API ，通过分享的地图可以看到在 Data 中添加的数据。   修改地图后一定要点击上方的 Save 保存。</description>
            <content type="html"><![CDATA[

<p>Mapbox 想要构建世界上最漂亮的地图。支持多种平台，可以免费创建并定制个性化的地图，实现非常绚丽的效果。</p>

<ul>
<li>主页：<a href="http://www.mapbox.com" target="_blank">http://www.mapbox.com</a></li>
<li>这里有一个介绍：<a href="http://www.pingwest.com/demo/mapbox" target="_blank">http://www.pingwest.com/demo/mapbox</a></li>
</ul>

<h2 id="定制自己的地图">定制自己的地图</h2>

<p>首先要注册一个账号，然后在主页面上方点击 Project ，进入到如下界面，点击 Create project 就可以新建一个自己的地图。</p>

<p><img src="/images/2014-10-09/2014-10-09_1.PNG" alt="" /></p>

<p>我新建了一个 My First Map 。点击它，就可以进入编辑界面，左上方是定制地图所需的工具：</p>

<h3 id="style">Style</h3>

<p><img src="/images/2014-10-09/2014-10-09_2.PNG" alt="" /></p>

<p>这个标签用来设置地图的样式，包括：</p>

<ul>
<li>Color ：设置街道，绿地，建筑，水在地图上显示的颜色。</li>
<li>Baselayer ：设置地图的基本图层，有街道地图，地形图和卫星图。</li>
<li>Language ：设置地图的语言，Localized 表示本地语言。</li>
</ul>

<h3 id="data">Data</h3>

<p><img src="/images/2014-10-09/2014-10-09_3.PNG" alt="" /></p>

<p>这个标签用来向地图添加自定义的数据，包括：</p>

<ul>
<li>Marker ：点状标记。</li>
<li>Line ：线，轨迹。</li>
<li>Poygon ：一块图形，或者区域。</li>
</ul>

<p>另外，点击下方的 import ，可以导入 csv 、kml 、gpx 格式的数据文件。</p>

<h3 id="project">Project</h3>

<p><img src="/images/2014-10-09/2014-10-09_4.PNG" alt="" /></p>

<p>这个标签中可以设置地图名称和描述，还可以在此下载和分享地图。</p>

<ul>
<li>Info ：Data 栏可以选择下载 GeoJSON 或 KML 格式的地图文件。Map ID 是这个地图的唯一标识符，用于开发。Share 栏是该地图的分享链接。Embed 是该地图嵌入 Web 页面的代码，下面可以选择页面中是否显示放大缩小，搜索和分享链接按钮。</li>
<li>Settings ：设置地图名称和描述。</li>
<li>Advanced ：这里有两个选项，选中 Save current map position 后，通过分享的地图会显示现在所选的位置和大小。选中 Hind Project frome public API ，通过分享的地图可以看到在 Data 中添加的数据。</li>
</ul>

<p><img src="/images/2014-10-09/2014-10-09_5.PNG" alt="" /></p>

<blockquote>
<p>修改地图后一定要点击上方的 Save 保存。</p>
</blockquote>
]]></content>
        </item>
        
        <item>
            <title>Mac OS X 常用软件和技巧</title>
            <link>https://shaocheng.li/posts/2014/09/09/</link>
            <pubDate>Tue, 09 Sep 2014 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2014/09/09/</guid>
            <description>1.键盘操作 使用 Macbook ，没有合适的鼠标，用了外接键盘后，触摸板也离得远了，尽量是用键盘操作，熟练后效率很高。
按 F1 键打开 Spotlight ,输入要打开的程序名称，同样适用于搜索并打开文件。
Mac 键盘快捷键 ：https://support.apple.com/zh-cn/HT201236
常用快捷键  command + shift + f ：全屏显示当前窗口 command + q ：退出当前程序 command + w ： 关闭当前窗口或标签页 command + t ： 新建窗口或标签页 command + n ： 新建窗口 command + shift + 4 ：截屏，如果再按一次空格，鼠标会变成相机图标，可以选择要解取的程序窗口  Safari 快捷键  command + option + f ：选择到地址栏 command + option + 2 ：打开历史记录 command + d ：收藏当前页面  2. 常用软件 Keka —— 免费开源的文件解压缩软件  http://www.</description>
            <content type="html"><![CDATA[

<h2 id="1-键盘操作">1.键盘操作</h2>

<p>使用 Macbook ，没有合适的鼠标，用了外接键盘后，触摸板也离得远了，尽量是用键盘操作，熟练后效率很高。</p>

<p>按 F1 键打开 Spotlight ,输入要打开的程序名称，同样适用于搜索并打开文件。</p>

<p>Mac 键盘快捷键 ：<a href="https://support.apple.com/zh-cn/HT201236" target="_blank">https://support.apple.com/zh-cn/HT201236</a></p>

<h3 id="常用快捷键">常用快捷键</h3>

<ul>
<li>command + shift + f ：全屏显示当前窗口</li>
<li>command + q ：退出当前程序</li>
<li>command + w ： 关闭当前窗口或标签页</li>
<li>command + t ： 新建窗口或标签页</li>
<li>command + n ： 新建窗口</li>
<li>command + shift + 4 ：截屏，如果再按一次空格，鼠标会变成相机图标，可以选择要解取的程序窗口</li>
</ul>

<h3 id="safari-快捷键">Safari 快捷键</h3>

<ul>
<li>command + option + f ：选择到地址栏</li>
<li>command + option + 2 ：打开历史记录</li>
<li>command + d ：收藏当前页面</li>
</ul>

<h2 id="2-常用软件">2. 常用软件</h2>

<h3 id="keka-免费开源的文件解压缩软件">Keka —— 免费开源的文件解压缩软件</h3>

<ul>
<li><a href="http://www.kekaosx.com/" target="_blank">http://www.kekaosx.com/</a></li>
</ul>

<p>苹果系统自带的压缩软件功能太单一，而且压缩后的 zip 文件在 windows 下会出现乱码，导致识别文件损坏。</p>

<p>Keka 支持多种压缩格式： 7z，zip，tar，gzip 。</p>

<h3 id="mou-免费-markdown-编辑器">Mou —— 免费 Markdown 编辑器</h3>

<ul>
<li><a href="mouapp.com" target="_blank">mouapp.com</a></li>
</ul>

<p>Mou 编辑器的界面非常简洁，分为左右两部分，在左栏写 Markdown 代码，右侧就能实时显示输出效果。还可以设置多种编辑器主题和 CSS 样式，支持导出 HTML 和 PDF 文档。</p>

<p>该软件的作者是 80 后国人。</p>

<h3 id="onyx-免费的系统维护软件">Onyx —— 免费的系统维护软件</h3>

<ul>
<li><a href="http://www.onyxmac.com/" target="_blank">http://www.onyxmac.com/</a></li>
</ul>

<p>Onyx 可以实现很多 “系统偏好设置” 里没有提供的设置，例如默认的截屏保持路径。</p>

<h3 id="brew-os-x-的包管理器">brew —— OS X 的包管理器</h3>

<ul>
<li><a href="http://brew.sh/" target="_blank">http://brew.sh/</a></li>
</ul>

<p>用于从开源社区安装各种包。通过 brew 安装到包都位于 <code>/usr/local/</code> 目录下，不会与系统已有的软件产生干扰。</p>

<h3 id="xmarks">xmarks</h3>

<ul>
<li><a href="www.xmarks.com" target="_blank">www.xmarks.com</a></li>
</ul>

<p>在 Mac 上主要使用 Safari 浏览器，在 Windows 平台主要使用 Chrome 。xmarks 可以实现多个浏览器之间的书签同步，而且是插件的形式。</p>

<h3 id="xtrafinder">Xtrafinder</h3>

<ul>
<li><a href="http://www.trankynam.com/xtrafinder/" target="_blank">http://www.trankynam.com/xtrafinder/</a></li>
</ul>

<p>在 Mac 的 Finder 不太好用，无法新建文件，显示文件属性也比较麻烦，还没有剪切功能。这个软件可以解决这个问题。它将这些功能都集成到了 Finder 中。</p>
]]></content>
        </item>
        
        <item>
            <title>让 Mac 的 Photoshop CS6 支持 ICO 文件</title>
            <link>https://shaocheng.li/posts/2014/07/12/</link>
            <pubDate>Sat, 12 Jul 2014 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2014/07/12/</guid>
            <description>在 http://www.telegraphics.com.au/sw/product/ICOFormat#icoformat页面下载 ico 格式插件。
在如下界面选择 Mac CS5/CS6 ：
然后打开下载的 DMG 文件 。将其中的 ICOFormat.plugin 文件复杂到 photoshop 的插件目录下 :
/Applications/Adobe Photoshop C6/Plug-ins/  OK!
这样就可以新建，保存 ICO 图片了。</description>
            <content type="html"><![CDATA[<p>在 <a href="http://www.telegraphics.com.au/sw/product/ICOFormat#icoformat" target="_blank">http://www.telegraphics.com.au/sw/product/ICOFormat#icoformat</a>页面下载 ico 格式插件。</p>

<p>在如下界面选择 Mac CS5/CS6 ：</p>

<p><img src="/images/2014-07-12/2014-07-12_1.PNG" alt="" /></p>

<p>然后打开下载的 DMG 文件 。将其中的 ICOFormat.plugin 文件复杂到 photoshop 的插件目录下 :</p>

<pre><code>/Applications/Adobe Photoshop C6/Plug-ins/
</code></pre>

<p>OK!</p>

<p>这样就可以新建，保存 ICO 图片了。</p>
]]></content>
        </item>
        
        <item>
            <title>用 google-code-prettify 实现代码语法高亮</title>
            <link>https://shaocheng.li/posts/2014/07/11/</link>
            <pubDate>Fri, 11 Jul 2014 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2014/07/11/</guid>
            <description>google-code-prettify 可以通过 javascript 和 css 文件为 html 页面实现代码段的语法高亮。
 1. 下载 在 https://code.google.com/p/google-code-prettify/ 下载 prettify-small-4-Mar-2013.tar.bz2 ，解压后的文件夹放在博客模板的 include 目录下，改名为 prettify 。
2. 导入 在模板的 base.html 文件的 &amp;lt;head&amp;gt; 段添加 ：
&amp;lt;link href=&amp;quot;/template/include/prettify/prettify.css&amp;quot; type=&amp;quot;text/css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; /&amp;gt;  js 文件添加到 &amp;lt;body&amp;gt; 段的尾部，这样可以提升加载速度 ：
&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;/template/include/prettify/prettify.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;  3. 实现代码高亮 在 base.html 文件的 &amp;lt;body&amp;gt; 段尾部添加如下代码，它会在页面的 &amp;lt;pre&amp;gt; 标签添加 class=&amp;quot;prettyprint linenums prettyprinted&amp;quot; style=&amp;quot;overflow: auto;&amp;quot; ，用于识别需要高亮的代码块 ：
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; $(document).ready(function() { $(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto&#39;); prettyPrint(); }); &amp;lt;/script&amp;gt;   这段 js 代码用到了 jQuery ，需要提前引入。</description>
            <content type="html"><![CDATA[

<blockquote>
<p>google-code-prettify 可以通过 javascript 和 css 文件为 html 页面实现代码段的语法高亮。</p>
</blockquote>

<h2 id="1-下载">1. 下载</h2>

<p>在 <a href="https://code.google.com/p/google-code-prettify/" target="_blank">https://code.google.com/p/google-code-prettify/</a> 下载 prettify-small-4-Mar-2013.tar.bz2 ，解压后的文件夹放在博客模板的 include 目录下，改名为 prettify 。</p>

<h2 id="2-导入">2. 导入</h2>

<p>在模板的 base.html 文件的 <code>&lt;head&gt;</code> 段添加 ：</p>

<pre><code>&lt;link href=&quot;/template/include/prettify/prettify.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt;
</code></pre>

<p>js 文件添加到 <code>&lt;body&gt;</code> 段的尾部，这样可以提升加载速度 ：</p>

<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;/template/include/prettify/prettify.js&quot;&gt;&lt;/script&gt;
</code></pre>

<h2 id="3-实现代码高亮">3. 实现代码高亮</h2>

<p>在 base.html 文件的 <code>&lt;body&gt;</code> 段尾部添加如下代码，它会在页面的 <code>&lt;pre&gt;</code> 标签添加 <code>class=&quot;prettyprint linenums prettyprinted&quot; style=&quot;overflow: auto;&quot;</code> ，用于识别需要高亮的代码块 ：</p>

<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    $(document).ready(function() {
        $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto');
        prettyPrint();
    });
&lt;/script&gt;
</code></pre>

<blockquote>
<p>这段 js 代码用到了 jQuery ，需要提前引入。</p>
</blockquote>

<p>如果对代码高亮的主题不满意，可以修改 prettify.css 文件。</p>
]]></content>
        </item>
        
        <item>
            <title>在博客添加返回顶部按钮</title>
            <link>https://shaocheng.li/posts/2014/07/09/</link>
            <pubDate>Wed, 09 Jul 2014 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2014/07/09/</guid>
            <description>添加后的效果如右下角。
 1. 导入 jQuery 在 http://jquery.com/download/ 中下载压缩过的 jQuery ：jquery-1.11.1.min.js ,放入博客模板的相应目录下，比如 include/ 。
在 base.html 的  中添加：
&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;/template/include/jquery-1.11.1.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;  2. 添加 div 在 base.html 中添加:
&amp;lt;div id=&amp;quot;back-top&amp;quot;&amp;gt; &amp;lt;a href=&amp;quot;#top&amp;quot; title=&amp;quot;回到顶部&amp;quot;&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt;  3. 添加js代码 使用 js 响应窗口滚动事件和按钮的点击事件，其中 100 表示向下滚动 100 个像素时出现按md钮，800 表示使用 800ms 的时间滚动到顶部。
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; $(&amp;quot;#back-top&amp;quot;).hide(); $(document).ready(function () { $(window).scroll(function () { if ($(this).scrollTop() &amp;gt; 100) { $(&#39;#back-top&#39;).fadeIn(); } else { $(&#39;#back-top&#39;).fadeOut(); } }); $(&#39;#back-top a&#39;).</description>
            <content type="html"><![CDATA[

<blockquote>
<p>添加后的效果如右下角。</p>
</blockquote>

<h2 id="1-导入-jquery">1. 导入 jQuery</h2>

<p>在 <a href="http://jquery.com/download/" target="_blank">http://jquery.com/download/</a> 中下载压缩过的 jQuery ：jquery-1.11.1.min.js ,放入博客模板的相应目录下，比如 include/ 。</p>

<p>在 base.html 的 <head> 中添加：</p>

<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;/template/include/jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt;
</code></pre>

<h2 id="2-添加-div">2. 添加 div</h2>

<p>在 base.html 中添加:</p>

<pre><code>&lt;div id=&quot;back-top&quot;&gt;
    &lt;a href=&quot;#top&quot; title=&quot;回到顶部&quot;&gt;&lt;/a&gt;
&lt;/div&gt;
</code></pre>

<h2 id="3-添加js代码">3. 添加js代码</h2>

<p>使用 js 响应窗口滚动事件和按钮的点击事件，其中 100 表示向下滚动 100 个像素时出现按md钮，800 表示使用 800ms 的时间滚动到顶部。</p>

<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    $(&quot;#back-top&quot;).hide();
    $(document).ready(function () {
        $(window).scroll(function () {
            if ($(this).scrollTop() &gt; 100) {
                $('#back-top').fadeIn();
            } else {
                $('#back-top').fadeOut();
            }
        });
        $('#back-top a').click(function () {
            $('body,html').animate({
                scrollTop: 0
            }, 800);
            return false;
        });
    });
&lt;/script&gt;
</code></pre>

<p>可以将这段代码添加到 <code>&lt;div id=&quot;back-top&quot;&gt;</code> 段的后面。</p>

<h2 id="4-添加样式">4. 添加样式</h2>

<p>此处使用一个背景透明的向上箭头图片 bg_up_arrow.png，将其放入 include/ 目录下。通过 <code>backgroud-color</code> 指定正常时和鼠标放上时的背景颜色，<code>border-radius</code> 指定圆角的半径。</p>

<pre><code>#back-top {
  position: fixed;
  bottom: 30px;
  right: 80px;
}
#back-top a {
  width: 54px;
  height: 54px;
  display: block;
  background: #ddd url(/template/include/bg_up_arrow.png) no-repeat center center;
  background-color: #e9e9e9;
  -webkit-border-radius: 7px;
  -moz-border-radius: 7px;
  border-radius: 7px;
  -webkit-transition: 1s;
  -moz-transition: 1s;
  transition: 1s;
}
#back-top a:hover {
  background-color: #c8c8c8;
}
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>QNX 的 Telnet 和 FTP 服务</title>
            <link>https://shaocheng.li/posts/2013/12/27/</link>
            <pubDate>Fri, 27 Dec 2013 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2013/12/27/</guid>
            <description>Telnet 在QNX中，telnet 服务必须用 inetd启动，所以，先确保 /etc/inetd.conf 文件中有一行 ：
telnet stream tcp nowait root /usr/sbin/telnetd in.telnetd  且没有被注释。
各自字段的含义：
&amp;lt;service_name&amp;gt; &amp;lt;socket_type&amp;gt; &amp;lt;proto&amp;gt; &amp;lt;flags&amp;gt; &amp;lt;user&amp;gt; &amp;lt;server_pathname&amp;gt; &amp;lt;args&amp;gt;  其中 &amp;lt;user&amp;gt; 为启动服务的用户名，必须为系统中已经存在的用户。
然后执行 inetd &amp;amp; 即可启动telnet服务。
执行 netstat 命令，可以看到 telnet 已经打开：
如果要开机启动，可以将 /usr/sbin/inetd &amp;amp; 命令添加到 /etc/rc.d/rc.local 文件中。
FTP 在QNX中，FTP 服务必须用 inetd启动，所以，先确保 /etc/inetd.conf 文件中有一行 ：
ftp stream tcp nowait root /usr/sbin/ftpd in.ftpd -l  且没有被注释。
各自字段的含义：
&amp;lt;service_name&amp;gt; &amp;lt;socket_type&amp;gt; &amp;lt;proto&amp;gt; &amp;lt;flags&amp;gt; &amp;lt;user&amp;gt; &amp;lt;server_pathname&amp;gt; &amp;lt;args&amp;gt;  其中 &amp;lt;user&amp;gt; 为启动服务器的用户名，必须为系统中已经存在的用户。</description>
            <content type="html"><![CDATA[

<h2 id="telnet">Telnet</h2>

<p>在QNX中，telnet 服务必须用 inetd启动，所以，先确保 /etc/inetd.conf 文件中有一行 ：</p>

<pre><code>telnet  stream  tcp  nowait  root  /usr/sbin/telnetd    in.telnetd 
</code></pre>

<p>且没有被注释。</p>

<p>各自字段的含义：</p>

<pre><code>&lt;service_name&gt; &lt;socket_type&gt; &lt;proto&gt; &lt;flags&gt; &lt;user&gt; &lt;server_pathname&gt; &lt;args&gt;
</code></pre>

<p>其中 <code>&lt;user&gt;</code> 为启动服务的用户名，必须为系统中已经存在的用户。</p>

<p>然后执行 inetd &amp; 即可启动telnet服务。</p>

<p>执行 netstat 命令，可以看到 telnet 已经打开：</p>

<p><img src="/images/2013-12-27/2013-12-27_1.PNG" alt="" /></p>

<p>如果要开机启动，可以将 /usr/sbin/inetd &amp; 命令添加到 /etc/rc.d/rc.local 文件中。</p>

<h2 id="ftp">FTP</h2>

<p>在QNX中，FTP 服务必须用 inetd启动，所以，先确保 /etc/inetd.conf 文件中有一行 ：</p>

<pre><code>ftp  stream  tcp  nowait  root  /usr/sbin/ftpd    in.ftpd -l
</code></pre>

<p>且没有被注释。</p>

<p>各自字段的含义：</p>

<pre><code>&lt;service_name&gt; &lt;socket_type&gt; &lt;proto&gt; &lt;flags&gt; &lt;user&gt; &lt;server_pathname&gt; &lt;args&gt;
</code></pre>

<p>其中 <code>&lt;user&gt;</code> 为启动服务器的用户名，必须为系统中已经存在的用户。</p>

<p>然后执行 inetd &amp; 即可启动ftp服务。</p>

<p>执行 netstat 命令，可以看到 ftp 已经打开：</p>

<p><img src="/images/2013-12-27/2013-12-27_2.PNG" alt="" /></p>

<p>如果要开机启动，可以将 /usr/sbin/inetd &amp; 命令添加到 /etc/rc.d/rc.local 文件中。</p>

<p>/etc/ftpuser 文件用于控制访问ftpd 的用户。要使root用户登陆，将文件中把禁止root用户使用ftp这项屏蔽掉（root前面加#号）:</p>

<p><img src="/images/2013-12-27/2013-12-27_3.PNG" alt="" /></p>

<p>并且，root 用户必须有密码，否则无法通过 ftp 登陆。</p>
]]></content>
        </item>
        
        <item>
            <title>Google Fonts</title>
            <link>https://shaocheng.li/posts/2013/10/16/</link>
            <pubDate>Wed, 16 Oct 2013 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2013/10/16/</guid>
            <description>Google Fonts 是一套高品质的 Web 字体，可以通过 Google Fonts API 添加到任意 Web 页面中，只需在 HTML 文件的头部添加一个 stylesheet 链接，然后就可以通过 CSS 使用字体。
优势：
 高品质，开源 支持大多数浏览器 极其易用  劣势：
 墙内链接不稳定  Google Fonts API ：https://developers.google.com/fonts/
Example 下面是一个简单的例子，将这份代码复制并保存为 html 文件。
&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;https://fonts.googleapis.com/css?family=Tangerine&amp;quot;&amp;gt; &amp;lt;style&amp;gt; body { font-family: &#39;Tangerine&#39;, serif; font-size: 48px; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div&amp;gt;Making the Web Beautiful!&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  然后在浏览器中打开这个 html 文件，就会看到如下效果：
Making the Web Beautiful!
这是普通文本，所以可以用 CSS 改变它的样式，试着添加阴影:</description>
            <content type="html"><![CDATA[

<p>Google Fonts 是一套高品质的 Web 字体，可以通过 Google Fonts API 添加到任意 Web 页面中，只需在 HTML 文件的头部添加一个 <code>stylesheet</code> 链接，然后就可以通过 CSS 使用字体。</p>

<p>优势：</p>

<ul>
<li>高品质，开源</li>
<li>支持大多数浏览器</li>
<li>极其易用</li>
</ul>

<p>劣势：</p>

<ul>
<li>墙内链接不稳定</li>
</ul>

<p>Google Fonts API ：<a href="https://developers.google.com/fonts/" target="_blank">https://developers.google.com/fonts/</a></p>

<h2 id="example">Example</h2>

<p>下面是一个简单的例子，将这份代码复制并保存为 html 文件。</p>

<pre><code>&lt;html&gt;
    &lt;head&gt;
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://fonts.googleapis.com/css?family=Tangerine&quot;&gt;
        &lt;style&gt;
            body {
                font-family: 'Tangerine', serif;
                font-size: 48px;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div&gt;Making the Web Beautiful!&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>然后在浏览器中打开这个 html 文件，就会看到如下效果：</p>

<p style="font-family:'Tangerine';font-size:48px">Making the Web Beautiful!</p>

<p>这是普通文本，所以可以用 CSS 改变它的样式，试着添加阴影:</p>

<pre><code>body {
    font-family: 'Tangerine', serif;
    font-size: 48px;
    text-shadow: 4px 4px 4px #aaa;
}
</code></pre>

<p>效果如下：</p>

<p style="font-family:'Tangerine';font-size:48px;text-shadow: 4px 4px 4px #aaa">Making the Web Beautiful!</p>

<h2 id="overview">Overview</h2>

<p>使用 Google Fonts API 只需两步：</p>

<ol>
<li><p>添加一个 stylesheet 链接：</p>

<pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://fonts.googleapis.com/css?family=Font+Name&quot;&gt;
</code></pre></li>

<li><p>为一个元素指定需要的字体：</p>

<pre><code>CSS selector {
  font-family: 'Font Name', serif;
}
</code></pre>

<p>或者用内联式的 style ：</p>

<pre><code>&lt;div style=&quot;font-family: 'Font Name', serif;&quot;&gt;Your text&lt;/div&gt;
</code></pre></li>
</ol>

<blockquote>
<p>注意，推荐在 <code>href</code> 中使用 https 的 url ，否则可能无法连接到 googleapis.com 。</p>
</blockquote>

<p>在 <a href="https://www.google.com/fonts" target="_blank">Google Fonts</a> 中可以看到可用的字体列表。</p>
]]></content>
        </item>
        
        <item>
            <title>Font Awesome 矢量字体图标</title>
            <link>https://shaocheng.li/posts/2013/10/15/</link>
            <pubDate>Tue, 15 Oct 2013 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2013/10/15/</guid>
            <description>项目主页：http://fortawesome.github.io/Font-Awesome/
目前的 Version 3.2.1 版本支持如下特性：
 一个字体文件， 361 个图标 用 CSS 控制样式 无限缩放 免费 支持视网膜屏幕 为 Bootstrap 设计，也可集成到非 Bootstrap 项目  1.集成  复制 font 目录到项目根目录下 复制 css 目录到项目根目录下，主要使用 font-awesome.min.css 文件 修改 font-awesome.min.css 文件中的字体路径，默认是 ../font/ 在 html 文件中引用 css 文件：&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;./css/font-awesome.min.css&amp;quot; type=&amp;quot;text/css&amp;quot; /&amp;gt;  2.实例 使用图标 &amp;lt;i class=&amp;quot;icon-youtube&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; icon-youtube   icon-youtube
其中的 icon-youtube 是图标的名称，所有支持的图标名称可以在 font-awesome.min.css 文件中查找，也可在 Font-Awesome icons 中预览。
更大的图标 通过给图标设置 icon-large、icon-2x、 icon-3x 或 icon-4x 样式，可以让图标相对于它所在的容器变得更大：
&amp;lt;p&amp;gt;&amp;lt;i class=&amp;quot;icon-camera-retro icon-large&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; icon-camera-retro&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;&amp;lt;i class=&amp;quot;icon-camera-retro icon-2x&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; icon-camera-retro&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;&amp;lt;i class=&amp;quot;icon-camera-retro icon-3x&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; icon-camera-retro&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;&amp;lt;i class=&amp;quot;icon-camera-retro icon-4x&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; icon-camera-retro&amp;lt;/p&amp;gt;   icon-camera-retro</description>
            <content type="html"><![CDATA[

<p>项目主页：<a href="http://fortawesome.github.io/Font-Awesome/" target="_blank">http://fortawesome.github.io/Font-Awesome/</a></p>

<p>目前的  Version 3.2.1  版本支持如下特性：</p>

<ul>
<li>一个字体文件， 361 个图标</li>
<li>用 CSS 控制样式</li>
<li>无限缩放</li>
<li>免费</li>
<li>支持视网膜屏幕</li>
<li>为 Bootstrap 设计，也可集成到非 Bootstrap 项目</li>
</ul>

<h2 id="1-集成">1.集成</h2>

<ol>
<li>复制 font 目录到项目根目录下</li>
<li>复制 css 目录到项目根目录下，主要使用 font-awesome.min.css 文件</li>
<li>修改 font-awesome.min.css 文件中的字体路径，默认是 ../font/</li>
<li>在 html 文件中引用 css 文件：<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/font-awesome.min.css&quot; type=&quot;text/css&quot; /&gt;</code></li>
</ol>

<h2 id="2-实例">2.实例</h2>

<h3 id="使用图标">使用图标</h3>

<pre><code>&lt;i class=&quot;icon-youtube&quot;&gt;&lt;/i&gt; icon-youtube
</code></pre>

<p><i class="icon-youtube"></i> icon-youtube</p>

<p>其中的 icon-youtube 是图标的名称，所有支持的图标名称可以在 font-awesome.min.css 文件中查找，也可在 <a href="http://fortawesome.github.io/Font-Awesome/icons/" target="_blank">Font-Awesome icons</a> 中预览。</p>

<h3 id="更大的图标">更大的图标</h3>

<p>通过给图标设置 icon-large、icon-2x、 icon-3x 或 icon-4x 样式，可以让图标相对于它所在的容器变得更大：</p>

<pre><code>&lt;p&gt;&lt;i class=&quot;icon-camera-retro icon-large&quot;&gt;&lt;/i&gt; icon-camera-retro&lt;/p&gt;
&lt;p&gt;&lt;i class=&quot;icon-camera-retro icon-2x&quot;&gt;&lt;/i&gt; icon-camera-retro&lt;/p&gt;
&lt;p&gt;&lt;i class=&quot;icon-camera-retro icon-3x&quot;&gt;&lt;/i&gt; icon-camera-retro&lt;/p&gt;
&lt;p&gt;&lt;i class=&quot;icon-camera-retro icon-4x&quot;&gt;&lt;/i&gt; icon-camera-retro&lt;/p&gt;
</code></pre>

<p><i class="icon-camera-retro icon-large"></i> icon-camera-retro</p>
<p><i class="icon-camera-retro icon-2x"></i> icon-camera-retro</p>
<p><i class="icon-camera-retro icon-3x"></i> icon-camera-retro</p>
<p><i class="icon-camera-retro icon-4x"></i> icon-camera-retro</p>

<h3 id="动画微调">动画微调</h3>

<p>使用 icon-spin 使图标旋转，对于 icon-spinner 和 icon-refresh 图标可以得到很好的效果：</p>

<pre><code>&lt;i class=&quot;icon-spinner icon-spin&quot;&gt;&lt;/i&gt; Spinner icon when loading content...
</code></pre>

<p><i class="icon-spinner icon-spin"></i> Spinner icon when loading content&hellip;</p>

<pre><code>&lt;i class=&quot;icon-refresh icon-spin&quot;&gt;&lt;/i&gt; Refresh icon when refresh content...
</code></pre>

<p><i class="icon-refresh icon-spin"></i> Refresh icon when refresh content&hellip;</p>

<h3 id="列表">列表</h3>

<p>在列表中使用图标：</p>

<pre><code>&lt;ul class=&quot;icons&quot;&gt;
  &lt;li&gt;&lt;i class=&quot;icon-ok&quot;&gt;&lt;/i&gt; Lists&lt;/li&gt;
  &lt;li&gt;&lt;i class=&quot;icon-ok&quot;&gt;&lt;/i&gt; Buttons&lt;/li&gt;
  &lt;li&gt;&lt;i class=&quot;icon-ok&quot;&gt;&lt;/i&gt; Button groups&lt;/li&gt;
  &lt;li&gt;&lt;i class=&quot;icon-ok&quot;&gt;&lt;/i&gt; Navigation&lt;/li&gt;
  &lt;li&gt;&lt;i class=&quot;icon-ok&quot;&gt;&lt;/i&gt; Prepended form inputs&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<ul class="icons">
  <li><i class="icon-ok"></i> Lists</li>
  <li><i class="icon-ok"></i> Buttons</li>
  <li><i class="icon-ok"></i> Button groups</li>
  <li><i class="icon-ok"></i> Navigation</li>
  <li><i class="icon-ok"></i> Prepended form inputs</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Hello Farbox</title>
            <link>https://shaocheng.li/posts/2013/10/12/</link>
            <pubDate>Sat, 12 Oct 2013 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2013/10/12/</guid>
            <description>第一节 1.1 ####1.1.1
正文
 无序列表1 无序列表2  无序列表子项 无序列表子项  无序列表3  第二节 正文
 有序列表1 有序列表2  代码段：
include&amp;lt;stdio.h&amp;gt; int main() { printf(&amp;quot;hello farbox\n!&amp;quot;); return 0; }   注意事项
 插入图片：
正文</description>
            <content type="html"><![CDATA[

<h2 id="第一节">第一节</h2>

<h3 id="1-1">1.1</h3>

<p>####1.1.1</p>

<p>正文</p>

<ul>
<li>无序列表1</li>
<li>无序列表2

<ul>
<li>无序列表子项</li>
<li>无序列表子项</li>
</ul></li>
<li>无序列表3</li>
</ul>

<h2 id="第二节">第二节</h2>

<p>正文</p>

<ol>
<li>有序列表1</li>
<li>有序列表2</li>
</ol>

<p>代码段：</p>

<pre><code>include&lt;stdio.h&gt;
int main()
{
    printf(&quot;hello farbox\n!&quot;);
    return 0;
}
</code></pre>

<blockquote>
<p>注意事项</p>
</blockquote>

<p>插入图片：</p>

<p><img src="/images/2013-10-12/2013-10-12_1.jpg" alt="" /></p>

<p>正文</p>
]]></content>
        </item>
        
        <item>
            <title>QNX 对触摸屏的支持</title>
            <link>https://shaocheng.li/posts/2013/09/15/</link>
            <pubDate>Sun, 15 Sep 2013 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2013/09/15/</guid>
            <description>QNX Neutrino 支持多种触摸屏，可以在官网上查找支持的型号和对应的驱动：
http://www.qnx.com/developers/hardware_support/
或者在 Utilities Reference 中查看 devi-* 驱动，然后确定所需的参数，启动驱动。例如，启动一个 Dynapro SC4 触摸屏：
devi-dyna dyna -4 fd -d/dev/ser1 &amp;amp;  使用 devi-dyna 驱动，SC4 协议（-4），串口1（/dev/ser1）。
第一次使用驱动时，会返回一个错误状态，无法获取校准文件。要校准触摸屏，需要在 Photon 下使用 calib 工具。
calib 用于校准触摸屏。成功配置触摸屏后（已经创建了设备文件），必须校准。calib 工具的配置文件保存在 /etc/system/config/calib.$hostname 。关于该文件的格式，可以在 “Writing an Input Device Driver” 的 “Calibration file format” 查看.
校准的步骤是：
 启动 Photon. 运行 calib. 触摸屏幕上的目标点. 点击 Press to Complete Calibration 按钮，完成校准.  语法 calib [options]  参数  -a alg ：指定校准算法。有效算法是 3 和 4 ，默认值是 3 。</description>
            <content type="html"><![CDATA[

<p>QNX Neutrino 支持多种触摸屏，可以在官网上查找支持的型号和对应的驱动：</p>

<p><a href="http://www.qnx.com/developers/hardware_support/" target="_blank">http://www.qnx.com/developers/hardware_support/</a></p>

<p>或者在 Utilities Reference 中查看 <code>devi-*</code> 驱动，然后确定所需的参数，启动驱动。例如，启动一个 Dynapro SC4 触摸屏：</p>

<pre><code>devi-dyna dyna -4 fd -d/dev/ser1 &amp;
</code></pre>

<p>使用 devi-dyna 驱动，SC4 协议（-4），串口1（/dev/ser1）。</p>

<p>第一次使用驱动时，会返回一个错误状态，无法获取校准文件。要校准触摸屏，需要在 Photon 下使用 calib 工具。</p>

<h2 id="calib">calib</h2>

<p>用于校准触摸屏。成功配置触摸屏后（已经创建了设备文件），必须校准。calib 工具的配置文件保存在 /etc/system/config/calib.$hostname 。关于该文件的格式，可以在 “Writing an Input Device Driver” 的 “Calibration file format” 查看.</p>

<p>校准的步骤是：</p>

<ol>
<li>启动 Photon.</li>
<li>运行 calib.</li>
<li>触摸屏幕上的目标点.</li>
<li>点击 Press to Complete Calibration 按钮，完成校准.</li>
</ol>

<h3 id="语法">语法</h3>

<pre><code>calib [options]
</code></pre>

<h3 id="参数">参数</h3>

<ul>
<li><p>-a alg ：指定校准算法。有效算法是 3 和 4 ，默认值是 3 。</p></li>

<li><p>-b val ：指定触摸点的验收方差（范围是 0 - 2000）。使能该参数将会强制检查触摸点。</p></li>

<li><p>-c ：如果已经配置文件 /etc/system/config/calib.$(hostname) 已经存在，就停止运行。</p></li>

<li><p>-d w,h ：触摸屏的宽度和高度。如果不设置该参数，calib 会尝试从硬件获取信息。</p></li>

<li><p>-f file ：校准文件的名称和路径，代替默认的 /etc/system/config/calib.$hostname 。</p></li>

<li><p>-l limit ：校准触摸点的个数，默认值是 15 。</p></li>

<li><p>-o offset ：相对于十字线的偏移，用于调整校验。只能用在四点校验。</p></li>

<li><p>-O ：将触摸屏的起点（0,0）设为右下角。默认为左上角。</p></li>

<li><p>-p x,y ：相对于校验起点的偏移。</p></li>

<li><p>-P ：关闭提示。默认会在屏幕上显示提示信息。</p></li>

<li><p>-s server ：服务器节点或设备名称。</p></li>

<li><p>-S ：使用小触摸目标。默认是大的。</p></li>

<li><p>-t timer ：完成按钮的定时值，默认是 10 。</p></li>

<li><p>-v ：输出详情。</p></li>

<li><p>-x x ：初始化 x 坐标。</p></li>

<li><p>-y y ：初始化 y 坐标。</p></li>
</ul>

<h3 id="例">例</h3>

<p>校准一个四分子一的标准 640*480 VGA 屏：</p>

<pre><code>calib -d 320,240
</code></pre>

<h2 id="elo-触摸屏">ELO 触摸屏</h2>

<p>Elographics 触摸屏的驱动是 <code>devi-elo</code> ，它会在 Photon 上启动一个 Elographics 输入管理器 。</p>

<h3 id="语法-1">语法</h3>

<pre><code>devi-elo [general_opts] 
         protocol* [protocol_opts]*
         device* [device_opts]*
         filter* [filter_opts]*
</code></pre>

<blockquote>
<p>使用 <code>devi-*</code> 触摸屏驱动时，需要一个校准文件。用 <code>calib</code> 工具产生：</p>

<p>calib &gt; calib_file.txt</p>
</blockquote>

<h3 id="参数-1">参数</h3>

<p>general_opts：</p>

<ul>
<li><p>-b ：禁止使用 Ctrl-Alt-Shift-Backspace 组合键结束 Photon （默认是允许的）。</p></li>

<li><p>-d device ：设备（默认：/dev/photon 或 $PHOTON ）。</p></li>

<li><p>-G ：启动触摸屏驱动时无需图形驱动。在调试时很有用。</p></li>

<li><p>-g input_group ：输入组（默认是 1 ）。</p></li>

<li><p>-l ：列出内部模块。模块用如下格式显示：</p>

<pre><code>module name | date compiled | revision | class
</code></pre></li>

<li><p>-v[v]&hellip; ：输出详情，更多的 v 字符导致输出更多的详情。</p></li>
</ul>

<p>protocol* [protocol_opts]*：</p>

<pre><code>smartset [smartset_opts] [fd fd_opts]|[uart uart_opts]
</code></pre>

<ul>
<li><p>smartset —— Elographics smartset 协议</p>

<p>-b baud ：波特率（默认是9600）</p>

<p>-R ：不要 reset 设备（默认是 reset ）</p></li>
</ul>

<p>device* [device_opts]*：</p>

<ul>
<li><p>fd —— 通过 open() 打开一个设备</p>

<p>-d device ：设备文件名（默认是 /dev/ser1）</p>

<p>-s ：输入接口是串口</p></li>

<li><p>uart —— 直接访问 8250/16550/16450 UART</p>

<p>-1 ：COM1</p>

<p>-2 ：COM2</p>

<p>-i irq ：串口的 IRQ （默认是 4 ）</p>

<p>-p ioport ：串口的端口地址（默认是 3f8）</p></li>
</ul>

<p>filter* [filter_opts]*：</p>

<ul>
<li><p>abs —— 转换和压缩绝对坐标</p>

<p>-b ：点击屏幕代表鼠标右键（默认是左键）</p>

<p>-c ：校准模式；不转换坐标</p>

<p>-f filename ：校准文件</p>

<p>-o x,y ：显示区域的起始点（默认是图形区域的起始点）</p>

<p>-s x,y ：显示区域右下角的坐标（默认是图形区域的宽和高）</p>

<p>-x ：翻转 x 坐标</p>

<p>-y ：翻转 y 坐标</p></li>
</ul>

<h3 id="例-1">例</h3>

<p>使用 COM1 ，点击屏幕代表鼠标右键：</p>

<pre><code>devi-elo smartset fd -d/dev/ser1 abs -b
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>QNX 编程</title>
            <link>https://shaocheng.li/posts/2013/07/28/</link>
            <pubDate>Sun, 28 Jul 2013 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2013/07/28/</guid>
            <description>处理中断的线程应该先获得 I/O 权限，调用 ThreadCtl() 函数：
#include &amp;lt;sys/neutrino.h&amp;gt; ThreadCtl( _NTO_TCTL_IO, 0 );  QNX 提供了两种捆绑中断服务程序和中断号的方式：InterruptAttach() 和 InterruptAttachEvent() 。两种方式调用中断服务程序的方式也不同。分离可以调用 InterruptDetach() 函数：
#define IRQ3 3 /* A forward reference for the handler */ extern const sigevent *serint (void *, int); … /* * Associate the interrupt handler, serint, * with IRQ 3, the 2nd PC serial port */ ThreadCtl( _NTO_TCTL_IO, 0 ); id = InterruptAttach (IRQ3, serint, NULL, 0, 0); … /* Perform some processing.</description>
            <content type="html"><![CDATA[

<p>处理中断的线程应该先获得 I/O 权限，调用 ThreadCtl() 函数：</p>

<pre><code>#include &lt;sys/neutrino.h&gt;
ThreadCtl( _NTO_TCTL_IO, 0 );
</code></pre>

<p>QNX 提供了两种捆绑中断服务程序和中断号的方式：<code>InterruptAttach()</code> 和 <code>InterruptAttachEvent()</code> 。两种方式调用中断服务程序的方式也不同。分离可以调用 <code>InterruptDetach()</code> 函数：</p>

<pre><code>#define IRQ3 3

/*  A forward reference for the handler */
extern const sigevent *serint (void *, int);
…

/*
 *  Associate the interrupt handler, serint,
 *  with IRQ 3, the 2nd PC serial port
 */
ThreadCtl( _NTO_TCTL_IO, 0 );
id = InterruptAttach (IRQ3, serint, NULL, 0, 0);
…

/*  Perform some processing. */
…

/*  Done; detach the interrupt source. */
InterruptDetach (id);
</code></pre>

<h2 id="中断服务程序">中断服务程序</h2>

<p>中断服务程序中应该完成如下几个工作：</p>

<ol>
<li><p>判断中断源</p>

<p>根据你的硬件配置，可能出现多个硬件共享一个中断号。大部分PIC(可编程中断控制器)芯片可以编程配置为电平触发中断或边沿触发中断。触发方式决定了中断是否可以共享。</p>

<p>下面是多中断源请求中断的示意图：</p>

<p><img src="~/IMG_2491.JPG" alt="" /></p>

<p>在上面这种情况下，如果 PIC 配置为电平触发，只要电平为高，就认为 IRQ 处于激活状态。第二个中断请求(step2)本身并不会产生新的中断，中断一直被认为处于激活状态，即使最初引起中断的中断源已经删除(step3)。直到最后一个中断源被清除，该中断才会被认为处于未激活状态。</p>

<p>如果是边沿触发模式，中断只会被“注意”一次，即 step1 。只有当中断线被清除，然后被再次请求，PIC 才会认为有新的中断产生。</p>

<p>QNX 允许多个中断服务程序关联一个中断号。这样的话，每个服务程序必须找到自己关联的硬件并且判断是否是由该硬件引起的中断。这项工作在电平触发环境下是可靠的，边沿触发环境就不一定了。</p></li>

<li><p>处理硬件</p>

<p>通常是读写硬件寄存器。</p>

<p>需要注意的是，在 ISR 中不能使用大部分内核调用。在使用库函数时也要小心，因为它们的底层实现可能使用了系统调用，例如 <code>printf()</code> 函数。</p>

<p>在 ISR 中可以使用的内核调用有：</p>

<pre><code>* InterruptMask()
* InterruptUnmask()
* TraceEvent()
</code></pre>

<p><code>InterruptMask()</code> 和 <code>InterruptUnmask()</code> 用于关闭和使能一个特定的中断号。
<code>TraceEvent()</code> 用于跟踪内核事件。</p></li>

<li><p>更新数据结构</p>

<p>另一个问题是如何安全的更新 ISR 和软件线程共同使用的数据结构。有两个特点值得重申：</p>

<ul>
<li>ISR 拥有比任何软件线程都高的优先级</li>
<li>ISR 不能使用内核调用(特别声明的除外)</li>
</ul>

<p>这意味着不能在 ISR 中使用线程级别的同步(例如互斥)。</p></li>

<li><p>唤醒应用层代码</p>

<p>因为 ISR 中的操作受到很大限制，通常需要将大量的操作放在线程级别运行</p>

<p>为了做到这一点，有两个选择：</p>

<ul>
<li>在 ISR 中完成一些对时限要求严格的工作，其他的安排给唤醒的线程来处理</li>
<li>在 ISR 中什么都不做，只是唤醒一个线程</li>
</ul>

<p>这也是 <code>InterruptAttach()</code> 和 <code>InterruptAttachEvent()</code> 的区别。</p></li>
</ol>

<h2 id="使用-interruptattach">使用 InterruptAttach</h2>

<p><code>InterruptAttach()</code> 函数的原型：</p>

<pre><code>#include &lt;sys/neutrino.h&gt;

int InterruptAttach( int intr,
       const struct sigevent * (* handler)(void *, int),
       const void * area,
       int size,
       unsigned flags );
</code></pre>

<p>参数：</p>

<ul>
<li>intr : 中断号</li>
<li>handler : 中断服务函数</li>
<li>area : 线程与中断服务函数进行通讯的空间，如果不需要可以设为NULL</li>
<li>size : 通讯空间的大小</li>

<li><p>flags : 表示捆绑中断服务函数的方式，有三个可选值：</p>

<ul>
<li><p>_NTO_INTR_FLAGS_END  : 将新的中断服务函数放在该中断的处理函数队列的尾部。</p></li>

<li><p>_NTO_INTR_FLAGS_PROCESS  : 将中断服务函数关联到进程，而不是当前线程.</p></li>

<li><p>_NTO_INTR_FLAGS_TRK_MSK  : 跟踪调用 <code>InterruptMask()</code> 和 <code>InterruptUnmask()</code> 来安全的分离中断服务函数。</p></li>
</ul></li>
</ul>

<p>调用成功的话会返回一个 id ，用于 <code>InterruptMask()</code> 和 <code>InterruptUnmask()</code> 等函数。失败返回-1。</p>

<p>中断服务函数(ISR)的原型是：</p>

<pre><code>const struct sigevent *handler (void *area, int id);
</code></pre>

<p>参数：</p>

<ul>
<li>area : 即 <code>InterruptAttach()</code> 函数的 <code>area</code></li>
<li>id : 即 <code>InterruptAttach()</code> 函数的返回值</li>
</ul>

<p>在 <code>handler()</code> 函数中完成了相应的中断服务后，可以选择安排一个线程来完成后续的工作。为此，ISR 需要返回一个指向 <code>const struct sigevent</code> 结构的指针，当内核收到这个结构后，就会将 event 带到目的地。</p>

<p><code>struct sigevent</code> 定义在 <code>&lt;sys/siginfo.h&gt;</code> 头文件，结构成员 <code>sigev_notify</code> 指定了产生怎样的通知。该文件提供了一些宏来初始化这个结构，第一个参数都是 <code>struct sigevent</code> 类型的指针，中断服务函数中常用的宏有如下两个：</p>

<ul>
<li><p>SIGEV_INTR_INIT(&amp;event)</p>

<p>设置 <code>sigev_notify</code> 为 <code>SIGEV_INTR</code>，表示发送一个中断通知到指定的线程。</p></li>

<li><p>SIGEV_NONE_INIT(&amp;event)</p>

<p>设置 <code>sigev_notify</code> 为 <code>SIGEV_NONE</code>，表示不发送任何通知。</p></li>
</ul>

<p>典型的处理中断的方法是，在一个线程中调用 <code>InterruptAttach()</code> 绑定中断服务函数，然后调用 <code>InterruptWait()</code> 阻塞线程，直到 ISR 返回一个 <code>SIGEV_INTR</code> ，<code>InterruptWait()</code> 才会返回：</p>

<pre><code>main ()
{
    // perform initializations, etc.
    …
    // start up a thread that is dedicated to interrupt processing
    pthread_create (NULL, NULL, int_thread, NULL);
    …
    // perform other processing, as appropriate
    …
}

// this thread is dedicated to handling and managing interrupts
void *
int_thread (void *arg)
{
    // enable I/O privilege
    ThreadCtl (_NTO_TCTL_IO, NULL);
    …
    // initialize the hardware, etc.
    …
    // attach the ISR to IRQ 3
    InterruptAttach (IRQ3, isr_handler, NULL, 0, 0);
    …
    // perhaps boost this thread's priority here
    …
    // now service the hardware when the ISR says to
    while (1)
    {
        InterruptWait (NULL, NULL);
        // at this point, when InterruptWait unblocks,
        // the ISR has returned a SIGEV_INTR, indicating
        // that some form of work needs to be done.


        …
        // do the work
        …
        // if the isr_handler did an InterruptMask, then
        // this thread should do an InterruptUnmask to
        // allow interrupts from the hardware
    }
}

// this is the ISR
const struct sigevent *
isr_handler (void *arg, int id)
{
    // look at the hardware to see if it caused the interrupt
    // if not, simply return (NULL);
    …
    // in a level-sensitive environment, clear the cause of
    // the interrupt, or at least issue InterruptMask to
    // disable the PIC from reinterrupting the kernel
    …
    // return a pointer to an event structure (preinitialized
    // by main) that contains SIGEV_INTR as its notification type.
    // This causes the InterruptWait in &quot;int_thread&quot; to unblock.
    return (&amp;event);
}
</code></pre>

<p>这种方案相对于使用 <code>SIGEV_SIGNAL</code> 或 <code>SIGEV_PULSE</code> 类型有几个优点：</p>

<ul>
<li>应用程序无需调用 <code>MsgReceive()</code> 函数(用于等到一个pulse)。</li>
<li>应用程序无需一个 signal-handler 函数(用于等待一个signal)。</li>
<li>如果中断处理很急迫，可以定义一个具有高优先级的 <code>int_thread()</code> 线程；当 <code>isr_handler()</code> 返回 SIGEV_INTR 时，只要 <code>int_thread()</code> 的优先级足够高，它就会立即执行。</li>
</ul>

<p>使用 <code>InterruptWait()</code> 时需要注意一点，被绑定的中断必须产生 <code>SIGEV_INTR</code> 。</p>

<h2 id="使用-interruptattachevent">使用 InterruptAttachEvent</h2>

<p><code>InterruptAttachEvent()</code> 函数的原型：</p>

<pre><code>int InterruptAttachEvent( 
       int intr,
       const struct sigevent* event,
       unsigned flags );
</code></pre>

<p>前面关于 <code>InterruptAttach()</code> 的讨论大部分都适用于 <code>InterruptAttachEvent()</code> ，除了 ISR 。这里不需要提供 ISR ,<code>InterruptAttachEvent()</code> 会自己处理中断，因为已经为中断号绑定了一个 <code>struct sigevetn</code> 结构，内核可以检查到这个事件。这样的好处是我们无需考虑进入 ISR 以及如何返回。</p>

<p>需要注意的是，使用该函数时，内核会在处理中断时自动调用 <code>InterruptMask()</code> 。因此，你应该在中断处理线程中调用 <code>InterruptUnmask()</code> 清除中断。</p>
]]></content>
        </item>
        
        <item>
            <title>QNX下的串口驱动——devc-ser8250</title>
            <link>https://shaocheng.li/posts/2013/06/09/</link>
            <pubDate>Sun, 09 Jun 2013 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2013/06/09/</guid>
            <description>devc-ser8250 是 QNX 下的8250串口驱动，支持8250s, 14450s 和 16550s 。
必须以 root 用户运行该程序。
语法： devc-ser8250 [[options] [port[^shift][,intr]]]... &amp;amp;  选项：  -b number：初始化波特率，默认是 57600。 -C size ：canonical buffer 的大小，单位是字节，默认是 256 。 -c clock[/divisor] ：自定义时钟频率，单位是 Hz ，divisor 是串口。 -E ：raw 模式（默认）。默认关闭软件流控制。 -e ：edited 模式。默认使能软件流控制。 -F ：关闭硬件流控制，默认使能硬件流控制。edited 模式不支持硬件流控制。 -f ：使能硬件流控制。 -I number ：中断输入 buffer 的大小，单位是字节，默认是2048 。 -O number ：中断输出 buffer 的大小，单位是字节，默认是2048 。 -o opt[,opt&amp;hellip;] ：额外选项，用逗号隔开，包括：
 nodaemon —— 不要调用 procmgr_daemon() 是驱动在后台运行。如果你需要知道设备终止的时间，可以使用这个选项。 priority=prio —— 设置内部脉冲的工作优先级。  -S|s ：关闭/使能软件流控制。默认：raw 模式时关闭，edited 模式时使能。</description>
            <content type="html"><![CDATA[

<p>devc-ser8250 是 QNX 下的8250串口驱动，支持8250s, 14450s 和 16550s 。</p>

<p>必须以 root 用户运行该程序。</p>

<h2 id="语法">语法：</h2>

<pre><code>devc-ser8250 [[options] 
    [port[^shift][,intr]]]... &amp;
</code></pre>

<h2 id="选项">选项：</h2>

<ul>
<li>-b number：初始化波特率，默认是 57600。</li>
<li>-C size ：canonical buffer 的大小，单位是字节，默认是 256 。</li>
<li>-c clock[/divisor] ：自定义时钟频率，单位是 Hz ，divisor 是串口。</li>
<li>-E ：raw 模式（默认）。默认关闭软件流控制。</li>
<li>-e ：edited 模式。默认使能软件流控制。</li>
<li>-F ：关闭硬件流控制，默认使能硬件流控制。edited 模式不支持硬件流控制。</li>
<li>-f ：使能硬件流控制。</li>
<li>-I number ：中断输入 buffer 的大小，单位是字节，默认是2048 。</li>
<li>-O number ：中断输出 buffer 的大小，单位是字节，默认是2048 。</li>

<li><p>-o opt[,opt&hellip;] ：额外选项，用逗号隔开，包括：</p>

<ul>
<li>nodaemon —— 不要调用 <code>procmgr_daemon()</code> 是驱动在后台运行。如果你需要知道设备终止的时间，可以使用这个选项。</li>
<li>priority=prio —— 设置内部脉冲的工作优先级。</li>
</ul></li>

<li><p>-S|s ：关闭/使能软件流控制。默认：raw 模式时关闭，edited 模式时使能。</p></li>

<li><p>-T number ：使能发送 FIFO 并设置每次 TX 中断发送的字符数：1,4,8 或 14 。默认是 0 （FIFO 关闭）</p></li>

<li><p>-t number ：使能接收 FIFO 并设置字符数为 1,4,8 或 14 。默认是 0 。</p></li>

<li><p>-u number ：在设备名前缀(/dev/ser)附加号码。默认是 1 ；添加设备。</p></li>

<li><p>port ：一个串口的十六进制的 I/O 地址（X86系统）或物理内存地址（PowerPC和MIPS）。</p></li>

<li><p>shift ：设备寄存器的间隔为 2 的幂。例如：</p>

<p>0 寄存器是 1 byte 间隔
1 寄存器是 2 byte 间隔
2 寄存器是 4 byte 间隔
&hellip;
n 寄存器是 2^n byte 间隔
默认 shift 是 0 。</p></li>

<li><p>intr ： 该 port 使用的中断。</p></li>
</ul>

<h2 id="描述">描述：</h2>

<p>如果没有指定 I/O 端口，默认为 COM1(3f8,4) 和 COM2(2f8,3) 。</p>
]]></content>
        </item>
        
        <item>
            <title>QNX 编程读写 I/O 端口</title>
            <link>https://shaocheng.li/posts/2013/06/02/</link>
            <pubDate>Sun, 02 Jun 2013 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2013/06/02/</guid>
            <description>要读写 I/O 端口，必须获得 I/O 权限，这需要以 root 权限运行线程，并且调用 ThreadCtl() 函数：
#include &amp;lt;sys/neutrino.h&amp;gt; ThreadCtl( _NTO_TCTL_IO, 0 );  然后调用 mmap_device_io 函数映射 I/O 端口地址：
#include &amp;lt;stdint.h&amp;gt; #include &amp;lt;sys/mman.h&amp;gt; uintptr_t mmap_device_io( size_t len, uint64_t io );  io 表示要访问的 I/O 端口地址（基地址），len 表示要访问的 I/O 端口的字节数。如果调用成功会返回映射后的起始地址，可以直接用 in8 和 out8 等函数访问；如果失败则返回 MAP_DEVICE_FAILED。
调用读写 I/O 端口的函数要包括头文件：
#include &amp;lt;hw/inout.h&amp;gt;  主要的函数有：
uint8_t in8( uintptr_t port );  从指定端口读取 8 位数据，port 表示端口地址，返回值是读到的数据。
void out8( uintptr_t port, uint8_t val );  向指定端口写一个 8 位数据。</description>
            <content type="html"><![CDATA[<p>要读写 I/O 端口，必须获得 I/O 权限，这需要以 root 权限运行线程，并且调用 ThreadCtl() 函数：</p>

<pre><code>#include &lt;sys/neutrino.h&gt;
ThreadCtl( _NTO_TCTL_IO, 0 );
</code></pre>

<p>然后调用 <code>mmap_device_io</code> 函数映射 I/O 端口地址：</p>

<pre><code>#include &lt;stdint.h&gt;
#include &lt;sys/mman.h&gt;

uintptr_t mmap_device_io( size_t len, uint64_t io );
</code></pre>

<p>io 表示要访问的 I/O 端口地址（基地址），len 表示要访问的 I/O 端口的字节数。如果调用成功会返回映射后的起始地址，可以直接用 in8 和 out8 等函数访问；如果失败则返回 <code>MAP_DEVICE_FAILED</code>。</p>

<p>调用读写 I/O 端口的函数要包括头文件：</p>

<pre><code>#include &lt;hw/inout.h&gt;
</code></pre>

<p>主要的函数有：</p>

<pre><code>uint8_t in8( uintptr_t port );
</code></pre>

<p>从指定端口读取 8 位数据，port 表示端口地址，返回值是读到的数据。</p>

<pre><code>void out8( uintptr_t port, uint8_t val );
</code></pre>

<p>向指定端口写一个 8 位数据。</p>
]]></content>
        </item>
        
        <item>
            <title>搭建 QNX 开发环境</title>
            <link>https://shaocheng.li/posts/2013/05/02/</link>
            <pubDate>Thu, 02 May 2013 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2013/05/02/</guid>
            <description>30天评估版页面：http://www.qnx.com/products/evaluation/ 在该页面下载所需软件，并申请 License 。
系统环境为：Windows XP 和 VMware 7.0
1. 安装 Windows 平台的 QNX 开发套件 下载 QNXSDP-6.5.0 和 QNXSDP-6.5.0-SP1 ，依次安装，安装过程中需要输入 License 。
 注意：安装目录不能有空格，否则以后使用过程中会出错。
 安装后在桌面会出现 QNX Momentics IDE 4.7 的图标:
2. 在 VMWare 中运行 QNX 在该页面中选择 VMware (PC) target ，下载文件 650SP1-VM.tar 。下载后解压。
然后用 VMware Workstation 7.0 或 VMware Player 3.0 打开其中的 650SP1-VM.vmx 文件。
如果在启动过程中 VMWare 弹出对话框提示“虚拟机被移动”，选择 Create 并点击 OK 。
启动后无需密码可直接用 root 用户登录。
登录后打开终端，用 ifconfig 查看网卡配置，用 ping 命令查看网络连接。确保可以和宿主机联通。</description>
            <content type="html"><![CDATA[

<p>30天评估版页面：<a href="http://www.qnx.com/products/evaluation/" target="_blank">http://www.qnx.com/products/evaluation/</a>
在该页面下载所需软件，并申请 License 。</p>

<p>系统环境为：Windows XP 和 VMware 7.0</p>

<h2 id="1-安装-windows-平台的-qnx-开发套件">1. 安装 Windows 平台的 QNX 开发套件</h2>

<p>下载 QNXSDP-6.5.0 和 QNXSDP-6.5.0-SP1 ，依次安装，安装过程中需要输入 License 。</p>

<blockquote>
<p>注意：安装目录不能有空格，否则以后使用过程中会出错。</p>
</blockquote>

<p>安装后在桌面会出现 QNX Momentics IDE 4.7 的图标:</p>

<p><img src="/images/2013-05-02/2013-05-02_1.GIF" alt="" /></p>

<h2 id="2-在-vmware-中运行-qnx">2. 在 VMWare 中运行 QNX</h2>

<p>在该页面中选择 VMware (PC) target ，下载文件 650SP1-VM.tar 。下载后解压。</p>

<p>然后用 VMware Workstation 7.0 或 VMware Player 3.0 打开其中的 650SP1-VM.vmx 文件。</p>

<p>如果在启动过程中 VMWare 弹出对话框提示“虚拟机被移动”，选择 Create 并点击 OK 。</p>

<p>启动后无需密码可直接用 root 用户登录。</p>

<p>登录后打开终端，用 ifconfig 查看网卡配置，用 ping 命令查看网络连接。确保可以和宿主机联通。</p>

<p>默认是用 DHCP 方式获取 IP 。</p>

<h2 id="3-创建程序项目">3. 创建程序项目</h2>

<p>打开 QNX Momentics IDE 。首次打开是根据提示设置 Workspace ，路径中不能有空格。</p>

<p>在菜单上选择 File / New / QNX C Project ，打开 New Project 对话框:</p>

<p><img src="/images/2013-05-02/2013-05-02_2.GIF" alt="" /></p>

<p>输入 Project Name ，点击 Next 。在 Build Variants 标签页中选择 X86(Little Endian) 。最后点击 Finish :</p>

<p><img src="/images/2013-05-02/2013-05-02_3.GIF" alt="" /></p>

<p>这时 IDE 可能还处于 Welcome 页面，点击右上方的 Workbench 图标，进入项目页面。</p>

<p><img src="/images/2013-05-02/2013-05-02_4.GIF" alt="" /></p>

<h2 id="4-qnx-的通讯">4. QNX 的通讯</h2>

<p>目标机系统需要能够响应来自开发环境的请求，所以要保证网络连通，并且在目标机系统的终端里启动 qconn 程序：</p>

<p><img src="/images/2013-05-02/2013-05-02_5.GIF" alt="" /></p>

<p>然后在开发环境的 Window 菜单中选择 Open Perspective&ndash;&gt;QNX System Information ，在打开的 Target Navigator 标签页的空白处点击鼠标右键并选择 New QNX Target&hellip;  :</p>

<p><img src="/images/2013-05-02/2013-05-02_6.GIF" alt="" /></p>

<p>在打开的对话框中输入 Target Name，也可以选择 Same as hostname ，输入目标机的 IP 。点击 Finish :</p>

<p><img src="/images/2013-05-02/2013-05-02_7.GIF" alt="" /></p>

<p>然后在 Target Navigator 中点击刚才新建的目标就可以在右边的 System Summary 页面看到目标机系统的进程列表:</p>

<p><img src="/images/2013-05-02/2013-05-02_8.GIF" alt="" /></p>

<h2 id="5-编译和链接">5. 编译和链接</h2>

<p>点击右上方的 C/C++ 图标从 QNX System Information 页面返回项目源码编辑页面:</p>

<p><img src="/images/2013-05-02/2013-05-02_9.GIF" alt="" /></p>

<p>在项目名称上点击鼠标右键，选择 Build Project 开始编译链接。编译过程应该不会报错。</p>

<h2 id="6-启动和调试">6. 启动和调试</h2>

<p>首先要创建一个启动配置。在工具栏上的 bug 图标下拉菜单中选择 Debug Configurations… ：</p>

<p><img src="/images/2013-05-02/2013-05-02_10.GIF" alt="" /></p>

<p>然后会出现一个对话框，在这里可以创建、管理和启动配置。</p>

<p>在左栏中选择 C/C++ QNX QConn (IP) ，然后点击 New launch configuration  图标：</p>

<p><img src="/images/2013-05-02/2013-05-02_11.GIF" alt="" /></p>

<p>现在只需要设置 main 标签页中的内容。在 C/C++ Application 中点击 C/C++ Application 按钮，选择需要启动和调试的二进制文件，其中带有 <code>_g</code> 后缀的文件带有调试信息，否则只能运行不能调试。选择后点击 OK 。</p>

<p><img src="/images/2013-05-02/2013-05-02_12.GIF" alt="" /></p>

<p>确保目标机在 Target Options 下列表中，然后点击 Apply ，一个新的启动配置就完成了。</p>

<p>现在点击 Debug ，集成开发环境就进入了调试界面，并通过网络将可执行程序传送到了目标机的系统中，然后在调试器中启动它。</p>
]]></content>
        </item>
        
        <item>
            <title>xargs 命令</title>
            <link>https://shaocheng.li/posts/2013/04/28/</link>
            <pubDate>Sun, 28 Apr 2013 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2013/04/28/</guid>
            <description>xagrs &amp;ndash; 从标准输入获得参数并执行命令
 xargs 有点类似反引号 ，但是功能更强大，它从标准输入获得参数列表，然后分割小块分段，再逐条传递给其他命令并执行。例如：
find ./ -type f | xargs grep date  该命令相当于对当前目录下的每个文件执行一次 grep date ，也就是将列出当前目录下文件内容中包含 date 的文件 。如果没有 xargs，只会列出当前目录下文件名中包含 date 字段的文件。
但是上面这个例子存在一个问题，如果文件名中包含有空格，会出错，这是因为 xargs 默认是按照空白字符来分割输入的。一个简单的解决办法就是告诉find使用NUL(\0)来分割结果（向find提供-print0选项），并且告诉xargs也使用Nul来分隔输入（-0）。例如删除当前目录下所有的 python 文件：
find ./ -name &#39;*.py&#39; -type f -print0 | xargs -0 rm  如果要指定参数在命令中的文件，可以用 -i 选项和 {} 的组合，参数就会被放到 {} 所在的位置。例如，将当前目录下的文件移动到 back 目录下：
find ./ -type f | xargs -i mv {} ./back/  有的命令执行时需要不止一个参数，xargs 提供了 -n 选项指定参数数目。一个简单的例子，逐对比较当前目录下的文件的不同：
find ./ -type f | xargs -n 2 diff  还用两个有用的选项：</description>
            <content type="html"><![CDATA[<blockquote>
<p>xagrs &ndash; 从标准输入获得参数并执行命令</p>
</blockquote>

<p>xargs 有点类似反引号 ，但是功能更强大，它从标准输入获得参数列表，然后分割小块分段，再逐条传递给其他命令并执行。例如：</p>

<pre><code>find ./ -type f | xargs grep date
</code></pre>

<p>该命令相当于对当前目录下的每个文件执行一次 <code>grep date</code> ，也就是将列出当前目录下文件内容中包含 <code>date</code> 的文件 。如果没有 <code>xargs</code>，只会列出当前目录下文件名中包含 <code>date</code> 字段的文件。</p>

<p>但是上面这个例子存在一个问题，如果文件名中包含有空格，会出错，这是因为 xargs 默认是按照空白字符来分割输入的。一个简单的解决办法就是告诉find使用NUL(\0)来分割结果（向find提供-print0选项），并且告诉xargs也使用Nul来分隔输入（-0）。例如删除当前目录下所有的 python 文件：</p>

<pre><code>find ./ -name '*.py' -type f -print0 | xargs -0 rm
</code></pre>

<p>如果要指定参数在命令中的文件，可以用 <code>-i</code> 选项和 <code>{}</code> 的组合，参数就会被放到 <code>{}</code> 所在的位置。例如，将当前目录下的文件移动到 back 目录下：</p>

<pre><code>find ./ -type f | xargs -i mv {} ./back/
</code></pre>

<p>有的命令执行时需要不止一个参数，xargs 提供了 <code>-n</code> 选项指定参数数目。一个简单的例子，逐对比较当前目录下的文件的不同：</p>

<pre><code>find ./ -type f | xargs -n 2 diff
</code></pre>

<p>还用两个有用的选项：</p>

<ul>
<li>-t 每次执行命令前将完整的命令打印一次</li>
<li>-r 在无输入情况下则不构造命令执行</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>在 ubuntu 中下载内核源码</title>
            <link>https://shaocheng.li/posts/2013/04/27/</link>
            <pubDate>Sat, 27 Apr 2013 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2013/04/27/</guid>
            <description>下载源码前必须确保已经安装了 dpkg-dev 。使用 apt-get install dpkg-dev 命令安装。
 查找带ubuntu补丁的内核源码
apt-cache search linux-source  该条命令会查找到很多版本的内核源码，选择所需要的，然后执行：
apt-get source linux-source-[version]  开始将内核源码包下载到当前目录中。源码包中有三个文件：*.dsc 、*.diff.gz 和 *.orig.tar.gz 。
下载完成后会自动调用 dpkg-source 命令，根据 dsc 文件中的信息，将源码包解压到同名目录中。然后就可以在源码目录下编译内核了。
 不只是内核源码，用 apt-get 下载其他源码也是这样的方式。
 在编译源码包前，还可以用下面命令安装具有依赖关系的相关软件包：
apt-get build-dep  在源码目录下执行 dpkg-buildpackage 命令，会生成 Deb 软件包，并放置在上层目录中。</description>
            <content type="html"><![CDATA[<blockquote>
<p>下载源码前必须确保已经安装了 <code>dpkg-dev</code> 。使用 <code>apt-get install dpkg-dev</code> 命令安装。</p>
</blockquote>

<p>查找带ubuntu补丁的内核源码</p>

<pre><code>apt-cache search linux-source
</code></pre>

<p>该条命令会查找到很多版本的内核源码，选择所需要的，然后执行：</p>

<pre><code>apt-get source linux-source-[version]
</code></pre>

<p>开始将内核源码包下载到当前目录中。源码包中有三个文件：*.dsc 、*.diff.gz 和 *.orig.tar.gz 。</p>

<p>下载完成后会自动调用 <code>dpkg-source</code> 命令，根据 <code>dsc</code> 文件中的信息，将源码包解压到同名目录中。然后就可以在源码目录下编译内核了。</p>

<blockquote>
<p>不只是内核源码，用 apt-get 下载其他源码也是这样的方式。</p>
</blockquote>

<p>在编译源码包前，还可以用下面命令安装具有依赖关系的相关软件包：</p>

<pre><code>apt-get build-dep
</code></pre>

<p>在源码目录下执行 <code>dpkg-buildpackage</code> 命令，会生成 Deb 软件包，并放置在上层目录中。</p>
]]></content>
        </item>
        
        <item>
            <title>GRUB2常用配置</title>
            <link>https://shaocheng.li/posts/2013/04/25/</link>
            <pubDate>Thu, 25 Apr 2013 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2013/04/25/</guid>
            <description> GRUB2 指南中文版
修改 GRUB2 的配置文件后，都要执行 update_grub 命令生成 /boot/grub/grub.cfg 文件，这样才能使修改生效。任何情况下都不建议手动更改该文件。
1.显示启动菜单 默认情况下，如果只安装了一个系统，GRUB2是不会显示启动菜单的。
可以在启动时按住 Shift 键，强制显示启动菜单。
2.修改默认启动项 在 /etc/default/grub 文件中，设置 GRUB_DEFAULT：
GRUB_DEFAULT = 0  /boot/grub/grub.cfg 文件中的第一个菜单项为 0 ，第二个为 1 &amp;hellip;
也可以设置为 saved ，表示默认启动项为上一次选择的项目。
3.修改 Linux 内核参数 在 /etc/default/grub 文件中，有两个选项用于设置向 Linux 内核传递的参数：
 GRUB_CMDLINE_LINUX 若存在，无论在一般或是救援模式，此行将追加到所有的 &amp;lsquo;linux&amp;rsquo; 命令行后面（传统 GRUB 的「kernel」选项）。类似于 menu.lst 中的「altoptions 」选项。
 GRUB_CMDLINE_LINUX_DEFAULT 此行将追加在 &amp;lsquo;linux&amp;rsquo; 命令行后面（传统 GRUB 的「kernel」选项）。此选项只会追加在一般模式的最后方。类似于 menu.lst 中的「defoptions」选项。如果想显示黑色屏幕以及启动进程文字，请移除「quiet splash」。若想看到 grub 引导画面及简短的文字输出，使用「splash」。若有需要的话，也可以在此行输入选项「acpi=off」。  </description>
            <content type="html"><![CDATA[

<p><a href="http://www.eit.name/blog/read.php?442" target="_blank">GRUB2 指南中文版</a></p>

<p>修改 GRUB2 的配置文件后，都要执行 <code>update_grub</code> 命令生成 <code>/boot/grub/grub.cfg</code> 文件，这样才能使修改生效。任何情况下都不建议手动更改该文件。</p>

<h2 id="1-显示启动菜单">1.显示启动菜单</h2>

<p>默认情况下，如果只安装了一个系统，GRUB2是不会显示启动菜单的。</p>

<p>可以在启动时按住 Shift 键，强制显示启动菜单。</p>

<h2 id="2-修改默认启动项">2.修改默认启动项</h2>

<p>在 <code>/etc/default/grub</code> 文件中，设置 <code>GRUB_DEFAULT</code>：</p>

<pre><code>GRUB_DEFAULT = 0
</code></pre>

<p><code>/boot/grub/grub.cfg</code> 文件中的第一个菜单项为 0 ，第二个为 1 &hellip;</p>

<p>也可以设置为 <code>saved</code> ，表示默认启动项为上一次选择的项目。</p>

<h2 id="3-修改-linux-内核参数">3.修改 Linux 内核参数</h2>

<p>在 <code>/etc/default/grub</code> 文件中，有两个选项用于设置向 Linux 内核传递的参数：</p>

<ul>
<li><strong>GRUB_CMDLINE_LINUX</strong>  若存在，无论在一般或是救援模式，此行将追加到所有的 &lsquo;linux&rsquo;  命令行后面（传统 GRUB  的「kernel」选项）。类似于 menu.lst 中的「altoptions 」选项。<br /></li>
<li><strong>GRUB_CMDLINE_LINUX_DEFAULT</strong>   此行将追加在 &lsquo;linux&rsquo;  命令行后面（传统 GRUB  的「kernel」选项）。此选项只会追加在一般模式的最后方。类似于 menu.lst 中的「defoptions」选项。如果想显示黑色屏幕以及启动进程文字，请移除「quiet splash」。若想看到 grub 引导画面及简短的文字输出，使用「splash」。若有需要的话，也可以在此行输入选项「acpi=off」。</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Linux 系统下编程控制蜂鸣器</title>
            <link>https://shaocheng.li/posts/2013/01/24/</link>
            <pubDate>Thu, 24 Jan 2013 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2013/01/24/</guid>
            <description>&lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;

&lt;p&gt;X86架构的蜂鸣器连接图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://shaocheng.li/images/2013-01-24/2013-01-24_1.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;由图可见，蜂鸣器的声调是由定时器8254的计数器2的输出 OUT2 控制的，OUT2 输出一定频率的正弦波就可以驱动蜂鸣器发声。8254 的端口地址是 0x40~0x43 。&lt;/p&gt;</description>
            <content type="html"><![CDATA[<h2 id="原理">原理</h2>

<p>X86架构的蜂鸣器连接图如下：</p>

<p><img src="/images/2013-01-24/2013-01-24_1.JPG" alt="" /></p>

<p>由图可见，蜂鸣器的声调是由定时器8254的计数器2的输出 OUT2 控制的，OUT2 输出一定频率的正弦波就可以驱动蜂鸣器发声。8254 的端口地址是 0x40~0x43 。</p>

<p>计数器2是否工作由门控信号 GATE2 决定，GATE2 接并口 PB0 位，即 IO 端口 0x61 的 D0 位。OUT2 和 PB1 经过一个与门后连接到蜂鸣器，PB1 是 IO 端口 0x61 的 D1 位。所以只有当 PB0 和 PB1 同时为高，OUT2 的输出才会到达蜂鸣器。</p>

<h2 id="编程">编程</h2>

<p>在 Linux 下，可以直接在用户空间访问 IO 端口。下面程序将是蜂鸣器发声 2 秒。</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/io.h&gt;

/*
 * val 为写入计数器的值
 * delay 为蜂鸣器发声持续的时间，单位是毫秒
 */
void beep(unsigned short int val,int delay)
{
    unsigned char reg_val = 0;
    iopl(3);

    outb(0xb6,0x43); //counter 2 , mode 3
    outb(val&amp;0x00ff,0x42);
    outb(val&gt;&gt;8,0x42);

    reg_val = inb(0x61);
    outb(reg_val|0x03,0x61);  //PB0和PB1输出高电平
    usleep(1000*delay);
    outb(reg_val&amp;0xfc,0x61);  //PB0和PB1输出低电平

    iopl(0);

}

int main()
{
    beep(500,2000);
    return 0;
}
</code></pre>]]></content>
        </item>
        
        <item>
            <title>使用 udev 管理设备</title>
            <link>https://shaocheng.li/posts/2013/01/05/</link>
            <pubDate>Sat, 05 Jan 2013 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2013/01/05/</guid>
            <description>udev 是 linux 2.6 内核提供的一种动态管理设备器，主要功能是管理 /dev 目录下的设备节点，同时也替换了 devfs 和 hotplug 的功能，这意味着它要在添加/删除硬件时处理 /dev 目录以及所有用户空间的行为，包括加载 firmware 时。
udev 依赖于内核提供的 uevent 接口，每次添加或删除设备时，内核都会发送 uevent 向 udev 通知更改。udev 的守护进程是 udevd ，在系统启动时会读取并分析 udev 规则文件提供的所有规则，并保存在内存。 当 udev 接收到内核发出的设备更改事件后，会将设备信息与规则进行匹配，然后执行相应的操作。
linux内核中的设备信息都是通过 sysfs 文件系统导出的，位于 /sys 目录下。
1. udevadm udevadm 是一个 udev 管理工具。可用于监视和控制 udev 的运行时行为、请求内核事件、管理事件队列，以及提供简单的调试机制。
1.1 监视正在运行的 udev 守护进程 程序 udevadm monitor 用于将驱动程序核心时间和 udev 事件处理的计时可视化。执行 udevadm monitor 后，会出现如下内容：
monitor will print the received events for: UDEV - the event which udev sends out after rule processing KERNEL - the kernel uevent  之后发生的所有 udev 事件都会显示。例如下面是插入 U 盘后显示的前几行：</description>
            <content type="html"><![CDATA[

<p>udev 是 linux 2.6 内核提供的一种动态管理设备器，主要功能是管理 /dev 目录下的设备节点，同时也替换了 devfs 和 hotplug 的功能，这意味着它要在添加/删除硬件时处理 /dev 目录以及所有用户空间的行为，包括加载 firmware 时。</p>

<p>udev 依赖于内核提供的 uevent 接口，每次添加或删除设备时，内核都会发送 uevent 向 udev 通知更改。udev 的守护进程是 udevd ，在系统启动时会读取并分析 udev 规则文件提供的所有规则，并保存在内存。 当 udev 接收到内核发出的设备更改事件后，会将设备信息与规则进行匹配，然后执行相应的操作。</p>

<p>linux内核中的设备信息都是通过 sysfs 文件系统导出的，位于 /sys 目录下。</p>

<h2 id="1-udevadm">1. udevadm</h2>

<p>udevadm 是一个 udev 管理工具。可用于监视和控制 udev 的运行时行为、请求内核事件、管理事件队列，以及提供简单的调试机制。</p>

<h3 id="1-1-监视正在运行的-udev-守护进程">1.1 监视正在运行的 udev 守护进程</h3>

<p>程序 <code>udevadm monitor</code> 用于将驱动程序核心时间和 udev 事件处理的计时可视化。执行 <code>udevadm monitor</code> 后，会出现如下内容：</p>

<pre><code>monitor will print the received events for:
UDEV - the event which udev sends out after rule processing
KERNEL - the kernel uevent
</code></pre>

<p>之后发生的所有 udev 事件都会显示。例如下面是插入 U 盘后显示的前几行：</p>

<pre><code>KERNEL[1356423352.040293] add      /devices/pci0000:00/0000:00:11.0/0000:02:03.0/usb1/1-1 (usb)
KERNEL[1356423352.098881] add      /devices/pci0000:00/0000:00:11.0/0000:02:03.0/usb1/1-1/1-1:1.0 (usb)
UDEV  [1356423352.181389] add      /devices/pci0000:00/0000:00:11.0/0000:02:03.0/usb1/1-1 (usb)
KERNEL[1356423352.239535] add      /module/usb_storage (module)
UDEV  [1356423352.241499] add      /module/usb_storage (module)
</code></pre>

<p>每行表示一个事件。第一个字段中，KERNEL 表示这是一个内核产生的事件，UDEV 表示 udev 事件。第二个字段是计时，单位是微秒。第三个字段表示事件的动作，add 表示添加，如果卸载 U 盘会显示 remove 。最后是 sysfs 文件系统中添加或删除的文件和目录。</p>

<h3 id="1-2-查询设备信息">1.2 查询设备信息</h3>

<p><code>udevadm info</code> 用于查询 sysfs 文件系统中的设备信息，信息是按照 Linux 设备模型的层次结构显示的，首先是这个设备的路径和信息，然后依次遍历它的父设备。</p>

<p>例如要查询 U 盘 sdb1 的信息，就执行：</p>

<pre><code>udevadm info -a -p /sys/class/block/sdb1
</code></pre>

<p>显示的第一段信息如下：</p>

<pre><code>looking at device '/devices/pci0000:00/0000:00:11.0/0000:02:03.0/usb1/1-1/1-1:1.0/host5/target5:0:0/5:0:0:0/block/sdd/sdd1':
KERNEL==&quot;sdd1&quot;
SUBSYSTEM==&quot;block&quot;
DRIVER==&quot;&quot;
ATTR{partition}==&quot;1&quot;
ATTR{start}==&quot;1040128&quot;
ATTR{size}==&quot;6848768&quot;
ATTR{alignment_offset}==&quot;0&quot;
ATTR{stat}==&quot;     143     6874     9334     1493        1        0        1        3        0     1266     1496&quot;
ATTR{inflight}==&quot;       0        0&quot;
</code></pre>

<p>KERNEL 是设备在内核中的名称，SUBSYSTEM 表示它所属的子系统，ATTR{} 表示各种属性。这些字段都会在 udev 规则中 用到。</p>

<h2 id="2-udev-规则">2. udev 规则</h2>

<p>udev 规则可以与内核添加到事件本身的属性或者内核导出到 sysfs 的任何信息匹配。规则还可以从外部程序请求其他信息。根据提供的规则匹配每个事件。所有规则都位于 /etc/udev/rules.d 目录下。</p>

<p>规则文件中的每一行至少包含一个关键字值对。有两种类型的关键字，匹配关键字和指派关键字。如果所有匹配关键字与它们的值匹配，则应用此规则并将指派关键字指派给特定的值。匹配规则可以指定设备节点的名称、添加指向该节点的符号链接或者运行作为事件处理一部分的特定程序。如果找不到匹配的规则，则使用默认设备节点名来创建设备节点。udev 手册页中描述了有关规则语法和提供用来与数据匹配或导入数据的关键字的详细信息。</p>

<p>下面这个例子来自 /etc/udev/rules.d/10-automount.rules 。</p>

<pre><code>KERNEL==&quot;sd[b-z]&quot;,SUBSYSTEM==&quot;block&quot;,BUS==&quot;usb&quot;,SYMLINK+=&quot;usb_%k&quot;
KERNEL==&quot;sd[b-z][1-9]&quot;,SUBSYSTEM==&quot;block&quot;,BUS==&quot;usb&quot;,SYMLINK+=&quot;usb_%k&quot;

ACTION==&quot;add&quot;,KERNEL==&quot;sd[b-z][1-9]&quot;,SUBSYSTEM==&quot;block&quot;,BUS==&quot;usb&quot;,RUN+=&quot;/bin/mkdir -m 777 /media/usb_%k&quot;,RUN+=&quot;/bin/mount -t auto /dev/usb_%k /media/usb_%k&quot;

ACTION==&quot;remove&quot;,KERNEL==&quot;sd[b-z][1-9]&quot;,SUBSYSTEM==&quot;block&quot;,BUS==&quot;usb&quot;,RUN+=&quot;/bin/rm -rf /media/usb_%k&quot;
</code></pre>

<p>前两条规则由四个键构成：三个匹配键 (KERNEL,SUBSYSTEM,BUS) 和一个赋值键 (SYMLINK)。三个匹配规则搜索设备列表以查找所有的 U 盘。只有完全匹配才能触发执行此规则。在这种情况下，SYMLINK 指派关键字会在 /dev 目录下生产一个的链接，指向默认的设备节点。匹配此特殊设备类型的任何后续规则都不产生任何影响。</p>

<p>后两条规则分别对应插入(add)和拔出(remove) U 盘的事件。RUN 表示事件发生时执行的程序。</p>

<p>所有规则具有一些共同的特征:</p>

<ul>
<li><p>每个规则由一个或多个以逗号分隔的关键字值对构成。</p></li>

<li><p>关键字的运算由运算符确定，udev 规则支持多个不同的运算符。</p></li>

<li><p>每个给定值必须用引号引起来。</p></li>

<li><p>规则文件的每一行代表一个规则。如果一个规则超过一行，请使用 <code>\</code> 合并不同行，就像在壳层语法中一样。</p></li>

<li><p>udev 规则支持与 *、? 和 [] 模式匹配的外壳式模式。</p></li>

<li><p>udev 规则支持替换。</p></li>
</ul>

<h3 id="2-1-在-udev-规则中使用运算符">2.1 在 udev 规则中使用运算符</h3>

<p>创建可以从若干不同运算符选择的关键字，具体取决于希望创建的关键字类型。匹配关键字通常仅用于查找匹配或明显不匹配搜索值的值。匹配关键字包含以下运算符之一：</p>

<ul>
<li><p><code>==</code>  比较等于性。如果关键字包含搜索模式，则匹配该模式的所有结果均有效。</p></li>

<li><p><code>!=</code>  比较不等于性。如果关键字包含搜索模式，则匹配该模式的所有结果均有效。</p></li>
</ul>

<p>赋值关键字可以使用下面的任何运算符：</p>

<ul>
<li><p><code>=</code>   为关键字指派值。如果关键字以前由一列值构成，关键字将重置，并且仅指派一个值。</p></li>

<li><p><code>+=</code>  为包含一列项的关键字添加一个值。</p></li>

<li><p><code>:=</code>  指派最终值。不允许后面的规则进行任何后续更改。</p></li>
</ul>

<h3 id="2-2-在-udev-规则中使用替换项">2.2 在 udev 规则中使用替换项</h3>

<p>udev 规则支持使用占位符和替换项。请按照在其他任何脚本中的相同方式使用。在 udev 规则中可使用以下替换项：</p>

<ul>
<li><p><strong>%r、$root</strong></p>

<p>设备目录 /dev（默认）。</p></li>

<li><p><strong>%p、$devpath</strong></p>

<p>DEVPATH 的值。</p></li>

<li><p><strong>%k、$kernel</strong></p>

<p>KERNEL 的值或内部设备名称。</p></li>

<li><p><strong>%n、$number</strong></p>

<p>设备号。</p></li>

<li><p><strong>%N、$tempnode</strong></p>

<p>设备文件的临时名称。</p></li>

<li><p><strong>%M、$major</strong></p>

<p>设备的主编号。</p></li>

<li><p><strong>%m、$minor</strong></p>

<p>设备的次编号。</p></li>

<li><p><strong>%s{attribute}/$attr{attribute}</strong></p>

<p>sysfs 属性的值（由 attribute 指定）。</p></li>

<li><p><strong>%E{variable}、$attr{variable}</strong></p>

<p>环境变量的值（由 variable 指定）。</p></li>

<li><p><strong>%c、$result</strong></p>

<p>PROGRAM 的输出。</p></li>

<li><p><strong>%%</strong></p>

<p>%字符。</p></li>

<li><p><strong>$$</strong></p>

<p>$ 字符。</p></li>
</ul>

<h3 id="2-3-使用-udev-匹配关键字">2.3 使用 udev 匹配关键字</h3>

<p>匹配关键字描述应用 udev 规则之前必须满足的条件。以下匹配关键字可用：</p>

<ul>
<li><p><strong>ACTION</strong></p>

<p>事件操作的名称，如 add 或 remove（添加或删除设备时）。</p></li>

<li><p><strong>DEVPATH</strong></p>

<p>事件设备的设备路径，如 DEVPATH=/bus/pci/drivers/ipw3945，用于搜索与 ipw3945 驱动程序有关的所有事件。</p></li>

<li><p><strong>KERNEL</strong></p>

<p>事件设备的内部（内核）名称。</p></li>

<li><p><strong>SUBSYSTEM</strong></p>

<p>事件设备的子系统，如 SUBSYSTEM=usb（用于与 USB 设备有关的所有事件）。</p></li>

<li><p><strong>ATTR{filename}</strong></p>

<p>事件设备的 sysfs 属性。例如，要匹配 vendor 属性文件名中包含的字符串，可以使用 ATTR{vendor}==&ldquo;On(sS)tream&rdquo;。</p></li>

<li><p><strong>KERNELS</strong></p>

<p>让 udev 向上搜索设备路径以查找匹配的设备名称。</p></li>

<li><p><strong>SUBSYSTEMS</strong></p>

<p>让 udev 向上搜索设备路径以查找匹配的设备子系统名称。</p></li>

<li><p><strong>DRIVERS</strong></p>

<p>让 udev 向上搜索设备路径以查找匹配的设备驱动程序名称。</p></li>

<li><p><strong>ATTRS{filename}</strong></p>

<p>让 udev 向上搜索设备路径以查找具有匹配的 sysfs 属性值的设备。</p></li>

<li><p><strong>ENV{key}</strong></p>

<p>环境变量的值，如 ENV{ID_BUS}=&ldquo;ieee1394，用于搜索与该 FireWire 总线 ID 有关的所有事件。</p></li>

<li><p><strong>PROGRAM</strong></p>

<p>让 udev 执行外部程序。程序必须返回退出码零，才能成功。程序的输出（打印到 stdout）可用于 RESULT 关键字。</p></li>

<li><p><strong>RESULT</strong></p>

<p>匹配上次 PROGRAM 调用的输出字符串。在与 PROGRAM 关键字相同的规则中包含该关键字，或在后面的一个中。</p></li>
</ul>

<h3 id="2-4-使用-udev-指派关键字">2.4 使用 udev 指派关键字</h3>

<p>与上述匹配键相比，赋值键未描述必须满足的条件。它们将值、名称和操作指派给由 udev 维护的设备节点。</p>

<ul>
<li><p><strong>NAME</strong></p>

<p>将创建的设备节点的名称。在一个规则设置节点名称之后，将对该节点忽略带有 NAME 关键字的其他所有规则。</p></li>

<li><p><strong>SYMLINK</strong></p>

<p>与要创建的节点有关的符号链接名称。多个匹配的规则可添加要使用设备节点创建的符号链接。也可以通过使用空格字符分隔符号链接名称，在一个规则中为一个节点指定多个符号链接。</p></li>

<li><p><strong>OWNER, GROUP, MODE</strong></p>

<p>新设备节点的权限。此处指定的值重写已编译的任何值。</p></li>

<li><p><strong>ATTR{key}</strong></p>

<p>指定要写入事件设备的 sysfs 属性的值。如果使用 == 运算符，也将使用该关键字匹配 sysfs 属性的值。</p></li>

<li><p><strong>ENV{key}</strong></p>

<p>告知 udev 将变量导出到环境。如果使用 == 运算符，也将使用该关键字匹配环境变量。</p></li>

<li><p><strong>RUN</strong></p>

<p>告知 udev 向程序列表添加要为该设备执行的程序。请记住，将此程序限制于很短的任务，以免妨碍此设备的后续事件。</p></li>

<li><p><strong>LABEL</strong></p>

<p>添加 GOTO 可跳至的标签。</p></li>

<li><p><strong>GOTO</strong></p>

<p>告知 udev 跳过一些规则，继续执行具有按 GOTO 关键字引用的标签的规则。</p></li>

<li><p><strong>IMPORT{type}</strong></p>

<p>将变量装载入外部程序输出之类的事件环境中。udev 导入不同类型的若干变量。如果未指定任何类型，udev 将尝试根据文件许可权限的可执行位来自行确定类型。</p>

<ul>
<li>program 告知 udev 执行外部程序并导入其输出。</li>
<li>file 告知 udev 导入文本文件。</li>
<li>parent 告知 udev 从父设备导入储存的关键字。</li>
</ul></li>

<li><p><strong>WAIT_FOR_SYSFS</strong></p>

<p>告知 udev 等待要为某个设备创建的指定 sysfs 文件。例如，WAIT_FOR_SYSFS=&ldquo;ioerr_cnt&rdquo; 通知 udev 等待 ioerr_cnt 文件创建完成。</p></li>

<li><p><strong>OPTIONS</strong></p>

<p>OPTION 关键字可能有若干值：</p>

<ul>
<li>last_rule 告知 udev 忽略后面的所有规则。</li>
<li>ignore_device 告知 udev 完全忽略此事件。</li>
<li>ignore_remove 告知 udev 忽略后面针对设备的所有删除事件。</li>
<li>all_partitions 告知 udev 为块设备上的所有可用分区创建设备节点。</li>
</ul></li>
</ul>

<h2 id="3-udev-使用的文件">3. udev 使用的文件</h2>

<ul>
<li><p>/sys/*</p>

<p>Linux 内核提供的虚拟文件系统，用于导出所有当前已知设备。此信息由 udev 用于在 /dev 中创建设备节点</p></li>

<li><p>/dev/*</p>

<p>动态创建的设备节点和引导时从 /lib/udev/devices/* 复制的静态内容</p></li>

<li><p>/etc/udev/udev.conf</p>

<p>主 udev 配置文件。</p></li>

<li><p>/etc/udev/rules.d/*</p>

<p>udev 事件匹配规则.</p></li>

<li><p>/lib/udev/devices/*</p>

<p>静态 /dev 内容。</p></li>

<li><p>/lib/udev/*</p>

<p>从 udev 规则调用的帮助程序。</p></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Linux 字符驱动的基本结构</title>
            <link>https://shaocheng.li/posts/2013/01/04/</link>
            <pubDate>Fri, 04 Jan 2013 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2013/01/04/</guid>
            <description>假设字符设备名为 led ，源文件为led.c ，不涉及实际的硬件操作。基本的驱动代码结构如下：
1. 包含必要的头文件 #include &amp;lt;linux/init.h&amp;gt; //module_init() 和 module_exit() #include &amp;lt;linux/sched.h&amp;gt; //包含大部分内核API的定义 #include &amp;lt;linux/module.h&amp;gt; //什么模块信息的宏，例如MODULE_AUTHOR(author) #include &amp;lt;linux/version.h&amp;gt; //包含内核版本信息的头文件 #include &amp;lt;linux/moduleparam.h&amp;gt; //创建模块参数的宏 #include &amp;lt;linux/kernel.h&amp;gt; //printk等函数 #include &amp;lt;linux/types.h&amp;gt; //内核模块的各种数据类型，例如dev_t #include &amp;lt;linux/fs.h&amp;gt; //文件系统 #include &amp;lt;linux/cdev.h&amp;gt;  还可以根据需要添加其他头文件。
2. 定义一个设备私有数据结构 通常会将设备名，设备号，cdev等都放入这个数据结构。
struct led_dev_t { char dev_name[10]; dev_t dev_num; struct cdev cdev; } struct led_dev_t *led_dev;  3. 实现 file_operations 结构 file_operations 结构首先要实现 .owner 然后再根据需要实现相关函数。
struct file_operations led_fops = { .owner = THIS_MODULE, .</description>
            <content type="html"><![CDATA[

<p>假设字符设备名为 led ，源文件为led.c ，不涉及实际的硬件操作。基本的驱动代码结构如下：</p>

<h2 id="1-包含必要的头文件">1. 包含必要的头文件</h2>

<pre><code>#include &lt;linux/init.h&gt;    //module_init() 和 module_exit() 
#include &lt;linux/sched.h&gt;   //包含大部分内核API的定义
#include &lt;linux/module.h&gt;  //什么模块信息的宏，例如MODULE_AUTHOR(author)
#include &lt;linux/version.h&gt; //包含内核版本信息的头文件
#include &lt;linux/moduleparam.h&gt;  //创建模块参数的宏
#include &lt;linux/kernel.h&gt;  //printk等函数
#include &lt;linux/types.h&gt;   //内核模块的各种数据类型，例如dev_t
#include &lt;linux/fs.h&gt;      //文件系统
#include &lt;linux/cdev.h&gt;    
</code></pre>

<p>还可以根据需要添加其他头文件。</p>

<h2 id="2-定义一个设备私有数据结构">2. 定义一个设备私有数据结构</h2>

<p>通常会将设备名，设备号，cdev等都放入这个数据结构。</p>

<pre><code>struct led_dev_t {
    char dev_name[10];
    dev_t dev_num;
    struct cdev cdev;
}
struct led_dev_t *led_dev;
</code></pre>

<h2 id="3-实现-file-operations-结构">3. 实现 file_operations 结构</h2>

<p>file_operations 结构首先要实现 <code>.owner</code> 然后再根据需要实现相关函数。</p>

<pre><code>struct file_operations led_fops = {
    .owner = THIS_MODULE,
    .open = led_open,
    .release = led_close,
}
</code></pre>

<h2 id="4-实现模块初始化函数">4. 实现模块初始化函数</h2>

<p>模块加载函数应该依次完成如下几个步骤：</p>

<ol>
<li>为设备私有数据结构分配内存，然后初始化。</li>
<li>申请设备号。</li>
<li>注册字符设备。即初始化 <code>cdev</code> ，将 <code>file_operations</code> 结构和设备号与 <code>cdev</code> 绑定。</li>
</ol>

<p>最后用 <code>module_init()</code> 宏向内核说明初始化函数的位置。</p>

<h2 id="5-实现模块卸载函数">5. 实现模块卸载函数</h2>

<p>模块卸载函数的内容基本是加载函数的逆过程：</p>

<ol>
<li>释放设备号。</li>
<li>删除 <code>cdev</code> 。</li>
<li>释放申请的内存。</li>
</ol>

<p>最后用 <code>module_exit()</code> 宏向内核说明卸载函数的位置。</p>

<h2 id="6-实现文件操作函数">6. 实现文件操作函数</h2>

<p>open 和 close 函数通常是必须的。</p>

<p>open 函数的原型是</p>

<pre><code>int (*open)(struct inode *,struct file *)
</code></pre>

<p><code>inode</code> 结构的成员 <code>i_cdev</code> 指向的就是先前设置的 <code>cdev</code> 。要确保设备成功打开，应该通过 <code>inode-&gt;i_cdev</code> 找到包含 <code>cdev</code> 的设备私有数据结构的实例。内核提供 <code>container_of</code> 宏来完成这项工作：</p>

<pre><code>container_of(poiner,container_type,container_field);
</code></pre>

<p>用法如下：</p>

<pre><code>struct led_dev_t *dev;
dev = container_of(inode-&gt;i_cdev,struct led_dev_t,cdev);
DEBUG(&quot;open %s\n&quot;,dev-&gt;dev_name);
filp-&gt;private_data = dev;
</code></pre>

<p>close 函数的原型是</p>

<pre><code>int (*release)(struct inode *,struct file *)
</code></pre>

<h2 id="7-模块参数">7. 模块参数</h2>

<p>模块的参数通过 <code>module_param(name,type,flag)</code> 声明，并且应该有一个默认值，例如：</p>

<pre><code>static int addr=0x300;
module_param(addr,int,S_IRUGO|S_IWUSR);
</code></pre>

<p>如果参数类型为字符串，type 应该设为 <code>charp</code> 。</p>

<p>flag 是访问许可值，可用的值定义在 <code>&lt;linux/stat.h&gt;</code> 中。<code>S_IRUGO</code> 表示任何人都可以读取该参数，但不能修改；<code>S_IWUSR</code> 表示 root 用户可以修改该参数。</p>

<h2 id="8-声明许可证">8. 声明许可证</h2>

<pre><code>MODULE_LICENSE(&quot;GPL&quot;);
</code></pre>

<h2 id="9-关于调试">9. 关于调试</h2>

<p>最常用的调试手段是内核打印函数 <code>printk</code> ，使用方法与标准库函数 <code>printf</code> 类似。<code>printk</code> 打印的信息通常用 <code>dmesg</code> 命令查看。</p>

<p>为了方便在最终发布时去掉打印的调试信息，通常将 <code>printk</code> 函数封装为一个宏 ：</p>

<pre><code>#define PRINT_DEBUG
#ifdef PRINT_DEBUG
    #define DEBUG(fmt,args...) printk(&quot;LED:&quot;fmt,##args)
#else
    #define DEBUG(fmt,args...)
#endif
</code></pre>

<p>发布时只需将第一行注释掉，就可以去掉打印信息。</p>

<h2 id="10-makefile">10. Makefile</h2>

<pre><code>KERNELDIR=/lib/modules/$(shell uname -r)/build
PWD=$(shell pwd)

obj-m := led.o

default:
    $(MAKE) -C $(KERNELDIR) M=$(PWD) modules
clean:
    $(MAKE) -C $(KERNELDIR) M=$(PWD) clean
</code></pre>

<p>如果模块包含多个源文件，比如 file1.c 和 file2.c ，Makefile 应该如下编写：</p>

<pre><code>obj-m := modulename.o
modulename-objs := file1.o file2.o
</code></pre>

<p>modulename 是模块的名称，最好不要与源文件同名。</p>

<h2 id="11-加载驱动">11. 加载驱动</h2>

<p>用 insmod 命令加载驱动，加载时可以指定参数，例如：</p>

<pre><code>insmod led.ko addr=0x300
</code></pre>

<p>加载成功后，<code>/sys/modules/</code> 下会出现相应的目录，<code>/proc/modules</code>文件（lsmod 即查看的该文件）中会出现模块的信息， <code>/proc/devices</code> 文件中可以看到设备名和主设备号：</p>

<pre><code>cat /proc/devices | grep led
</code></pre>

<p>可以根据主设备号创建设备节点。</p>

<h2 id="12-附录-完整代码">12. 附录：完整代码</h2>

<pre><code>#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/mm.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/types.h&gt;
#include &lt;linux/cdev.h&gt;
#include &lt;linux/version.h&gt;

#define PRINT_DEBUG
#ifdef PRINT_DEBUG
    #define DEBUG(fmt,args...) printk(&quot;LED : &quot;fmt,##args)
#else
    #define DEBUG(fmt,args...)
#endif


struct led_dev_t {
    const char *dev_name;
    dev_t dev_num;
    struct cdev cdev;
};

struct led_dev_t *led_dev;

int led_open(struct inode *inode,struct file *filp)
{
    struct led_dev_t *dev;
    dev = container_of(inode-&gt;i_cdev,struct led_dev_t,cdev);
    DEBUG(&quot;open %s\n&quot;,dev-&gt;dev_name);
    filp-&gt;private_data = dev;

    return 0;
}

int led_close(struct inode *inode,struct file *filp)
{
    DEBUG(&quot;close %s\n&quot;,((struct led_dev_t *)filp-&gt;private_data)-&gt;dev_name);

    return 0;
}

struct file_operations led_fops = {
    .owner = THIS_MODULE,
    .open = led_open,
    .release = led_close,
};

static int __init led_init(void)
{
    int ret = 0;
    unsigned int dev_major = 0;
    unsigned int dev_minor = 0;

    //初始化设备私有数据结构
    led_dev = kmalloc(sizeof(struct led_dev_t),GFP_KERNEL);
    if(led_dev &lt;= 0) {
    DEBUG(&quot;led init kmalloc failed\n&quot;);
    return -1;
    }
    memset(led_dev,0,sizeof(struct led_dev_t));
    led_dev-&gt;dev_name = &quot;led&quot;;  //定义设备名

    //申请设备号
    if(dev_major) {
    led_dev-&gt;dev_num = MKDEV(dev_major,dev_minor);
    ret = register_chrdev_region(led_dev-&gt;dev_num,1,led_dev-&gt;dev_name);
    }
    else {
    ret = alloc_chrdev_region(&amp;(led_dev-&gt;dev_num),dev_minor,1,led_dev-&gt; dev_name);
    dev_major = MAJOR(led_dev-&gt;dev_num);
    }

    if(ret) {
    DEBUG(&quot;register chrdev region failed\n&quot;);
    return ret;
    }
    else {
    DEBUG(&quot;Major: %d, Minor: %d\n&quot;,dev_major,dev_minor);
    }

    //初始化 cdev
    cdev_init(&amp;(led_dev-&gt;cdev),&amp;led_fops);
    led_dev-&gt;cdev.owner = THIS_MODULE;
    ret = cdev_add(&amp;(led_dev-&gt;cdev),led_dev-&gt;dev_num,1);

    if(ret&lt;0) {
    DEBUG(&quot;cdev add failed\n&quot;);
    return ret;
    }

    DEBUG(&quot;led init\n&quot;);

    return 0;
}


static void __exit led_exit(void)
{

    DEBUG(&quot;device is %s\n&quot;,led_dev-&gt;dev_name);
    unregister_chrdev_region(led_dev-&gt;dev_num,1);
    cdev_del(&amp;led_dev-&gt;cdev);
    kfree(led_dev);
    DEBUG(&quot;led exit\n&quot;);
}

module_init(led_init);
module_exit(led_exit);


MODULE_AUTHOR(&quot;Li Shaocheng&quot;);
MODULE_LICENSE(&quot;GPL&quot;);
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>在 Linux 内核中新增模块代码</title>
            <link>https://shaocheng.li/posts/2012/12/18/</link>
            <pubDate>Tue, 18 Dec 2012 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2012/12/18/</guid>
            <description>一个最简单的内核模块 编写一个最简单的内核模块 hellomod，源码 hellomod.c 如下：
#include &amp;lt;linux/init.h&amp;gt; #include &amp;lt;linux/module.h&amp;gt; static int __init hellomod_init(void) { printk(&amp;quot;hellomod init\n&amp;quot;); return 0; } static void __exit hellomod_exit(void) { printk(&amp;quot;hellomod exit\n&amp;quot;); } module_init(hellomod_init); module_exit(hellomod_exit); MODULE_LICENSE(&amp;quot;GPL&amp;quot;);  Makefile 文件如下：
KERDIR=/lib/modules/$(shell uname -r)/build PWD=$(shell pwd) obj-m:=hellomod.o default: make -C ${KERDIR} M=${PWD} modules clean: make -C ${KERDIR} M=${PWD} clean  直接运行 make 即可将其编译为 hellomod.ko 。下面以该模块为例介绍添加到内核的步骤。
添加到内核 将一个模块源码添加到内核需要如下三个步骤：
1.将源码文件复制的相应的目录中 我们将 hellomod.c 复制到内核源码的 driver/char/ 目录下。
2.修改 Makefile 文件 在 driver/char/Makefile 文件中添加新的模块：</description>
            <content type="html"><![CDATA[

<h2 id="一个最简单的内核模块">一个最简单的内核模块</h2>

<p>编写一个最简单的内核模块 <code>hellomod</code>，源码 <code>hellomod.c</code> 如下：</p>

<pre><code>#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;

static int __init hellomod_init(void)
{
    printk(&quot;hellomod init\n&quot;);
    return 0;
}

static void __exit hellomod_exit(void)
{
    printk(&quot;hellomod exit\n&quot;);
}

module_init(hellomod_init);
module_exit(hellomod_exit);

MODULE_LICENSE(&quot;GPL&quot;);
</code></pre>

<p><code>Makefile</code> 文件如下：</p>

<pre><code>KERDIR=/lib/modules/$(shell uname -r)/build
PWD=$(shell pwd)

obj-m:=hellomod.o

default:
    make -C ${KERDIR} M=${PWD} modules
clean:
    make -C ${KERDIR} M=${PWD} clean
</code></pre>

<p>直接运行 <code>make</code> 即可将其编译为 hellomod.ko 。下面以该模块为例介绍添加到内核的步骤。</p>

<h2 id="添加到内核">添加到内核</h2>

<p>将一个模块源码添加到内核需要如下三个步骤：</p>

<h3 id="1-将源码文件复制的相应的目录中">1.将源码文件复制的相应的目录中</h3>

<p>我们将 <code>hellomod.c</code> 复制到内核源码的 <code>driver/char/</code> 目录下。</p>

<h3 id="2-修改-makefile-文件">2.修改 Makefile 文件</h3>

<p>在 <code>driver/char/Makefile</code> 文件中添加新的模块：</p>

<pre><code>obj-$(CONFIG_HELLOMOD) += hellomod.o
</code></pre>

<p>其中 <code>CONFIG_HELLOMOD</code> 变量是在配置内核是确定的，通常可以取三个值：y 、n 、m 。其中 <code>CONFIG_</code> 是固定的， <code>HELLOMOD</code> 是自定义的，但必须与 Kconfig 文件中的设置一致。</p>

<h3 id="3-修改-kconfig-文件">3.修改 Kconfig 文件</h3>

<p><code>drivers/char/Kconfig</code> 文件的基本结构如下：</p>

<pre><code>menu &quot;Characters devices&quot;

config ...
...

source &quot;drivers/char/ipmi/Kconfig&quot;
...

endmenu
</code></pre>

<p><code>menu</code> 和 <code>endmenu</code> 之间定义了一个 <code>Characters devices</code> 菜单。<code>config</code> 字段定义了一个模块选项，<code>source</code> 导入了一个外部的 <code>Kconfig</code> 。</p>

<p>在 <code>menu</code> 和 <code>endmenu</code> 之间添加：</p>

<pre><code>config HELLOMOD
    tristate &quot;hellomod&quot;
    default m
    help
        just a module
</code></pre>

<p><code>HELLOMOD</code> 与 <code>Makefile</code> 中定义的变量是一致的。<code>tristate</code> 设置的是显示在配置界面的条目，<code>default</code> 设置的是该配置的默认值。<code>help</code> 显示的是帮助内容。</p>

<p>如上修改之后，运行 <code>make menuconfig</code> ，就可以在 <code>Device Drivers -&gt; Character devices</code> 中看到 <code>&lt;M&gt;hellomod</code> 。退出保存后可以在 <code>.config</code> 文件中看到 <code>CONFIG_HELLOMOD=m</code> 。</p>

<h2 id="新增一个模块目录">新增一个模块目录</h2>

<p>如果要为 <code>hellomod</code> 新建一个单独的目录，可以按如下步骤完成：</p>

<h3 id="1-新建目录并添加源文件">1.新建目录并添加源文件</h3>

<p>在 <code>drivers/char/</code> 目录下新建 <code>hellomod</code> 目录，并将 <code>hellomod.c</code> 复制到该目录下。</p>

<h3 id="2-添加-makefile">2.添加 Makefile</h3>

<p>在 <code>drivers/char/hellomod/</code> 目录下新建 <code>Makefile</code> 文件，内容如下：</p>

<pre><code>obj-$(CONFIG_HELLOMOD) += hellomod.o
</code></pre>

<h3 id="3-添加-kconfig">3.添加 Kconfig</h3>

<p>在 <code>drivers/char/hellomod/</code> 目录下新建 <code>Kconfig</code> 文件，内容如下：</p>

<pre><code>menu &quot;hello module&quot;
    config HELLOMOD
        tristate &quot;hellomod&quot;
        default m
        help
            just a module
endmenu
</code></pre>

<p>然后在上层目录 <code>drivers/chars</code> 的 <code>Kconfig</code> 文件中添加：</p>

<pre><code>source drivers/char/hellomod/Kconfig
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>Linux 驱动的异步通知</title>
            <link>https://shaocheng.li/posts/2012/11/20/</link>
            <pubDate>Tue, 20 Nov 2012 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2012/11/20/</guid>
            <description>实现步骤 假设设备驱动名为 module ，设备的私有数据结构为 module_dev_t ，实现异步通知的步骤如下 ：
1.定义一个 struct fasync_struct *类型的指针，通常是在设备的私有数据结构中定义。
struct module_dev_t module_dev { ... strcut fasync_struct * fasync_queue; }  2.实现 fasync 方法,在 fasync 方法中调用 fasync_helper 函数。
static int module_fasync(int fd,struct file *filp,int mode) { struct module_dev_t *dev = filp-&amp;gt;private_data; return fasync_helper(fd,filp,mode,&amp;amp;dev-&amp;gt;fasync_queue); } struct file_operations fops = { ... .fasync = module_fasync, }  3.在数据到达时调用 kill_fasync 函数产生信号。
if(dev-&amp;gt;fasync_queue) kill_fasync(&amp;amp;dev-&amp;gt;fasync_queue,SIGIO,POLL_IN);  4.在关闭设备是调用 fasync 方法。
module_fasync(-1,filp,0);  应用程序的编程方法 1.为信号注册一个处理函数</description>
            <content type="html"><![CDATA[

<h2 id="实现步骤">实现步骤</h2>

<p>假设设备驱动名为 module ，设备的私有数据结构为 module_dev_t ，实现异步通知的步骤如下 ：</p>

<p>1.定义一个 <code>struct fasync_struct *</code>类型的指针，通常是在设备的私有数据结构中定义。</p>

<pre><code>struct module_dev_t module_dev {
...
strcut fasync_struct * fasync_queue;
}
</code></pre>

<p>2.实现 <code>fasync</code> 方法,在 <code>fasync</code> 方法中调用 <code>fasync_helper</code> 函数。</p>

<pre><code>static int module_fasync(int fd,struct file *filp,int mode)
{
    struct module_dev_t *dev = filp-&gt;private_data;
    return fasync_helper(fd,filp,mode,&amp;dev-&gt;fasync_queue);
}

struct file_operations fops = {
...
.fasync = module_fasync,
}
</code></pre>

<p>3.在数据到达时调用 <code>kill_fasync</code> 函数产生信号。</p>

<pre><code>if(dev-&gt;fasync_queue)
    kill_fasync(&amp;dev-&gt;fasync_queue,SIGIO,POLL_IN);
</code></pre>

<p>4.在关闭设备是调用 <code>fasync</code> 方法。</p>

<pre><code>module_fasync(-1,filp,0);
</code></pre>

<h2 id="应用程序的编程方法">应用程序的编程方法</h2>

<p>1.为信号注册一个处理函数</p>

<pre><code>signal(SIGIO,sig_handler);
</code></pre>

<p>当进程接收到 SIGIO 信号是会执行 sig_handler 函数：</p>

<pre><code>void (*sig_handler)(int sig)
</code></pre>

<p>2.设置将要接收 SIGIO 或 SIGURG 信号的进程 id 。</p>

<pre><code>fcntl(fd,F_SETOWN,getpid());
</code></pre>

<p>这样会将进程的 ID 保存到 filp-&gt;f_woner 中，内核就知道当信号到达时应该通知哪个进程。</p>

<p>3.为文件设置 FASYNC 标志。</p>

<pre><code>oflas = fcntl(fd,F_GETFL);
fcntl(fd,F_SETFL,oflags | FASYNC);
</code></pre>

<p>设置 FASYNC 时就会调用驱动的 fasync 方法。在文件打开时，FASYNC 标志是默认清除的。</p>
]]></content>
        </item>
        
        <item>
            <title>《Unix Shell 范例精解》第五章 sed 习题</title>
            <link>https://shaocheng.li/posts/2012/11/04/</link>
            <pubDate>Sun, 04 Nov 2012 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2012/11/04/</guid>
            <description>数据文件 datefile
Steve Blenheim:238-923-7366:95 Latham Lane, Easton, PA 83755:11/12/56:20300 Betty Boop:245-836-8357:635 Cutesy Lane, Hollywood, CA 91464:6/23/23:14500 Igor Chevsky:385-375-8395:3567 Populus Place, Caldwell, NJ 23875:6/18/68:23400 Norma Corder:397-857-2735:74 Pine Street, Dearborn, MI 23874:3/28/45:245700 Jennifer Cowan:548-834-2348:583 Laurel Ave., Kingsville, TX 83745:10/1/35:58900 Jon DeLoach:408-253-3122:123 Park St., San Jose, CA 04086:7/25/53:85100 Karen Evich:284-758-2857:23 Edgecliff Place, Lincoln, NB 92743:7/25/53:85100 Karen Evich:284-758-2867:23 Edgecliff Place, Lincoln, NB 92743:11/3/35:58200 Karen Evich:284-758-2867:23 Edgecliff Place, Lincoln, NB 92743:11/3/35:58200 Fred Fardbarkle:674-843-1385:20 Parak Lane, Duluth, MN 23850:4/12/23:780900 Fred Fardbarkle:674-843-1385:20 Parak Lane, Duluth, MN 23850:4/12/23:780900 Lori Gortz:327-832-5728:3465 Mirlo Street, Peabody, MA 34756:10/2/65:35200 Paco Gutierrez:835-365-1284:454 Easy Street, Decatur, IL 75732:2/28/53:123500 Ephram Hardy:293-259-5395:235 CarltonLane, Joliet, IL 73858:8/12/20:56700 James Ikeda:834-938-8376:23445 Aster Ave.</description>
            <content type="html"><![CDATA[<p>数据文件 datefile</p>

<pre><code>Steve Blenheim:238-923-7366:95 Latham Lane, Easton, PA 83755:11/12/56:20300
Betty Boop:245-836-8357:635 Cutesy Lane, Hollywood, CA 91464:6/23/23:14500
Igor Chevsky:385-375-8395:3567 Populus Place, Caldwell, NJ 23875:6/18/68:23400
Norma Corder:397-857-2735:74 Pine Street, Dearborn, MI 23874:3/28/45:245700
Jennifer Cowan:548-834-2348:583 Laurel Ave., Kingsville, TX 83745:10/1/35:58900
Jon DeLoach:408-253-3122:123 Park St., San Jose, CA 04086:7/25/53:85100
Karen Evich:284-758-2857:23 Edgecliff Place, Lincoln, NB 92743:7/25/53:85100
Karen Evich:284-758-2867:23 Edgecliff Place, Lincoln, NB 92743:11/3/35:58200
Karen Evich:284-758-2867:23 Edgecliff Place, Lincoln, NB 92743:11/3/35:58200
Fred Fardbarkle:674-843-1385:20 Parak Lane, Duluth, MN 23850:4/12/23:780900
Fred Fardbarkle:674-843-1385:20 Parak Lane, Duluth, MN 23850:4/12/23:780900
Lori Gortz:327-832-5728:3465 Mirlo Street, Peabody, MA 34756:10/2/65:35200
Paco Gutierrez:835-365-1284:454 Easy Street, Decatur, IL 75732:2/28/53:123500
Ephram Hardy:293-259-5395:235 CarltonLane, Joliet, IL 73858:8/12/20:56700
James Ikeda:834-938-8376:23445 Aster Ave., Allentown, NJ 83745:12/1/38:45000
Barbara Kertz:385-573-8326:832 Ponce Drive, Gary, IN 83756:12/1/46:268500
Lesley Kirstin:408-456-1234:4 Harvard Square, Boston, MA 02133:4/22/62:52600
William Kopf:846-836-2837:6937 Ware Road, Milton, PA 93756:9/21/46:43500
Sir Lancelot:837-835-8257:474 Camelot Boulevard, Bath, WY 28356:5/13/69:24500
Jesse Neal:408-233-8971:45 Rose Terrace, San Francisco, CA 92303:2/3/36:25000
Zippy Pinhead:834-823-8319:2356 Bizarro Ave., Farmount, IL 84357:1/1/67:89500
Arthur Putie:923-835-8745:23 Wimp Lane, Kensington, DL 38758:8/31/69:126000
Popeye Sailor:156-454-3322:945 Bluto Street, Anywhere, USA 29358:3/19/35:22350
Jose Santiago:385-898-8357:38 Fife Way, Abilene, TX 39673:1/5/58:95600
Tommy Savage:408-724-0140:1222 Oxbow Court, Sunnyvale, CA 94087:5/19/66:34200
Yukio Takeshida:387-827-1095:13 Uno Lane, Ashville, NC 23556:7/1/29:57000
Vinh Tranh:438-910-7449:8235 Maple Street, Wilmington, VM 29085:9/23/63:68900
</code></pre>

<ul>
<li><p>把 Jon 的名字改为 Jonathan</p>

<pre><code>sed -e 's/^Jon /Jonathan /' datebook
</code></pre></li>

<li><p>删除前 3 行</p>

<pre><code>sed -e '1,3d' datebook
</code></pre></li>

<li><p>打印第 5~10 行</p>

<pre><code>sed -n -e '5,10p' datebook
</code></pre></li>

<li><p>删除含有 Lane 的所有行</p>

<pre><code>sed -e '/Lane/d' datebook
</code></pre></li>

<li><p>删除不含有 Lane 的所有行</p>

<pre><code>sed -e '/Lane/!d' datebook
</code></pre></li>

<li><p>打印所有生日在十一月或十二月的行</p>

<pre><code>sed -n -e '/:1[12]\//p' datebook
</code></pre></li>

<li><p>在以 James 开头的各行末尾加上 3 颗星号</p>

<pre><code>sed -e '/^James/s/$/***&amp;/' datebook
</code></pre></li>

<li><p>将所有包含 Jose 的行都替换为 JOSE HAS RETIRED</p>

<pre><code>sed -e '/Jose/c\JOSE HAS RETIRED' datebook
</code></pre></li>

<li><p>把 Popeye 的生日改为 11/14/46 ，假定您不知道 Popeye 的生日，设法用正则表达式查找出来</p>

<pre><code>sed -n -e '/^Popeye /s/:[0-9]*\/[0-9]*\/[0-9]*/:11\/14\/46:/p' datebook
</code></pre></li>

<li><p>删除所有空行</p>

<pre><code>sed -e '/^$/d' datebook
</code></pre></li>

<li><p>写一个能完成下列任务的 sed 脚本</p>

<p>a) 在第一行上方插入标题 PERSONNEL FILE</p>

<p>b) 删除以 500 结尾的工资项</p>

<p>c) 把名和姓的位置颠倒后，打印文件内容</p>

<p>d) 在文件末尾加上 THE END</p>

<pre><code>1i\PERSONNEL FILE
/500$/d
s/\([a-zA-Z]*\) \([a-zA-Z]*\)/\2 \1/
$a\THE END
</code></pre></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>《Unix Shell 范例精解》第四章 grep 习题</title>
            <link>https://shaocheng.li/posts/2012/11/03/</link>
            <pubDate>Sat, 03 Nov 2012 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2012/11/03/</guid>
            <description>数据文件：
Steve Blenheim:238-923-7366:95 Latham Lane, Easton, PA 83755:11/12/56:20300 Betty Boop:245-836-8357:635 Cutesy Lane, Hollywood, CA 91464:6/23/23:14500 Igor Chevsky:385-375-8395:3567 Populus Place, Caldwell, NJ 23875:6/18/68:23400 Norma Corder:397-857-2735:74 Pine Street, Dearborn, MI 23874:3/28/45:245700 Jennifer Cowan:548-834-2348:583 Laurel Ave., Kingsville, TX 83745:10/1/35:58900 Jon DeLoach:408-253-3122:123 Park St., San Jose, CA 04086:7/25/53:85100 Karen Evich:284-758-2857:23 Edgecliff Place, Lincoln, NB 92743:7/25/53:85100 Karen Evich:284-758-2867:23 Edgecliff Place, Lincoln, NB 92743:11/3/35:58200 Karen Evich:284-758-2867:23 Edgecliff Place, Lincoln, NB 92743:11/3/35:58200 Fred Fardbarkle:674-843-1385:20 Parak Lane, Duluth, MN 23850:4/12/23:780900 Fred Fardbarkle:674-843-1385:20 Parak Lane, Duluth, MN 23850:4/12/23:780900 Lori Gortz:327-832-5728:3465 Mirlo Street, Peabody, MA 34756:10/2/65:35200 Paco Gutierrez:835-365-1284:454 Easy Street, Decatur, IL 75732:2/28/53:123500 Ephram Hardy:293-259-5395:235 CarltonLane, Joliet, IL 73858:8/12/20:56700 James Ikeda:834-938-8376:23445 Aster Ave.</description>
            <content type="html"><![CDATA[<p>数据文件：</p>

<pre><code>Steve Blenheim:238-923-7366:95 Latham Lane, Easton, PA 83755:11/12/56:20300
Betty Boop:245-836-8357:635 Cutesy Lane, Hollywood, CA 91464:6/23/23:14500
Igor Chevsky:385-375-8395:3567 Populus Place, Caldwell, NJ 23875:6/18/68:23400
Norma Corder:397-857-2735:74 Pine Street, Dearborn, MI 23874:3/28/45:245700
Jennifer Cowan:548-834-2348:583 Laurel Ave., Kingsville, TX 83745:10/1/35:58900
Jon DeLoach:408-253-3122:123 Park St., San Jose, CA 04086:7/25/53:85100
Karen Evich:284-758-2857:23 Edgecliff Place, Lincoln, NB 92743:7/25/53:85100
Karen Evich:284-758-2867:23 Edgecliff Place, Lincoln, NB 92743:11/3/35:58200
Karen Evich:284-758-2867:23 Edgecliff Place, Lincoln, NB 92743:11/3/35:58200
Fred Fardbarkle:674-843-1385:20 Parak Lane, Duluth, MN 23850:4/12/23:780900
Fred Fardbarkle:674-843-1385:20 Parak Lane, Duluth, MN 23850:4/12/23:780900
Lori Gortz:327-832-5728:3465 Mirlo Street, Peabody, MA 34756:10/2/65:35200
Paco Gutierrez:835-365-1284:454 Easy Street, Decatur, IL 75732:2/28/53:123500
Ephram Hardy:293-259-5395:235 CarltonLane, Joliet, IL 73858:8/12/20:56700
James Ikeda:834-938-8376:23445 Aster Ave., Allentown, NJ 83745:12/1/38:45000
Barbara Kertz:385-573-8326:832 Ponce Drive, Gary, IN 83756:12/1/46:268500
Lesley Kirstin:408-456-1234:4 Harvard Square, Boston, MA 02133:4/22/62:52600
William Kopf:846-836-2837:6937 Ware Road, Milton, PA 93756:9/21/46:43500
Sir Lancelot:837-835-8257:474 Camelot Boulevard, Bath, WY 28356:5/13/69:24500
Jesse Neal:408-233-8971:45 Rose Terrace, San Francisco, CA 92303:2/3/36:25000
Zippy Pinhead:834-823-8319:2356 Bizarro Ave., Farmount, IL 84357:1/1/67:89500
Arthur Putie:923-835-8745:23 Wimp Lane, Kensington, DL 38758:8/31/69:126000
Popeye Sailor:156-454-3322:945 Bluto Street, Anywhere, USA 29358:3/19/35:22350
Jose Santiago:385-898-8357:38 Fife Way, Abilene, TX 39673:1/5/58:95600
Tommy Savage:408-724-0140:1222 Oxbow Court, Sunnyvale, CA 94087:5/19/66:34200
Yukio Takeshida:387-827-1095:13 Uno Lane, Ashville, NC 23556:7/1/29:57000
Vinh Tranh:438-910-7449:8235 Maple Street, Wilmington, VM 29085:9/23/63:68900
</code></pre>

<ul>
<li><p>打印所有包含字符串 San 的行</p>

<pre><code>grep 'San' databook
</code></pre></li>

<li><p>打印所有以 J 开头的行</p>

<pre><code>grep '^J' databook
</code></pre></li>

<li><p>打印所有以 700 结尾的行</p>

<pre><code>grep '700$' databook
</code></pre></li>

<li><p>打印所有不包含 834 的行</p>

<pre><code>grep -v '834' databook
</code></pre></li>

<li><p>打印所有生日在 December 的行</p>

<pre><code>grep ':12/' databook
</code></pre></li>

<li><p>打印所有电话号码区号为 408 的行</p>

<pre><code>grep ':408-' databook
</code></pre></li>

<li><p>打印所有包含一个大写字母，后跟四个小写字母，一个逗号，一个空格和一个大写字母的行</p>

<pre><code>grep '[[:upper:]][[:lower:]]\{4\}, [[:upper:]]' databook
</code></pre></li>

<li><p>打印所有最后一个名字以 K 或 k 开始的行</p>

<pre><code>grep '^[A-Za-z]* [Kk]' databook
</code></pre></li>

<li><p>打印所有薪水为 6 位数的行，前导是一个行号</p>

<pre><code>grep -n ':[0-9]\{6\}$' databook
</code></pre></li>

<li><p>打印包含 Lincoln 或 lincoln （注意，grep 不区分大小写）的行</p>

<pre><code>grep '[Ll]incoln' databook
</code></pre></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>sed 学习笔记</title>
            <link>https://shaocheng.li/posts/2012/11/02/</link>
            <pubDate>Fri, 02 Nov 2012 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2012/11/02/</guid>
            <description>一些选项  -e script ：添加一套命令，可通过该选项添加多个处理命令 -n ：只打印通过 p 命令匹配到的行 -i ：将修改结果写入文件 -f scriptfile ：使用脚本文件  常用命令  ! ：对所选行以为的行进行操作 p ：打印 d ：删除 s ：替换 g ：行内全局替换 w ：将行写入文件 c\ ：用命令后面的文本替换当前的行 a\ ：在当前行后添加文本  GNU对正则表达式的扩展  \n : 产生或匹配一个换行符（ASCII 10） \r : 产生或匹配一个回车符（ASCII 13） \t : 产生或匹配一个制表符（ASCII 9） \v : 产生或匹配一个垂直制表符（ASCII 11）  指定地址范围 打印第一行到第十行：
sed -n -e &#39;1,10p&#39; filename  打印最后一行：
sed -n -e &#39;$p&#39; filename  用正则表达式匹配行， 打印从以 root 开头的行到以 mail 开头的行：</description>
            <content type="html"><![CDATA[

<h2 id="一些选项">一些选项</h2>

<ul>
<li>-e script ：添加一套命令，可通过该选项添加多个处理命令</li>
<li>-n ：只打印通过 p 命令匹配到的行</li>
<li>-i ：将修改结果写入文件</li>
<li>-f scriptfile ：使用脚本文件</li>
</ul>

<h2 id="常用命令">常用命令</h2>

<ul>
<li>! ：对所选行以为的行进行操作</li>
<li>p ：打印</li>
<li>d ：删除</li>
<li>s ：替换</li>
<li>g ：行内全局替换</li>
<li>w ：将行写入文件</li>
<li>c\ ：用命令后面的文本替换当前的行</li>
<li>a\ ：在当前行后添加文本</li>
</ul>

<h2 id="gnu对正则表达式的扩展">GNU对正则表达式的扩展</h2>

<ul>
<li>\n : 产生或匹配一个换行符（ASCII 10）</li>
<li>\r : 产生或匹配一个回车符（ASCII 13）</li>
<li>\t : 产生或匹配一个制表符（ASCII 9）</li>
<li>\v : 产生或匹配一个垂直制表符（ASCII 11）</li>
</ul>

<h2 id="指定地址范围">指定地址范围</h2>

<p>打印第一行到第十行：</p>

<pre><code>sed -n -e '1,10p' filename
</code></pre>

<p>打印最后一行：</p>

<pre><code>sed -n -e '$p' filename
</code></pre>

<p>用正则表达式匹配行，  打印从以 root 开头的行到以 mail 开头的行：</p>

<pre><code>sed -n -e '/^root/,/^mail/p' filename
</code></pre>

<h2 id="大小写转换">大小写转换</h2>

<p>\U \u ：转换为大写</p>

<p>\L \l ：转换为小写</p>

<pre><code>sed -e 's/[a-z]/\U&amp;/g' filename
sed -e 's/[A-Z]/\L&amp;/g' filename
</code></pre>

<p><em>&amp; 表示前面的模式所匹配到的字符</em></p>

<h2 id="文本转换">文本转换</h2>

<p>DOS/Windows格式的文本的每一行末尾是一个回车（CR）和一个换行符（LF），而Unix风格的文本只有一个换行符。</p>

<p>Unix转DOS，$ 匹配到每行的末尾，\r 表示回车符，这样就会在每行的末尾前添加一个回车符：</p>

<pre><code>sed -e 's/$/\r/' filename &gt; filename.txt
</code></pre>

<p>DOS转Unix，将行尾前的一个字符（回车）替换为空即可：</p>

<pre><code>sed -e 's/.$//' filename.txt &gt; filename
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>awk 实例练习</title>
            <link>https://shaocheng.li/posts/2012/10/28/</link>
            <pubDate>Sun, 28 Oct 2012 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2012/10/28/</guid>
            <description>测试文件 file 的内容如下：
Mike Harrington:(510) 548-1278:250:100:175 Christian Dobbins:(408) 538-2358:155:90:201 Susan Dalsass:(206) 654-6279:250:60:50 Archie McNichol:(206) 548-1348:250:100:175 Jody Savage:(206) 548-1278:15:188:150 Guy Quigley:(916) 343-6410:250:100:175 Dan Savage:(406) 298-7744:450:300:275 Nancy McNeil:(206) 548-1278:250:80:75 John Goldenrod:(916) 348-4278:250:100:175 Chet Main:(510) 548-5258:50:95:135 Tom Savage:(408) 926-3456:250:168:200 Elizabeth Stachelin:(916) 440-1763:175:75:300  该文件依次显示的是姓名，电话号码，过去三个月的捐款额。
显示所有的电话号码
awk -F &amp;quot;:&amp;quot; &#39;{print $2}&#39; file  显示 Dan 的电话号码
awk -F &amp;quot;:&amp;quot; &#39;$1 ~ /^Dan / {print $2}&#39; file  显示所有以 D 开头的姓
awk -F &amp;quot;[ :]&amp;quot; &#39;$2 ~ /^D/ {print $2}&#39; file  显示所有以 C 或 E 开头的名</description>
            <content type="html"><![CDATA[<p>测试文件 file 的内容如下：</p>

<pre><code>Mike Harrington:(510) 548-1278:250:100:175
Christian Dobbins:(408) 538-2358:155:90:201
Susan Dalsass:(206) 654-6279:250:60:50 
Archie McNichol:(206) 548-1348:250:100:175 
Jody Savage:(206) 548-1278:15:188:150 
Guy Quigley:(916) 343-6410:250:100:175 
Dan Savage:(406) 298-7744:450:300:275 
Nancy McNeil:(206) 548-1278:250:80:75 
John Goldenrod:(916) 348-4278:250:100:175 
Chet Main:(510) 548-5258:50:95:135 
Tom Savage:(408) 926-3456:250:168:200 
Elizabeth Stachelin:(916) 440-1763:175:75:300
</code></pre>

<p>该文件依次显示的是姓名，电话号码，过去三个月的捐款额。</p>

<p>显示所有的电话号码</p>

<pre><code>awk -F &quot;:&quot; '{print $2}' file
</code></pre>

<p>显示 Dan 的电话号码</p>

<pre><code>awk -F &quot;:&quot; '$1 ~ /^Dan / {print $2}' file
</code></pre>

<p>显示所有以 D 开头的姓</p>

<pre><code>awk -F &quot;[ :]&quot; '$2 ~ /^D/ {print $2}' file
</code></pre>

<p>显示所有以 C 或 E 开头的名</p>

<pre><code>awk  -F &quot;[ :]&quot; '$1 ~ /^[CE]/ {print $1}' file
</code></pre>

<p>显示只有四个字符的名</p>

<pre><code>awk -F &quot;[ :]&quot; '{if(length($1) == 4) print $1}' file
</code></pre>

<p>显示所有区号为 916 的人名</p>

<pre><code>awk -F &quot;:&quot; '$2 ~ /(916)/ {print $1}' file
</code></pre>

<p>显示 Mike 的捐款，每笔捐款以 $ 开头</p>

<pre><code>awk -F &quot;:&quot; '$1 ~ /^Mike / {printf(&quot;$%s,$%s,$%s\n&quot;,$3,$4,$5)}' file
</code></pre>

<p>将所有信息输出为如下格式：</p>

<pre><code>                      *** CAMPAIGN 1998 CONTRIBUTIONS ***
----------------------------------------------------------------------------
               NAME            PHONE       Jan   |   Feb   |   Mar    | Total Donated
----------------------------------------------------------------------------
    Mike Harrington   (510) 548-1278    250.00    100.00    175.00      525.00
  Christian Dobbins   (408) 538-2358    155.00     90.00    201.00      446.00
      Susan Dalsass   (206) 654-6279    250.00     60.00     50.00      360.00
    Archie McNichol   (206) 548-1348    250.00    100.00    175.00      525.00
        Jody Savage   (206) 548-1278     15.00    188.00    150.00      353.00
        Guy Quigley   (916) 343-6410    250.00    100.00    175.00      525.00
         Dan Savage   (406) 298-7744    450.00    300.00    275.00     1025.00
       Nancy McNeil   (206) 548-1278    250.00     80.00     75.00      405.00
     John Goldenrod   (916) 348-4278    250.00    100.00    175.00      525.00
          Chet Main   (510) 548-5258     50.00     95.00    135.00      280.00
         Tom Savage   (408) 926-3456    250.00    168.00    200.00      618.00
Elizabeth Stachelin   (916) 440-1763    175.00     75.00    300.00      550.00
---------------------------------------------------------------------------
                              SUMMARY
---------------------------------------------------------------------------
The campaign received a total of $6137.00 for this quarter
The average donation for the 12 contributors was $511.42
The highest contribution was $450.00
The lowest contributino was $15.00
</code></pre>

<p>脚本文件 script 如下：</p>

<pre><code>BEGIN {
    FS=&quot;:&quot;
    sum=0
    max=0
    min=0
    printf(&quot;               *** CAMPAIGN 1998 CONTRIBUTIONS ***\n&quot;)
    printf(&quot;----------------------------------------------------------------------------\n&quot;)
    printf(&quot;%19s%17s%10s%10s%10s%19s\n&quot;,&quot;NAME&quot;,&quot;PHONE&quot;,&quot;Jan&quot;,&quot;|   Feb&quot;,&quot;|   Mar&quot;,&quot;| Total Donated&quot;)
    printf(&quot;----------------------------------------------------------------------------\n&quot;)
}

{
    printf(&quot;%19s%17s%10.2f%10.2f%10.2f&quot;,$1,$2,$3,$4,$5)
    total=$3+$4+$5
    printf(&quot;%12.2f\n&quot;,total)
    sum+=total  
    if(NR==1)
    {
        min=$3
        max=$3
    }

    for(i=3;i&lt;6;i++)
    {
        if(min&gt;$i) min=$i
        if(max&lt;$i) max=$i
    }
}

END {
    ave=sum/NR
    printf(&quot;---------------------------------------------------------------------------\n&quot;)
    printf(&quot;                              SUMMARY\n&quot;)
    printf(&quot;---------------------------------------------------------------------------\n&quot;)
    printf(&quot;The campaign received a total of $%.2f for this quarter\n&quot;,sum);
    printf(&quot;The average donation for the 12 contributors was $%.2f\n&quot;,ave);
    printf(&quot;The highest contribution was $%.2f\n&quot;,max)
    printf(&quot;The lowest contributino was $%.2f\n&quot;,min)
}
</code></pre>

<p>执行：</p>

<pre><code>awk -f script file
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>Linux Wireless —— 无线操作模式</title>
            <link>https://shaocheng.li/posts/2012/10/27/</link>
            <pubDate>Sat, 27 Oct 2012 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2012/10/27/</guid>
            <description>原文： Wireless Operating Modes
Translated by Bob
2012-10-27
Email：gexbob@gmail.com
Blog：http://shaocheng.li
一个 WNIC （Wireless Network Interface Controller，无线网络接口控制器）总是运行在如下几种模式之一。这些模式设定了无线连接的主要功能。有时也可能同时运行在两种模式。
Station (STA) 基本模式 任何无线驱动都能运行在这种模式。因此它被称作默认模式。两个 STA 模式的 WNIC 无法相互连接。它们需要第三个 AP 模式的 WNIC 来管理无线网络！STA 模式的 WNIC 通过发送管理数据帧来连接 AP 模式的 WNIC 。这个过程叫做认证（authentication）和关联（association）。当 AP 发送关联成功的回复后，这个 STA 就成为了无线网络的一部分。
AccessPoint (AP) 基本模式 在一个已经被管理的无线网络中，Access Point 是作为主设备存在的。它通过管理和维护 STA 列表来聚合网络。它还管理安全策略。这个网络就以 AP 的 MAC 地址命名。同时还会为 AP 设置一个可读的名字 SSID 。
Linux 下使用 AP 模式需要用到 hostapd ，当前至少是 0.6 版本，最好通过 git 获得。http://wireless.erley.org
Monitor (MON) 模式 Monitor 模式是一个被动模式，不会传输数据帧。所有的输入包都交给主机处理，不会进行任何过滤。这个模式被用来监视网络。</description>
            <content type="html"><![CDATA[

<p>原文：
<a href="http://linuxwireless.org/en/users/Documentation/modes" target="_blank">Wireless Operating Modes</a></p>

<p>Translated by Bob</p>

<p>2012-10-27</p>

<p>Email：gexbob@gmail.com</p>

<p>Blog：<a href="http://shaocheng.li" target="_blank">http://shaocheng.li</a></p>

<hr />

<p>一个 WNIC （Wireless Network Interface Controller，无线网络接口控制器）总是运行在如下几种模式之一。这些模式设定了无线连接的主要功能。有时也可能同时运行在两种模式。</p>

<h2 id="station-sta-基本模式">Station (STA) 基本模式</h2>

<p>任何无线驱动都能运行在这种模式。因此它被称作默认模式。两个 STA 模式的 WNIC 无法相互连接。它们需要第三个 AP 模式的 WNIC 来管理无线网络！STA 模式的 WNIC 通过发送管理数据帧来连接 AP 模式的 WNIC 。这个过程叫做认证（authentication）和关联（association）。当 AP 发送关联成功的回复后，这个 STA 就成为了无线网络的一部分。</p>

<h2 id="accesspoint-ap-基本模式">AccessPoint (AP) 基本模式</h2>

<p>在一个已经被管理的无线网络中，Access Point 是作为主设备存在的。它通过管理和维护 STA 列表来聚合网络。它还管理安全策略。这个网络就以 AP 的 MAC 地址命名。同时还会为 AP 设置一个可读的名字 SSID 。</p>

<p><em>Linux 下使用 AP 模式需要用到 hostapd ，当前至少是 0.6 版本，最好通过 git 获得。<a href="http://wireless.erley.org" target="_blank">http://wireless.erley.org</a></em></p>

<h2 id="monitor-mon-模式">Monitor (MON) 模式</h2>

<p>Monitor 模式是一个被动模式，不会传输数据帧。所有的输入包都交给主机处理，不会进行任何过滤。这个模式被用来监视网络。</p>

<p>对于 mac80211 ，除了常规设备，它可能还有一个处于 Monitor 模式的网络设备，用于检测和使用网络。可是，不是所有的硬件都支持这个功能，因为不是所有的硬件都能配置为在其他模式下显示所有的数据包。Monitor 模式接口总是工作在“尽可能(best effort)”的基础上。</p>

<p>对于 mac80211 ，也可以在 Monitor 模式下发送数据包，这叫做数据包注入。用于想在用户空间实施 MLME 工作的应用程序，例如支持 IEEE 802.11 的非标准 MAC 扩展。</p>

<h2 id="ad-hoc-ibss-模式">Ad-Hoc (IBSS) 模式</h2>

<p>Ad-Hoc 模式也叫 IBBS (Independent Basic Service Set) 模式，用于创建无需 AP 的无线网络。IBSS 网络中的每个节点都管理自己的网络。 Ad-Hoc 用于在没有可用 AP 的情况下使两台或更多的电脑相互连接。</p>

<h2 id="wireless-distribution-system-wds-模式">Wireless Distribution System (WDS) 模式</h2>

<p>分发系统 (Distribution System) 是通过有线连接到 AP 。无线分发系统 (Wireless Distribution System) 是通过无线的方式完成相同的工作。WDS 作为多个关联 AP 之间的共同途径，可被用于替代综合布线。阅读 <a href="http://linuxwireless.org/en/users/Documentation/iw#Setting_up_a_WDS_peer" target="_blank">iw WDS</a> 文档可以详细了解怎样使能这个模式，也要重新理解使用 <a href="http://linuxwireless.org/en/users/Documentation/iw#Using_4-address_for_AP_and_client_mode" target="_blank">4-address mode</a> 。</p>

<h2 id="mesh">Mesh</h2>

<p>Mesh 接口被用于允许多个设备之间通过动态的建立智能路由来相互沟通。</p>

<p>查看 <a href="http://en.wikipedia.org/wiki/IEEE_802.11s" target="_blank">Wikipedia&rsquo;s entry on 802.11s</a> 和 <a href="http://en.wikipedia.org/wiki/Wireless_mesh_network" target="_blank">Wireless mesh network(WMN)</a>。</p>

<p>为了实现 mesh 的 portal 功能，可以为常规网口桥接一个 mesh 接口。</p>
]]></content>
        </item>
        
        <item>
            <title>Linux 系统的电源管理</title>
            <link>https://shaocheng.li/posts/2012/10/23/</link>
            <pubDate>Tue, 23 Oct 2012 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2012/10/23/</guid>
            <description>现在的 linux 内核支持三种电源管理模式,可以在 /sys/power/state 文件中查看：
cat /sys/power/state standby mem disk  向该文件写入模式的名称即可实现待机，休眠等，例如：
echo standby &amp;gt; /sys/power/state  下面对各模式详细说明。
1. standby ACPI state: S1
该模式会关闭显示器和键盘等输入设备， CPU 依然在工作，所有的操作状态都不会丢失。
在该模式下按一下计算机的开关键，系统会在1~2秒内恢复到之前的状态。
2. mem ACPI state: S3
该模式相当于 Windows 下的待机。计算机将进入一个低供电状态，只有内存保持供电，并处于自刷新模式，以便保存内容。
此时，系统和设备的状态都存储在内存中。所有设备电源都进入 D3 状态，即全部断电。多数情况下，外围设备总线也全部断电。
在该模式下按一下计算机的开关键，系统会在3~5秒内恢复到之前的状态。
3. disk ACPI state: S4
该模式类似 mem 模式，但是最后多了一个步骤：将内存的内容写入硬盘（通常是写入 swap 分区）。在恢复时，再将其读出，并重新写入暂停前的工作状态。这样做的好处是，即使在该模式下计算机断电，也不会丢失数据，依然可以恢复到以前的工作状态。
从该模式恢复需要大约30秒。
在 disk 模式中，将内存内容写入硬盘的 swap 分区使用的是 swsusp 机制。关于该机制的详情在内核源码的 Documentation/power/swsusp.txt 文件中。</description>
            <content type="html"><![CDATA[

<p>现在的 linux 内核支持三种电源管理模式,可以在 /sys/power/state 文件中查看：</p>

<pre><code>cat /sys/power/state
standby mem disk
</code></pre>

<p>向该文件写入模式的名称即可实现待机，休眠等，例如：</p>

<pre><code>echo standby &gt; /sys/power/state
</code></pre>

<p>下面对各模式详细说明。</p>

<h3 id="1-standby">1. standby</h3>

<p>ACPI state: S1</p>

<p>该模式会关闭显示器和键盘等输入设备， CPU 依然在工作，所有的操作状态都不会丢失。</p>

<p>在该模式下按一下计算机的开关键，系统会在1~2秒内恢复到之前的状态。</p>

<h3 id="2-mem">2. mem</h3>

<p>ACPI state: S3</p>

<p>该模式相当于 Windows 下的待机。计算机将进入一个低供电状态，只有内存保持供电，并处于自刷新模式，以便保存内容。</p>

<p>此时，系统和设备的状态都存储在内存中。所有设备电源都进入 D3 状态，即全部断电。多数情况下，外围设备总线也全部断电。</p>

<p>在该模式下按一下计算机的开关键，系统会在3~5秒内恢复到之前的状态。</p>

<h3 id="3-disk">3. disk</h3>

<p>ACPI state: S4</p>

<p>该模式类似 mem 模式，但是最后多了一个步骤：将内存的内容写入硬盘（通常是写入 swap 分区）。在恢复时，再将其读出，并重新写入暂停前的工作状态。这样做的好处是，即使在该模式下计算机断电，也不会丢失数据，依然可以恢复到以前的工作状态。</p>

<p>从该模式恢复需要大约30秒。</p>

<p>在 disk 模式中，将内存内容写入硬盘的 swap 分区使用的是 swsusp 机制。关于该机制的详情在内核源码的 Documentation/power/swsusp.txt 文件中。</p>
]]></content>
        </item>
        
        <item>
            <title>Sublime Text</title>
            <link>https://shaocheng.li/posts/2012/09/16/</link>
            <pubDate>Sun, 16 Sep 2012 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2012/09/16/</guid>
            <description>简介 官方 : http://www.sublimetext.com/
参考了非官方文档 : http://docs.sublimetext.info/en/latest/index.html
视频简介 : http://v.youku.com/v_show/id_XMzU5NzQ5ODgw.html
1.基本编辑 1.1.操作文件  Ctrl+n :新建文件。 Ctrl+s :保存文件。 Ctrl+w :关闭当前文件，没有文件时会关闭窗口。 Ctrl+tab :在多个打开的文件之间切换 在 View-&amp;gt;Syntax 中可以选择当前文件的语法。  1.2.选择文本  Ctrl+l :选择当前行 Shift+鼠标右键 :按列选择文本。 反复按下 Ctrl+d 可以将全文中与光标所在处相同的单词逐一加入选择，直接按 Alt+F3 可以一次选择全部相同的单词。  1.3.跳转  用 Ctrl+P 可以快速跳转到当前项目中的任意文件，可进行关键词匹配。 用 Ctrl+P 后 @ (或是Ctrl+R)可以快速列出/跳转到某个函数（很爽的是在 markdown 当中是匹配到标题，而且还是带缩进的！）。 用 Ctrl+P 后 # 可以在当前文件中进行搜索。 用 Ctrl+P 后 : (或是Ctrl+G)加上数字可以跳转到相应的行。 而更酷的是你可以用 Ctrl+P 加上一些关键词跳转到某个文件同时加上 @ 来列出/跳转到目标文件中的某个函数，或是同时加上 # 来在目标文件中进行搜索，或是同时加上 : 和数字来跳转到目标文件中相应的行。  1.</description>
            <content type="html"><![CDATA[

<h2 id="简介">简介</h2>

<p>官方 : <a href="http://www.sublimetext.com/" target="_blank">http://www.sublimetext.com/</a></p>

<p>参考了非官方文档 : <a href="http://docs.sublimetext.info/en/latest/index.html" target="_blank">http://docs.sublimetext.info/en/latest/index.html</a></p>

<p>视频简介 : <a href="http://v.youku.com/v_show/id_XMzU5NzQ5ODgw.html" target="_blank">http://v.youku.com/v_show/id_XMzU5NzQ5ODgw.html</a></p>

<h2 id="1-基本编辑">1.基本编辑</h2>

<h3 id="1-1-操作文件">1.1.操作文件</h3>

<ul>
<li>Ctrl+n :新建文件。</li>
<li>Ctrl+s :保存文件。</li>
<li>Ctrl+w :关闭当前文件，没有文件时会关闭窗口。</li>
<li>Ctrl+tab :在多个打开的文件之间切换</li>
<li>在 View-&gt;Syntax 中可以选择当前文件的语法。</li>
</ul>

<h3 id="1-2-选择文本">1.2.选择文本</h3>

<ul>
<li>Ctrl+l :选择当前行</li>
<li>Shift+鼠标右键 :按列选择文本。</li>
<li>反复按下 Ctrl+d 可以将全文中与光标所在处相同的单词逐一加入选择，直接按 Alt+F3 可以一次选择全部相同的单词。</li>
</ul>

<h3 id="1-3-跳转">1.3.跳转</h3>

<ul>
<li>用 Ctrl+P 可以快速跳转到当前项目中的任意文件，可进行关键词匹配。</li>
<li>用 Ctrl+P 后 @ (或是Ctrl+R)可以快速列出/跳转到某个函数（很爽的是在 markdown 当中是匹配到标题，而且还是带缩进的！）。</li>
<li>用 Ctrl+P 后 # 可以在当前文件中进行搜索。</li>
<li>用 Ctrl+P 后 : (或是Ctrl+G)加上数字可以跳转到相应的行。</li>
<li>而更酷的是你可以用 Ctrl+P 加上一些关键词跳转到某个文件同时加上 @ 来列出/跳转到目标文件中的某个函数，或是同时加上 # 来在目标文件中进行搜索，或是同时加上 : 和数字来跳转到目标文件中相应的行。</li>
</ul>

<!-- more -->

<h3 id="1-4-注释">1.4.注释</h3>

<ul>
<li>Ctrl+/ :快速注释一行，会根据当前文件的语法选择注释字符。</li>
<li>Ctrl+Shift+/ :注释一块代码。</li>
</ul>

<h2 id="2-常用设置">2.常用设置</h2>

<p>Sublime Text 的各项特性都是用配置文件来设置的。例如用 Preferences-&gt;Settings-User 可打开针对当前用户的配置文件，文件中每行设置一个特性，以逗号结尾，最后一个行末尾不可以写逗号，例如:</p>

<pre><code>{
    &quot;font_face&quot;: &quot;DejaVu Sans Mono&quot;,
    &quot;font_size&quot;: 12
}
</code></pre>

<h3 id="2-1-设置字体">2.1.设置字体</h3>

<p>点击菜单上的 Preferences-&gt;Settings-User ，在打开的用户配置文件中输入:</p>

<pre><code>&quot;font_face&quot;: &quot;DejaVu Sans Mono&quot;,
&quot;font_size&quot;: 12,
</code></pre>

<p>也可以选择 Preferences-&gt;Settings-Default，在默认配置文件中的相同字段中设置默认字体。</p>

<h3 id="2-2-设置缩进">2.2.设置缩进</h3>

<p>在 Preferences-&gt;Settings-Default 中可以看到默认缩进为4个空格的宽度，并且 Tab 不会转换为空格，相应的字段为:</p>

<pre><code>&quot;tab_size&quot;: 4,
&quot;translate_tabs_to_spaces&quot;: false,
</code></pre>

<p>还可以针对相应的语法设置特定的缩进格式。先在 View-&gt;Syntax 中选择语法，然后点击 Preferences-&gt;Settings-More-&gt;Syntax Specific-User,在打开的文件中设置。</p>

<h3 id="2-3-设置文件的保存格式">2.3.设置文件的保存格式</h3>

<p>我们希望根据当前的语法将文件保存为相应的格式，例如Markdown文件保存为后缀为 .md 的文件。设置方法如下:</p>

<ol>
<li><p>新建一个文件，设置 View-&gt;Syntax 为 Markdown 。</p></li>

<li><p>选择 preferences-&gt;Setting-more-&gt;Syntax Specific-User ，在打开的 Markdown.sublime-settings 文件中输入:</p>

<pre><code>{
    &quot;extensions&quot;: [ &quot;md&quot; ] 
}  
</code></pre>

<p>然后保存。</p></li>

<li><p>保存之前新建的文件，后缀就会是 .md 。</p></li>
</ol>

<h3 id="2-4-设置为vim模式">2.4.设置为Vim模式</h3>

<p>点击 Preferences-&gt;Setting-user ，在打开的配置文件中添加：</p>

<pre><code>&quot;ignored_packages&quot;: [],
</code></pre>

<p>然后保存。</p>

<p>在 Vim 的 insert 模式下也可以用正常 Sublime Text 的方式编辑文件。</p>

<h2 id="3-安装插件">3.安装插件</h2>

<p>只需将下载的插件解压到 Packages 目录即可，打开 Packages 目录的方法是点击 Preferences-&gt;Browse Packages&hellip; 。</p>

<p>也可以通过 Sublime Package Control 插件来搜索、下载、安装源中的插件，方法如下：</p>

<ol>
<li><p>用 Ctrl+· 打开 console ，输入如下命令:</p>

<pre><code>import urllib2,os; pf='Package Control.sublime-package'; ipp=sublime.installed_packages_path(); os.makedirs(ipp) if not os.path.exists(ipp) else None; urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler())); open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read()); print 'Please restart Sublime Text to finish installation'
</code></pre>

<p>该命令会创建一个 Installed Packages Text 文件夹，然后下载 Package Control.sublime-package 到他下面。</p></li>

<li><p>然后重启 Sublime Text 。在菜单 Preferences 下可以看到多出了 Package Control 条目。</p></li>

<li><p>按下 Ctrl+Shift+p ，打开命令面板。输入 install 调出 Package Control: Install Package 后按回车，在列表中选择需要安装的插件，就会自动安装，重启后生效。</p></li>
</ol>

<h3 id="3-1-一些有用的插件">3.1.一些有用的插件</h3>

<ul>
<li><p>GBK Encoding Support : Sublime Text 目前只支持 UTF-8 编码的文件，该插件可以使 Sublime Text 支持 GBK 编码文件。启用后载入文件的速度变慢，还有一个Bug就是标签上的文件名乱码，根据某网友的方法对该插件的 sublime_gbk.py 文件的进行修改后解决，修改后的代码如下，用 # 注释的是源代码，用 #new line 标记的是新加的代码。</p>

<pre><code>except:
    gbk = file(view.file_name()).read()
    text = gbk.decode('gbk')

    file_name = view.file_name().encode('utf-8')

    #tmp_file_name = urllib.quote_plus(os.path.basename(file_name))  + SEPERATOR + urllib.quote_    plus(file_name)
    #tmp_file = os.path.join(TEMP_PATH, tmp_file_name)

    #f = file(tmp_file, 'w')
    f = file(view.file_name(),'w')  #new line
    f.write(text.encode('utf8'))
    f.close()

    window = sublime.active_window()

    #v = window.find_open_file(tmp_file)
    v = window.find_open_file(file_name)  #new line

    if(not v):
        #window.open_file(tmp_file)
        window.open_file(file_name)  #new
</code></pre></li>

<li><p>ConvertToUTF8 : 功能与 GBK Encoding Support 类似，且没有 Bug 。</p></li>

<li><p>Markdown Build : 用于将 Markdown 文件转换为 Html ，并用浏览器打开。快捷键是 Ctlr+b 。</p></li>

<li><p>Tag : 格式化 Html 和 CSS 语句，选中一段语句，安装组合键 ctrl+alt+f 即可。</p></li>

<li><p>JSFormat : 格式化 Javascript 文件</p>

<p>安装后重启 sublime text 就能使用js格式化插件</p>

<p>使用方法：</p>

<p>1.快捷键：ctrl+alt+f</p>

<p>2.先用快捷键打开命令面板 “ctrl + shift + p”, 再输入 “Format: Javascript” 就可以使用格式化命令</p></li>

<li><p>SublimeCodeIntel : 代码补全提示，支持多种语言。</p></li>

<li><p>Soda : 一个主题，比默认的漂亮一些。安装后，打开配置文件Preferences -&gt; Settings - User，加上一行&rdquo;theme&rdquo;: &ldquo;Soda Light.sublime-theme&rdquo;或者 &ldquo;theme&rdquo;: &ldquo;Soda Dark.sublime-theme&rdquo;。前面一个是亮色主题，后面一个是暗色主题。</p></li>
</ul>

<h3 id="3-2-用-sublime-text-编辑-markdown-文件">3.2.用 Sublime Text 编辑 Markdown 文件</h3>

<ol>
<li><p>配置 Markdown 语法高亮</p>

<p>下载 <a href="https://github.com/kumarnitin/made-of-code-tmbundle" target="_blank">Made of code</a> 配色文件，放在 Preferences-&gt;Browse Package&hellip; 所打开的目录下即可。</p>

<p>在 Preferences-&gt;Color Scheme 中选择 Made of code ，在 View-&gt;Syntax 中选择 Markdown 。</p></li>

<li><p>安装 Markdown Build 插件。</p></li>

<li><p>在 Tool 菜单里点击 Build，快捷键是 Ctrl+b ，会调用 Markdown Build 生成 Html 文件并用默认的浏览器打开。</p></li>
</ol>

<h2 id="4-一些问题">4.一些问题</h2>

<p>最近发现打开文件时，会多出一个带 dump 后缀的文件。最后发现是 GBK Encoding Support 插件的问题，卸载后解决，然后换上了 ConvertToUTF8 。</p>
]]></content>
        </item>
        
        <item>
            <title>Octopress 使用笔记</title>
            <link>https://shaocheng.li/posts/2012/09/15/</link>
            <pubDate>Sat, 15 Sep 2012 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2012/09/15/</guid>
            <description>1.代码和语法高亮 除了 Markdown 语法的缩进方式，在 Octopress 中还多种方式可以在文章中嵌入代码并显示语法高亮：
 反引号代码块  语法
``` [language] [title] [url] [link text] code snippet ```   嵌入 Gist  Gist 是 Github 提供的一个代码管理功能。在 Gist 中新建的代码文件会获得一个 gist_id ，用下面的语法就可以在文章中嵌入相应的代码：
{ % gist gist_id [filename] % }  filename 是可选的，如果一个 gist_id 下有多个文件，可以依次嵌入。
 include_code   include_code 用于在文章中导入代码文件。可以在 _config.yml 的 code_dir 设置文件路径，默认是 source/downloads/code 。
语法：
{ % include_code [title] [lang:language] path/to/file % }  例如，导入 source/downloads/code/test.js ：</description>
            <content type="html"><![CDATA[

<h2 id="1-代码和语法高亮">1.代码和语法高亮</h2>

<p>除了 Markdown 语法的缩进方式，在 Octopress 中还多种方式可以在文章中嵌入代码并显示语法高亮：</p>

<ul>
<li>反引号代码块</li>
</ul>

<p>语法</p>

<pre><code>``` [language] [title] [url] [link text]
code snippet
```
</code></pre>

<ul>
<li>嵌入 Gist</li>
</ul>

<p><a href="https://gist.github.com/" target="_blank">Gist</a> 是 Github 提供的一个代码管理功能。在 Gist 中新建的代码文件会获得一个 gist_id ，用下面的语法就可以在文章中嵌入相应的代码：</p>

<pre><code>{ % gist gist_id [filename] % }
</code></pre>

<p>filename 是可选的，如果一个 gist_id 下有多个文件，可以依次嵌入。</p>

<ul>
<li>include_code
<br /></li>
</ul>

<p>include_code 用于在文章中导入代码文件。可以在 _config.yml 的 code_dir 设置文件路径，默认是 source/downloads/code 。</p>

<p>语法：</p>

<pre><code>{ % include_code [title] [lang:language] path/to/file % }
</code></pre>

<p>例如，导入 source/downloads/code/test.js ：</p>

<pre><code>{ % include_code test.js % }
</code></pre>

<!-- more -->

<h2 id="2-插入图片">2.插入图片</h2>

<p>github 提供的空间有限，图片最好使用外链。</p>

<p>Octopress 提供的插入图片的语法如下：</p>

<pre><code>{ % img [class names] /path/to/image [width] [height] [title text [alt text]] % }
</code></pre>

<p>如果只输入图片的路径 (/path/to/image) ，图片会以左对齐的方式显示，其他可选参数可以控制图片的宽高和显示位置 (class names) 。</p>

<h2 id="3-添加导航">3.添加导航</h2>

<p>以添加一个 About 页面为例：</p>

<ul>
<li><p>执行：
    rake new_page[blog/about]
在 source/blog/ 目录先生成 about 目录和 about/index.markdown 文件，默认的布局方式是 layout: page 。</p></li>

<li><p>在 source/_includes/custom/navigation.html 文件中添加一行：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">		&lt;<span style="color:#f92672">li</span>&gt;&lt;<span style="color:#f92672">a</span> <span style="color:#a6e22e">href</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;{{ root_url }}/blog/about&#34;</span>&gt;About&lt;/<span style="color:#f92672">a</span>&gt;&lt;/<span style="color:#f92672">li</span>&gt;</code></pre></div></li>
</ul>

<h2 id="4-布局">4.布局</h2>

<p>所有的页面布局文件都位于 source/_layouts 目录下，例如 post.html 是发布文章时默认的布局。</p>

<p>可以从已有的布局文件复制，然后修改，例如从 page.html 复制一份 about.html ，并修改，然后就可以在上面新建的 about/index.markdown 中设置 layout: about 。</p>

<h2 id="5-侧边栏">5.侧边栏</h2>

<p>Octopress 提供的侧边栏都位于 source/_includes/asides 目录下，例如：显示最近发表的 recent_posts.html ，显示 github 版本库的 github.html。我们新增的侧边栏最好放在 source/_includes/custom/asides 下。</p>

<p>假设我们新建了一个显示发布许可证的侧边栏:license.html，要将其显示在所有的页面需要修改 _config.yml 文件：</p>

<pre><code>default_asides: [custom/asides/license.html]
</code></pre>

<p>default_asides 中添加的侧边栏会显示在所有布局的页面中，如果想要根据页面的布局显示不同的侧边栏，Octopress 提供了三个默认布局的设置变量：</p>

<pre><code>blog_index_asides # blog 主页上显示的侧边栏
post_asides       # post 布局页面显示的侧边栏
page_asides       # page 布局页面显示的侧边栏
</code></pre>

<p>只要在相应的变量中添加侧边栏即可。</p>

<p>如果要新建了其他布局，如 about.html，只需在 _config.yml 文件中添加 about_asides 。</p>

<h2 id="6-评论">6.评论</h2>

<p>Octproess 已经包含了支持 <a href="http://disqus.com" target="_blank">Disqus</a> 的插件，只需做简单的设置即可使用：</p>

<ul>
<li>首先确保你已经注册了一个 Disqus 的账户，并将你的 Blog 的 URL 添加到 Disqus 。</li>

<li><p>然后在 _config.yml 中设置 Disqus 账户的 short name , 并将其使能：</p>

<pre><code># Disqus Comments
disqus_short_name: exbob
disqus_show_comment_count: true
</code></pre></li>

<li><p>最后在每个 post 的头部设置允许评论：</p>

<pre><code>comments: true
</code></pre></li>
</ul>

<h2 id="7-分享">7.分享</h2>

<p>添加分享按钮的方式有很多，这里用的是 <a href="share.baidu.com" target="_blank">百度分享</a>：</p>

<ul>
<li><p>首先在百度分享中选择分享按钮的样式，并生成代码，例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"><span style="color:#75715e">&lt;!-- Baidu Button BEGIN --&gt;</span>
&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">id</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;bdshare&#34;</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;bdshare_t bds_tools get-codes-bdshare&#34;</span>&gt;
	&lt;<span style="color:#f92672">a</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;bds_qzone&#34;</span>&gt;&lt;/<span style="color:#f92672">a</span>&gt;
	&lt;<span style="color:#f92672">a</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;bds_tsina&#34;</span>&gt;&lt;/<span style="color:#f92672">a</span>&gt;
	&lt;<span style="color:#f92672">a</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;bds_tqq&#34;</span>&gt;&lt;/<span style="color:#f92672">a</span>&gt;
	&lt;<span style="color:#f92672">a</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;bds_renren&#34;</span>&gt;&lt;/<span style="color:#f92672">a</span>&gt;
	&lt;<span style="color:#f92672">span</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;bds_more&#34;</span>&gt;更多&lt;/<span style="color:#f92672">span</span>&gt;
	&lt;<span style="color:#f92672">a</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;shareCount&#34;</span>&gt;&lt;/<span style="color:#f92672">a</span>&gt;
&lt;/<span style="color:#f92672">div</span>&gt;
&lt;<span style="color:#f92672">script</span> <span style="color:#a6e22e">type</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;text/javascript&#34;</span> <span style="color:#a6e22e">id</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;bdshare_js&#34;</span> <span style="color:#a6e22e">data</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;type=tools&amp;amp;uid=949520&#34;</span> &gt;&lt;/<span style="color:#f92672">script</span>&gt;
&lt;<span style="color:#f92672">script</span> <span style="color:#a6e22e">type</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;text/javascript&#34;</span> <span style="color:#a6e22e">id</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;bdshell_js&#34;</span>&gt;&lt;/<span style="color:#f92672">script</span>&gt;
&lt;<span style="color:#f92672">script</span> <span style="color:#a6e22e">type</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;text/javascript&#34;</span>&gt;
	document.<span style="color:#a6e22e">getElementById</span>(<span style="color:#e6db74">&#34;bdshell_js&#34;</span>).<span style="color:#a6e22e">src</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=&#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">new</span> Date().<span style="color:#a6e22e">getHours</span>();
&lt;/<span style="color:#f92672">script</span>&gt;
<span style="color:#75715e">&lt;!-- Baidu Button END --&gt;</span></code></pre></div></li>

<li><p>将上面的代码添加到 source/_includes/post/sharing.html 文件的中：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;sharing&#34;</span>&gt;

{ % if site.baidushare % }

<span style="color:#75715e">&lt;!-- Baidu Button BEGIN --&gt;</span>
&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">id</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;bdshare&#34;</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;bdshare_t bds_tools get-codes-bdshare&#34;</span>&gt;
	&lt;<span style="color:#f92672">a</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;bds_qzone&#34;</span>&gt;&lt;/<span style="color:#f92672">a</span>&gt;
	&lt;<span style="color:#f92672">a</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;bds_tsina&#34;</span>&gt;&lt;/<span style="color:#f92672">a</span>&gt;
	&lt;<span style="color:#f92672">a</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;bds_tqq&#34;</span>&gt;&lt;/<span style="color:#f92672">a</span>&gt;
	&lt;<span style="color:#f92672">a</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;bds_renren&#34;</span>&gt;&lt;/<span style="color:#f92672">a</span>&gt;
	&lt;<span style="color:#f92672">span</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;bds_more&#34;</span>&gt;更多&lt;/<span style="color:#f92672">span</span>&gt;
	&lt;<span style="color:#f92672">a</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;shareCount&#34;</span>&gt;&lt;/<span style="color:#f92672">a</span>&gt;
&lt;/<span style="color:#f92672">div</span>&gt;
&lt;<span style="color:#f92672">script</span> <span style="color:#a6e22e">type</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;text/javascript&#34;</span> <span style="color:#a6e22e">id</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;bdshare_js&#34;</span> <span style="color:#a6e22e">data</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;type=tools&amp;amp;uid=949520&#34;</span> &gt;&lt;/<span style="color:#f92672">script</span>&gt;
&lt;<span style="color:#f92672">script</span> <span style="color:#a6e22e">type</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;text/javascript&#34;</span> <span style="color:#a6e22e">id</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;bdshell_js&#34;</span>&gt;&lt;/<span style="color:#f92672">script</span>&gt;
&lt;<span style="color:#f92672">script</span> <span style="color:#a6e22e">type</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;text/javascript&#34;</span>&gt;
	document.<span style="color:#a6e22e">getElementById</span>(<span style="color:#e6db74">&#34;bdshell_js&#34;</span>).<span style="color:#a6e22e">src</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=&#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">new</span> Date().<span style="color:#a6e22e">getHours</span>();
&lt;/<span style="color:#f92672">script</span>&gt;
<span style="color:#75715e">&lt;!-- Baidu Button END --&gt;</span>
{ % endif % }

&lt;/<span style="color:#f92672">div</span>&gt;</code></pre></div></li>

<li><p>最后，在 _config.yml 文件中添加 baidushare :</p>

<pre><code>		# baidu share
		baidushare: true
</code></pre></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>用 Octopress 在 github 上部署博客</title>
            <link>https://shaocheng.li/posts/2012/09/09/</link>
            <pubDate>Sun, 09 Sep 2012 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2012/09/09/</guid>
            <description>1.准备  安装 git
sudo yum install git  配置：
git config --global user.name &amp;quot;your name&amp;quot; git config --global user.email &amp;quot;your email&amp;quot;  用 RVM 安装 Ruby 1.9.3：
curl -L https://get.rvm.io | bash -s stable --ruby  根据提示执行：
source ~/.rvm/scripts/rvm  再安装 ruby 1.9.3：
rvm install 1.9.3 rvm use 1.9.3 rvm rubygems latest  安装结束后运行 ruby &amp;ndash;version 查看 ruby 版本。
   安装 Octopress
git clone git://github.com/imathis/octopress.git octopress cd octopress # 首次进入该目录时会询问是否信任 .</description>
            <content type="html"><![CDATA[

<h2 id="1-准备">1.准备</h2>

<ul>
<li><p>安装 git</p>

<pre><code>sudo yum install git
</code></pre>

<p>配置：</p>

<pre><code>git config --global user.name &quot;your name&quot;
git config --global user.email &quot;your email&quot;
</code></pre></li>

<li><p>用 RVM 安装 Ruby 1.9.3：</p>

<pre><code>curl -L https://get.rvm.io | bash -s stable --ruby
</code></pre>

<p>根据提示执行：</p>

<pre><code>source ~/.rvm/scripts/rvm
</code></pre>

<p>再安装 ruby 1.9.3：</p>

<pre><code>rvm install 1.9.3
rvm use 1.9.3
rvm rubygems latest
</code></pre>

<p>安装结束后运行 ruby &ndash;version 查看 ruby 版本。</p></li>
</ul>

<!-- more -->

<ul>
<li><p>安装 Octopress</p>

<pre><code>git clone git://github.com/imathis/octopress.git octopress
cd octopress    # 首次进入该目录时会询问是否信任 .rvmrc 文件，选择 yes 
ruby --version  # 应该是 Ruby 1.9.3
</code></pre>

<p>再安装一些依赖文件：</p>

<pre><code>gem install bundler
bundle install
</code></pre>

<p>安装默认的主题：</p>

<pre><code>rake install
</code></pre></li>
</ul>

<h2 id="2-部署到-github-pages">2.部署到 Github Pages</h2>

<p>先在 github 上新建一个名为 username.github.com (username 替换为你的用户名) 的版本库。然后执行：</p>

<pre><code>rake setup_github_pages
</code></pre>

<p>这里会询问你的 Github Pages 版本库的 URL ，应该输入 git@github.com:username/username.github.com.git 。这条命令还会做以下几件事：</p>

<ul>
<li>将 Github Pages 版本库作为默认的 origin remote</li>
<li>将活动分支从 master 切换到 source</li>
<li>根据版本库设置博客的 URL</li>
<li>在 _deploy 目录下设置一个 master 分支用于部署博客。</li>
</ul>

<p>然后执行：</p>

<pre><code>rake generate
rake deploy
</code></pre>

<p>会在 _deploy 目录下生成博客，并把该目录下的文件发布到 github 版本库的 master 分支。十分钟以后就可以通过 username.github.com 访问你的博客了。</p>

<p>Octopress 的源文件也应该提交到 github 保存：</p>

<pre><code>git add .
git commit
git push origin source
</code></pre>

<h2 id="3-配置">3.配置</h2>

<p>Octopress 的配置文件有四个：</p>

<pre><code>_config.yml   #主配置文件（jekyll的设置）
Rakefile      #关于部署的配置
config.rb
config.ru
</code></pre>

<p>通常只需要修改 _config.yml 和 Rakefile 。</p>

<p>_config.yml 文件中的配置分为三个部分：</p>

<p><strong>Main Configs</strong>
主要的设置有：</p>

<pre><code>url:                # 用于 RSS 的 URL
title:              # 博客的标题，会显示在博客和浏览器标签上。
subtitle:           # 博客的副标题
author:             # 名字, 用于 RSS, Copyright, Metadata
simple_search:      # 搜素栏所用的网址
description:        # 默认的关于本站点的描述
date_format:        # Format dates using Ruby's date strftime syntax
subscribe_rss:      # 用于 rss 订阅的 URL, 默认用 /atom.xml
subscribe_email:    # Url to subscribe by email (service required)
category_feeds:     # Enable per category RSS feeds (defaults to false in 2.1)
email:              # Email address for the RSS feed if you want it.
</code></pre>

<p><strong>Jekyll &amp; Plugin</strong></p>

<p>用于 Jekyll 及其插件的设置，主要有：</p>

<pre><code>root:               # 相对根目录，默认是 / ，如果博客要发布在一个子目录下（例如 site.com/project），要设为 /project 
permalink:          # 博客文章的存放结构
source:             # 源文件的目录
destination:        # 生成的文件存放的目录
plugins:            # Jekyll 插件的目录
code_dir:           # 代码片段文件的存放目录 (用于 include_code 插件)
category_dir:       # Directory for generated blog category pages

pygments:           # Toggle python pygments syntax highlighting
paginate:           # Posts per page on the blog index
pagination_dir:     # Directory base for pagination URLs eg. /blog/page/2/
recent_posts:       # Number of recent posts to appear in the sidebar

default_asides:     # Configure what shows up in the sidebar and in what order
blog_index_asides:  # Optional sidebar config for blog index page
post_asides:        # Optional sidebar config for post layout
page_asides:        # Optional sidebar config for page layout
</code></pre>

<p><strong>3rd Party Setting</strong></p>

<p>这些第三方工具已经安装，只要简单的设置就可以使用。</p>

<h2 id="4-写博客">4.写博客</h2>

<p><strong>发表文章</strong></p>

<p>所有要发表的博文都存放在 source/_posts 目录下，并遵循 Jekyll 的命名方式：YYYY-MM-DD-post-title.markdown 。可以将写好的文章按照这种方式命名，并在文件中添加下面讲到的头部，然后复制到该目录习下。也可以用 Octopress 提供的命令生成，语法如下：</p>

<pre><code>rake new_post[&quot;tiltle&quot;]
</code></pre>

<p>这样生成的文件默认是 markdown 格式，可以在 Rakefile 中修改默认的格式。</p>

<p>打开文件会发现有一个头部，类似：</p>

<pre><code>---
layout: post
title: &quot;tiltle&quot;
date: 2012-09-03 15:59
comments: true
external-url:
categories:
---
</code></pre>

<p>layout: post 表示使用 source/_layouts/post.html 布局方式。 comment: true 表示允许评论，也可设为 off 关闭评论。如果有其他作者，可以添加 author: your name ，默认会使用 _config.yml 中的设置。如果要保存为草稿，添加 published: false ，这样在生成博客时就不会被发表。categories 用于设置标签，如果只有一个标签，可以用如下格式：</p>

<pre><code>categories: Sass
</code></pre>

<p>如果有多个标签：</p>

<pre><code># Multiple categories example 1
categories: [CSS3, Sass, Media Queries]

# Multiple categories example 2
categories:
- CSS3
- Sass
- Media Queries
</code></pre>

<p>默认情况下，post 的全部内容将显示在 index 页面。可以在文章中插入 &lt;!&ndash; more &ndash;&gt; ，index 页面只会显示该标记之前的内容，点击 “Continue-&gt;” 按钮后会完全显示。</p>

<p><strong>添加页面</strong></p>

<p>可以在 source 目录下添加页面，添加的文件的路径与最终生成的博客的 URL 是直接对应的，例如 about.markdown 就对应 site.com/about.html 。如果想要 site.com/about ，就要在 source 下添加 about/index.markdown 。可以用 rake 命令添加页面：</p>

<pre><code>rake new_page[super-awesome]
# 生成 source/super-awesome/index.markdown

rake new_page[super-awesome/page.html]
# 生成 source/super-awesome/page.html
</code></pre>

<p>默认添加的文件的格式是 markdown ，也可以在 Rakefile 中修改。文件的内容与 post 类似：</p>

<pre><code>---
layout: page
title: &quot;Super Awesome&quot;
date: 2011-07-03 5:59
comments: true
sharing: true
footer: true
---
</code></pre>

<p><strong>生成和预览</strong></p>

<p>执行：</p>

<pre><code>rake generate   
</code></pre>

<p>在 _site 目录下生成博客的静态页面。</p>

<p>然后执行：</p>

<pre><code>rake preview    # Watches, and mounts a webserver at 
</code></pre>

<p>在浏览器中访问 <a href="http://localhost:4000" target="_blank">http://localhost:4000</a> 即可预览博客。</p>

<p>最后用 rake deploy 发布。</p>
]]></content>
        </item>
        
        <item>
            <title>在 Redhat9 文本系统上安装 Qt/E 4.4.0</title>
            <link>https://shaocheng.li/posts/2012/06/01/</link>
            <pubDate>Fri, 01 Jun 2012 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2012/06/01/</guid>
            <description>Qt Embedded 直接依赖 Framebuffer，无需 X-Window。所以要开启 Linux 系统的 Framebuffer 。开启方法是通过 BootLoader 向内核传递参数：
 对于 grub，在 grub.conf 文件的kernel 命令后面添加 vga=0x311 fb:on 。 对于 lilo，在 lilo.conf 文件中添加 vga=0x311。0x311 表示分辨率为 640*480，16dpp。  编译安装 首先下载 Qt/E-4.4.0 的源码，然后解压在 root 目录：
cd /root tar -xvjf qt-embedded-linux-opensource-src-4.4.0.tar.bz2 cd qt-embedded-linux-opensource-src-4.4.0  源码中包含了文档、例程。这些会占用很多空间和编译时间，如果不需要的话就修改 configure ，把它去掉：
QT_DEFAULT_BUILD_PARTS=&amp;quot;libs tools examples demos doc&amp;quot; 改为 QT_DEFAULT_BUILD_PARTS=&amp;quot;libs tools&amp;quot;  通过 configure 的选项可以关闭很多不需要的模块，用 ./configure -help 查看详情。
针对嵌入式版本，还可以用 -no-feature-&amp;lt;feature&amp;gt; 关闭相应的特性，默认情况下会编译全部的特性。可用的 feature 在 src/corelib/global/qfeatures.txt 文件中有完整描述。但是这个方法不方便，通常是通过 -qconfig 参数指定一个配置文件，在 src/corelib/global/ 目录下有几个典型的配置文件：</description>
            <content type="html"><![CDATA[

<p>Qt Embedded 直接依赖 Framebuffer，无需 X-Window。所以要开启 Linux 系统的 Framebuffer 。开启方法是通过 BootLoader 向内核传递参数：</p>

<ul>
<li>对于 grub，在 grub.conf 文件的kernel 命令后面添加 vga=0x311 fb:on 。</li>
<li>对于 lilo，在 lilo.conf 文件中添加 vga=0x311。0x311 表示分辨率为 640*480，16dpp。</li>
</ul>

<h2 id="编译安装">编译安装</h2>

<p>首先下载 Qt/E-4.4.0 的源码，然后解压在 root 目录：</p>

<pre><code>cd /root
tar -xvjf qt-embedded-linux-opensource-src-4.4.0.tar.bz2
cd qt-embedded-linux-opensource-src-4.4.0
</code></pre>

<p>源码中包含了文档、例程。这些会占用很多空间和编译时间，如果不需要的话就修改 configure ，把它去掉：</p>

<pre><code>QT_DEFAULT_BUILD_PARTS=&quot;libs tools examples demos doc&quot; 

改为

QT_DEFAULT_BUILD_PARTS=&quot;libs tools&quot;
</code></pre>

<p>通过 configure 的选项可以关闭很多不需要的模块，用 ./configure -help 查看详情。</p>

<!-- more -->

<p>针对嵌入式版本，还可以用 -no-feature-&lt;feature&gt; 关闭相应的特性，默认情况下会编译全部的特性。可用的 feature 在 src/corelib/global/qfeatures.txt 文件中有完整描述。但是这个方法不方便，通常是通过 -qconfig 参数指定一个配置文件，在 src/corelib/global/ 目录下有几个典型的配置文件：</p>

<pre><code>qconfig-large.h  #包含了大多数特性。
qconfig-small.h  #关闭了很多特性。
qconfig-minimal.h   #最小配置，几乎关闭了所有特性。
</code></pre>

<p>可以手动编辑修改配置。但是各种特性之间的依赖很复杂，所有Qt提供了一个图形工具 qconfig 来帮助生成配置。这个工具需要编译，安装 Qt/E 后再介绍。</p>

<p>执行：</p>

<pre><code>./configure -prefix /usr/qt -release -no-largefile -no-qt3support -no-xmlpatterns -no-phonon -no-svg -no-webkit  -no-mmx -no-3dnow -no-sse -no-sse2 -no-gif -no-libtiff -no-libmng -qt-libpng -qt-libjpeg -no-openssl -no-nis -no-cups -no-iconv -no-opengl -no-dbus -qt-freetype -depths 16 -embedded x86 -qt-decoration-default -qt-gfx-linuxfb -qt-kbd-tty -qt-kbd-usb -qt-mouse-pc -qt-mouse-bus -no-glib -qconfig src/corelib/global/qconfig-small.h
make
make install
</code></pre>

<p>编译工程需要几个小时，所有文件都会被安装到 /usr/qt/ 目录下。现在配置环境变量：
在 /etc/profile 文件中添加：</p>

<pre><code>PATH=$PATH:/usr/qt/bin
</code></pre>

<p>在 /etc/ld.so.conf 文件中添加：</p>

<pre><code>/usr/qt/lib
</code></pre>

<p>然后执行 ldconf -v</p>

<p>重启系统后，Qt/E 就可以使用了。</p>

<h2 id="测试">测试</h2>

<p>demo.cpp</p>

<pre><code>#include &lt;QApplication&gt;  
#include &lt;QPushButton&gt;  
#include &lt;QFont&gt;  
#include &lt;QTextCodec&gt;  
int main(int argc, char *argv[])  
{  
    QApplication app(argc, argv);  
    QTextCodec *codec = QTextCodec::codecForName(&quot;GB18030&quot;);    
    QTextCodec::setCodecForLocale(codec);    
    QTextCodec::setCodecForCStrings(codec);    
    QTextCodec::setCodecForTr(codec);    
    QPushButton hello(&quot;Hello 世界!&quot;);  
    hello.show();  
    return app.exec();  
}  
</code></pre>

<p>编译：</p>

<pre><code>qmake -project
qmake
make
</code></pre>

<p>编译生成了 demo 程序，运行：</p>

<pre><code>./demo -qws -fn wenquanyi
</code></pre>

<p><img src="/images/2012-06-01/2012-06-01_1.PNG" alt="" /></p>

<h2 id="用qconfig工具配置qconfig-local-h文件">用qconfig工具配置qconfig-local.h文件</h2>

<p>进入qconfig的源码目录编译生成 qconfig ：</p>

<pre><code>cd  tools/qconfig/
qmake 
make
</code></pre>

<p>执行qconfig：</p>

<pre><code>./qconfig -qws
</code></pre>

<p>首次打开时可能出现如下界面，需要导入 feature.txt 文件：</p>

<p><img src="/images/2012-06-01/2012-06-01_2.PNG" alt="" /></p>

<p>选择 src/corelib/global/feature.txt 文件，然后点击 Open ，就会导入所有可配置的特性：</p>

<p><img src="/images/2012-06-01/2012-06-01_3.PNG" alt="" /></p>

<p>在左侧的树状列表中选择需要编译的特性，然后通过 File 菜单的 Save As 保存为qconfig-local.h文件即可。
也可以通过 File -&gt; Open 打开已有的配置文件，例如 qconfig-small.h，进行修改。</p>
]]></content>
        </item>
        
        <item>
            <title>Vim/Cscope 教程</title>
            <link>https://shaocheng.li/posts/2012/04/29/</link>
            <pubDate>Sun, 29 Apr 2012 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2012/04/29/</guid>
            <description>原文：
The Vim/Cscope tutorial
http://cscope.sourceforge.net/cscope_vim_tutorial.html
Translated by Bob
2012-4-27
Email：gexbob@gmail.com
Blog：http://shaocheng.li
Cscope 是一个非常方便的工具, 它会为你的编辑器（即 Vim ）带来很好的舒适性. 幸运的是, Cscope 已经被 Vim 在内部集成.
这个教程向你介绍了 Vim 内建的 Cscope 支持，以及一套让搜索更方便的方法.
假设你知道使用 vi 风格编辑器的基本知识, 但是不需要任何关于Vim的特定知识 (会简单介绍一些用得到的 Vim 特有功能——如多窗口). 你也无需知道任何关于Cscope的知识: 我们会逐步介绍一些基本的东西.
简而言之，Vim 的 Cscope 支持很像你用过的 Vim 的 ctags 功能。但是因为 Cscope 的搜索类型比 ctags 更多，所以会有些不同。
这是一个实践教程, 所以要启动一个 shell , 然后跟着下面的步骤做:
1.
如果你的电脑还没有Cscope，先下载并安装。理想状态下, 你的 Vim 应该是 6.x 版本, 但是用 Vim 5 以上的版本都可以获得大部分功能 (无法使用垂直分割, 但是通过修改相关文件可以使用水平分割).
注意: 如果你的 Vim 版本在编译时没有指定 &amp;lsquo;&amp;ndash;enable-cscope&amp;rsquo; 选项, 你需要重新编译和配置 Vim 。 大部分随 Linux 发行版安装的 Vim 二进制文件都使能了 Cscope 插件。</description>
            <content type="html"><![CDATA[<p>原文：</p>

<p>The Vim/Cscope tutorial</p>

<p><a href="http://cscope.sourceforge.net/cscope_vim_tutorial.html" target="_blank">http://cscope.sourceforge.net/cscope_vim_tutorial.html</a></p>

<p>Translated by Bob</p>

<p>2012-4-27</p>

<p>Email：<a href="mailto:gexbob@gmail.com" target="_blank">gexbob@gmail.com</a></p>

<p>Blog：<a href="http://shaocheng.li" target="_blank">http://shaocheng.li</a></p>

<hr />

<p>Cscope 是一个非常方便的工具, 它会为你的编辑器（即 Vim ）带来很好的舒适性. 幸运的是, Cscope 已经被 Vim 在内部集成.</p>

<p>这个教程向你介绍了 Vim 内建的 Cscope 支持，以及一套让搜索更方便的方法.</p>

<p>假设你知道使用 vi 风格编辑器的基本知识, 但是不需要任何关于Vim的特定知识 (会简单介绍一些用得到的 Vim 特有功能——如多窗口). 你也无需知道任何关于Cscope的知识: 我们会逐步介绍一些基本的东西.</p>

<p>简而言之，Vim 的 Cscope 支持很像你用过的 Vim 的 ctags 功能。但是因为 Cscope 的搜索类型比 ctags 更多，所以会有些不同。</p>

<!-- more -->

<p>这是一个实践教程, 所以要启动一个 shell , 然后跟着下面的步骤做:</p>

<p>1.</p>

<p>如果你的电脑还没有Cscope，先下载并安装。理想状态下, 你的 Vim 应该是 6.x 版本, 但是用 Vim 5 以上的版本都可以获得大部分功能 (无法使用垂直分割, 但是通过修改相关文件可以使用水平分割).</p>

<p>注意: 如果你的 Vim 版本在编译时没有指定 &lsquo;&ndash;enable-cscope&rsquo; 选项, 你需要重新编译和配置 Vim 。 大部分随 Linux 发行版安装的 Vim 二进制文件都使能了 Cscope 插件。</p>

<p>2.</p>

<p>下载 cscope_maps.vim 文件, 让 Vim 在启动时读取它. 如果你用的是 Vim 6.x, 把它复制到 $HOME/.vim/plugin 目录下即可 (或者其他插件子目录). 如果你用的是 Vim 5.x, 只能把 cscope_maps 文件的内容复制到 $HOME/.vimrc 文件中, 或者黏贴 &ldquo;source cscope_maps.vim&rdquo; 一行到 .vimrc 文件.</p>

<p>3.</p>

<p>进入一个有C代码文件的目录, 执行 &lsquo;cscope -R&rsquo; ( &lsquo;-R&rsquo; 会让 Cscope 遍历所有子目录, 否则只会检测当前目录). 由于没有使用 &lsquo;-b&rsquo; 选项 (它告诉 Cscope 只建立数据库后就退出), Cscope 会打开一个基于 curses 的 GUI 界面. 在这里尝试一些搜索 (提示: 使用方向键可以在搜索类型之间移动, 用 &lsquo;tab&rsquo; 键来在搜索类型和搜索结果之间做出选择). 在搜索结果的左边敲入数字, Cscope 就会在 Vim 中打开它的位置. (除非你把 EDITOR 环境变量设为了 Vim 之外的东西). 关闭 Vim, 就会返回到离开 Cscope GUI 时的位置. 有趣。</p>

<p>Cscope 接口有个大问题； 每次要执行新的搜索时都要关闭 Vim. 这就是 Vim 插件. 用 CTRL-D 关闭 Cscope.</p>

<p>4.</p>

<p>启动 Vim. 如果你愿意, 可以在启动时带一个C语言的标识符 (入: &lsquo;vim -t main&rsquo;), 然后就会跳到代码中该标识符定义的地方.</p>

<p>5.</p>

<p>把光标移到一个在程序中多次使用的标识符上. 键入 &ldquo;CTRL-\ s&rdquo; (先敲CTRL-\, 然后敲 &rsquo;s&rsquo;) , 应该会在 Vim 窗口的底部看到一个菜单，显示了程序中所有用到这个标识符的地方. 选择其中的一个然后点回车, 就会跳到那里. 类似 ctags, 可以点击 &ldquo;CTRL-t&rdquo; 调回搜索之前的位置 (也可以多搜索几个，然后用 CTRL-t 依次释放).</p>

<p>助记符: &lsquo;\&lsquo;键在&rsquo;]&lsquo;键的右边, 用于 ctags 搜索.</p>

<p>6.</p>

<p>尝试同样的搜索, 但是这次用 &ldquo;CTRL-spacebar s&rdquo; 组合键. 这一次，Vim 窗口会水平分割为两个, Cscope 的搜索结果将在新的窗口上显示.[如果你从来没用过 Vim 的多窗口: 用 &lsquo;CTRL-W w&rsquo; (或 CTRL-W 和方向键, 或 CTRL-W 和 h/j/k/l )在窗口之间移动, 用 &lsquo;CTRL-W c&rsquo; (或 &lsquo;:q&rsquo;)关闭一个窗口, 用 &lsquo;CTRL-W o&rsquo;只显示当前窗口, 用 &lsquo;CTRL-W s&rsquo; (或 &lsquo;CTRL-W v&rsquo; 垂直分割)将窗口分割为两个, 用 &lsquo;:spl[it] filename]&rsquo; 在分割的新窗口打开文件。</p>

<p>Mnemonic: 在两个分割的窗口之间会有一条空白的间隔.</p>

<p>7.</p>

<p>现在用 &ldquo;CTRL-spacebar CTRL-spacebar s&rdquo;(只需按住CTRL连按两次空格)进行同样的搜索. 如果你无法快速的按键, 就打开 cscope_maps.vim 脚本，将 Vim 的超时设置改为注释 [事实上，我通常关闭 Vim 的超时]. 这一次 Vim 的窗口会被垂直分割 (注意: 在 Vim 5.x 上是无法实现的).</p>

<p>8.</p>

<p>到目前为止，我们只用到了&rsquo;cscope_maps.vim&rsquo;的热键,所有的搜索都与 Vim 中的光标有关. Cscope 搜索有一个老办法 (用 Vim 的内建 Cscope), 用 &ldquo;:cscope find symbol foo&rdquo;命令 (或者简单点，&rdquo;:cs f s foo&rdquo;). 对于可水平分割的版本,可以用&rdquo;:scscope&rdquo; (或&rdquo;:scs&rdquo;) . 如果要搜索的词就在光标下，用热键更简单, 命令行的方式可以让你搜索任何标识符，所以要根据实际情况选择.</p>

<p>9.</p>

<p>到目前为止，我们只用了一种搜索方法：‘s&rsquo;，查找标识符的使用情况。试一下 Cscope 的其他用法: &lsquo;g&rsquo; ，查找全局定义的标识符；&rsquo;c&rsquo;，查找一个函数的所有调用；&rsquo;f&rsquo; 打开光标所指的文件名 (注意: 因为 Cscope 默认从 /usr/include 查找头文件, 可以用这个功能打开大部分标准头文件). 这些都是我最常用的, 但是还有其他的 (在 cscope_maps.vim 文件可以找到所有的用法，也可以看 Cscope 的 man 手册).</p>

<p>10.</p>

<p>虽然 Cscope 最初只支持 C 语言, 实际上它是个非常灵活的工具，可以支持类似 C++ 和 Java 这样的语言. 你可以把它想象成一个通用的&rsquo;grep&rsquo;数据库, 它的作用是分析函数调用和变量定义等类似的结构. Cscope 默认只能解析当前目录(用‘-R’选项可以包括子目录)下的 C, lex, 和 yacc 文件 (.c, .h, .l, .y) , 目前还无法修改文件扩展列表 (我们应该改变这个现状). 所以你必须做一个要解析的文件列表, 命名为&rsquo;cscope.files&rsquo;(如果用 &lsquo;cscope -i foofile&rsquo;命令，就可以随意命名). 有一个简单（而且十分灵活）的方法是通过 Unix 的&rsquo;find&rsquo;命令:</p>

<pre><code>find . -name '*.java' &gt; cscope.files
</code></pre>

<p>然后执行 &lsquo;cscope -b&rsquo; 重新构建数据库(‘-b’会让 Cscope 只构建数据库而不启动 GUI), 你就可以浏览 Java 文件中的所有标识符. 很多人用 Cscope 来浏览和编辑大量的文档文件, 说明 Cscope 解析器是非常灵活的。</p>

<p>对于大的项目,你可能需要用 -q 选项, 并且使用更复杂的 &lsquo;find&rsquo; 命令. 在 tutorial on using Cscope with large projects 可以得到更多信息.</p>

<p>11.</p>

<p>尝试通过设置 $CSCOPE_DB 环境变量来指定一个你创建的 Cscope 数据库, 这样就不用总是在数据库的目录下启动 Vim. 这种用法多用于代码分别放在多个子目录的项目。注意: 这种情况下, 应该用绝对路径来构建数据库: cd to / ,然后：</p>

<pre><code>find /my/project/dir -name '*.c' -o -name '*.h' &gt; /foo/cscope.files
</code></pre>

<p>然后在 cscope.files 的目录下运行 Cscope (或者用 &lsquo;cscope -i /foo/cscope.files&rsquo;), 然后设置并到处 $CSCOPE_DB 变量, 让它指向 cscope.out 文件):</p>

<pre><code>cd /foo
cscope -b
CSCOPE_DB=/foo/cscope.out; export CSCOPE_DB   
</code></pre>

<p>(上面最后一条命令是针对 Bourne/Korn/Bash 的: 我已经忘了在基于 csh 的 shell 中如何导出变量, 因为我不喜欢它).</p>

<p>现在应该可以在任何目录下运行 &lsquo;vim -t foo&rsquo; ，并且会准确的跳到定义 &lsquo;foo&rsquo; 的地方. 我通常会为不同的项目写一个小的 shell 脚本 (仅用于定义和导出 CSCOPE_DB) , 以后只需用一个 &lsquo;source projectA&rsquo; 命令来选择它们.</p>

<blockquote>
<p>BUG: 在 Cscope V15.4 之前的版本, 有一个愚蠢的Bug，当执行上面的命令时，可能会导致Vim 停止工作，除非你调用你的数据库是不用默认的‘cscope.out&rsquo;：用’-f foo&rsquo;命名为‘foo.out&rsquo;。</p>
</blockquote>

<p>12.</p>

<p>就是这样！如果有什么问题的话就用&rdquo;:help cscope&rdquo; (Vim) 或 &ldquo;man cscope&rdquo; (根据你的 shell) , 还可以学习细微之处.</p>

<p><em>Cscope support added to Vim by Andy Kahn</em></p>

<p><em>Tutorial and cscope_maps.vim by Jason Duell</em></p>

<p><em>Cscope art by Petr Sorfa</em></p>
]]></content>
        </item>
        
        <item>
            <title>在大项目中使用 Cscope</title>
            <link>https://shaocheng.li/posts/2012/04/28/</link>
            <pubDate>Sat, 28 Apr 2012 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2012/04/28/</guid>
            <description>原文：
Using Cscope on large projects (example: the Linux kernel)
http://cscope.sourceforge.net/large_projects.html
Translated by Bob
2012-4-28
Email：gexbob@gmail.com
Blog：http://shaocheng.li
如果你要涉及一个大的代码库，Cscope 会是一个非常有用的工具. 它可以通过快速、有目的的搜索为你节省很多时间，而不是像 grep 那样随机的对源文件手动搜索(对于大的代码库，grep 需要一段时间才能启动).
在这个教程中，你将学会如何针对一个大项目来设置 Cscope. 我们用到的例子是 Linux 内核源代码, 基本的步骤和其他大项目是一样的, 包括 C++ 和 JAVA 项目.
1.获取源代码. 首先要获取源代码. 可以从 http://www.kernel.org 下载内核源代码. 本教程中假设你下载的是 Linux 2.4.18 并且安装在 /home/jru/linux-2.4.18.
注意: 确保你有足够的磁盘空间: 内核压缩包只有 30 MB, 解压后会的源代码是 150 MB , 生成的 Cscope 数据库会占用额外的 20-100+ MB (这取决于你想要数据库包含多少内核代码). 有必要的话，可以把源代码和 Cscope 数据库放在两个不同的磁盘分区 .
2.弄清楚你想要把 Cscope 数据库文件放在哪里. 我假设你会在 /home/jru/cscope 存放数据库和关联文件.
3.生成一个带有浏览文件列表的 cscope.</description>
            <content type="html"><![CDATA[<p>原文：</p>

<p>Using Cscope on large projects (example: the Linux kernel)</p>

<p><a href="http://cscope.sourceforge.net/large_projects.html" target="_blank">http://cscope.sourceforge.net/large_projects.html</a></p>

<p>Translated by Bob</p>

<p>2012-4-28</p>

<p>Email：<a href="mailto:gexbob@gmail.com" target="_blank">gexbob@gmail.com</a></p>

<p>Blog：<a href="http://shaocheng.li" target="_blank">http://shaocheng.li</a></p>

<hr />

<p>如果你要涉及一个大的代码库，Cscope 会是一个非常有用的工具. 它可以通过快速、有目的的搜索为你节省很多时间，而不是像 grep 那样随机的对源文件手动搜索(对于大的代码库，grep 需要一段时间才能启动).</p>

<p>在这个教程中，你将学会如何针对一个大项目来设置 Cscope. 我们用到的例子是 Linux 内核源代码, 基本的步骤和其他大项目是一样的, 包括 C++ 和 JAVA 项目.</p>

<!-- more -->

<p>1.获取源代码. 首先要获取源代码. 可以从 <a href="http://www.kernel.org" target="_blank">http://www.kernel.org</a> 下载内核源代码. 本教程中假设你下载的是 Linux 2.4.18 并且安装在 /home/jru/linux-2.4.18.</p>

<p>注意: 确保你有足够的磁盘空间: 内核压缩包只有 30 MB, 解压后会的源代码是 150 MB , 生成的 Cscope 数据库会占用额外的 20-100+ MB (这取决于你想要数据库包含多少内核代码). 有必要的话，可以把源代码和 Cscope 数据库放在两个不同的磁盘分区 .</p>

<p>2.弄清楚你想要把 Cscope 数据库文件放在哪里. 我假设你会在 /home/jru/cscope 存放数据库和关联文件.</p>

<p>3.生成一个带有浏览文件列表的 cscope.files . 对于某些项目, 你可能想要在 Cscope 数据库中包含项目目录中的所有 C 源文件. 这种情况下可以跳过这一步, 只需在项目的顶层目录上执行 &lsquo;cscope -R&rsquo; 来构建你的 Cscope 数据库. 但是如果有些代码你不想包含, 或者你的项目包含 C++ 或 JAVA 源代码 (Cscope 默认只能解析 .c, .h, .y, 或 .l 文件), 就要生成一个 cscope.files 文件, 其中包含了想要 Cscope 扫描的所有文件名 (每个文件名占一行).</p>

<p>你有可能用到绝对路径 (至少在编辑器里使用 Cscope 数据库时需要), 这样就可以在你创建的目录之外使用数据库. 我展示的命令会先进入根目录, 这样就可以用 find 打印出绝对路径.</p>

<p>对于很多项目, find 命令可以这样用:</p>

<pre><code>cd /  
find /my/project/dir -name '*.java' &gt;/my/cscope/dir/cscope.files  
</code></pre>

<p>对于 Linux 内核, 就有点棘手, 因为我们想要排除文档和脚本目录下的代码, 还有除 Intel x86 外的所有芯片和体系结构的汇编代码(我想你的体系结构是 X86). 另外, 本例中我会排除所有的内核驱动代码 (这些代码超过要解析的代码总量的两倍, 会导致 Cscope 数据库膨胀, 并且包含了很多重复的定义, 通常更难搜素. 如果你对驱动代码感兴趣, 可以省略下面相关的行, 或者修改为只输出你感兴趣的驱动文件):</p>

<pre><code>LNX=/home/jru/linux-2.4.18  
cd /       
find  $LNX                                                                \  
-path &quot;$LNX/arch/*&quot; ! -path &quot;$LNX/arch/i386*&quot; -prune -o               \  
-path &quot;$LNX/include/asm-*&quot; ! -path &quot;$LNX/include/asm-i386*&quot; -prune -o \  
-path &quot;$LNX/tmp*&quot; -prune -o                                           \  
-path &quot;$LNX/Documentation*&quot; -prune -o                                 \  
-path &quot;$LNX/scripts*&quot; -prune -o                                       \  
-path &quot;$LNX/drivers*&quot; -prune -o                                       \  
-name &quot;*.[chxsS]&quot; -print &gt;/home/jru/cscope/cscope.files  
</code></pre>

<p>这里用到了 find 命令, 在大项目中，这样做比手动编辑一个文件列表容易多了, 也可以从其他地方复制一个.</p>

<p>4.生成 Cscope 数据库. 到了生成 Cscope 数据库的时候了:</p>

<pre><code>cd /home/jru/cscope     # the directory with 'cscope.files'  
cscope -b -q -k  
</code></pre>

<p>-b 选项告诉 Cscope 只要构建数据库，无需启动 Cscope GUI. -q 会导致一个额外的&rsquo;inverted index&rsquo; 文件被创建, 它会使大数据库的搜索更快. 最后, -k 设置 Cscope 为 &lsquo;kernel&rsquo; 模式——这样它就不会去 /usr/include 下搜索源文件中包含的头文件 (这是在操作系统或 C 源码库中使用 Cscope 时的主要作用).</p>

<p>在我的 900 MHz Pentium III 系统上 (带一个标准的 IDE 硬盘), 解析这样的 Linux 源码只用了 12 秒, 输出的 3 个文件 (cscope.out, cscope.in.out, 和 cscope.po.out) 总共占用了 25 MB.</p>

<p>5.使用数据库. 如果你喜欢用 vim 或 emacs/xemacs, 我建议你先学习怎样在这些编辑器中使用 Cscope, 这样才能让你在编辑器中轻松的运行搜索. 我们有一份 tutorial for Vim, emacs 用户当然是足够聪明的，可以根据 cscope/contrib/xcscope 目录下的宝贵意见来解决所有问题.</p>

<p>否则, 你可以用独立的基于 curses 的 Cscope GUI 来运行搜索, 然后启动你喜欢的编辑器(无论 $EDITOR 设为什么,或默认是vi) 来打开搜索结果中的行.</p>

<p>如果你用独立的 Cscope 浏览器, 确保这样调用它:</p>

<pre><code>cscope -d  
</code></pre>

<p>这样 Cscope 就不会重新生成数据库. 否则你就不得不 Cscope 检测修改过的文件, 在大项目中会花很多时间, 即使没有文件被修改过. 如果偶然没有带任何参数就运行了 &lsquo;cscope&rsquo;, 也会导致重新创建没有快速索引和内核模式的数据库, 那就要重新运行之前的 cscope 命令了.</p>

<p>6.源码改变时重新生成数据库.
如果项目中有了新文件, 就再运行 &lsquo;find&rsquo; 命令来更新 cscope.files (如果正在使用它).</p>

<p>像初始生成数据那样，用同样的方法调用 cscope (并且在相同的目录下) (即, cscope -b -q -k).</p>

<p><em>Tutorial by Jason Duell</em></p>
]]></content>
        </item>
        
        <item>
            <title>建立一个定制内核</title>
            <link>https://shaocheng.li/posts/2012/04/01/</link>
            <pubDate>Sun, 01 Apr 2012 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2012/04/01/</guid>
            <description>原文：
Building a custom kernel
https://fedoraproject.org/wiki/Building_a_custom_kernel
Translated By Bob
2012-3-31
Email：gexbob@gmail.com
Blog：http://shaocheng.li
1. 从源码RPM包建立一个内核  注意：下面的说明只对 Fedora12 和之后版本有效
 这份文档为那些想要重新建立内核的高级用户提供说明。但是，重新建立的内核无法得到 Fedora 内核团队的支持。但是，您是高级用户，您可以自己处理，对吗？无论如何，高级用户建立定制内核的原因有如下几项：
 测试他们编写的或从其他地方得到的补丁。 重新配置已经存在的内核。 学习内核或内核开发。  这些说明也可以用于简单的准备内核源码树。
开始之前，确认系统已经安装了必要的软件包：
 rpmdevtools yum-utils  yum-utils 是一个默认的包。用如下命令安装：
su -c &#39;yum install rpmdevtools yum-utils&#39;  如果您要用 make xconfig，安装如下软件是必要的：
 qt3-devle libXi-devel gcc-c++  对于 Fedora 15，用如下命令：
su -c &#39;yum install qt3-devel libXi-devel&#39;  1.1. 获得源码  不要用 root 建立软件包,用 root 建立软件包是很危险且没有必要的，即使对于内核。下面的指令允许任何普通用户从源码包开始建立和安装内核.
 1.</description>
            <content type="html"><![CDATA[

<p>原文：</p>

<p>Building a custom kernel</p>

<p><a href="https://fedoraproject.org/wiki/Building_a_custom_kernel" target="_blank">https://fedoraproject.org/wiki/Building_a_custom_kernel</a></p>

<p>Translated By Bob</p>

<p>2012-3-31</p>

<p>Email：<a href="mailto:gexbob@gmail.com" target="_blank">gexbob@gmail.com</a></p>

<p>Blog：<a href="http://shaocheng.li" target="_blank">http://shaocheng.li</a></p>

<hr />

<h2 id="1-从源码rpm包建立一个内核">1. 从源码RPM包建立一个内核</h2>

<blockquote>
<p>注意：下面的说明只对 Fedora12 和之后版本有效</p>
</blockquote>

<p>这份文档为那些想要重新建立内核的高级用户提供说明。但是，重新建立的内核无法得到 Fedora 内核团队的支持。但是，您是高级用户，您可以自己处理，对吗？无论如何，高级用户建立定制内核的原因有如下几项：</p>

<ul>
<li>测试他们编写的或从其他地方得到的补丁。</li>
<li>重新配置已经存在的内核。</li>
<li>学习内核或内核开发。</li>
</ul>

<p>这些说明也可以用于简单的准备内核源码树。</p>

<!-- more -->

<p>开始之前，确认系统已经安装了必要的软件包：</p>

<ul>
<li>rpmdevtools</li>
<li>yum-utils</li>
</ul>

<p>yum-utils 是一个默认的包。用如下命令安装：</p>

<pre><code>su -c 'yum install rpmdevtools yum-utils'
</code></pre>

<p>如果您要用 make xconfig，安装如下软件是必要的：</p>

<ul>
<li>qt3-devle</li>
<li>libXi-devel</li>
<li>gcc-c++</li>
</ul>

<p>对于 Fedora 15，用如下命令：</p>

<pre><code>su -c 'yum install qt3-devel libXi-devel'
</code></pre>

<h3 id="1-1-获得源码">1.1. 获得源码</h3>

<blockquote>
<p>不要用 root 建立软件包,用 root 建立软件包是很危险且没有必要的，即使对于内核。下面的指令允许任何普通用户从源码包开始建立和安装内核.</p>
</blockquote>

<p>1.在您的用户主目录下准备一个建立RPM包的环境，运行如下命令：</p>

<pre><code>rpmdev-setuptree
</code></pre>

<p>这个命令新建了几个不同的目录 ${HOME}/rpmbuild/SOURCES， ${HOME}/rpmbuild/SPECS和${HOME}/rpmbuild/BUILD 。${HOME} 是您的用户主目录。</p>

<p>2.下载 kernel-&lt;version&gt;.src.rpm 文件。用&ndash;enablerepo选项使能适当的源码库。（yumdownloader &ndash;enablerepo=repo_to_enable &ndash;source kernel)</p>

<pre><code>yumdownloader --source kernel
</code></pre>

<p>3.用 yum-builddep 命令为内核源码安装编译依赖。</p>

<pre><code>su -c 'yum-builddep kernel-&lt;version&gt;.src.rpm'
</code></pre>

<p>4.用如下命令安装 kernel-&lt;version&gt;.src.rpm</p>

<pre><code>rpm -Uvh kernel-&lt;version&gt;.src.rpm
</code></pre>

<p>这个命令把RPM目录写入了 ${HOME}/repbuild/SOURCES和${HOME}/rpmbuild/SPECS ，${HOME} 是您的用户主目录。可以忽略像下面这样的信息：</p>

<pre><code>warning: user kojibuilder does not exist - using root
warning: group kojibuilder does not exist - using root
</code></pre>

<blockquote>
<p>空间需求:完全的内部编译过程需要若干 GB 的额外空间。</p>
</blockquote>

<h3 id="1-2-准备内核源码树">1.2. 准备内核源码树</h3>

<p>这一步扩大为整个内核源码文件。这对于查看代码、编辑代码和生成补丁是必需的。</p>

<p>用如下命令准备内核源码树：</p>

<pre><code>cd ~/rpmbuild/SPECS
rpmbuild -bp --target=$(uname -m) kernel.spec
</code></pre>

<p>现在，内核源码树就位于 ~/rpmbuild/BUILD/kernel-&lt;version&gt;/linux-&lt;version&gt;.&lt;arch&gt; 目录。</p>

<h3 id="1-3-复制源码树和生成一个补丁">1.3. 复制源码树和生成一个补丁</h3>

<p>这一步是为了对内核源码使用一个补丁。如果不需要这个补丁，直接跳到“配置内核选项”。</p>

<blockquote>
<p>高级用户：
有些工具，例如“quilt”，允许您避免复制源码树。对应高级用户，这样的工具可以使您在下面的步骤中节省很多时间。</p>
</blockquote>

<p>复制源码树是为了保留修改前的原始代码。</p>

<pre><code>export arch=x86_64 # replace x86_64 with your arch
export ver=3.1 # replace 3.1 with your kernel version
export fedver=fc16 # replace fc16 with your fedora version 
cp -r ~/rpmbuild/BUILD/kernel-$ver.$fedver/linux-$ver.$arch ~/rpmbuild/BUILD/kernel-$ver.$fedver.orig
cp -al ~/rpmbuild/BUILD/kernel-$ver.$fedver.orig ~/rpmbuild/BUILD/kernel-$ver.$fedver.new
</code></pre>

<blockquote>
<p>第二个 cp 命令在 .orig 和 .new 树之间建立了硬连接，这样可以使 diff 运行的更快。大部分文本编辑者都知道怎样正确的破坏硬连接来避免问题。</p>
</blockquote>

<p>在 FC14 上使用 vim 时，它会把上面的硬连接当做硬连接来处理，从而导致上面的技术失败。有必要将原始代码完全复制到 .new 目录。但是这样将使用双倍的空间。</p>

<p>直接更改 .new 源码树中的代码，或者复制到一个副本文件。这个文件可以来自于一个要求测试的开发者，上游内核源码，或者另一个发行版本。</p>

<p>修改 .new 源码树之后，生成一个补丁。要生成一个补丁，用下面命令对整个 .new 和 .orig 源码树运行 diff 。</p>

<pre><code>cd ~/rpmbuild/BUILD
diff -uNrp kernel-$ver.$fedver.orig kernel-$ver.$fedver.new &gt; ../SOURCES/linux-$ver.$fedver-mynewpatch.patch
</code></pre>

<p>用新补丁的名字替换 &lsquo;linux-$ver.$fedver-mynewpatch.patch&rsquo; 。在 FC14 上必须把前面的补丁名字复制到 ~/rpmbuild/SOURCES 中的 linux-$ver.$fedver-mynewpatch.patch ，以便 rpmbuild 找到它。</p>

<blockquote>
<p>更多关于补丁的信息请看 diff(1) 和 patch(1) 的 man 手册</p>
</blockquote>

<h3 id="1-4-配置内核选项">1.4. 配置内核选项</h3>

<p>这一步是为了修改内核的选项。这一步是可选的。如果没有需要修改的配置，可以跳到“准备建立文件”。</p>

<blockquote>
<p>小变化:
如果您只是想要做一点小的修改，可以在config-local文件中根据需要直接设置选项。这样会找到并覆盖其余的config-*文件，避免很多不必要的工作。如果您使用config-local就可以跳过下面的步骤。*</p>
</blockquote>

<p>1.改变内核源码树目录：</p>

<pre><code>cd ~/rpmbuild/BUILD/kernel-$ver.$fedver/linux-$ver.$arch/
</code></pre>

<p>如果您只是对默认的 fedora 内核做小的修改，跳到第四步，从两个配置工作中选择一个，将这些修改编辑到默认的配置文件。</p>

<p>2.从 ~/rpmbuild/BUILD/kernel-$ver.$fedver/linux-$ver.$arch/configs 选择所需的配置文件。复制所需的 config 文件到 ~/rpmbuild/BUILD/kernel-$ver.$fedver/linux-$ver.$arch/.config:</p>

<pre><code>cp configs/&lt;desired-config-file&gt; .config
</code></pre>

<p>3.运行下面命令：</p>

<pre><code>make oldconfig
</code></pre>

<p>4.运行下面命令，在文本界面上选择并保持所需的内核选项</p>

<pre><code>make menuconfig
</code></pre>

<p>运行图形界面的话用这个命令：</p>

<pre><code>make xconfig
</code></pre>

<p>5.在顶层 config 文件中添加一行，该文件包含了内核支持的硬件架构（uname -i的输出）。这一行以 # 开头。例如，x86_64 设备应该在顶层 config 文件中添加下面这行：</p>

<pre><code># x86_64
</code></pre>

<p>6.复制 config 文件到 ~/rpmbuild/SOURCES/:</p>

<pre><code>cp .config ~/rpmbuild/SOURCES/config-`uname -m`-generic
</code></pre>

<p><em>32-bit x86 内核</em></p>

<p><em>32-bit PAE 内核使用 config-i686-PAE 配置文件。如果您正在建立一个 PAE 内核，需要复制您的 config 文件到 ~/rpmbuild/SOURCES/:</em></p>

<pre><code>cp .config ~/rpmbuild/SOURCES/config-i686-PAE
</code></pre>

<p><em>如果您正在建立一个非 PAE 内核，需要复制您的 config 文件到：</em></p>

<pre><code>cp .config ~/rpmbuild/SOURCES/config-x86-32-generic
</code></pre>

<p><em>再次鼓励使用 config-local，除非您正在修改大量的配置。</em></p>

<h3 id="1-5-准备建立文件">1.5. 准备建立文件</h3>

<p>这一步将对 kernel.spec 文件做必要的修改。只是建立定制内核所需的。</p>

<p>1.进入~/rpmbuild/SPECS目录：</p>

<pre><code>cd ~/rpmbuild/SPECS
</code></pre>

<p>2.用编辑器打开kernel.spec文件。</p>

<p>3.为内核起一个唯一的名字。这对于确保定制内核不与其他内核混淆是很重要的。通过修改 ‘buildid’ 一行，为内核名字添加一个唯一的字符串。可以把 “.local” 改为您的名字缩写，一个 bug 号，日期，或其它任何唯一的字符串。</p>

<p>修改这一行：</p>

<pre><code>#% define buildid .local
</code></pre>

<p>改为（注意，# 号和额外的空格都被删除了）：</p>

<pre><code>%define buildid .&lt;custom_text&gt;
</code></pre>

<p>4.如果您生成了一个补丁，最后把它添加到 kernel.spec 文件中所有已存在的补丁的后面，并且添加详细的注释。</p>

<pre><code># cputime accounting is broken, revert to 2.6.22 version
Patch2220: linux-2.6-cputime-fix-accounting.patch
Patch9999: linux-2.6-samfw-test.patch
</code></pre>

<p>然后，需要将补丁应用到spec文件的application段，放在所有已存在的补丁应用的后面，并添加详细的注释。</p>

<pre><code>ApplyPatch linux-2.6-cputime-fix-accounting.patch
ApplyPatch linux-2.6-samfw-test.patch
</code></pre>

<h3 id="1-6-建立新内核">1.6. 建立新内核</h3>

<p>这一步实际是要生成一个内核 RPM 文件。只是建立定制内核所需的。对于 Fedora10 或 11 ，大多数场合下，这是建立内核（包括固件）的最简单的方法（看最后一部分）。</p>

<p>用 rpmbuild 工具建立新内核：</p>

<p>1.建立所有内核配置：</p>

<pre><code>rpmbuild -bb --target='uname -m' kernel.spec
</code></pre>

<p>2.关闭指定的内核配置（为了更快的建立）：</p>

<pre><code>rpmbuild -bb --without &lt;option&gt; --target='uname -m' kernel.spec
</code></pre>

<p>其中 “option” 的有效值包括 xen、smp、up、pae、kdump、debug 和 debuginfo 。指定 &ndash;without debug 会剔除内核中的调试代码，指定 &ndash;without debuginfo 会禁止建立 kernel-debuginfo 包。</p>

<p>3.只建立一个特定的内核：</p>

<pre><code>rpmbuild -bb --with &lt;option&gt; --target='uname -m' kernel-spec
</code></pre>

<p>“option” 的有效值包括 xenonly、smponly 和 beseonly。</p>

<p>4.例如，只建立 kernel 和 kernel-devel 包的命令是：</p>

<pre><code>rpmbuild -bb --with baseonly --without debuginfo --target='uname -m' kernel.spec
</code></pre>

<p>5.建立时包含固件，用如下命令：</p>

<pre><code>rpmbuild -bb --with baseonly --with firmware --without debuginfo --target=`uname -m` kernel.spec
</code></pre>

<p>建立的过程需要很长时间。会在屏幕上打印大量的信息。这些信息可以被忽略，除非建立过程因为一个error而停止。如果成功完成建立过程，一个新的内核包会出现在~/rpmbuild/RPMS目录。</p>

<p><em>应该添加一个故障排除的部分。</em></p>

<p>####1.6.1. 以下是通用教程</p>

<p>大部分关于 Linux 内核开发的教程，例子和教科书都假设内核源码被安装在/usr/src/linux目录下。如果您想下面这样做一个符号链接，您就可以使用那些Fedora包的学习材料了。安装合适的内核源码，然后运行下面命令：</p>

<pre><code>su -c 'ln -s /usr/src/kernels/&lt;version&gt;.&lt;release&gt;-&lt;arch&gt; /usr/src/linux'
</code></pre>

<p>根据提示输入 root 密码。</p>

<h3 id="1-7-安装新内核">1.7. 安装新内核</h3>

<p>这一步将把新内核安装到运行中的系统。</p>

<p>要安装新内核，用 rpm -ivh 命令，不要带 -U 或 &ndash;upgrade 选项：</p>

<pre><code>su -c &quot;rpm -ivh --force $HOME/rpmbuild/RPMS/&lt;arch&gt;/kernel-&lt;version&gt;.&lt;arch&gt;.rpm&quot;
</code></pre>

<p>如果您根据需要修改了内核的名字，您的固件和内核头文件将无法匹配。最简单的解决方法是用前面描述的方法建立新的固件，然后：</p>

<pre><code>su -c &quot;rpm -ivh $HOME/rpmbuild/RPMS/&lt;arch&gt;/kernel-&lt;version&gt;.&lt;arch&gt;.rpm \
$HOME/rpmbuild/RPMS/&lt;arch&gt;/kernel-firmware-&lt;version&gt;.&lt;arch&gt;.rpm \
$HOME/rpmbuild/RPMS/&lt;arch&gt;/kernel-headers-&lt;version&gt;.&lt;arch&gt;.rpm \
$HOME/rpmbuild/RPMS/&lt;arch&gt;/kernel-devel-&lt;version&gt;.&lt;arch&gt;.rpm&quot;
</code></pre>

<p>这些命令会把您的内核安装到 /boot目录，创建一个新的 initramfs，并且自动把新内核添加到 grub 的 “menu.list” 中。然后，您就可以重启并使用您的新内核了。</p>

<h2 id="2-只建立内核模块-kernel-modules">2. 只建立内核模块（kernel modules）</h2>

<p><em>本段需要更新和充实</em></p>

<p>这一段针对那些只想在内核模块上工作的用户，他们并不想建立一个完整的内核。只要就没必要下载和重新建立整个内核。要为当前运行的内核建立一个模块，只需要相匹配的 kernel-devel 包。运行下面命令安装 kernel-devel 包：</p>

<pre><code>su -c 'yum install kernel-devel'
</code></pre>

<p>如果您用的是 PAE 内核，可能要安装 “kernel-PAE-devel” 。</p>

<p>只要您安装了相应版本的 kernel 或 kernel-devel 包，就可以建立任何内核版本。本段的其余部分假设您正在使用当前运行的内核。如果不是，用指定的版本号代替 ‘uname -r’。</p>

<p>kernel-doc 包包含了官方的 Kbuild 文档。在 Documentation/kbuild 目录下查看，尤其是 modules.txt 文件。</p>

<p>一个简单的例子，从 foo.c 建立 foo.ko 模块，在 foo.c 所在的目录下创建下面这样的 Makefile：</p>

<pre><code>obj-m := foo.o
KDIR  := /lib/modules/$(shell uname -r)/build
PWD   := $(shell pwd)
default:
[TAB]$(MAKE) -C $(KDIR) M=$(PWD) modules
</code></pre>

<p>[TAB] 表示 makefile 中包含命令的一行必须以一个 tab 字符开头。</p>

<p>然后，执行 make 命令建立 foo.ko 模块。</p>

<p>上面是是通过一个本地 Makefile 包装调用 kbuild。通常您可以简单一点，想下面这样来建立那些目标。</p>

<pre><code># make -C /lib/modules/`uname -r`/build M=`pwd` modules
# make -C /lib/modules/`uname -r`/build M=`pwd` clean
# make -C /lib/modules/`uname -r`/build M=`pwd` modules_install
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>在 Linux 系统中部署 goagent</title>
            <link>https://shaocheng.li/posts/2012/03/23/</link>
            <pubDate>Fri, 23 Mar 2012 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2012/03/23/</guid>
            <description>Goagent 的项目主页在 googlecode：http://code.google.com/p/goagent/
首页有 Windows 系统中的部署教程，Linux 系统中的部署方法有些复杂，记录如下:
 申请一个Google Appengine：http://code.google.com/intl/zh-CN/appengine/，并且创建一个 appid。 下载 Python 版的 Google App Engine SDK，下载页面：http://code.google.com/intl/zh-CN/appengine/downloads.html#Google_App_Engine_SDK_for_Python，要选择 Linux 平台。下载后解压为一个 google_appengine 文件夹。 下载 goagent 稳定版，在项目主页的顶部就有下载链接，当前的版本是 goagent 1.7.10。下载后解压到 google_appengine/goagent 文件夹。 修改 local/proxy.ini 文件中的 [gae] 下的 appid=你的appid ，多个 appid 可以用 | 隔开。 上传。在 google_appengine 目录下执行：python appcfg.py update goagent/server/python。上传需要一些时间。 chrome 浏览器请安装 SwitchySharp 插件：https://chrome.google.com/webstore/detail/dpplabbmogkhghncfbfdeeokoefdjegm，安装后导入这个设置：http://goagent.googlecode.com/files/SwitchyOptions.bak。 使用时在 goagent/local 下执行 python proxy.py ，然后打开 chrome 即可。  </description>
            <content type="html"><![CDATA[<p>Goagent 的项目主页在 googlecode：<a href="http://code.google.com/p/goagent/" target="_blank">http://code.google.com/p/goagent/</a></p>

<p>首页有 Windows 系统中的部署教程，Linux 系统中的部署方法有些复杂，记录如下:</p>

<ol>
<li>申请一个Google Appengine：<a href="http://code.google.com/intl/zh-CN/appengine/" target="_blank">http://code.google.com/intl/zh-CN/appengine/</a>，并且创建一个 appid。</li>
<li>下载 Python 版的 Google App Engine SDK，下载页面：<a href="http://code.google.com/intl/zh-CN/appengine/downloads.html#Google_App_Engine_SDK_for_Python" target="_blank">http://code.google.com/intl/zh-CN/appengine/downloads.html#Google_App_Engine_SDK_for_Python</a>，要选择 Linux 平台。下载后解压为一个 google_appengine 文件夹。</li>
<li>下载 goagent 稳定版，在项目主页的顶部就有下载链接，当前的版本是 goagent 1.7.10。下载后解压到 google_appengine/goagent 文件夹。</li>
<li>修改 local/proxy.ini 文件中的 [gae] 下的 appid=你的appid ，多个 appid 可以用 | 隔开。</li>
<li>上传。在 google_appengine 目录下执行：python appcfg.py update goagent/server/python。上传需要一些时间。</li>
<li>chrome 浏览器请安装 SwitchySharp 插件：<a href="https://chrome.google.com/webstore/detail/dpplabbmogkhghncfbfdeeokoefdjegm" target="_blank">https://chrome.google.com/webstore/detail/dpplabbmogkhghncfbfdeeokoefdjegm</a>，安装后导入这个设置：<a href="http://goagent.googlecode.com/files/SwitchyOptions.bak" target="_blank">http://goagent.googlecode.com/files/SwitchyOptions.bak</a>。</li>
<li>使用时在 goagent/local 下执行 python proxy.py ，然后打开 chrome 即可。</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>牛逼的AA</title>
            <link>https://shaocheng.li/posts/2012/03/05/</link>
            <pubDate>Mon, 05 Mar 2012 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2012/03/05/</guid>
            <description>也许你还不知道 AA 是什么，但只看那牛逼哄哄的名字，就该知道它绝非善类。
没错。进入这个项目的主页：http://aa-project.sourceforge.net/，就能看到它的三个宏伟目标：
 将所有的重要软件移植到AA-lib 将AA-lib移植到所有的可用平台 迫使IBM重新制造MDA卡   注：MDA（Monochrome Display Adapter ），单色字符显示适配卡，与单色字符显示器配接，它只支持字符显示功能，无图形功能，是一种相当古老的显卡。
 如果你对技术不感兴趣，可用点击这里 http://v.youku.com/v_show/id_XMzYwNTIyODY4.html，观看利用 AA 制作的一段动画,制作方法和源代码在文档的最后一节。
简单的说，它可用实现下面的效果，就是将图片转换为 ASCII 文本。
这个略显粗糙，如果将字体调小，增大分辨率，可显示更加逼真的图片，例如：
其实，这是一个由ASCII字符的狂热爱好者们开发的项目，最初的发起人叫 Jan Hubicka ，目的是将计算机上的一切都用 ASCII 字符来表现，包括图形和视频。
该项目提供了一个库—— AA-lib ，这是一个低级图形库，与其他的库的区别是它不需要图形设备，完全用 ASCII 字符描绘图形，它的 API 被设计得与其他库类似。还提提供一个演示程序—— BB（这个名字更显另类），播放了一段完全由 ASCII 字符绘制的动画，其中有文字，图像，分形几何，还有一个 3D 效果。
下面在 fedora12 中安装它们。
1. 安装 AA-lib 下载 aalib-1.2：
http://prdownloads.sourceforge.net/aa-project/aalib-1.2.tar.gz
最新版本是 1.4，但是 BB 是基于 1.2 的，所有先安装1.2。
解压、编译、安装：
tar xvzf aalib-1.2.tar.gz cd aalib-1.2 ./configure make make install  默认安装在 /usr/local 下</description>
            <content type="html"><![CDATA[

<p>也许你还不知道 AA 是什么，但只看那牛逼哄哄的名字，就该知道它绝非善类。</p>

<p>没错。进入这个项目的主页：<a href="http://aa-project.sourceforge.net/" target="_blank">http://aa-project.sourceforge.net/</a>，就能看到它的三个宏伟目标：</p>

<ul>
<li>将所有的重要软件移植到AA-lib</li>
<li>将AA-lib移植到所有的可用平台</li>
<li>迫使IBM重新制造MDA卡</li>
</ul>

<blockquote>
<p>注：MDA（Monochrome Display Adapter ），单色字符显示适配卡，与单色字符显示器配接，它只支持字符显示功能，无图形功能，是一种相当古老的显卡。</p>
</blockquote>

<p>如果你对技术不感兴趣，可用点击这里 <a href="http://v.youku.com/v_show/id_XMzYwNTIyODY4.html" target="_blank">http://v.youku.com/v_show/id_XMzYwNTIyODY4.html</a>，观看利用 AA 制作的一段动画,制作方法和源代码在文档的最后一节。</p>

<p>简单的说，它可用实现下面的效果，就是将图片转换为 ASCII 文本。</p>

<p><img src="/images/2012-03-05/2012-03-05_1.JPG" alt="" /></p>

<p>这个略显粗糙，如果将字体调小，增大分辨率，可显示更加逼真的图片，例如：</p>

<p><img src="/images/2012-03-05/2012-03-05_2.JPG" alt="" /></p>

<p>其实，这是一个由ASCII字符的狂热爱好者们开发的项目，最初的发起人叫 Jan Hubicka ，目的是将计算机上的一切都用 ASCII 字符来表现，包括图形和视频。</p>

<p>该项目提供了一个库—— AA-lib ，这是一个低级图形库，与其他的库的区别是它不需要图形设备，完全用 ASCII 字符描绘图形，它的 API 被设计得与其他库类似。还提提供一个演示程序—— BB（这个名字更显另类），播放了一段完全由 ASCII 字符绘制的动画，其中有文字，图像，分形几何，还有一个 3D 效果。</p>

<p>下面在 fedora12 中安装它们。</p>

<h3 id="1-安装-aa-lib">1. 安装 AA-lib</h3>

<p>下载 aalib-1.2：</p>

<p><a href="http://prdownloads.sourceforge.net/aa-project/aalib-1.2.tar.gz" target="_blank">http://prdownloads.sourceforge.net/aa-project/aalib-1.2.tar.gz</a></p>

<p>最新版本是 1.4，但是 BB 是基于 1.2 的，所有先安装1.2。</p>

<p>解压、编译、安装：</p>

<pre><code>tar  xvzf aalib-1.2.tar.gz  
cd  aalib-1.2  
./configure  
make  
make install  
</code></pre>

<p>默认安装在 /usr/local 下</p>

<h3 id="2-安装-bb">2. 安装 bb</h3>

<p>下载 bb-1.2：</p>

<p><a href="http://prdownloads.sourceforge.net/aa-project/bb-1.2.tar.gz" target="_blank">http://prdownloads.sourceforge.net/aa-project/bb-1.2.tar.gz</a></p>

<p>编译前需要设置一个环境变量，否则会找不到 aa-lib：</p>

<pre><code>export CFLAGS=-I/usr/local/include  
</code></pre>

<p>解压：</p>

<pre><code>tar xvzf bb-1.2.tar.gz  
cd aalib-1.2  
</code></pre>

<p>编译时会报 textform.c 文件的错误，是因为该文件内定义的某些字符串太长，换行时没有用反斜杠，可以在后面加上反斜杠   ，或直接注释掉。然后编译：</p>

<pre><code>./configure  
make  
</code></pre>

<p>编译生成了可执行文件 bb，直接执行即可看到一段演示。最好在文本模式下执行，否则可能会报错。</p>

<p>这段演示还可以添加音乐，在源码的 mikunix 目录下有音频的程序，直接 make ，然后执行 strip ../bb_snd_ server。但是我一直没有弄出声音，也许是虚拟机的问题。</p>

<h3 id="3-安装-aview">3. 安装 aview</h3>

<p>aview 的作用是将 pnm 格式的图片转换为 ASCII 文本，并显示。aview只支持 pnm、pgm、pbm 和 ppm 格式的图片，所以需要将其他格式的图片转换，它提供了一个 asciiview 的脚本，利用 convert 转换图片格式，然后再传递给 aview。</p>

<p>aview 依赖于 aalib-1.4，所有要先用 1.4 替换之前安装的 1.2，安装方法与 1.2 相同。安装后下载 aview：<a href="http://prdownloads.sourceforge.net/aa-project/aview-1.3.0rc1.tar.gz" target="_blank">http://prdownloads.sourceforge.net/aa-project/aview-1.3.0rc1.tar.gz</a></p>

<p>解压、编译、安装：</p>

<pre><code>tar xvzf aview-1.3.0rc1.tar.gz  
cd  aview-1.3.0  
./configure  
make  
make install  
</code></pre>

<p>编译生成的 aview 程序可以将 pbm、pgm 或 pnm 图片用 ASCII 字符显示。但是不支持 JPEG 图片，所以它提供了一个 shell 脚本 ascii    view，先调用 convert 将 JPEG 图片转换为 pgm 图片，然后再用 aview 显示。</p>

<p>fedora12 中没有 convert 命令，先用下面的命令安装：</p>

<pre><code>yum  install  ImageMagick  
</code></pre>

<p>准备一张图片，例如 1.jpg，用下面的命令就可以把它转换为 ASCII文本：</p>

<pre><code>asciiview  1.jpg  
</code></pre>

<h3 id="4-bad-apple">4. Bad Apple</h3>

<p>下面参考 aview 的源码，编写了一个程序，在 Linux 的终端下播放一段由 ASCII 字符绘制的动画：Bad Apple。原理比较   简单，就是将视频逐帧截图，然后用程序按一定的时间间隔将图片依次转换为ASCII文本在终端上显示。动画视频在这里：<a href="http://v.youku.com/v_show/id_XMzYwNTIyODY4.html" target="_blank">http://v.youku.com/v_show/id_XMzYwNTIyODY4.html</a>，动画中的卡顿是屏幕录像软件的问题，AA-lib本身是很流畅的。</p>

<p>制作步骤：</p>

<p>准备 apple.flv，用 kmplayer 做每 50 毫秒截图，截图为 jpeg 格式，把它们都复制到 /root/aa/img 目录下。</p>

<p>用下面 shell 脚本将 jpeg 图片转化为 pgm 格式，共 3202 张，文件名为 1.pgm 到 3202.pgm ，全部放在 pgm 文件夹下。</p>

<pre><code>#!/bin/sh  
ls -l *.jpg &gt; sort  
i=1  
while [ $i -le 3202 ]  
do  
    filename=`sed -n ''$i'p' sort | awk '{print $8}'`  
    echo $filename  
    convert $filename ./pgm/$i.pgm  
    i=`expr $i + 1`  
done  
</code></pre>

<p>在 pgm 文件夹下执行程序：</p>

<pre><code>./aviewdemo -contrast 20 -extended 1.pgm  
</code></pre>

<p>程序源码在这里：<a href="http://download.csdn.net/detail/exbob/4112093" target="_blank">http://download.csdn.net/detail/exbob/4112093</a></p>

<p>动画视频在这里：<a href="http://v.youku.com/v_show/id_XMzYwNTIyODY4.html" target="_blank">http://v.youku.com/v_show/id_XMzYwNTIyODY4.html</a></p>
]]></content>
        </item>
        
        <item>
            <title>X Window 架构概述</title>
            <link>https://shaocheng.li/posts/2012/02/27/</link>
            <pubDate>Mon, 27 Feb 2012 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2012/02/27/</guid>
            <description>原文：
X Window System Architecture Overview HOWTO
http://www.linuxdoc.org/HOWTO/XWindow-Overview-HOWTO/index.html
Daniel Manrique
roadmr@entropia.com.mx
Translated By Bob
Email：gexbob@gmail.com
Blog：http://shaocheng.li
修订历史
Revision 1.0.1 2001-05-22 Revised by: dm 一些语法修正，由Bill Staehle指出。
Revision 1.0 2001-05-20 Revised by: dm 初始发行。
本文档描述了X Window的架构，给出了对于X Window设计的更好理解, 包括X的组件，这些组件结合起来构成的可运行图形环境，这些组件作为窗口管理器该怎样选择，工具包和构件库，桌面环境。
1. 序言 这个文档的目的是提供一个 X-Window 系统架构的概述，希望人们更好的理解它为什么要这样设计，X 的组件是怎样组合起来形成一个可工作的图形环境，怎样选择这些组件。
我们探讨一些经常被提到的概念，如果没有相关的技术背景，这些概念可能被混淆，例如部件（widgets）和工具包（toolkits），窗口管理器（window managers）和桌面环境（desktop environments）。还提供了一些例子，展示了这些组件在日常使用的应用程序中如何相互作用。
这个文档故意写得不太偏重技术，它基于作者的经验知识，以非技术方式引入，它可以从各种意见中吸取营养，包括更深入的例子和解释，以及技术上的更正。作者欢迎所有关于这个文档的问题和意见，Email：roadmr@entropia.com.mx 。
2. 简介 回到UNIX还是新鲜事物的时代，大约是1970年，图形用户接口还是一个奇怪的东西，只被一个实验室（Xerox&amp;rsquo;s PARC）使用。可是今天，任何操作系统只要想拥有竞争力，就必须有一个GUI子系统。GUI界面提供了良好的易用性。这不是UNIX所关心的，UNIX 有它的传统，某种程度来讲，多功能比易用性更好。但是，有几个原因使得 UNIX 系统需要有一个GUI。例如，UNIX 的多任务特性，在给定的时间内要运行多个程序。GUI 提供了多种控制方式，可以在同一时间在屏幕上显示多个运行的程序。所以，某些类型的信息更适合在图形界面上显示（有些甚至只能在图形界面上显示，例如pr0n和其他图形数据）。
历史上，UNIX有很多学术上的改进。一个好的例子是，70年代末加入了 BSD 网络代码，这是加州大学伯克利分校的工作成果。事实证明，X Window 系统也是一个学术项目的结果，即 MIT 的雅典娜项目，它成为了现代 UNIX（类UNIX系统）中大部分GUI子系统的基础，包括 Linux 和 BSD。
从一开始，UNIX就是一个多用户、多任务的分时操作系统。随着网络技术的加入，它还允许用户远程连接和执行任务。以前，这是通过串行终端或网络连接（telnet）完成的。
当开发UNIX下的GUI系统的时候，这些概念都被加入到了设计中。事实上，X是一个相当复杂的设计，这是经常被提到的一个缺点。可是，正因如此，它才是一个真正多功能的系统，当我们解释GUI的各个部分在UNIX下是怎样结合的时候，这些都会变的很清晰。</description>
            <content type="html"><![CDATA[

<p>原文：</p>

<p>X Window System Architecture Overview HOWTO</p>

<p><a href="http://www.linuxdoc.org/HOWTO/XWindow-Overview-HOWTO/index.html" target="_blank">http://www.linuxdoc.org/HOWTO/XWindow-Overview-HOWTO/index.html</a></p>

<p>Daniel Manrique</p>

<p>roadmr@entropia.com.mx</p>

<p>Translated By Bob</p>

<p>Email：<a href="mailto:gexbob@gmail.com" target="_blank">gexbob@gmail.com</a></p>

<p>Blog：<a href="http://shaocheng.li" target="_blank">http://shaocheng.li</a></p>

<hr />

<p>修订历史</p>

<p>Revision 1.0.1  2001-05-22  Revised by: dm  一些语法修正，由Bill Staehle指出。</p>

<p>Revision 1.0    2001-05-20  Revised by: dm  初始发行。</p>

<p>本文档描述了X Window的架构，给出了对于X Window设计的更好理解, 包括X的组件，这些组件结合起来构成的可运行图形环境，这些组件作为窗口管理器该怎样选择，工具包和构件库，桌面环境。</p>

<hr />

<h2 id="1-序言">1. 序言</h2>

<p>这个文档的目的是提供一个 X-Window 系统架构的概述，希望人们更好的理解它为什么要这样设计，X 的组件是怎样组合起来形成一个可工作的图形环境，怎样选择这些组件。</p>

<p>我们探讨一些经常被提到的概念，如果没有相关的技术背景，这些概念可能被混淆，例如部件（widgets）和工具包（toolkits），窗口管理器（window managers）和桌面环境（desktop environments）。还提供了一些例子，展示了这些组件在日常使用的应用程序中如何相互作用。</p>

<p>这个文档故意写得不太偏重技术，它基于作者的经验知识，以非技术方式引入，它可以从各种意见中吸取营养，包括更深入的例子和解释，以及技术上的更正。作者欢迎所有关于这个文档的问题和意见，Email：<a href="mailto:roadmr@entropia.com.mx" target="_blank">roadmr@entropia.com.mx</a> 。</p>

<!-- more -->

<h2 id="2-简介">2. 简介</h2>

<p>回到UNIX还是新鲜事物的时代，大约是1970年，图形用户接口还是一个奇怪的东西，只被一个实验室（Xerox&rsquo;s PARC）使用。可是今天，任何操作系统只要想拥有竞争力，就必须有一个GUI子系统。GUI界面提供了良好的易用性。这不是UNIX所关心的，UNIX 有它的传统，某种程度来讲，多功能比易用性更好。但是，有几个原因使得 UNIX 系统需要有一个GUI。例如，UNIX 的多任务特性，在给定的时间内要运行多个程序。GUI 提供了多种控制方式，可以在同一时间在屏幕上显示多个运行的程序。所以，某些类型的信息更适合在图形界面上显示（有些甚至只能在图形界面上显示，例如pr0n和其他图形数据）。</p>

<p>历史上，UNIX有很多学术上的改进。一个好的例子是，70年代末加入了 BSD 网络代码，这是加州大学伯克利分校的工作成果。事实证明，X Window 系统也是一个学术项目的结果，即 MIT 的雅典娜项目，它成为了现代 UNIX（类UNIX系统）中大部分GUI子系统的基础，包括 Linux 和 BSD。</p>

<p>从一开始，UNIX就是一个多用户、多任务的分时操作系统。随着网络技术的加入，它还允许用户远程连接和执行任务。以前，这是通过串行终端或网络连接（telnet）完成的。</p>

<p>当开发UNIX下的GUI系统的时候，这些概念都被加入到了设计中。事实上，X是一个相当复杂的设计，这是经常被提到的一个缺点。可是，正因如此，它才是一个真正多功能的系统，当我们解释GUI的各个部分在UNIX下是怎样结合的时候，这些都会变的很清晰。</p>

<p>介绍X的架构之前，简单介绍一下它的历史，还有它是如果进入Linux系统的。</p>

<p>X是由雅典娜项目开发，在1984年发行。1988年，一个叫做“X Consortium ”的实体接手X，之后开始处理它的开发和发布。X规范是自由提供的，这个聪明的举动使X得到了很大程度的普及。下面介绍XFree86是什么。XFree86是我们在Linux系统上使用的X实体，XFree86也可以工作在其他操作系统上，例如BSD系列、OS/2和其他。尽管它的名字中带有86，它依然支持其他CPU架构。</p>

<h2 id="3-x-window系统架构-概览">3. X Window系统架构：概览</h2>

<p>X被设计为客户端—服务器的架构（client-server）。应用软件作为客户端，他们通过服务器进行沟通和发布请求，当然也可以从服务器接受信息。</p>

<p>X server维护一个独立的显示控制器和处理来自client的请求。从这一点上来看，使用这种模式的优点是显而易见的。应用程序（client）只需要知道怎样同server沟通，而不需要关注实际图像显示设备的细节。最基本的，client会告诉server一些这样的东西：“画一条从这里到那里的线”，或者“显示一个文本字符串，使用这个字体，在屏幕的这个位置”。</p>

<p>这与只用图形库写应用没什么不同。但是，X模式更进一步。它不限制client和server在同处一台电脑。使用这个协议可以让client和server通过网络进行沟通，事实上，“进程间通信机制提供了可靠的字节流”。当然，更好的方法是使用TCP/IP协议。可以看到，X的模式是很强大的。一个经典的例子是，在Cray计算机上运行一个处理器密集阵应用程序，在Solaris 服务器上运行一个数据库监视器，在小型BSD邮件服务器上运行一个E-mail应用，在SGI服务器上运行一个可视化应用，然后，将以上这些都显示在我的Linux平台的屏幕上。</p>

<p>目前为止，我们已经看到X server是一个处理实际图形显示的东西。由于X server是运行在用户使用的实际计算机上，它的职责是处理所有与用户的交互。这包括监听鼠标和键盘。所有这些信息都要传达给client，还有对它进行响应。</p>

<p>X提供了一个库，称作Xlib，负责处理所有低级的client-server通信任务。很显然，client调用Xlib中的函数进行工作。</p>

<p>这样看来，一切都工作的很好。我们有一个server负责虚拟输出和数据输入，客户端应用程序，两者之间可以通过一种方法互相通信。假设client和server之间有一个互动，client可以让server在屏幕上分配一指定的矩形区域。作为client，我并不关心我被现实在屏幕的哪个位置，我只是告诉server“给我一个X乘以Y像素大小的区域”，然后调用函数执行类似“画一条从这里到那里的线”，“用户是否在我的屏幕范围内移动鼠标”等等。</p>

<h2 id="4-窗口管理器">4. 窗口管理器</h2>

<p>可是，我们没有提到X server怎样处理client在屏幕现实范围内的操作（调用窗口）。显然，对于任何使用GUI的用户，对需要对“client windows”进行控制。通常情况下，你可以对窗口进行移动和排列；改变大小；最大化或最小化。那么，X server是怎样处理这些任务呢？答案是：不能。</p>

<p>X的设计原则之一就是“只提供机制，不提供策略”。所以，X server提供了一个操作窗口的方法（机制），并没有说怎样表现这种机制（策略）。</p>

<p>这些机制和策略可以归结为：有一个程序的责任是管理屏幕空间。这个程序决定了窗口的位置，为用户提供了控制窗口外观、位置和大小的机制，通常还会提供一些“装饰”，例如标题、边框和按钮，这些是我们对窗口本身的控制。这个控制窗口的程序称作“窗口管理器”。</p>

<p>“窗口管理器只是X的一个客户端程序——它不是X window系统的一部分，尽管它享有一些特权——所以，窗口管理器不是唯一的，而是有很多，它们提供了不同的用户与窗口的交互方式和不同的窗口布局、修饰、键盘和色调的风格。”</p>

<p>X的架构提供了用于窗口管理器执行这些窗口操作的方法，但确实没有提供一个窗口管理器。</p>

<p>另外，由于窗口管理器是一个外部元件，可以很容易的根据你的参数设定窗口，例如，你希望它看起来是什么样子，你想要它怎样执行，你想要它出现在哪里，等等。有些窗口管理器比较简单和丑陋（例如twm）；还有一些是华而不实的；还有介于两者之间的；fvwm, amiwm, icewm, windowmaker, afterstep, sawfish, kwm, 还有数不清的其他窗口管理器。每一种口味都有对应的窗口管理器。</p>

<p>窗口管理器是一个“meta-client”，最基本的使命是管理其他客户端程序。大部分窗口管理器会提供一些额外的设施（有些会提供很多）。 可是，有个功能是大部分窗口管理器都有的——启动应用程序的方法。有些窗口管理器会提供一个命令盒子，你可以在这里写标准命令（用于启动应用程序）。还有一些窗口管理器会提供某种类型的应用程序启动菜单。这些不是标准配置。由于X没有制度关于如何启动应用程序的策略，这项功能在客户端程序中实施。那么，通常情况下，窗口管理器所负责的这个功能（个体之间会由差异），它的唯一使命就是如果启动客户端应用程序，就像一个程序启动平台。当然，人们已经写了大量的“启动程序”的应用。</p>

<h2 id="5-客户端应用">5. 客户端应用</h2>

<p>下面让我们关注一些客户端程序。假设你想要从头开始写一个客户端程序，并且只用X提供的设施。你很快就会发现，Xlib是漂亮的斯巴达，想要在屏幕上放一个按钮、文本，或是为用户提供的漂亮空间（滚动条，单选框），这些事竟是令人恐怖的复杂。</p>

<p>幸运的是，有人为我们提供了一个库，可以解决这些控件的编程问题。这些控件通常称作“部件”（widget library ），所以，这个库称作“部件库”。我只需从库中调用一个带参数的函数就可以在屏幕上显示一个按钮。这些部件包括菜单、按钮、单选按钮、滚动条和画布。</p>

<p>“canvas”（画布）是一个有趣的部件，它是客户端上的一个子空间，我能在里面话一些东西。可以理解，我不能直接使用Xlib，那样会干扰部件库，这个库本身提供了在画布内画任意图像的方法。</p>

<p>由于部件库确实可以在屏幕上画各种元素，以及解释用户的输入动作，这个库要对每个客户端的外观和行为负责。从开发者的角度来看，部件库也有一些API（设置函数），定义了我想要用到的部件。</p>

<h2 id="6-部件库和工具包">6. 部件库和工具包</h2>

<p>原始的部件库是为雅典娜项目开发的，理所当然应该是雅典娜部件库，也被称作雅典娜部件。它非常基础，非常简陋，安装现在的标准来看，它的使用方便并不直观（例如，要移动一个滚动条或滑块，你不能拖动，你要点击右边的按钮让它向上滑，或者点击左边的按钮让它向下滑），正因如此，现在几乎没有被使用了。</p>

<p>像窗口管理器一样，考虑到不同的设计目的，工具包（toolkit）也有很多种。最早的工具包之一是著名的Motif，这是开发软件基金会（OSF）的Motif图像环境的一部分，由一个窗口管理器和一个匹配工具包组成。OSF的历史超出了本文档的讨论范围。Motif工具包优于雅典娜部件，在80年代和90年代初使用广泛。</p>

<p>这些年，Motif不是一个受欢迎的选择。它不是免费的，如果你想要一个开发许可证（即用它编译你自己的程序），你需要向OSF Motif缴费，尽管可以发布一个针对Motif的二进制连接。至少对于Linux用户来说，最知名的Motif应用可能就是Netscape Navigator/Communicator。</p>

<p>有一段时间，Motif是唯一正常可用的工具包。有很多软件围绕着Motif。于是人们开始开发替代品，产生了丰富的工具包，例如XForms, FLTK等等。</p>

<p>已经有些时间没有听到Motif了，特别是在自由软件世界。原因是：就许可、性能（Motif被普遍认为像一头猪）和功能而言已经有了更好的替代品。</p>

<p>有一个知名并广泛使用的工具包是Gtk，它是GIMP项目专门设计用来替代Motif的。Gtk现在非常流行，因为它相对较轻，功能丰富，可扩展，而且完全免费。GIMP的0.6发行版的更新日志里包含了“Bloatif has been zorched ”，这句话是给Motif的臃肿的遗嘱。</p>

<p>另一个目前很流行的工具包是Qt。直到KDE项目的出现，它才开始出名，KDE利用了Qt的所有GUI元素。当然，我们不会深入Qt的许可问题和KDE/GNOME的分离性。Gtk说来话长，因为它的历史伴随着Motif的替换而变的很有趣。Qt没什么可说的，因为它真的很流行。</p>

<p>最后，另一个值得一提的替代品是LessTif，这个名字是对于Motif的双关语，LessTif的目标是成为免费的，兼容Motif API的替代品。并不清楚LessTif的目标已经达到了怎样的程度，倒不如帮助那些使用Motif代码的应用，在它们想要移植到其他的工具包时，有个一个免费的替代品。</p>

<h2 id="7-目前为止我们所拥有的">7. 目前为止我们所拥有的</h2>

<p>现在，我们已经知道，X有一个client-server架构，我们的应用程序就是client。在这个client-server架构的图形系统下，有多种可选的窗口管理器，它管理着我们的屏幕空间。client是我们真正完成工作的地方，而且，可以使用不同的工具包进行客户端编程。</p>

<p>困境就从这里产生了。各种窗口管理器使用各自不同的方法管理客户端，它们的功能和外观各不相同。同样的，由于每个客户端使用不同的工具包，它们的外观和性能也会不同。由于没有人说作者必须用同一个工具包写应用程序，下面这种情况很可能在用户运行程序是出现，比方说，六个不同的应用，都使用不同的工具包，那么它们的外观和性能也不同。这是由于应用之间的功能不一致而造成的困境。如果你一直使用一个用雅典娜组件写的程序，你会注意到，它和用Gtk所写的程序不太一样。通过使用这些外观和体验差别很大的应用，会让你记住是一个困境。这基本上否定了一个GUI环境的优势。</p>

<p>从技术角度来看，使用多种不同的工具包会增加对资源的占用。现代操作系统都支持动态链接库。这意味着，如果我有两三个使用Gtk的应用程序，还有一个Gtk动态链接库，那么这几个应用程序将共享这个Gtk。这样就节省了资源。另一方面，如果我有一个Gtk应用，一个Qt应用，一些基于雅典娜的程序，一个基于Motif的程序（例如Netscape），一个使用FLTK的程序，还有其他一些使用XForms，那我就要在内存中加载六个不同的库，每个库还要有一个不同的工具包。请记住，这些工具包提供的功能基本相同。</p>

<p>还用另外一些问题。每一种窗口管理器的启动程序的方式是不同的。有些窗口管理器有漂亮的启动程序菜单；有些则没有，它们希望我们打开一个程序启动箱，或者使用一个组合键，要不就是打开一个xterm，然后调用命令启动你的程序。所有，困境就是因为没有一个标准。</p>

<p>最后，我们的计划没有覆盖到一些GUI环境的细节。例如有效的配置，或者“控制面板”；还有图形文件管理器。当然，这些可以写成客户端应用。在典型的自由软件时尚中，有数百种文件管理器，数百种系统配置程序，可以想象，处理这些不同的软件组件将是更大的困境。</p>

<h2 id="8-桌面环境的救赎">8. 桌面环境的救赎</h2>

<p>先说一下桌面环境的概念是怎么来的。一个桌面环境应该提供一套设施和指导，用于规范我们之前提到的所有东西，以便我们前面提到的问题最小化。</p>

<p>桌面环境的概念对于Linux来说是新的东西，但是这些东西在其他操作系统（例如Windows和Mac OS）中本来就存在。例如，MacOS，它是最早的图形用户接口之一，为整个计算机会话提供了一个非常一致的感观。再例如，操作系统提供了很多我们前面提到的细节：它提供了一个默认的文件管理器，一个全系统控制面板，还有一个所有应用都使用的独立工具包（所以它们看起来都差不多）。应用窗口由系统（严格的将是窗口管理器）负责管理。最后，还有一套指南告诉开发者应该怎么表现他们的应用，如何设计外观和布局，以及根据系统中的其他应用设计外观。所有这些都是为了保证应用程序的一致性和易用性。</p>

<p>这引出了一个问题，“为什么X的开发者没有将桌面环境的事情放在首位？”。这是有道理的；毕竟，这样就可以避免前面提到的所有问题。答案就是，在X的设计过程中，它的设计者选择将它设计得尽可能的灵活。比如说，MacOS提供了大多数机制/策略规范，但是他们不鼓励人们玩弄这些东西，结果就是失去了多功能性，如果我不喜欢MacOS管理窗口的方式，或者工具包没有提供我需要的功能，我只能怪自己倒霉。X下就不会发生这样的事，灵活的代价就是更大的复杂性。</p>

<p>在Linux/Unix和X下，一切都归结于统一和坚持。以KDE为例，KDE包含一个单一的窗口管理器（kwm），负责管理和控制窗口的行为。它用了一个特定的图形工具包（Qt），以至于KDE应用的控制和外观都差不多。KDE提供了一套桌面环境库，这是Qt的扩展，用来完成一些常见的编程工作，例如创建菜单、“关于”框，编写工具栏，程序间通信，打印，选择文件，等等。这使得程序员的工作更加简单，并且标准化。KDE还为程序员提供了一套设计和行为指南，如果每个人都按照指南来做，那么KDE程序的外观和操作就会很相似。最后，KDE还为桌面环境提供一些组件，一个启动器面板（kpanel），一个标准的文件管理器，还有一个配置程序（控制面板），通过它可以全方位的控制计算机环境，比如设置桌面背景和标题栏的颜色。</p>

<p>KDE面板相当于Windows操作系统的任务栏。在这上面可以启动应用程序，还可以在上面显示将小程序（applets）。它还提供了大多数用户都离不开的实时时钟。</p>

<h2 id="9-特定桌面环境">9. 特定桌面环境</h2>

<p>我们以KDE为例，但它不是Unix系统上最早的桌面环境。最早的可能是CDE（Common Desktop Environment），OSF的另一个兄弟。根据CDE FAQ：“Common Desktop Environment是Unix的标准桌面，为最终用户、系统管理员和应用开发者提供一贯的跨平台服务。”可是，CDE没有足够丰富的功能和易用性。除了Motif，CDE几乎在自由软件世界消失了，最终被更好的平台替代。</p>

<p>在Linux下，最流行的桌面环境是KDE和GNOME，但是不止这两个。在网上可以轻易的搜索到半打桌面环境：GNUStep、ROX、GTK+XFce、UDE。它们都提供前面提到的基础功能。GNOME和KDE拥有来自社区和业界的最广泛的支持，所以它们是最优秀的之一，为用户和应用程序提供大量的服务。</p>

<p>我们提过在KDE下有很多提供特定服务的组件。作为一个好的桌面环境，GNOME在这方面也一样。最明显的差别是GNOME并不要求使用特定的窗口管理器（这方面KDE有kwm）。GNOME一直试图做到与窗口管理器无关，但是要承认，大多数用户与他们的窗口管理器联系紧密，而强迫他们使用不同的窗口管理器会损害他们的观众。GNOME原本青睐Enlightenment窗口管理器，现在它们更喜欢用Sawfish，但是GNOME控制面板一直有一个窗口管理器选择框。</p>

<p>除此以外，GNOME使用Gtk工具包，并且通过gnome-lib提供了一套高级功能和工具。GNOME有它自己的一套编程方法，可以确保兼容的应用之间行为一致；它提供了一个面板，一个文件管理器（gmc）和一个控制面板（gnome控制中心）。</p>

<h2 id="10-怎样把它们组合到一起">10. 怎样把它们组合到一起</h2>

<p>每个用户都可以自由的选择感觉最好的桌面环境。最终的结果是，如果你使用纯kde或纯gnome系统，整个环境的感观就非常一致；并且应用程序之间的沟通会更好。我们不可能在一个应用程序中使用多种不同的工具包。现代Linux桌面环境提供的设备还使用了一些其他的小技术，例如组件架构（KDE有Kparts，GNOME用Bonobo），它允许你在文字处理文档中嵌入表格或图表；还有整体打印设备，就像是Windows中的印刷背景；还有脚本语言，可以让更多的高级用户编写程序将多个应用结合到一起，让它们用有趣的方式进行协作。</p>

<p>在Unix的桌面环境概念中，一个程序可以在多个环境中运行。我可以想象在GNOME中用Konqueror，在KDE中用Gnumeric。它们只是程序而已。当然，一个桌面环境的整体理念是一致的，所以，坚持使用那些你喜欢的环境中的应用是有道理的。但是，如果你想要处理掉一个不太合适的应用，并且不影响环境中的其他部分，你完全可以自由的去做。</p>

<h2 id="11-x系统中的一天">11. X系统中的一天</h2>

<p>下面是一个例子，在Linux系统的桌面环境中，一个典型的GNOME会话是怎样运行的。假设它们工作在X之上。</p>

<p>当Linux系统启动X时，X server启动并初始化图形设备，然后等待客户端的应答。首先启动gnome-sessiong，并且设置工作会话。一个会话包括我同意打开的应用，它们在屏幕上的位置，等等。然后启动面板。面板通常出现在屏幕的底部，有点像桌面环境的仪表盘。我们可以用它来启动程序，看到正在运行的程序，还可以控制工作环境。然后，窗口管理器会启动。因为我们正在使用GNOME，无法确定是哪种窗口管理器，这里假设是Sawfish。最后，文件管理器启动。文件管理器负责处理桌面图标。至此，我的GNOME环境就完全准备好了。</p>

<p>到目前为止，所有启动的程序都是客户端，都连接到了X server。现在我们看到的X server和client是在同一台计算机上，但是就像我们前面看到的，这不是必须的。</p>

<p>现在，我们可以打开一个xterm来执行一些命令。当我们点击xterm图标时，面板会启动xterm程序。它是一个X client应用，所以，当它启动时会连接X server并显示它的界面。当X server为xterm分配屏幕空间时，它会让窗口管理器（Sawfish）为窗口装饰一个漂亮的标题栏，并决定它显示的位置。</p>

<p>让我们用一下浏览器。点击面板上的Netscape图标，启动一个浏览器。这个浏览器可不是GNOME的设备，它用的是Gtk工具包。所以，它和桌面环境中的其它部分不是特别协调。</p>

<p>接着打开“File”菜单。Motif在屏幕上提供了一个控制器，所以，Motif库的工作就是适当的调用相关的Xlib，为显示菜单在屏幕上绘制必要的元素，并且让我选择“exit”选项来关闭应用。</p>

<p>现在我们打开一个Gnumeric电子表格。有些时候我需要用到xterm，所以我点击它。Sawfish检测到了我的动作，然后对现有的窗口做些改变，将xterm放在了最上层，并且将焦点移动到xterm上面，这样我就可以在它上面工作了。</p>

<p>之后，我回到电子表格，想要打印这个文档。Gnumeric是一个GNOME应用，所以它可以使用GNOME环境提供的设备。当我打印时，Gnumeric调用gnome-print库，连接打印机并且打印。</p>

<h2 id="12-版权和许可">12. 版权和许可</h2>

<p>Copyright &copy; 2001 by Daniel Manrique</p>

<p>在自由软件社区发行的GNU Free Documentation License，Version1.1或之后版本的条款下（不包含不变章节、封面文字和封底文字），授予复制、发布和修改该文档的权限。在这里可以找到许可协议的衣服拷贝。</p>
]]></content>
        </item>
        
        <item>
            <title>在Fedora7下安装USB无线网卡TL-WN321G</title>
            <link>https://shaocheng.li/posts/2012/01/17/</link>
            <pubDate>Tue, 17 Jan 2012 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2012/01/17/</guid>
            <description>今天是年前最后一天上班，要在 Fedora7 下安装一款 USB 无线网卡—— TP-Link 的 WN321G+，该网卡使用的是 rt73 芯片，属于 Ralink 芯片组，安装过程中遇到了一下问题，最后总算成功了，记录一下。
插上usb网卡，用 lsusb 命令就可以看到设备：
Bus 004 Drvice 003： ID 148f:2573 Ralink Technology,Corp  fedora7 已经带了 rt73 的驱动，用如下命令即可加载：
modprobe rt73usb  可是加载了驱动后，网卡还是不能用，用 iwconfig 命令也没有看到无线网卡，用 dmesg 命令看到一条错误信息：
Error-connt read firmware  无法读取固件，原因不明。
无奈只能下载在一个新的驱动，编译安装，驱动名称是：
rt73-k2wrlz-3.0.3-3  下载地址： http://homepages.tu-darmstadt.de/~p_larbig/wlan/rt73-k2wrlz-3.0.3.tar.bz2
下载后解压，按照README文件的描述进行编译安装：
tar -xvf rt73-k2wrlz-3.0.3-3.tar.bz2 cd rt73-k2wrlz-3.0.3-3/Module make make install modprobe rt73 ifname=wlan0  安装成功。
用 iwconfig 可以看到 wlan0 的相关信息，
在 /etc/sysconfig/network-scripts 目录下添加 ifcfg-wlan0 文件，添加如下内容：</description>
            <content type="html"><![CDATA[<p>今天是年前最后一天上班，要在 Fedora7 下安装一款 USB 无线网卡—— TP-Link 的 WN321G+，该网卡使用的是 rt73 芯片，属于 Ralink 芯片组，安装过程中遇到了一下问题，最后总算成功了，记录一下。</p>

<p>插上usb网卡，用 lsusb 命令就可以看到设备：</p>

<pre><code>Bus 004 Drvice 003： ID 148f:2573  Ralink Technology,Corp
</code></pre>

<p>fedora7 已经带了 rt73 的驱动，用如下命令即可加载：</p>

<pre><code>modprobe  rt73usb
</code></pre>

<p>可是加载了驱动后，网卡还是不能用，用 iwconfig 命令也没有看到无线网卡，用 dmesg 命令看到一条错误信息：</p>

<pre><code>Error-connt read  firmware
</code></pre>

<p>无法读取固件，原因不明。</p>

<p>无奈只能下载在一个新的驱动，编译安装，驱动名称是：</p>

<pre><code>rt73-k2wrlz-3.0.3-3
</code></pre>

<p>下载地址：
<a href="http://homepages.tu-darmstadt.de/~p_larbig/wlan/rt73-k2wrlz-3.0.3.tar.bz2" target="_blank">http://homepages.tu-darmstadt.de/~p_larbig/wlan/rt73-k2wrlz-3.0.3.tar.bz2</a></p>

<p>下载后解压，按照README文件的描述进行编译安装：</p>

<pre><code>tar -xvf rt73-k2wrlz-3.0.3-3.tar.bz2
cd rt73-k2wrlz-3.0.3-3/Module
make
make install
modprobe rt73  ifname=wlan0
</code></pre>

<p>安装成功。</p>

<p>用 iwconfig 可以看到 wlan0 的相关信息，</p>

<p><img src="/images/2012-01-17/2012-01-17_1.JPG" alt="" /></p>

<p>在 /etc/sysconfig/network-scripts 目录下添加 ifcfg-wlan0 文件，添加如下内容：</p>

<pre><code>DEVICE=wlan0
ONBOOT=yes
ROOTPROTO=dhcp
</code></pre>

<p>保存，退出，用 ifup wlan0 命令启动网卡。</p>

<p>用 iwlist wlan0 scan 可以看到可用的无线路由器。
用 iwconfig wlan0 ap [mac] 命令连接到可用的无线路由器的MAC地址。</p>

<p>工作完成，开心回家。</p>

<p><strong>P.S.:</strong></p>

<p>make 后可能会报 warning：Module file much too big，用 strip 压缩即可：</p>

<pre><code>strip --strip-debug rt73.ko
</code></pre>

<p>原来 2.7M 的驱动文件压缩后只有200KB。</p>

<p>最近发现该驱动不太稳定，经常会连不上无线路由，最终更换为芯片厂商 Ralink 提供的驱动。</p>

<p>下载地址：<a href="http://www.ralinktech.com/en/04_support/support.php?sn=501" target="_blank">http://www.ralinktech.com/en/04_support/support.php?sn=501</a></p>

<p>文件名：2011_0210_RT73_Linux_STA_Drv1.1.0.5.bz2</p>

<p>安装方法参考Readme文件。</p>

<p><strong>参考：</strong></p>

<p>Wireless Setup：<a href="https://wiki.archlinux.org/index.php/Wireless_Setup" target="_blank">https://wiki.archlinux.org/index.php/Wireless_Setup</a></p>

<p>rt73-k2wrlz-3.0.3-3：<a href="http://aur.archlinux.org/packages.php?ID=15377" target="_blank">http://aur.archlinux.org/packages.php?ID=15377</a></p>

<p>Rt2x00 beta driver：<a href="https://wiki.archlinux.org/index.php/Using_the_new_rt2x00_beta_driver" target="_blank">https://wiki.archlinux.org/index.php/Using_the_new_rt2x00_beta_driver</a></p>
]]></content>
        </item>
        
        <item>
            <title>怎样设置Framebuffer</title>
            <link>https://shaocheng.li/posts/2011/12/14/</link>
            <pubDate>Wed, 14 Dec 2011 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2011/12/14/</guid>
            <description>环境：Redhat9.02
启动级别：3
1. 配置内核： 首先要再编译内核是选中如下几项：
Code maturity level options ---&amp;gt;[*] Prompt for development and/or incomplete code/drivers Processor type and features ---&amp;gt;[*] MTRR (Memory Type Range Register) support Block Devices -&amp;gt;[*] Loopback device support [*] RAM disk support (4096) Default RAM disk size [*] Initial RAM disk (initrd) support Console Drivers -&amp;gt;[*] VGA text console [*] Videomode selection support Console Drivers -&amp;gt; Frame-buffer support -&amp;gt;[*] Support for frame buffer devices [*] VESA VGA graphics console [*] Use splash screen instead of boot logo  2.</description>
            <content type="html"><![CDATA[

<p>环境：Redhat9.02</p>

<p>启动级别：3</p>

<h2 id="1-配置内核">1. 配置内核：</h2>

<p>首先要再编译内核是选中如下几项：</p>

<pre><code>Code maturity level options ---&gt;[*] Prompt for development and/or incomplete code/drivers  
Processor type and features ---&gt;[*] MTRR (Memory Type Range Register) support  
Block Devices -&gt;[*] Loopback device support
                [*] RAM disk support
                    (4096) Default RAM disk size
                [*] Initial RAM disk (initrd) support  
Console Drivers -&gt;[*] VGA text console
                  [*] Videomode selection support  
Console Drivers -&gt; Frame-buffer support -&gt;[*] Support for frame buffer devices
                                          [*] VESA VGA graphics console
                                          [*] Use splash screen instead of boot logo   
</code></pre>

<h2 id="2-配置bootloader">2. 配置Bootloader</h2>

<ul>
<li><p>Grub
修改/etc/grub.conf，在kernel项的最后添加vga参数和fb，例如：</p>

<pre><code>kernel  /boot/vmlinuz-2.4.20-8 ro root=LABEL=/  vga=0x311 fb:on  
</code></pre></li>

<li><p>LILO</p>

<p>修改/etc/lilo.conf，添加vga参数，例如：</p>

<pre><code>vga=0x311  
</code></pre>

<p>修改后执行lilo命令，写入bootloader。</p></li>
</ul>

<p>vga参数的可选值如下：</p>

<p><img src="/images/2011-12-14/2011-12-14_1.JPG" alt="" /></p>

<p>修改后重启系统，会在右上角看到一个Linux的企鹅Logo。</p>
]]></content>
        </item>
        
        <item>
            <title>使用GNU Autoconf/Automake创建Makefile</title>
            <link>https://shaocheng.li/posts/2011/11/21/</link>
            <pubDate>Mon, 21 Nov 2011 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2011/11/21/</guid>
            <description>原文：
How To Create a GNU Autoconf / Automake Based Configure Script for Your Application
http://www3.fh-swf.de/fbin/roth/download/prg3.howto_autoconfmake.pdf
by Prof.Dr. Walter Roth
University of Applied Science Suedwestfalen, Germany
Translated by Bob
2011-11-18
Email：gexbob@gmail.com
Blog：http://shaocheng.li
1. 本文档的基本信息 1.1. 印刷 有些字体比较难认，所以用下面这个表给出一些字符的图像，这对命令很重要。本文档用 Times New Roman 的 12 号字体写普通文本，用 Courier 的 11 号字体写命令行和源代码。注意：双线可能会画成一个比较长的单线
1.2. 名词定义 应用（Application）是指你开发的程序。
目标系统（target system）是用于安装你的程序的计算机。
开发系统（development system）是指开发程序所用计算机
2. 为什么使用GNU AutoXXX Tools？ 使用 Autoconf 和 Automake 是唯一的（合理的）为你的应用创建 Makefile 的方法，只要你的应用工作在任何有 GNU 工具的系统上。GNU 工具可用于所有的 Unix、Windows（Cywin）和 MacOS 系统</description>
            <content type="html"><![CDATA[

<p>原文：</p>

<p>How To Create a GNU Autoconf / Automake Based Configure Script for Your Application</p>

<p><a href="http://www3.fh-swf.de/fbin/roth/download/prg3.howto_autoconfmake.pdf" target="_blank">http://www3.fh-swf.de/fbin/roth/download/prg3.howto_autoconfmake.pdf</a></p>

<p>by Prof.Dr. Walter Roth</p>

<p>University of Applied Science Suedwestfalen, Germany</p>

<p>Translated by Bob</p>

<p>2011-11-18</p>

<p>Email：<a href="mailto:gexbob@gmail.com" target="_blank">gexbob@gmail.com</a></p>

<p>Blog：<a href="http://shaocheng.li" target="_blank">http://shaocheng.li</a></p>

<hr />

<h2 id="1-本文档的基本信息">1. 本文档的基本信息</h2>

<h3 id="1-1-印刷">1.1. 印刷</h3>

<p>有些字体比较难认，所以用下面这个表给出一些字符的图像，这对命令很重要。本文档用 Times New Roman 的 12 号字体写普通文本，用 Courier 的 11 号字体写命令行和源代码。注意：双线可能会画成一个比较长的单线</p>

<p><img src="/images/2011-11-21/2011-11-21_1.PNG" alt="" /></p>

<h3 id="1-2-名词定义">1.2. 名词定义</h3>

<p>应用（Application）是指你开发的程序。</p>

<p>目标系统（target system）是用于安装你的程序的计算机。</p>

<p>开发系统（development system）是指开发程序所用计算机</p>

<h2 id="2-为什么使用gnu-autoxxx-tools">2. 为什么使用GNU AutoXXX Tools？</h2>

<p>使用 Autoconf 和 Automake 是唯一的（合理的）为你的应用创建 Makefile 的方法，只要你的应用工作在任何有 GNU 工具的系统上。GNU 工具可用于所有的 Unix、Windows（Cywin）和 MacOS 系统</p>

<h2 id="3-它是如何工作的">3. 它是如何工作的？</h2>

<p>GNU Autoconf 由多个程序组成，最终由它们为你的应用创建 Makefile。它会为源码的每个子目录创建一个 Makefile。由于Makefile 是针对特定的用户机器的（目标系统），也就是你的程序运行的系统，所以必须在用户机器上创建。目标系统的所有信息对于这个机器都是可用的。Makefile 是由冗长的脚步程序“configure”创建的，这个脚本必须随你的源代码一起提供。在目标系统上，configure 是根据它运行的一些测试结果来创建 Makefile 的，这些结果已经事先写在了 Makefile.am文件。Makefile 支持很多不同的目标，第一个就是“all”。make all 会为你的程序创建二进制文件。install 目标会安装这些二进制文件，uninstall 用于卸载。这样的话，用户就可以很方便的使用你的程序，只需应用的顶层目录上，运行如下三条命令即可：</p>

<pre><code>./configure  
make  
make install  
</code></pre>

<p>第二条命令就相当于 make all，因为 all 是第一个目标。当然，目标系统必须有可用 make 工具和一个编译器。但是，这要用 configure 检查，如果 configure 没有找到所有它需要的程序，它会停止并返回错误信息。
可是，必须在你的系统上创建 configure 脚本，这是个非常复杂的任务。</p>

<h2 id="4-你需要什么">4. 你需要什么？</h2>

<p>首先，需要你的源码。确保处在顶层目录，并且包含了所有的文件，编译时不会报错。</p>

<p>你可能要添加一些新文件，为你的应用提供一些必要的文档。下面这些文件是必须存在于顶层目录的：</p>

<ul>
<li>INSTALL：安装描述。你可以从其他基于automake的应用中拷贝一个标准的INSTALL文件，然后添加一些针对你的应用的信息。</li>
<li>README：用户应该知道的一些关于本应用的信息。最好在文件的开始处简单描述一些这个应用的目的</li>
<li>AUTHORS：作者列表。</li>
<li>NEWS：关于本应用的最新的新闻</li>
<li>ChangLog：本应用的修订历史</li>
</ul>

<p>这些文件可以不包含任何内容，因此，第一次运行时，你可以只创建一些空文件。但是，这些文档对用户是很重要的。你应该花点时间好好的写了它们。README 文件是最重要的一个。让它尽可能的保护一些有用的信息。</p>

<p>然后，当然是需要GNU工具。幸运的是，现在所有的Linux发行版都包含了GNU工具。你可以验证一些它们是否已经安装。要检查的话，只需键入：</p>

<pre><code>which automake  
</code></pre>

<p>它会产生类似下面的结果：</p>

<pre><code>/usr/bin/automake  
</code></pre>

<p>如果返回的是空行，很可能没有安装GNU工具。</p>

<h2 id="5-一步一步为-hello-world-创建配置脚本">5. 一步一步为“Hello World”创建配置脚本</h2>

<h3 id="5-1-简评">5.1. 简评</h3>

<p>下面内容中的命令都用 Courier 字体。所有的命令都可以在普通用户中使用，无需变成 root 。例子中使用的应用叫做 myapplication，版本是 1.0。该应用只有一个文件夹“myapplication”，单一源文件 main.c。你要自己编辑源代码、文档、configure.ac 和 makefile.am 文件。其他的都可以自动生成。</p>

<h3 id="5-2-准备源码">5.2. 准备源码</h3>

<p>进入应用的顶层目录。</p>

<pre><code>cd  myapplication  
</code></pre>

<p>建立前面提到的那些空文档文件，稍后再填写它们。</p>

<pre><code>touch INSTALL README AUTHORS NEWS ChangeLog  
</code></pre>

<h3 id="5-3-新建makefile-am">5.3. 新建makefile.am</h3>

<p>####5.3.1. 构建应用</p>

<p>makefile.am 包含了关于应用的信息，配置脚本需要这些信息来创建最终的 Makefile。必须建立一个 makefile.am，它的内容包括目标、源代码和应用的子目录。下面是 myapplication 的 makefile.am，没有子目录：</p>

<pre><code>##Process this file with automake to create Makefile.in   
bin_PROGRAMS = myapplication   
myapplication_SOURCES=main.c  
</code></pre>

<p>第一行是默认的内容，每个 makefile.am 都可以使用。第二行列出了要建立和安装到目标系统的二进制程序文件。本例中只有一个 myapplication，它将被安装到 SuSe9.0 系统的 /usr/bin 目录下，这是一个默认目录。如果你要构建多于一个的程序，或要安装到其他目录，请查看第7章的 Automake 文档。</p>

<p>第三行列出了该应用的所有源文件。第一个词是由应用名称和_SOURCES组成的。</p>

<p>####5.3.2. 安装文件</p>

<p>makefile.am 不仅仅管理应用的构建过程，还定义了要安装到目标系统的文件的目标路径。automake已经提前定义了标准的安装目录，其中最重要的几个目录是：</p>

<ul>
<li>prefix ：安装目录树的顶层，标准是/usr/local(KDE是/opt/kde)</li>
<li>binary ：二进制程序的目录</li>
<li>libexecdir ：程序的库的目录</li>
</ul>

<p>还有更多的提前定义的目录，请阅读“The GNU Coding Startding”的目录变量（5）。安装到这些目录的文件会像下面这样被列出了：</p>

<pre><code>bin_PROGRAMS=myapplication  
</code></pre>

<p>myapplication文件将被放到一个bin目录下。</p>

<p>如果你需要将某些文件安装到非标准目录下，就要自己定义。名字必须以dir作为后缀。例如：</p>

<pre><code>htmldir=$(prefix)/html  
</code></pre>

<p>html 目录就会处于 prefix 之下。在 makefile.am 定义要安装的文件，如下：</p>

<pre><code>html_DATA=usermanual.html  
</code></pre>

<p>除了标准目录,automake 还为个别包定义了目录：pkglibdir、pkgincludedir 和 pkgdatadir，可以用它们将你的文件安装到标准的bin、lib或data目录下的独立子目录。这些安装目录会用包的名字命名。</p>

<p>并不是所有文件都要被最终安装。例如，图标（或图标），它们被编译到可执行文件后就不再需要了。但它们并不是真正的源文件。由于它们必须包含在最终的发布中，所有要把它们作为EXTRA_dist文件列出了。</p>

<h3 id="5-4-新建configure-ac">5.4. 新建configure.ac</h3>

<p>注意：在比较早的 automake 和 autoconf 版本中，configure.ac 被叫做 configure.in。autoscan 工具会扫描你的源代码，然后创建一个默认的 configure.ac 初始文件。因此，你可以在源代码的顶层目录执行 autoscan，生成一个 configure.scan 文件作为 configure.ac 的模板。</p>

<pre><code>autoscan  
</code></pre>

<p>autoscan的执行结果大概是这样：</p>

<pre><code>#         -*- Autoconf -*-   
# Process this file with autoconf to produce a configure script.   
AC_PREREQ(2.59)   
AC_INIT(FULL-PACKAGE-NAME, VERSION, BUG-REPORT-ADDRESS)   
AC_CONFIG_SRCDIR([config.h.in])   
AC_CONFIG_HEADER([config.h])   
# Checks for programs.   
AC_PROG_CXX   
AC_PROG_CC   
AC_PROG_CPP   
AC_PROG_INSTALL   
AC_PROG_LN_S   
AC_PROG_MAKE_SET   
AC_PROG_RANLIB   
# Checks for libraries.   
# Checks for header files.   
# Checks for typedefs, structures, and compiler characteristics.   
AC_HEADER_STDBOOL   
AC_C_CONST   
# Checks for library functions.   
AC_CONFIG_FILES([Makefile 
                        src/Makefile])   
AC_OUTPUT 
</code></pre>

<p>编辑 configure.scan 文件，修改下面这几行：</p>

<pre><code>AC_INIT(FULL-PACKAGE-NAME, VERSION, BUG-REPORT-ADDRESS)  
</code></pre>

<p>用你的应用的名字替换 FULL-PACKAGE-NAME ，VERSION 就是它的版本号。BUG-REPORT-ADDRESS 应该设一个 Email 地址，以便报告 Bug。例如：</p>

<pre><code>AC_INIT(myapplication,1.0)  
</code></pre>

<p>接下来添加一行，来调用 automake。</p>

<pre><code>AM_INIT_AUTOMAKE(@PACKAGE_NAME@, @PACKAGE_VERSION@)  
</code></pre>

<p>这一行使用 PACKAGE_NAME 和 PACKAGE_VERSION变量，它们都是 AC_INIT 中定义过的，最终会传递给 automake。@ 表示它包含字符串的是一个变量标识符。没有用 @ 的字符串直接按字面传递，结果包含在 PACKAGE_NAME_PACKAGE_VERSION 。</p>

<p>AC_CONFIG_SRCDIR 用于检测源代码目录下的 config.h 文件。AC_CONFIG_HEADER 表示你想要使用一个配置头文件。</p>

<p>下面的宏用于检测构建应用所需的各种程序，把你需要用在目标系统上的程序都添加到这里。</p>

<p>在 typedefs 这一组，你可以检测目标机器上的系统的特殊属性。AC_HEADER_STDBOOL 是 autoscan 为本例添加的，用于检测 stdbool.h 的可用性和 C99 的 bool 类型是否存在。AC_C_CONST 用于检测例程所需的常量机制。</p>

<p>最后，你可以在 AC_CONFIG_FILES 中指定所有你想要配置生成的 makefile 文件，这些文件将由 AC_OUTPUT 输出，通常将它卸载文件的最后一行。</p>

<h3 id="5-5-新建config-h-in">5.5. 新建config.h.in</h3>

<p>运行 autoheader 可以根据 configure.ac 文件创建一个 config.h.in。如果你想要指定 config.h 中包含 #define，必须在 configure.ac 中定义。查看 autoconf 文档中的 AC_CONFIG_HEADER。</p>

<pre><code>autoheader  
</code></pre>

<p>这样就会建立 config.h 文件，文件的内容是用预处理描述应用程序的代码。下面这段文本是例程的 config.h.in 文件的一部分。</p>

<pre><code>/* config.h.in.  Generated from configure.in by autoheader.  */   
* Define to 1 if stdbool.h conforms to C99. */   
#undef HAVE_STDBOOL_H   
/* Define to 1 if the system has the type `_Bool'. */   
#undef HAVE__BOOL   
/* Name of package */   
#undef PACKAGE   
/* Define to the address where bug reports for this package should be   
sent. */   
#undef PACKAGE_BUGREPORT   
/* Define to the full name of this package. */   
#undef PACKAGE_NAME   
/* Define to the full name and version of this package. */   
#undef PACKAGE_STRING   
/* Define to the one symbol short name of this package. */   
#undef PACKAGE_TARNAME   
/* Define to the version of this package. */   
#undef PACKAGE_VERSION   
/* Define to 1 if you have the ANSI C header files. */   
#undef STDC_HEADERS   
/* Version number of package */   
#undef VERSION   
/* Define to empty if `const' does not conform to ANSI C. */   
#undef const   
</code></pre>

<h3 id="5-6-新建aclocal-m4">5.6. 新建aclocal.m4</h3>

<p>很幸运有一个程序可以完成这个工作。只需执行：</p>

<pre><code>aclocal  
</code></pre>

<p>这样就创建了 aclocal.m4 文件。文件中包含了 autoconf 的宏，它们可以用在你的机器上。文件包含了宏的完整源代码，所以很长。如果没有在你的机器上找到所有的宏，可以尝试从 autoconf 的宏档案（www.gnu.org/software/ac-archive）中找一找。这里有很多宏，可以解决你遇到的大部分问题。另外，还有 BNV_HVE_QT 用于检测 Qt 库，MDL_HAVE_OPENGL 用于检测 OpenGL。</p>

<p>如果没有找到你所需的宏，就不得不自己去写了。“Goat book”（1）会告诉你怎么做。</p>

<h3 id="5-7-新建configure">5.7. 新建configure</h3>

<p>现在，autoconf 就可以用 autoconfig.ac 和 aclocal.m4 创建一个配置脚本了。只需运行：</p>

<pre><code>autoconf  
</code></pre>

<p>这样会产生一个配置脚本，对于一个GUI应用，可能超过2000行。</p>

<h3 id="5-8-新建makefile-in">5.8. 新建makefile.in</h3>

<p>makefile.in 包含很多从 makefile.am 自动添加的信息。makefile.in 是配置脚本最终创建 Makefile 所必须的。很幸运的是，automake 程序可以为你完成这个工作。可是，一些应用程序发布包所必须的文件还没有添加到应用的顶层目录。如果你运行下面的命令，automake 将从GNU工具中拷贝这些文件，然后创建 makefile.in：</p>

<pre><code>automake  -a  
</code></pre>

<p>或</p>

<pre><code>automake --add-missing  
</code></pre>

<h3 id="5-9-测试包">5.9. 测试包</h3>

<p>现在，配置脚本已经准备好了，可以在任何 GNU 支持系统上创建 Makefile。configure 接受很多命令行参数。运行 ./configure 可以得到一个概述。最重要的参数可能是 &ndash;enable-FEATURE ，这里的 FEATURE 有很多选择。对于程序开发而言，经常要用到 &ndash;enabl-debug=full 来选择调试。对于用户，&ndash;prefix 和 &ndash;with-LIBRARY-dir 可以控制很多安装路径。先试一下不用任何参数运行 configure。会在源码的顶层目录产生一个 Makefile ，prefix 设为 /usr/local。只需键入：</p>

<pre><code>./configure  
</code></pre>

<p>你将看到很多 check&hellip; 信息，最后结束时会出现在类似下面的信息：</p>

<pre><code>configure: creating ./config.status   
config.status: creating makefile   
config.status: creating config.h   
config.status: config.h is unchanged   
config.status: executing depfiles commands   
</code></pre>

<p>然后，测试一下新的 makefile：</p>

<pre><code>make  
</code></pre>

<p>应该会没有任何错误的编译应用。注意，不要用 root 用户运行 make install，否则会将程序安装到默认的 prefix 下，那很可能是一个错误的地址。运行如下命令就能将应用安装到默认的 prefix：</p>

<pre><code>make install  
</code></pre>

<p>只要你不是 root，将看到很多错误信息，这是因为没有写的权限。用普通用户运行 make install 的话，对于寻找安装的文件会很有用。</p>

<p>你的 Makefile 支持所有的标准的目标，例如 clean、dist、uninstall 等等。
要得到一个程序的开发版本，需要重新运行 configure，生成一个支持调试的 makefile。</p>

<pre><code>./configure  --enable-debug=full  
</code></pre>

<p>然后运行：</p>

<pre><code>make  
</code></pre>

<p>这样，编译的程序就包含了调试信息。因此，可执行文件也会比之前编译的大很多。现在你就可以在调试器中运行你的程序了。</p>

<h2 id="6-比较复杂的应用">6. 比较复杂的应用</h2>

<h3 id="6-1-带有子目录的应用">6.1. 带有子目录的应用</h3>

<p>你需要在顶层目录（myapplication）和每个子目录（src、doc、img）都有一个makefile.am。像myapplication/CVS这样的子目录不算发布包的一部分，必须跳过。相应目录的直接子目录必须像下面这样在 makefile.am 中列出了：</p>

<pre><code>SUBDIRS = subdir1  subdir2  subdir3  
</code></pre>

<p>不需要在SUBDIRS中指定子目录下的目录。每个子目录下的makefile.am只需指定本目录下的直接子目录。</p>

<p>例如，顶层目录是myapplication，CVS子目录用于管理CVS，src是源码，doc是文档，img是图片，myapplication 目录下的顶级 makefile.am 就应该是这样：</p>

<pre><code>##Process this file with automake to create Makefile.in  
SUBDIRS = src doc img  
</code></pre>

<p>提供一个好主意，为大多数 autoXXX 工具创建和使用的文件使用用一个叫做 admin 的单独目录。这会使顶层目录更具可读性。你要做的就是在AC_INIT后面直接添加：</p>

<pre><code>AC_CONFIG_AUX_DIR(admin)  
</code></pre>

<p>然后在手动创建一个 admin 目录，它就可以被 automake 使用了。</p>

<pre><code>mkdir admin  
</code></pre>

<p>源文件通常被列在 myapplication_SOURCES 列表。但是，这次的源文件在 src 目录下，所以要把它们列在 myapplication/src/makefile.am 文件中。二进制文件列表 bin_PROGRAMS 也在这个文件中指定。如下：</p>

<pre><code>##Process this file with automake to create Makefile.in  
bin_PROGRAMS = myapplication  
myapplication_SOURCES = main.c  
</code></pre>

<p>对于其他的非源代码文件，如果想将它们包含在发布包中，就必须作为 EXTRA_DIST 文件列出。如果 doc 目录中包含一个 index.html 文件，你必须将它添加到 myapplication/doc/makefile.am 文件的 EXTRA_DIST 列表中：</p>

<pre><code>##Process this file with automake to create Makefile.in  
EXTRA_DIST = index.html page1.html  
</code></pre>

<p>下面是 myapplication/img 目录下的 makefile.am 文件：</p>

<pre><code>##Process this file with automake to create Makefile.in  
EXTRA_DIST = image1.png image2.bmp  
</code></pre>

<p>运行 autoscan，并按照3.3节描述的那样编辑 configure.scan 文件。在文件末尾的 AC_CONFIG_FILES 宏中为每个要包含在发布包的子目录列一个 makefile 文件。在顶层目录（myapplication）下运行：</p>

<pre><code>aclocal  
autoconf  
autoheader  
automake -a  
</code></pre>

<p>那么，automake 将为每个 makefile.in 创建一个 makefile.am。</p>

<h3 id="6-2-库的应用">6.2. 库的应用</h3>

<p>####6.2.1. 静态库</p>

<p>静态库的构建很像应用，可是，目标要用 _LIBRARIES 变量指定。mylib 库可以用下面的这些方式指定：</p>

<ul>
<li><p>如果它要被安装在全局库目录下（默认：/usr/lib）：</p>

<pre><code>lib_LIBRARIES = mylib.a  
</code></pre></li>

<li><p>如果它要被安装在应用的lib目录下（默认：/usr/myapplication/lib）：</p>

<pre><code>pkglib_LIBRARIES = mylib.a  
</code></pre></li>

<li><p>如果它只是在构建的过程中使用，不需要安装：</p>

<pre><code>[python] view plaincopy
noinst_LIBRARIES = mylib.a  
</code></pre></li>
</ul>

<p>####6.2.2. 共享库</p>

<p>构建共享库是一个比较复杂的问题，你最好参考一下 automake 和 libtool 的文档。这里介绍一种简单情况下工作方式：对于用 libtool 构建的库使用 _LTLIBRARIES 宏。库的名字要以 lib 开头并以 .la 结尾（例如libmylib.la）。使用 _SOURCES宏 时，la 前面的点(.)必须用下划线(_)代替。对于要安装到 lib 目录下的 mylib 库来说，它的宏可以这样写：</p>

<pre><code>lib_LTLIBRARIES = libmylib.la  
libmylib_la_SOURCES = mylib.c  
</code></pre>

<p>在 configure.ac 文件中的 AC_PROG_CC 后面添加 AC_PROG_LIBTOOL 宏。这样的话，autoconf 就会为 configure 脚本增加 libtool 支持。</p>

<p>运行 automake 之前，先运行 libtoolize，会添加一些 automake 所需的文件。</p>

<h2 id="7-参考文献">7. 参考文献</h2>

<ol>
<li>Gary Vaughan, Ben Elliston, Tom Tromey, Ian Taylor: “GNU Autoconf, Automake and Libtool”, New Riders Publishing, 2000, also available online at <a href="http://www.gnu.org" target="_blank">http://www.gnu.org</a></li>
<li>GNU Automake:<a href="http://www.gnu.org/software/automake/manual/automake.html" target="_blank">http://www.gnu.org/software/automake/manual/automake.html</a></li>
<li>GNU Autoconf:<a href="http://www.gnu.org/software/autoconf/manual/autoconf-2.57/autoconf.html" target="_blank">http://www.gnu.org/software/autoconf/manual/autoconf-2.57/autoconf.html</a></li>
<li>Libtool</li>
<li>The GNU Coding Standards:<a href="http://www.gnu.org/prep/standards/standards.html&gt;" target="_blank">http://www.gnu.org/prep/standards/standards.html&gt;</a></li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>pkg-config指南</title>
            <link>https://shaocheng.li/posts/2011/11/19/</link>
            <pubDate>Sat, 19 Nov 2011 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2011/11/19/</guid>
            <description>原文：
Guide for pkg-config:http://people.freedesktop.org/~dbn/pkg-config-guide.html
Dan Nicholson
Translated By Bob
2011-11-13
Email:gexbob@gmail.com
Blog:http://shaocheng.li
概述 这个文档的目的是从用户和开发者的角度给一个 pkg-config 工具的使用概述。本文复习一些 pkg-config 背后的概念，怎样写 pkg-config 文件来支持你的项目，以及怎样用 pkg-config 集成第三方项目。
关于 pkg-config 的更多信息可以在 web 站点和 pkg-config 的 man 手册中找到。
本文档假的 pkg-config 在类UNIX操作系统中使用，例如 Linux。其他平台可能在一些细节上的存在差别。
为什么？ 现代计算机系统使用了很多分层组件为用户提供应用。其中一个困难就是如何正确的整合这些组件。pkg-config 会收集系统中安装的库的数据，然后提供给用户。
如果没有 pkg-config 这样的数据系统，定位计算机提供的服务和获取它们的细节会很困难。对于开发者，安装软件包的 pkg-config 文件极大的简化了对 API 的获取。
一些概念 使用 pkg-config 的初级阶段是为编译和链接程序时提供必要的细节。数据存储在 pkg-config 文件中。这些文件有一个 .pc 的后缀，放在一个特定的、pkg-config 工具所知道的位置。我们会在后面描述更多的细节。
这个文件的格式包括预定义的关键字和自由形式的变量。例如：
prefix=/usr/local exec_prefix=${prefix} includedir=${prefix}/include libdir=${exec_prefix}/lib Name: foo Description: The foo library Version: 1.0.0 Cflags: -I${includedir}/foo Libs: -L${libdir} -lfoo  以预定义关键字 Name：为例，以关键字开头，后面跟一个冒号和一个值。变量是一个字符串和一个值，例如 prefix= ，用等号分开。关键字是由 pkg-config 定义和输出的。变量不是必须的，但可以被关键字用来定位和存储 pkg-config 没有覆盖的数据。</description>
            <content type="html"><![CDATA[

<p>原文：</p>

<p>Guide for pkg-config:<a href="http://people.freedesktop.org/~dbn/pkg-config-guide.html" target="_blank">http://people.freedesktop.org/~dbn/pkg-config-guide.html</a></p>

<p>Dan Nicholson</p>

<p>Translated By Bob</p>

<p>2011-11-13</p>

<p>Email:<a href="mailto:gexbob@gmail.com" target="_blank">gexbob@gmail.com</a></p>

<p>Blog:<a href="http://shaocheng.li" target="_blank">http://shaocheng.li</a></p>

<hr />

<h2 id="概述">概述</h2>

<p>这个文档的目的是从用户和开发者的角度给一个 pkg-config 工具的使用概述。本文复习一些 pkg-config 背后的概念，怎样写 pkg-config 文件来支持你的项目，以及怎样用 pkg-config 集成第三方项目。</p>

<p>关于 pkg-config 的更多信息可以在 web 站点和 pkg-config 的 man 手册中找到。</p>

<p>本文档假的 pkg-config 在类UNIX操作系统中使用，例如 Linux。其他平台可能在一些细节上的存在差别。</p>

<h2 id="为什么">为什么？</h2>

<p>现代计算机系统使用了很多分层组件为用户提供应用。其中一个困难就是如何正确的整合这些组件。pkg-config 会收集系统中安装的库的数据，然后提供给用户。</p>

<p>如果没有 pkg-config 这样的数据系统，定位计算机提供的服务和获取它们的细节会很困难。对于开发者，安装软件包的 pkg-config 文件极大的简化了对 API 的获取。</p>

<h2 id="一些概念">一些概念</h2>

<p>使用 pkg-config 的初级阶段是为编译和链接程序时提供必要的细节。数据存储在 pkg-config 文件中。这些文件有一个 .pc 的后缀，放在一个特定的、pkg-config 工具所知道的位置。我们会在后面描述更多的细节。</p>

<p>这个文件的格式包括预定义的关键字和自由形式的变量。例如：</p>

<pre><code>prefix=/usr/local  
exec_prefix=${prefix}  
includedir=${prefix}/include  
libdir=${exec_prefix}/lib  
Name: foo  
Description: The foo library  
Version: 1.0.0  
Cflags: -I${includedir}/foo  
Libs: -L${libdir} -lfoo  
</code></pre>

<p>以预定义关键字 Name：为例，以关键字开头，后面跟一个冒号和一个值。变量是一个字符串和一个值，例如 prefix= ，用等号分开。关键字是由 pkg-config 定义和输出的。变量不是必须的，但可以被关键字用来定位和存储 pkg-config 没有覆盖的数据。</p>

<p>这里只是简单的描述一下关键字。更深入的描述和怎样有效的使用它们将在“写pkg-config文件”段中给出。</p>

<p><strong>Name：</strong>一个人们可读的链接库或软件包的名称，这不影响pkg-config的使用，它用的是.pc文件的名称。</p>

<p><strong>Description：</strong>关于软件包的简单描述。</p>

<p><strong>URL：</strong>一个URL，可以在那里获得更多的信息，并且下载这个软件包。</p>

<p><strong>Version：</strong>软件包的版本。</p>

<p><strong>Requires：</strong>这个软件包所需的包的列表。这些包的版本可能用一写运算符来指定：=、&gt;、&lt;、&gt;=、&lt;=。</p>

<p><strong>Requires.private：</strong>这个软件包所需的私有包的列表，不会暴露给应用。版本的指定规则与Requires相同。</p>

<p><strong>Conflicts：</strong>可选，描述了会与这个软件包产生冲突的包。版本的指定规则与Requires相同。这个域会提供同一个包的多个实例，例如：Conflicts: bar &lt; 1.2.3, bar &gt;= 1.3.0。</p>

<p><strong>Cflags：</strong>为这个软件包指定编译器选项，以及pkg-config不支持的必要的库。如果所需的库支持pkg-config，应该将它们添加到Requires和Requires.private。</p>

<p><strong>Libs：</strong>为这个软件包指定的链接选项，以及pkg-config不支持的必要的库。与Cflags的规则相同。</p>

<p><strong>Libs.private：</strong>这个软件包所需的私有库的链接选项，不会暴露给应用。规则与Cflags相同。</p>

<h2 id="写pkg-config文件">写pkg-config文件</h2>

<p>为一个软件包创建 pkg-config 时，首先要确定怎样描述它。一个文件最好只用于描述一个库，所以，每个软件包至少需要像它所需的链接库那么多的 pkg-config 文件。</p>

<p>软件包的名字是由 pkg-config 数据文件的名字确定的。就是文件名去掉 .pc 后缀的那一部分。通常都用库的名字命名 .pc 文件。例如，一个安装 libfoo.so 的包会有一个相应的 libfoo.c 文件来包含 pkg-config 数据。这不是必须的，.pc 文件仅仅是一个对你的库的唯一标识符。所以，foo.pc 或 foolib.pc 也能正常工作。</p>

<p>Name、Description 和 URL 的值是纯粹的信息，容易填写。Version 比较棘手，它要确保这个包可以被用户使用。pkg-config 使用 RPM 算法来进行版本比较。Version 最好是用点分开的十进制数字，例如 1.2.3，因为字母可能引起意外的结果。数字应该是单调递增的，并且要竟可能具体的描述这个库。通常使用包的版本号即可，这样可以方便使用者跟踪。</p>

<p>在描述更多的有用的关键字之前，有必要展示一下变量的定义。最常见的用法是定义安装路径，这样就不会使其他字段显得杂乱。因为变量是扩大递归的，在结合 autoconf 派生路径时，这会很有用。</p>

<pre><code>prefix=/usr/local  
includedir=${prefix}/include  
Cflags: -I${includedir}/foo  
</code></pre>

<p>最重要的 pkg-config 数据字段是 Requires，Requires.private，Cflags，Libs 和 Libs.private 。它们定义的数据被外部项目用来编译和链接库。</p>

<p>Requires 和 Requires.private 定义了库所需的其他模块。通常首选 Requires.private，以便避免程序链接到一些不必要的库。如果一个程序不使用所需库的符号，它就不应该直接链接到这个库。可以在 overlinking 的讨论中看到更多详细的解释。</p>

<p>由于 pkg-config 通常会公开 Requires 库的链接标识，这些模块会变成程序的直接依赖。另外，Requires.private 中的库只有在静态链接是才会被包含。正因如此，pkg-config 通常只会适当的从 Requires 中的同一个包中添加模块。</p>

<p>Libs 包含了使用库是所必须的链接标识。此外，Libs 和 Libs.private 还包含了 pkg-config 不支持的库的链接标识。与 Requires 类似，首选将外部库的链接标识添加到 Libs.private，这样，程序就不会获得额外的直接依赖。</p>

<p>最后，Cflags 包含了所用的库的编译标识。与 Libs 不同，Cflags 没有私有变种。这是因为，数据类型和宏定义在任何链接情况下都是需要的。</p>

<h2 id="使用pkg-config文件">使用pkg-config文件</h2>

<p>假设系统中已经安装了 .pc 文件，pkg-config 工具就被用来提取其中的数据。执行 pkg-config &ndash;help 命令可以看到一些关于命令选项的简单描述。深入的描述可以在 pkg-config（1）的 man 手册页中找到。本地将对一些常见的用法进行简单的描述。</p>

<p>假设系统中已经有了两个模块：foo和bar。它们的.pc文件可能像下面这样：</p>

<pre><code>foo.pc:  
prefix=/usr  
exec_prefix=${prefix}  
includedir=${prefix}/include  
libdir=${exec_prefix}/lib  
Name: foo  
Description: The foo library  
Version: 1.0.0  
Cflags: -I${includedir}/foo  
Libs: -L${libdir} -lfoo  
bar.pc:  
prefix=/usr  
exec_prefix=${prefix}  
includedir=${prefix}/include  
libdir=${exec_prefix}/lib  
Name: bar  
Description: The bar library  
Version: 2.1.2  
Requires.private: foo &gt;= 0.7  
Cflags: -I${includedir}  
Libs: -L${libdir} -lbar  
</code></pre>

<p>模块的版本可以用 &ndash;modversion 选项获得。</p>

<pre><code>$ pkg-config --modversion foo  
1.0.0  
$ pkg-config --modversion bar  
2.1.2  
</code></pre>

<p>要打印模块的链接标识，就用 &ndash;libs 选项。</p>

<pre><code>$ pkg-config --libs foo  
-lfoo  
$ pkg-config --libs bar  
-lbar  
</code></pre>

<p>请注意，pkg-config 压缩了两个模块 Libs 字段。这是因为 pkg-config 对 -L 标识有特殊处理，它知道 ${libdir} 目录 /usr/lib 是系统链接器搜素路径的一部分。也就是 pkg-config 受到了链接器选项的影响。</p>

<p>还有就是，虽然 foo 是 bar 所需要的，但是没有输出 foo 的链接标识。这是因为，只使用 bar 库的应用并不直接需要 foo。对应静态链接 bar 的应用，我们需要两个链接标识:</p>

<pre><code>$ pkg-config --libs --static bar  
-lbar -lfoo  
</code></pre>

<p>这种情况下，pkg-config就要输出两个链接标识，这样才能保证静态链接的应用可以找到所有必须的符号。另一方面，它会输出所有的Cflags字段。</p>

<pre><code>$ pkg-config --cflags bar  
-I/usr/include/foo    
$ pkg-config --cflags --static bar  
-I/usr/include/foo  
</code></pre>

<p>还有一个有用的选项，&ndash;exists，可以用来测试模块的可用性。</p>

<pre><code>$ pkg-config --exists foo  
$ echo $?  
0  
</code></pre>

<p>最值得注意的 pkg-config 特性是它所提供的版本检测，可以用来确定某个版本是否可用。</p>

<pre><code>$ pkg-config --exists foo  
$ echo $?  
0  
</code></pre>

<p>有些命令在结合 &ndash;print-errors 选项使用时可以输出更详细的信息。</p>

<pre><code>$ pkg-config --exists --print-errors xoxo  
Package xoxo was not found in the pkg-config search path.  
Perhaps you should add the directory containing `xoxo.pc'  
to the PKG_CONFIG_PATH environment variable  
No package 'xoxo' found  
</code></pre>

<p>上面的信息出现了 PKG_CONFIG_PATH 环境变量。这个变量用来配置 pkg-config 的搜索路径。在类 Unix 操作系统中，会搜索 /usr/lib/pkconfig 和 /usr/share/pkgconfig 目录。这通常已经覆盖了系统已经安装的模块。但是，有些本地模块可能安装在了其他路径，例如 /usr/local 。这种情况下，需要指定搜索路径，以便 pkg-config 可以定位 .pc 文件。</p>

<pre><code>$ pkg-config --modversion hello  
Package hello was not found in the pkg-config search path.  
Perhaps you should add the directory containing `hello.pc'  
to the PKG_CONFIG_PATH environment variable  
No package 'hello' found  
$ export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig  
$ pkg-config --modversion hello  
1.0.0  
</code></pre>

<p>autoconf也提供了一些宏，可以将pkg-config集成到项目中。</p>

<ul>
<li>PKG_PROG_PKG_CONFIG([MIN-VERSION])：定位系统中的 pkg-config 工具，并检测版本兼容性。</li>
<li>PKG_CHECK_EXISTS(MODULES,[ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])：检测指定的模块是否存在。</li>
<li>PKG_CHECK_MODULES(VARIABLE-PREFIX,MODULES, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND]):：检测指定的模块是否存在，如果存在，就根据 pkg-config &ndash;cflags 和 pkg-config &ndash;libs 的输出设置 &lt;VARIABLE-PREFIX&gt;_CFLAGS and &lt;VARIABLE-PREFIX&gt;_LIBS。</li>
</ul>

<h2 id="常见问题">常见问题</h2>

<ol>
<li><p>我的程序使用了x库，我该怎么做？
pkg-config 的输出可以在编译命令中使用，假设 x 库已经有了一个叫做 x.pc 的 pkg-config 文件：</p>

<pre><code>cc `pkg-config --cflags --libs x` -o myapp myapp.c  
</code></pre>

<p>将 pkg-config 集成到 autoconf 和 automake 中使用会更强大。但是，用 PKG_CONFIG_PATH 宏可以很容易的在建立过程中访问元数据。</p>

<pre><code>configure.ac:  
PKG_CHECK_MODULES(\[X], [x])  
Makefile.am:  
myapp_CFLAGS = $(X_CFLAGS)  
myapp_LDADD = $(X_LIBS)  
</code></pre>

<p>如果找到了 x 模块，宏会填充和替代 X_CFLAGS和X_LIBS变量。如果没有找到，会产生错误。配置 PKG_CHECK_MODULES 的第3、4个参数，可以控制没有找到模块时的动作。</p></li>

<li><p>我的 z 库安装了保护 libx 头的头文件。我应该在 z.pc 中添加什么？</p>

<p>如果 x 库支持 pkg-config，将它添加到 Requires.private 字段。如果不支持，就配置 Cflags 字段，添加一些使用 libx 头时所需的编译器标识。在这两种情况下，无论是否使用了&ndash;static，pkg-config 都会输出编译器标识。</p></li>

<li><p>我的 z 库内部使用了 libx，但是不能再公开 API 中暴露libx的数据类型。我应该在 z.pc 中添加什么？</p>

<p>同样的，如果 x 支持 pkg-config，就把它添加到 Requires.private 。这种情况下，就没必要发出编译器标识，但是在今天链接时要确保有链接器标识。如果 libx 不支持pkg-config ，就将必要的链接器标识添加到 Libs.private。</p></li>
</ol>

<hr />

<p>Dan Nicholson &lt;dbn.lists (at) gmail (dot) com&gt;</p>

<p>Copyright &copy; 2010 Dan Nicholson.</p>

<p>This document is licensed under the GNU General Public License, Version 2 or any later version.</p>
]]></content>
        </item>
        
        <item>
            <title>在Redhat9下构建TinyX&#43;GTK图形环境</title>
            <link>https://shaocheng.li/posts/2011/11/15/</link>
            <pubDate>Tue, 15 Nov 2011 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2011/11/15/</guid>
            <description>&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;最近要将 Redhat9.02 移植到一块嵌入式 586 的主板上，空间有限，还要有图形环境，支持中文。所以，要建立一个精简的图像环境，先选择 TinyX+GTK 的方式进行研究。TinyX 是 XFree86 针对嵌入式的编译选项，体积小，启动速度快。
本文使用虚拟机 vmware 安装 Redhat-9.02 文本系统，然后用 XFree86-4.3.0 编译 TinyX ，最后编译 GTK+-2.0。&lt;/p&gt;</description>
            <content type="html"><![CDATA[<h2 id="概述">概述</h2>

<p>最近要将 Redhat9.02 移植到一块嵌入式 586 的主板上，空间有限，还要有图形环境，支持中文。所以，要建立一个精简的图像环境，先选择 TinyX+GTK 的方式进行研究。TinyX 是 XFree86 针对嵌入式的编译选项，体积小，启动速度快。
本文使用虚拟机 vmware 安装 Redhat-9.02 文本系统，然后用 XFree86-4.3.0 编译 TinyX ，最后编译 GTK+-2.0。</p>

<h2 id="1-安装redhat-9-02">1. 安装Redhat-9.02</h2>

<p>在 vmware 上新建一个虚拟机，硬盘空间为 4GB，内存 512MB。开始安装 Redhat-9.02，选择 linux text 模式，中文安装语言，swap 分区为 512MB，其余空间都挂载到根目录下。bootloader 用 Grub，自定义安装软件包，选择的软件包如下：</p>

<pre><code>Administration tools
Development Tools
Editors
Ftp Server
Kernel Development
NetWork Server
Printing Support
Server Configuration Tools
Sound and Video
System Tool
</code></pre>

<p>选择系统支持的语言为 Chinese+English。</p>

<p>安装后将 /etc/sysconfig/ 下的 i18n 文件修改如下：</p>

<pre><code>LC_CTYPE=&quot;zh_CN.GB2312&quot;
SUPPORTED=&quot;zh_CN.GB2312:en_US.UTF-8:en_US:en&quot;
SYSFONT=&quot;latercyrheb-sun16&quot;
SYSFONTACM=&quot;iso01&quot;
</code></pre>

<h2 id="2-编译libpng-1-2-16">2. 编译libpng-1.2.16</h2>

<p>编译 TinyX 时需要 png.h 文件，所以要重新安装 libpng。先删除原有的 libpng：</p>

<pre><code>rm -rf /usr/lib/libpng*
</code></pre>

<p>下载 libpng-1.2.16.tar.bz2 ，复制到 /root 目录下解压：</p>

<pre><code>tar -xvjf  libpng-1.2.16.tar.bz2
</code></pre>

<p>源码包中的 README 和 INSTALL 文件有关于 libpng 的详细信息和编译安装方法，用如下命令编译安装：</p>

<pre><code>cd /root/libpng-1.2.16
./configure
make
make install
</code></pre>

<p>默认安装在 /usr/local/ 目录下，支持 pkg-config，pkg-config 文件放在 /usr/lib/pkg-config/ 目录下。如果想卸载 libpng，执行：make uninstall。</p>

<h2 id="3-编译freetype-2-2-1">3.编译freetype-2.2.1</h2>

<p>删除原有的 freetype：</p>

<pre><code>rm -rf /usr/lib/libfreetype*
</code></pre>

<p>下载 freetype-2.2.1.tar.gz：<a href="http://download.savannah.gnu.org/releases/freetype/" target="_blank">http://download.savannah.gnu.org/releases/freetype/</a></p>

<p>复制到 <code>/root/</code> 目录下解压：</p>

<pre><code>tar -xvzf  freetype-2.2.1.tar.gz
</code></pre>

<p>编译、安装：</p>

<pre><code>cd /root/freetype-2.2.1
./configure
make
make install
</code></pre>

<p>默认安装到 <code>/usr/local/</code> 目录下，支持 pkg-config。</p>

<h2 id="4-编译tinyx">4.编译TinyX</h2>

<p>先删除原系统的 X-window：</p>

<pre><code>rm -rf /usr/X11R6
rm -rf /etc/X11
</code></pre>

<p>下载XFree86-4.3.0：<a href="ftp://ftp.xfree86.org/pub/XFree86/4.3.0/，共下载7个软件包：" target="_blank">ftp://ftp.xfree86.org/pub/XFree86/4.3.0/，共下载7个软件包：</a></p>

<pre><code>X430src-1.tgz 
X430src-2.tgz
X430src-3.tgz
X430src-4.tgz 
X430src-5.tgz
X430src-6.tgz 
X430src-7.tgz
</code></pre>

<p>全部复制到 <code>/root</code> 下解压，解压后的源码都会放在 <code>/root/xc</code> 目录下。</p>

<p>先编译一个 lndir 工具：</p>

<pre><code>cd  /root/xc/config/util
make -f Makefile.ini lndir
cd ../../../
</code></pre>

<p>用 lndir 制作一个源文件的符号链接目录：</p>

<pre><code>mkdir build 
cd build
../xc/config/util/lndir  ../xc
</code></pre>

<p>用 TinyX.cf 的配置安装：</p>

<pre><code>cd config/cf
cp -arf TinyX.cf host.def
</code></pre>

<p>修改 host.def 为：</p>

<pre><code>#define KDriveXServer  YES  
#define TinyXServer    YES  
#define XfbdevServer   YES  
#define BuildLBX                YES  
#define BuildFonts              YES  
#define BuildAppgroup           NO  
#define BuildDBE                NO  
#define BuildXCSecurity         YES  
#define FontServerAccess        NO  
#undef BuildXF86RushExt  
#define BuildXF86RushExt        NO  
#undef BuildRender  
#define BuildRender             YES  
#define UseRgbTxt               YES  
#define BuildFontServer         NO  
</code></pre>

<p>然后：</p>

<pre><code>cd ../../
touch xf86Date.h
touch xf86Version.h
make World
make install
</code></pre>

<p>主要的库、头文件、可执行文件和配置文件等都安装了在 <code>/etc/X11</code> 和 <code>/usr/X11R6</code> 下。</p>

<p>TinyX 依赖于 framebuffer，要打开 framebuffer。修改 <code>/etc/grub.conf</code> 文件，在 <code>kernel</code> 一行添加：</p>

<pre><code>vga=0x311 fb：on
0x311为640x480，16bpp。
</code></pre>

<p>然后重启系统，启动时，屏幕左上方会出现一个企鹅 Logo。</p>

<p>重启后运行 /usr/X11R6/bin/Xfbdev，即可启动 Xserver，可以看到灰色背景上有一个 X 形的鼠标。
为 Xfbdev 建立一个符号链接：</p>

<pre><code>ln -s Xfbdev X
</code></pre>

<p>这样就可以用startx命令启动 X-window。用Ctrl+Alt+Backspace组合键退出X-window。</p>

<p>这里可能出现加载链接库的错误，查看 /etc/ld.so.conf 文件中是否有 /usr/X11R6/lib，然后执行 ldconfig -v。</p>

<h2 id="5-设置pkg-config">5.设置pkg-config</h2>

<p>在 /root/.bashrc 文件中添加 PKG_CONFIG_PATH 环境变量：</p>

<pre><code>export PKG\_CONFIG\_PATH=/usr/local/lib/pkgconfig:/usr/X11R6/lib/pkgconfig
</code></pre>

<h2 id="6-编译glib-2-0">6.编译Glib-2.0</h2>

<p>先删除原有的 glib：</p>

<pre><code>rm -rf /usr/lib/libglib*
rm -rf /usr/lib/libgmoudle*
rm -rf /usr/lib/libgobject*
rm -rf /usr/lib/gthread*
</code></pre>

<p>下载 glib-2.0.0.tar.bz2：<a href="http://ftp.gnome.org/pub/gnome/sources/glib/2.0/" target="_blank">http://ftp.gnome.org/pub/gnome/sources/glib/2.0/</a></p>

<p>复制到/root/目录下解压：</p>

<pre><code>tar -xvjf  glib-2.0.0.tar.bz2
</code></pre>

<p>编译、安装：</p>

<pre><code>cd /root/glib-2.0.0
./configure
make
make install
</code></pre>

<p>默认安装到/usr/local/目录下，支持pkg-config。</p>

<h2 id="7-编译atk-1-0-0">7.编译atk-1.0.0</h2>

<p>删除原有的 atk：</p>

<pre><code>rm -rf /usr/lib/libatk*
</code></pre>

<p>修改 /etc/ld.so.conf 文件，添加：</p>

<pre><code>/usr/local/lib
</code></pre>

<p>下载 atk-1.0.0.tar.bz2：<a href="http://ftp.gnome.org/pub/gnome/sources/atk/1.0/" target="_blank">http://ftp.gnome.org/pub/gnome/sources/atk/1.0/</a></p>

<p>复制到/root/目录下解压：</p>

<pre><code>tar -xvjf  atk-1.0.0.tar.bz2
</code></pre>

<p>编译、安装：</p>

<pre><code>cd /root/atk-1.0.0
./configure
make
make install
</code></pre>

<p>默认安装到 /usr/local/ 目录下，支持 pkg-config。</p>

<h2 id="8-编译pango-1-0-0">8.编译pango-1.0.0</h2>

<p>删除原有的pango：</p>

<pre><code>rm -rf /usr/lib/libpango*
rm -rf /usr/lib/pango
</code></pre>

<p>下载pango-1.0.0.tar.bz2：<a href="http://ftp.gnome.org/pub/gnome/sources/pango/1.0/" target="_blank">http://ftp.gnome.org/pub/gnome/sources/pango/1.0/</a></p>

<p>复制到 /root/ 目录下解压：</p>

<pre><code>tar -xvjf  pango-1.0.0.tar.bz2
</code></pre>

<p>编译、安装：</p>

<pre><code>cd  /root/pango-1.0.0
./configure
make
make install
</code></pre>

<p>默认安装到 /usr/local/ 目录下，支持 pkg-config。</p>

<h2 id="9-编译libjpeg-6b">9.编译libjpeg-6b</h2>

<p>删除原有的 libjpeg：</p>

<pre><code>rm -rf  /usr/lib/libjpeg*
</code></pre>

<p>下载libjpeg-6b.tar.gz：<a href="http://jaist.dl.sourceforge.net/project/cross-stuff/cross-stuff/1.0/libjpeg-6b.tar.gz" target="_blank">http://jaist.dl.sourceforge.net/project/cross-stuff/cross-stuff/1.0/libjpeg-6b.tar.gz</a></p>

<p>复制到 /root/ 目录下解压：</p>

<pre><code>tar -xvzf  libjpeg-6b.tar.gz
</code></pre>

<p>编译、安装：</p>

<pre><code>cd  /root/libjpeg-6b
./configure  --enable-shared
make
make install
</code></pre>

<p>默认安装到/usr/local/目录下。</p>

<h2 id="10-编译gtk-2-0">10.编译gtk+-2.0</h2>

<p>删除原有的gtk:</p>

<pre><code>rm -rf  /etc/gtk*
rm -rf  /etc/gnome
rm -rf  /usr/bin/*gtk*
rm -rf  /usr/lib/libgtk*
rm -rf  /usr/lib/gtk*
</code></pre>

<p>下载gtk+-2.0.0.tar.bz2：<a href="http://ftp.gnome.org/pub/gnome/sources/gtk+/2.0/" target="_blank">http://ftp.gnome.org/pub/gnome/sources/gtk+/2.0/</a></p>

<p>复制到/root/目录下解压：</p>

<pre><code>tar -xvjf  gtk+-2.0.0.tar.bz2
</code></pre>

<p>编译、安装：</p>

<pre><code>cd  /root/gtk+-2.0.0
./configure  --without-libtiff
make
make install
</code></pre>

<p>默认安装到/usr/local/目录下，支持pkg-config。</p>

<h2 id="11-测试">11.测试</h2>

<p>运行 startx，可以启动 X-window。
然后运行gtk-demo，可以启动 gtk-demo 程序。
编写 demo.c 文件：</p>

<pre><code>#include &lt;gtk/gtk.h&gt;  
char *_(char *c)  
{  
    return(g_locale_to_utf8(c,-1,0,0,0));  
}  
int  main(int argc,char *argv[])  
{  
    GtkWidget *window;  
    gtk_init(&amp;argc,&amp;argv);  
    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);  
    gtk_window_set_title(GTK_WINDOW(window),_(&quot;中文窗口&quot;));   //定义窗口的标题  
    gtk_window_set_default_size(GTK_WINDOW(window),200,200);   //设置窗口的大小  
    gtk_window_set_position(GTK_WINDOW(window),GTK_WIN_POS_MOUSE);   //设置窗口显示的位置为鼠标的位置  
    gtk_widget_show(window);  
    gtk_main();  
    return 1;  
}  
</code></pre>

<p>编译：</p>

<pre><code>gcc -Wall -o demo demo.c `pkg-config --cflags --libs gtk+-2.0` 
</code></pre>

<p>执行：</p>

<pre><code>./demo
</code></pre>

<p>效果：</p>

<p><img src="/images/2011-11-15/2011-11-15_1.JPG" alt="" /></p>]]></content>
        </item>
        
        <item>
            <title>从源码建立XFree86</title>
            <link>https://shaocheng.li/posts/2011/11/08/</link>
            <pubDate>Tue, 08 Nov 2011 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2011/11/08/</guid>
            <description>原文：
Building XFree86 from a Source Distribution
http://www.xfree86.org/4.3.0/BUILD.html
26 February 2003
Translated By Bob
Email：gexbob@gmail.com
Blog：http://shaocheng.li
这个文档描述了怎样从源代码发行版构建XFree86，要结合特定操作系统的README文件来使用它。
 注：构建XFree86之前，最好参考特定操作系统的README文件，这些文件包含了在你的操作系统下成功构建XFree86所需的详细信息。
 我们强烈推荐使用GCC构建XFree86，但是通常也可以使用各个平台的本地编译器。
1. 怎样得到XFree86 4.3.0 的源码 推荐的方法是从 XFree86 的 CVS 库中获取 XFree86 4.3.0 的源码。有多种途径可以做到这一点，可以在我们的 CVS 页面找到 xf-4.3.0 发行版的标签。
另一个途径是在 XFree86 的 FTP 站点下载 4.3.0 的 tar 格式源码包。步骤如下：
 XFree86 4.3.0的源码包含在 X430src-1.tgz, X430src-2.tgz, X430src-3.tgz, X430src-4.tgz,X430src-5.tgz, X430src-6.tgz 和 X430src-7.tgz 中。这些文件可以在 ftp://ftp.xfree86.org/pub/XFree86/4.3.0/source/ 或 XFree86 站点的类似地址中找到。X430src-4.tgz 和 X430src-5.tgz包含了字体，X430src-6.tgz 和 X430src-7.tgz 包含了文档。X430src-1.tgz, X430src-2.tgz 和 X430src-3.tgz 包含了其他所有的东西。如果你不需要字体和文档，可以只下载 X430src-1.</description>
            <content type="html"><![CDATA[

<p>原文：</p>

<p>Building XFree86 from a Source Distribution</p>

<p><a href="http://www.xfree86.org/4.3.0/BUILD.html" target="_blank">http://www.xfree86.org/4.3.0/BUILD.html</a></p>

<p>26 February 2003</p>

<p>Translated By Bob</p>

<p>Email：<a href="mailto:gexbob@gmail.com" target="_blank">gexbob@gmail.com</a></p>

<p>Blog：<a href="http://shaocheng.li" target="_blank">http://shaocheng.li</a></p>

<hr />

<p>这个文档描述了怎样从源代码发行版构建XFree86，要结合特定操作系统的README文件来使用它。</p>

<blockquote>
<p>注：构建XFree86之前，最好参考特定操作系统的README文件，这些文件包含了在你的操作系统下成功构建XFree86所需的详细信息。</p>
</blockquote>

<p>我们强烈推荐使用GCC构建XFree86，但是通常也可以使用各个平台的本地编译器。</p>

<hr />

<h2 id="1-怎样得到xfree86-4-3-0-的源码">1. 怎样得到XFree86 4.3.0 的源码</h2>

<p>推荐的方法是从 XFree86 的 CVS 库中获取 XFree86 4.3.0 的源码。有多种途径可以做到这一点，可以在我们的 CVS 页面找到 xf-4.3.0 发行版的标签。</p>

<p>另一个途径是在 XFree86 的 FTP 站点下载 4.3.0 的 tar 格式源码包。步骤如下：</p>

<ul>
<li><p>XFree86 4.3.0的源码包含在 X430src-1.tgz, X430src-2.tgz, X430src-3.tgz, X430src-4.tgz,X430src-5.tgz, X430src-6.tgz 和 X430src-7.tgz 中。这些文件可以在 <a href="ftp://ftp.xfree86.org/pub/XFree86/4.3.0/source/" target="_blank">ftp://ftp.xfree86.org/pub/XFree86/4.3.0/source/</a> 或 XFree86 站点的类似地址中找到。X430src-4.tgz 和 X430src-5.tgz包含了字体，X430src-6.tgz 和 X430src-7.tgz 包含了文档。X430src-1.tgz, X430src-2.tgz 和 X430src-3.tgz 包含了其他所有的东西。如果你不需要字体和文档，可以只下载 X430src-1.tgz, X430src-2.tgz 和 X430src-3.tgz。</p></li>

<li><p>运行下面的命令解压每个文件，确保足够的空间，全部源码大约需要305M，还要一些空间编译二进制文件。</p>

<pre><code>gzip -d &lt; X430src-1.tgz | tar vxf -
gzip -d &lt; X430src-2.tgz | tar vxf -
gzip -d &lt; X430src-3.tgz | tar vxf -
gzip -d &lt; X430src-4.tgz | tar vxf -
gzip -d &lt; X430src-5.tgz | tar vxf -
gzip -d &lt; X430src-6.tgz | tar vxf -
gzip -d &lt; X430src-7.tgz | tar vxf -
</code></pre></li>
</ul>

<p>如果你已经有了一份 XFree86 4.2.0 源码的拷贝，可以从 <a href="ftp://ftp.xfree86.org/pub/XFree86/4.3.0/patches/" target="_blank">ftp://ftp.xfree86.org/pub/XFree86/4.3.0/patches/</a> 下载补丁来升级到 4.3.0 。补丁的下载和使用信息可以在这个发行版的R EDAME 文件的 “How to get XFree86” 段找到。
所有的方法都将产生一个主源码目录，叫做 xc 。</p>

<h2 id="2-构建之前先配置源码">2. 构建之前先配置源码</h2>

<p>在大多数情况下，没有必要做任何配置。</p>

<p>如果你确实想要改变配置，建议你先进入 xc/config/cf 目录，复制 xf86site.def 为 host.def。然后通过阅读 host.def 文件，根据你的配置设置你想要的参数。你也可以通过查看 .cf 文件，找出针对你的操作系统的默认设置。</p>

<p>通常遵循的规则是，只修改你理解的选项，并且有好的修改原因。修改默认配置容易产生一些问题。很多配置选项记录在 xc/config/cf/README。</p>

<p>如果你只使用源代码的 x430src-1.tgz,x430src-2.tgz 和 x430src-3.tgx 部分，你需要定义 BuildFonts 为 NO。</p>

<h2 id="3-使用符号链接的目录来构建">3. 使用符号链接的目录来构建</h2>

<p>推荐的做法是，用一个符号链接的目录来构建 XFree86。这样可以保证源代码目录在构建过程中不被修改，还有以下好处：</p>

<ul>
<li>当使用 CVS 维护源码树的更新时，更新进程不会被非 CVS 控制的文件所干扰。</li>
<li>可以用同样的源码为不同的操作系统或架构构建 XFree86 ，用只读的 NFS 共享。</li>
<li>可以用不同的配置构建 XFree86，只需要在每一个构建树中放一个 host.def 的拷贝，并且分别定义。</li>
</ul>

<p>用下面步骤建立一个符号链接目录：</p>

<ul>
<li><p>在构建树的顶层创建目录，通常新建在xc目录的同层，但不是强制性的。</p>

<pre><code>cd [xc目录]
mkdir build
</code></pre></li>

<li><p>用“lndir”命令创建影子树：</p>

<pre><code>lndir ../xc
</code></pre>

<p>注：如果需要的话，最好使用xc目录的绝对路径。</p></li>
</ul>

<p>如果你的系统没有安装 lndir ，你可以用下面的命令从 XFree86 的源码安装它：</p>

<pre><code>cd xc/config/util
make -f Makefile.ini lndir
cp lndir [some directory in your PATH]
</code></pre>

<p>随着时间的推移，可能在构建树中产生一些陈旧的链接，例如，当源码中的文件被删除或重命名。可以在构建目录中运行“cleanlinks”脚本来清除。很少会因为一些变化而要从头开始重新创建构建树。如果有这样的情况，那可能是构建过程中问题。最好的方法是删除构建树，然后按上面的步骤重新构建。</p>

<h2 id="4-构建和安装">4. 构建和安装</h2>

<p>构建之前，读一下 xc/programs/Xserver/hw/xfree86/doc 中与你相关的特定操作系统的 README 。一旦特定操作系统的详情已经有了描述，就可以到你的构建目录（xc目录或之前建立的影子树），运行“make World”，如果有必要，就带上 README 中描述的 BOOTSTRAPCFLAGS 设置，但是 XFree86 支持大多数操作系统已经不需要 BOOTSTRAPCFLAGS。一个明智的做法是将 stdout 和 stderr 重定向到 World.log，以便追踪构建过程中可能产生的问题。</p>

<ul>
<li><p>在类 Bourne 的 shell(Bash,Korn shell,zsh,等)中使用如下的命令：</p>

<pre><code>make World &gt; World.log 2&gt;&amp;1
</code></pre></li>

<li><p>C-shell(csh,tcsh,等)中使用：</p>

<pre><code>make World &gt;&amp; World.log
</code></pre></li>
</ul>

<p>你可以根据构建的进展运行：</p>

<pre><code>tail -f World.log
</code></pre>

<p>构建完成后，如果有什么问题，你需要检查 World.log 文件。如果没有问题，你就可以安装二进制文件了。默认的“make World” 过程会忽略错误，以便尽可能的构建成功。如果在这一步中有无法解决的问题，安装过程将会失败。解决问题后重新开始构建时，只需要运行 “make” 。如果在解决问题的过程中改变了 Imakefile 或其它构建配置，需要重新运行 “make World” 或 “make Everything”。</p>

<p>如果你想要 “make World” 在第一个错误是结束，用下面的命令来替换前面所讲的:</p>

<ul>
<li><p>在类Bourne的shell中：</p>

<pre><code>make WORLDOPTS= World &gt; World.log 2&gt;&amp;1
</code></pre></li>

<li><p>在C-shell中：</p>

<pre><code>make WORLDOPTS= World &gt;&amp; World.log 
</code></pre></li>
</ul>

<p>对于安装，运行“make install”和“make install.man”。确保 /usr/X11R6 中有足够的空间用于安装。如果你想要安装在 /usr 之外的文件系统，需要在新建一个指向 /usr/X11R6 的符号连接。</p>

<h2 id="5-重新配置服务器">5. 重新配置服务器</h2>

<p>为服务器构建不同的设置，或带有不同驱动设置的服务器。</p>

<ol>
<li>确保新的驱动源码在正确的位置（例如，驱动源码应该在 xc/programs/Xserver/hw/xfree86/drivers 下的一个子目录）。</li>
<li>修改host.def（你要构建的服务器）中定义的服务器设置，也可以根据你的需要修改驱动列表。</li>

<li><p>在xc/programs/Xserver中运行：</p>

<pre><code>make Makefile
make Makefiles
make includes
make depend
make
</code></pre></li>
</ol>

<h2 id="6-其他有用的make目标">6. 其他有用的make目标</h2>

<p>下面是一些在 XFree86 的 Makefile 中定义的其他有用的目标：</p>

<ul>
<li><strong>Everything</strong>  make Worle之后，make Everything 会做任何 make World 可以做的，除了清理树。这是一个为源码打补丁后、快速重新构建树的方法。但它并不是100%可靠的。最好是用 make World 做一次完整的构建。</li>

<li><p><strong>clean</strong>       用于对源码树进行局部清理。删除目标文件和生成的手册页，但是保留 Makefile 和生成的依赖文件。执行 make clean 后，你需要重新运行以下命令来重新构建 XFree86 ：</p>

<pre><code>make include 
make depend
make
</code></pre></li>

<li><p><strong>disclean</strong>   对源码树进行完全清理，删除所有的生产文件。make disclean后，只能用make World重新构建XFree86。</p></li>

<li><p><strong>includes</strong>  生产所有的可生成头文件和构建所需的符号链接。make clean时，这些文件会被删除。</p></li>

<li><p><strong>depend</strong>   重新计算 Makefile 中各个目标的依赖关系。根据操作系统，依赖关系储存在 Makefile ，或一个独立的文件中，叫做 .depend。这目标需要用到 make includes 生产的头文件。VerifyOS  显示检测到的操作系统的版本。如版本号与你的系统不匹配，你可能要在 host.def 中设置并且向 <a href="mailto:XFree86@XFree86.org" target="_blank">XFree86@XFree86.org</a> 报告这个问题</p></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>不用任何变量，实现strlen函数</title>
            <link>https://shaocheng.li/posts/2011/10/18/</link>
            <pubDate>Tue, 18 Oct 2011 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2011/10/18/</guid>
            <description>使用递归：
int strlen(char * str) { if(*str) return strlen(str+1)+1; else return 0; }  </description>
            <content type="html"><![CDATA[<p>使用递归：</p>

<pre><code>int strlen(char * str)  
{  
     if(*str)            
          return strlen(str+1)+1;  
     else  
          return 0;  
}
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>Linux系统文本模式下的截屏</title>
            <link>https://shaocheng.li/posts/2011/07/29/</link>
            <pubDate>Fri, 29 Jul 2011 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2011/07/29/</guid>
            <description>Linux系统文本模式下截屏要用到/dev目录下的vcs设备：
ls /dev/vcs* /dev/vcs /dev/vcs1 /dev/vcs2 /dev/vcs3 /dev/vcs4 /dev/vcs5 /dev/vcs6  其中，/dev/vcs 是当前的虚拟控制台的内容，/dev/vcs1 是tty1的内容。
截取当前控制台的内容：
cat /dev/vcs &amp;gt; filename  得到的文件 filename 是一个文本文件，直接用编辑器即可查看。
如果要截取 tty1 的内容，就执行：
cat /dev/vcs1 &amp;gt; filename  </description>
            <content type="html"><![CDATA[<p>Linux系统文本模式下截屏要用到/dev目录下的vcs设备：</p>

<pre><code>ls  /dev/vcs*  
/dev/vcs  /dev/vcs1  /dev/vcs2  /dev/vcs3  /dev/vcs4  /dev/vcs5  /dev/vcs6   
</code></pre>

<p>其中，/dev/vcs 是当前的虚拟控制台的内容，/dev/vcs1 是tty1的内容。</p>

<p>截取当前控制台的内容：</p>

<pre><code>cat  /dev/vcs  &gt; filename  
</code></pre>

<p>得到的文件 filename 是一个文本文件，直接用编辑器即可查看。</p>

<p>如果要截取 tty1 的内容，就执行：</p>

<pre><code>cat  /dev/vcs1  &gt; filename
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>Linux下分割、合并文件——dd和cat</title>
            <link>https://shaocheng.li/posts/2011/07/26/</link>
            <pubDate>Tue, 26 Jul 2011 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2011/07/26/</guid>
            <description>dd的作用是转换和拷贝文件，我们可以利用它来分割文件，相关的选项如下：
 if=filename：输入的文件名
 of=finename：输出的文件名
 bs=bytes：一次读写的字节数，默认是512bytes
 skip=blocks:拷贝前，跳过的输入文件的前blocks块，块的大小有bs决定
 count=blocks：只拷贝输入文件的前blocks块
  例如，现在有一个文件file，大小为116616字节：
[root]# du -b file 116616 file  将其分割为两文件file1和file2，那我们就设置每块为1024字节，将file的前60块放入file1，余下的放入file2：
[root]# dd if=file bs=1024 count=60 skip=0 of=file1 [root]# dd if=file bs=1024 count=60 skip=60 of=file2  然后用cat将两个文件合并为file.bak，要注意文件的顺序：
[root]# cat file1 file2 &amp;gt; file.bak  可以用md5sum验证一下file和file.bak：
[root]# md5sum file 3ff53f7c30421ace632eefff36148a70 file [root]# md5sum file.bak 3ff53f7c30421ace632eefff36148a70 file.bak  可以证明两个文件时完全相同的。
为了方便分割、合并文件，我写了两个脚本：
ddf.sh
#ddf.sh：分割文件，分割后的文件以数字结尾，例如file分割为两个文件：file1和file2 #!/bin/sh #使用脚本是第一参数是要分割的文件名 Filename=$1 Filesize=0 Path=`pwd` #验证文件名是否正确，然后计算文件的大小 if [ -z $Filename ];then echo &amp;quot;Error:The file name can not be empty&amp;quot; exit fi if [ -e $Filename ];then Filesize=`du -b $Filename | awk &#39;{print $1}&#39;` if [ $Filesize == 0 ];then echo &amp;quot;Error:The File size is zero!</description>
            <content type="html"><![CDATA[<p>dd的作用是转换和拷贝文件，我们可以利用它来分割文件，相关的选项如下：</p>

<ul>
<li><p>if=filename：输入的文件名</p></li>

<li><p>of=finename：输出的文件名</p></li>

<li><p>bs=bytes：一次读写的字节数，默认是512bytes</p></li>

<li><p>skip=blocks:拷贝前，跳过的输入文件的前blocks块，块的大小有bs决定</p></li>

<li><p>count=blocks：只拷贝输入文件的前blocks块</p></li>
</ul>

<p>例如，现在有一个文件file，大小为116616字节：</p>

<pre><code>[root]# du -b file  
116616  file  
</code></pre>

<p>将其分割为两文件file1和file2，那我们就设置每块为1024字节，将file的前60块放入file1，余下的放入file2：</p>

<pre><code>[root]# dd if=file bs=1024 count=60 skip=0  of=file1  
[root]# dd if=file bs=1024 count=60 skip=60 of=file2  
</code></pre>

<p>然后用cat将两个文件合并为file.bak，要注意文件的顺序：</p>

<pre><code>[root]# cat file1 file2 &gt; file.bak  
</code></pre>

<p>可以用md5sum验证一下file和file.bak：</p>

<pre><code>[root]# md5sum file  
3ff53f7c30421ace632eefff36148a70  file  
[root]# md5sum file.bak  
3ff53f7c30421ace632eefff36148a70  file.bak  
</code></pre>

<p>可以证明两个文件时完全相同的。</p>

<p>为了方便分割、合并文件，我写了两个脚本：</p>

<p>ddf.sh</p>

<pre><code>#ddf.sh：分割文件，分割后的文件以数字结尾，例如file分割为两个文件：file1和file2  
#!/bin/sh  

#使用脚本是第一参数是要分割的文件名  
Filename=$1     
Filesize=0  

Path=`pwd`  

#验证文件名是否正确，然后计算文件的大小  
if [ -z $Filename ];then  
    echo &quot;Error:The file name can not be empty&quot;  
    exit  
fi  
if [ -e $Filename ];then  
    Filesize=`du -b $Filename | awk '{print $1}'`  
    if [ $Filesize == 0 ];then  
        echo &quot;Error:The File size is zero!&quot;  
        exit  
    fi  
    echo &quot;The file size is $Filesize Byte&quot;  
    echo &quot;Plese enter the subfile size(KB):&quot;  
else  
    echo &quot;Error:$Filename does not exist!&quot;  
    exit   
fi  

#输入分割后每个文件的大小，单位是KB  
read Subfilesize  
if [ -z $Subfilesize ];then  
    echo &quot;Error:Input can not be empty&quot;  
    exit  
fi  

echo $Subfilesize | grep '^[0-9]\+$' &gt;&gt; /dev/null  
if [ $? -ne 0 ];then  
    echo &quot;Error:The Input is not a number!&quot;  
    exit  
elif [ $Subfilesize -eq 0 ];then  
    echo &quot;Error:The Subfile size is zero!&quot;  
    exit  
fi  

#计算需要分割为几个文件  
SubfileByte=`expr $Subfilesize \* 1024`  
Subfilenum=`expr $Filesize / $SubfileByte`  
if [ `expr $Filesize % $Subfilesize` -ne 0 ];then  
    Subfilenum=`expr $Subfilenum + 1`  
fi  

#将文件分割  
echo &quot;$Filename will be divided into $Subfilenum&quot;   
i=1  
skipnum=0  
while [ $i -le $Subfilenum ]  
do  
    echo &quot;$Filename$i&quot;  
    dd if=$Filename of=&quot;$Path/$Filename$i&quot; bs=1024 count=$Subfilesize skip=$skipnum  
    i=`expr $i + 1`  
    skipnum=`expr $skipnum + $Subfilesize`  
done  
echo &quot;$Filename has been divided into $Subfilenum&quot;  
echo &quot;Done !&quot;  
</code></pre>

<p>caf.sh</p>

<pre><code>#caf.sh:合并文件，需要合并的文件要放在一个文件夹里  
#       文件名分为两个部分，第一部分都相同，第二部分必须是从1开始的连续数字，例如file1，file2，file3  
#       合并后的文件名为file.bak  
#!/bin/sh  

#输入文件名的第一部分  
echo &quot;Please enter file name:&quot;  
read Filename  
if [ -z $Filename ];then  
    echo &quot;Error:File name can not be empty&quot;  
    exit  
fi  

#输入待合并文件的个数  
echo &quot;Please enter the number of subfiles:&quot;   
read Subfilenum  
if [ -z $Subfilenum ];then  
    echo &quot;Error:The number of subfiles can not be empty&quot;  
    exit  
fi  
echo $Subfilenum | grep '^[0-9]\+$' &gt; /dev/null  
if [ $? -ne 0 ];then  
        echo &quot;Error:Input must be a number&quot;  
exit  
fi  
if [ $Subfilenum -eq 0 ];then  
        echo &quot;Error:The number of subfiles can not be zero&quot;  
exit  
fi  


#合并文件  
i=1  
Newfile=$Filename\.bak  
while [ $i -le $Subfilenum ]  
do  
    Subfilename=$Filename$i  
        if [ -e $Subfilename ];then  
            echo &quot;$Subfilename done!&quot;  
            cat $Subfilename &gt;&gt; $Newfile  
            i=`expr $i + 1`  
        else  
            echo &quot;Error:$Subfilename does not exist&quot;  
            rm -rf $Newfile  
            exit  
        fi  
done  


echo &quot;Subfiles be merged into $Newfile&quot;  
echo &quot;Success!&quot;  
</code></pre>

<p>用这两个脚本完成对file的分割、合并：</p>

<pre><code>[root]# ./ddf.sh file   
The file size is 116616 Byte  
Plese enter the subfile size(KB):  
60  
file will be divided into 2  
file1  
记录了60+0 的读入  
记录了60+0 的写出  
61440字节(61 kB)已复制，0.0352612 秒，1.7 MB/秒  
file2  
记录了53+1 的读入  
记录了53+1 的写出  
55176字节(55 kB)已复制，0.0316272 秒，1.7 MB/秒  
file has been divided into 2  
Done !  
[root]# ls  
caf.sh  ddf.sh  file  file1  file2  
[root]# ./caf.sh   
Please enter file name:  
file  
Please enter the number of subfiles:  
2  
file1 done!  
file2 done!  
Subfiles be merged into file.bak  
Success!  
[root]# ls  
caf.sh  ddf.sh  file  file1  file2  file.bak
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>如何在Linux系统下制作RamDisk</title>
            <link>https://shaocheng.li/posts/2011/07/25/</link>
            <pubDate>Mon, 25 Jul 2011 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2011/07/25/</guid>
            <description>原文：
《Linux Ramdisk mini-HOWTO》
By Van Emery
http://www.vanemery.com/Linux/Ramdisk/ramdisk.html
Translate By Bob
Friday, July 25, 2011
Email：gexbob@gmail.com
Blog：http://shaocheng.li
简介 什么是RamDisk？RamDisk就是将内存（Ram）的一部分当做硬盘（Disk）来使用。RamDisk有固定的大小，可以像正常硬盘分区那样去使用。 就操作时间来讲，RamDisk比真实的物理硬盘快很多，当系统关闭或断电时，保存在RamDisk中的数据会全部丢失。RamDisk可以成为一个存放临时数据的好地方。
Linux的2.4内核已经内建支持RamDisk。RamDisk在很多情况下是很有用的，包括：
 使用加密文件中的未加密数据； 某些类型的网页内容服务； 挂载loopback文件系统（例如，从软盘或CD运行）  我为什么要写这个文档？因为我需要设置一个16M的RamDisk来查看、创建加密文件。我不想让未加密的文件写入我的工作平台的任何物理介质。我还发现一个有趣的地方，可以轻易的在Ram中创建一个比我的第一个物理硬盘（20M）还大的虚拟硬盘，当时，我根本无法想象怎样填满这个虚拟硬盘。
这个文档将会带你一步步地经历创建和使用RamDisk的过程。
平台 我使用Red Hat 9进行测试，但是这应该适用于其他的 2.4 内核的Linux系统，我还假设你的Linux系统已经将RamDisk支持编译到了内核。我的计算机使用 Pentium 4 处理器，256M内存，确切的内核版本是：2.4.20-20.9
1. 查看你的系统已经创建了什么 RedHat默认创建16个RamDisk，虽然它们没有激活或使用任何Ram。系统列出的设备是ram0~ram19，但是只有ram0~ram15是默认可用的。使用下面的命令可用检出这些块设备：
[root]# ls -l /dev/ram* lrwxrwxrwx 1 root root 4 Jun 12 00:31 /dev/ram -&amp;gt; ram1 brw-rw---- 1 root disk 1, 0 Jan 30 2003 /dev/ram0 brw-rw---- 1 root disk 1, 1 Jan 30 2003 /dev/ram1 brw-rw---- 1 root disk 1, 10 Jan 30 2003 /dev/ram10 brw-rw---- 1 root disk 1, 11 Jan 30 2003 /dev/ram11 brw-rw---- 1 root disk 1, 12 Jan 30 2003 /dev/ram12 brw-rw---- 1 root disk 1, 13 Jan 30 2003 /dev/ram13 brw-rw---- 1 root disk 1, 14 Jan 30 2003 /dev/ram14 brw-rw---- 1 root disk 1, 15 Jan 30 2003 /dev/ram15 brw-rw---- 1 root disk 1, 16 Jan 30 2003 /dev/ram16 brw-rw---- 1 root disk 1, 17 Jan 30 2003 /dev/ram17 brw-rw---- 1 root disk 1, 18 Jan 30 2003 /dev/ram18 brw-rw---- 1 root disk 1, 19 Jan 30 2003 /dev/ram19 brw-rw---- 1 root disk 1, 2 Jan 30 2003 /dev/ram2 brw-rw---- 1 root disk 1, 3 Jan 30 2003 /dev/ram3 brw-rw---- 1 root disk 1, 4 Jan 30 2003 /dev/ram4 brw-rw---- 1 root disk 1, 5 Jan 30 2003 /dev/ram5 brw-rw---- 1 root disk 1, 6 Jan 30 2003 /dev/ram6 brw-rw---- 1 root disk 1, 7 Jan 30 2003 /dev/ram7 brw-rw---- 1 root disk 1, 8 Jan 30 2003 /dev/ram8 brw-rw---- 1 root disk 1, 9 Jan 30 2003 /dev/ram9 lrwxrwxrwx 1 root root 4 Jun 12 00:31 /dev/ramdisk -&amp;gt; ram0  现在，用grep在dmesg的输出中找出RamDisk的大小</description>
            <content type="html"><![CDATA[

<p>原文：</p>

<p>《Linux Ramdisk mini-HOWTO》</p>

<p>By Van Emery</p>

<p><a href="http://www.vanemery.com/Linux/Ramdisk/ramdisk.html" target="_blank">http://www.vanemery.com/Linux/Ramdisk/ramdisk.html</a></p>

<p>Translate By Bob</p>

<p>Friday, July 25, 2011</p>

<p>Email：<a href="mailto:gexbob@gmail.com" target="_blank">gexbob@gmail.com</a></p>

<p>Blog：<a href="http://shaocheng.li" target="_blank">http://shaocheng.li</a></p>

<hr />

<h2 id="简介">简介</h2>

<p>什么是RamDisk？RamDisk就是将内存（Ram）的一部分当做硬盘（Disk）来使用。RamDisk有固定的大小，可以像正常硬盘分区那样去使用。 就操作时间来讲，RamDisk比真实的物理硬盘快很多，当系统关闭或断电时，保存在RamDisk中的数据会全部丢失。RamDisk可以成为一个存放临时数据的好地方。</p>

<p>Linux的2.4内核已经内建支持RamDisk。RamDisk在很多情况下是很有用的，包括：</p>

<ul>
<li>使用加密文件中的未加密数据；</li>
<li>某些类型的网页内容服务；</li>
<li>挂载loopback文件系统（例如，从软盘或CD运行）</li>
</ul>

<p>我为什么要写这个文档？因为我需要设置一个16M的RamDisk来查看、创建加密文件。我不想让未加密的文件写入我的工作平台的任何物理介质。我还发现一个有趣的地方，可以轻易的在Ram中创建一个比我的第一个物理硬盘（20M）还大的虚拟硬盘，当时，我根本无法想象怎样填满这个虚拟硬盘。</p>

<p>这个文档将会带你一步步地经历创建和使用RamDisk的过程。</p>

<h2 id="平台">平台</h2>

<p>我使用Red Hat 9进行测试，但是这应该适用于其他的 2.4 内核的Linux系统，我还假设你的Linux系统已经将RamDisk支持编译到了内核。我的计算机使用 Pentium 4 处理器，256M内存，确切的内核版本是：2.4.20-20.9</p>

<hr />

<h2 id="1-查看你的系统已经创建了什么">1. 查看你的系统已经创建了什么</h2>

<p>RedHat默认创建16个RamDisk，虽然它们没有激活或使用任何Ram。系统列出的设备是ram0~ram19，但是只有ram0~ram15是默认可用的。使用下面的命令可用检出这些块设备：</p>

<pre><code>[root]# ls -l /dev/ram*  
lrwxrwxrwx    1 root     root            4 Jun 12 00:31 /dev/ram -&gt; ram1  
brw-rw----    1 root     disk       1,   0 Jan 30  2003 /dev/ram0  
brw-rw----    1 root     disk       1,   1 Jan 30  2003 /dev/ram1  
brw-rw----    1 root     disk       1,  10 Jan 30  2003 /dev/ram10  
brw-rw----    1 root     disk       1,  11 Jan 30  2003 /dev/ram11  
brw-rw----    1 root     disk       1,  12 Jan 30  2003 /dev/ram12  
brw-rw----    1 root     disk       1,  13 Jan 30  2003 /dev/ram13  
brw-rw----    1 root     disk       1,  14 Jan 30  2003 /dev/ram14  
brw-rw----    1 root     disk       1,  15 Jan 30  2003 /dev/ram15  
brw-rw----    1 root     disk       1,  16 Jan 30  2003 /dev/ram16  
brw-rw----    1 root     disk       1,  17 Jan 30  2003 /dev/ram17  
brw-rw----    1 root     disk       1,  18 Jan 30  2003 /dev/ram18  
brw-rw----    1 root     disk       1,  19 Jan 30  2003 /dev/ram19  
brw-rw----    1 root     disk       1,   2 Jan 30  2003 /dev/ram2  
brw-rw----    1 root     disk       1,   3 Jan 30  2003 /dev/ram3  
brw-rw----    1 root     disk       1,   4 Jan 30  2003 /dev/ram4  
brw-rw----    1 root     disk       1,   5 Jan 30  2003 /dev/ram5  
brw-rw----    1 root     disk       1,   6 Jan 30  2003 /dev/ram6  
brw-rw----    1 root     disk       1,   7 Jan 30  2003 /dev/ram7  
brw-rw----    1 root     disk       1,   8 Jan 30  2003 /dev/ram8  
brw-rw----    1 root     disk       1,   9 Jan 30  2003 /dev/ram9  
lrwxrwxrwx    1 root     root            4 Jun 12 00:31 /dev/ramdisk -&gt; ram0  
</code></pre>

<p>现在，用grep在dmesg的输出中找出RamDisk的大小</p>

<pre><code>[root]# dmesg | grep RAMDISK  
RAMDISK driver initialized: 16 RAM disks of 4096K size 1024 blocksize  
RAMDISK: Compressed image found at block 0  
</code></pre>

<p>你可用看到，RamDisk 默认只有 4MB。我想要一个 16MB 的 RamDisk，所以，下一步要配置 Linux，使得在启动过程中使用一个更大的 RamDisk 。</p>

<h2 id="2-增加ramdisk的大小">2. 增加RamDisk的大小</h2>

<p>RamDisk 的大小是被一个命令行选项控制的，这个选项会在系统启动时传给内核。由于 RedHat9 的默认 bootloader 是 GRUB，我将用新的选项修改 /etc/grub.conf，RamDisk 大小的内核选项是：ramdisk_size=xxxxx ，xxxxx 是指大小为 1024-Byte 的块的个数。下面是我要添加到 /etc/grub.conf 的内容，它将 RamDisk 配置为16MB：</p>

<p>gurb.conf</p>

<pre><code># grub.conf generated by anaconda  
#  
# Note that you do not have to rerun grub after making changes to this file  
# NOTICE:  You have a /boot partition.  This means that  
#          all kernel and initrd paths are relative to /boot/, eg.  
#          root (hd0,0)  
#          kernel /vmlinuz-version ro root=/dev/hda5  
#          initrd /initrd-version.img  
#boot=/dev/hda  
default=0  
timeout=10  
splashimage=(hd0,0)/grub/splash.xpm.gz  
title Red Hat Linux (2.4.20-20.9)  
        root (hd0,0)  
        kernel /vmlinuz-2.4.20-20.9 ro root=LABEL=/ hdc=ide-scsi ramdisk_size=16000  
        initrd /initrd-2.4.20-20.9.img  
</code></pre>

<p>将文件保存后，你需要重启系统。重启后，通过查看dmesg的输出来确认修改已经生效：</p>

<pre><code>[root]# dmesg | grep RAMDISK  
RAMDISK driver initialized: 16 RAM disks of 16000K size 1024 blocksize  
RAMDISK: Compressed image found at block 0  
</code></pre>

<h2 id="3-格式化ramdisk">3. 格式化RamDisk</h2>

<p>无需将 RamDisk 格式化为日志文件系统，我们将使用 EXT2 文件系统。我只想使用一个 RamDisk ，所以我只格式化 ram0。</p>

<pre><code>[root]# mke2fs -m 0 /dev/ram0  
mke2fs 1.32 (09-Nov-2002)  
Filesystem label=  
OS type: Linux  
Block size=1024 (log=0)  
Fragment size=1024 (log=0)  
4000 inodes, 16000 blocks  
0 blocks (0.00%) reserved for the super user  
First data block=1  
2 block groups  
8192 blocks per group, 8192 fragments per group  
2000 inodes per group  
Superblock backups stored on blocks:  
        8193  

Writing inode tables: done  
Writing superblocks and filesystem accounting information: done  

This filesystem will be automatically checked every 22 mounts or  
180 days, whichever comes first.  Use tune2fs -c or -i to override.  
</code></pre>

<p>-m 0选项指定了文件系统上root用户保留区块的比例为0，这是默认的特性。我希望普通用户可以使用所有的RamDisk空间。</p>

<h2 id="4-新建一个挂载点并挂载ramdisk">4. 新建一个挂载点并挂载RamDisk</h2>

<p>你已经格式化了RamDisk，现在要为它新建一个挂载点。然后就可以挂载你的RamDisk并使用它。我们将会使用/mnt/rd文件夹。</p>

<pre><code>[root]# mkdir /mnt/rd  
[root]# mount /dev/ram0 /mnt/rd  
</code></pre>

<p>检测新挂载的RamDisk</p>

<pre><code>[root]# mount | grep ram0  
/dev/ram0 on /mnt/rd type ext2 (rw)  
[root]# df -h | grep ram0  
/dev/ram0              16M   13K   16M   1% /mnt/rd  
</code></pre>

<p>你可以用tune2fs命令查看新RamDisk的详细信息</p>

<pre><code>[root]# tune2fs -l /dev/ram0  
tune2fs 1.32 (09-Nov-2002)  
Filesystem volume name:   none  
Last mounted on:          not available  
Filesystem UUID:          fbb80e9a-8e7c-4bd4-b3d9-37c29813a5f5  
Filesystem magic number:  0xEF53  
Filesystem revision #:    1 (dynamic)  
Filesystem features:      filetype sparse_super  
Default mount options:    (none)  
Filesystem state:         not clean  
Errors behavior:          Continue  
Filesystem OS type:       Linux  
Inode count:              4000  
Block count:              16000  
Reserved block count:     0  
Free blocks:              15478  
Free inodes:              3989  
First block:              1  
Block size:               1024  
Fragment size:            1024  
Blocks per group:         8192  
Fragments per group:      8192  
Inodes per group:         2000  
Inode blocks per group:   250  
Filesystem created:       Mon Dec  8 14:33:57 2003  
Last mount time:          Mon Dec  8 14:35:39 2003  
Last write time:          Mon Dec  8 14:35:39 2003  
Mount count:              1  
Maximum mount count:      22  
Last checked:             Mon Dec  8 14:33:57 2003  
Check interval:           15552000 (6 months)  
Next check after:         Sat Jun  5 14:33:57 2004  
Reserved blocks uid:      0 (user root)  
Reserved blocks gid:      0 (group root)  
First inode:              11  
Inode size:               128  
</code></pre>

<p>在我的系统中，我需要&rsquo;var&rsquo;用户能够读写RamDisk，所以必须修改/mnt/rd文件夹的所有者和权限。</p>

<pre><code>[root]# chown van:root /mnt/rd  
[root]# chmod 0770 /mnt/rd  
[root]# ls -ald /mnt/rd  
drwxrwx---    2 van     root         4096 Dec  8 11:09 /mnt/rd  
</code></pre>

<p>RamDisk挂载点的所有者和权限要根据你的特定情况进行修改。</p>

<h2 id="5-使用ramdisk">5. 使用RamDisk</h2>

<p>RamDisk已经创建成功，现在，你可以像在物理硬盘分区那样，在RamDisk上复制、移动、删除、编辑或列出文件。这是一个查看加密的GPG或OpenSSL文件的好地方，也是一个创建加密文件的好地方。你的主机关闭后，所有在RamDisk上创建的文件都会消失。</p>

<p>用下面的命令可以轻易的卸载RamDisk：</p>

<pre><code>[root]# umount -v /mnt/rd  
/dev/ram0 umounted  
</code></pre>

<p><strong>Note：</strong>如果你卸载了RamDisk，你的数据依然会保存在那里。一旦内存被分配给了RamDisk，它就会被标记，之后内核就不会试图重用这块内存。因此，使用了RamDisk后，就不能回收那块内存。正因如此，你要考虑清楚，不要给RamDisk分配太多的内存。在我的系统里，我分配了小于10%的物理内存。你要根据自己的需要确定RamDisk的大小。当然，也可以重启后释放空间。</p>

<hr />

<h2 id="自动创建ramdisk">自动创建RamDisk</h2>

<p>如果你需要每次系统启动后创建和挂载RamDisk，可以通过在/etc/rc.local启动脚本里添加命令来自动执行这个进程。
下面是我添加的命令：</p>

<pre><code># Formats, mounts, and sets permissions on my 16MB ramdisk
/sbin/mke2fs -q -m 0 /dev/ram0
/bin/mount /dev/ram0 /mnt/rd
/bin/chown van:root /mnt/rd
/bin/chmod 0750 /mnt/rd
</code></pre>

<h2 id="结语">结语</h2>

<p>现在你可以尝试在你的UNIX/Linux系统上创建和使用RamDisk。希望这些信息对你有用。</p>

<h2 id="参考">参考</h2>

<ul>
<li>/usr/src/linux-2.4/Documentation/ramdisk.txt</li>
<li>/usr/src/linux-2.4/drivers/block/rd.c</li>
<li>man mke2fs</li>
<li>Ramdisk article by Mark Nielsen for Red Hat 6.0</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>为Linux系统配置serial console</title>
            <link>https://shaocheng.li/posts/2011/07/22/</link>
            <pubDate>Fri, 22 Jul 2011 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2011/07/22/</guid>
            <description>原文：
《Remote Serial Console HOWTO》：http://www.linux.com/learn/docs/ldp/714-Remote-Serial-Console-HOWTO
Translate By Bob
Friday, July 15, 2011
Email：gexbob@gmail.com
Blog：http://shaocheng.li
根据我的环境（Redhat 9，Grub 0.93），翻译了我需要的部分。原文还有针对Lilo和Syslinux的配置说明。
1. 准备工作 1.1. 关于serial console Console是一个输出系统管理信息的文本输出设备，这些信息来自于内核，系统启动和系统用户，serial console就是串口作为输出终端设备，是这些信息可以通过串口在远程的终端上显示。
配置一个serial console大致包括五项内容：
 配置BIOS使用serial console（可选）； 配置Bootloader使用serial console（可选）； 配置内核使用serial console 在系统启动时运行一个支持serial console登录的程序 一些其他系统配置，使这些功能支持serial console，或者防止它们扰乱serial console  1.2. 串口线 使用RS232方式的DB9串口线，信号连接如下：
 Signal ground ------------------ Signal ground Receive data ------------------ Transmit data Transmit data ------------------ Receive data Ready to send ------------------ Clear to send Clear to send ------------------ Ready to send ata terminal ready -------------+--- Data carrier detect | +--- Data set ready Data carrier detect ----+---------------- Data terminal ready | Data set ready ----+  1.</description>
            <content type="html"><![CDATA[

<p>原文：</p>

<p>《Remote Serial Console HOWTO》：<a href="http://www.linux.com/learn/docs/ldp/714-Remote-Serial-Console-HOWTO" target="_blank">http://www.linux.com/learn/docs/ldp/714-Remote-Serial-Console-HOWTO</a></p>

<p>Translate By Bob</p>

<p>Friday, July 15, 2011</p>

<p>Email：<a href="mailto:gexbob@gmail.com" target="_blank">gexbob@gmail.com</a></p>

<p>Blog：<a href="http://shaocheng.li" target="_blank">http://shaocheng.li</a></p>

<p>根据我的环境（Redhat 9，Grub 0.93），翻译了我需要的部分。原文还有针对Lilo和Syslinux的配置说明。</p>

<hr />

<h2 id="1-准备工作">1. 准备工作</h2>

<h3 id="1-1-关于serial-console">1.1. 关于serial console</h3>

<p>Console是一个输出系统管理信息的文本输出设备，这些信息来自于内核，系统启动和系统用户，serial console就是串口作为输出终端设备，是这些信息可以通过串口在远程的终端上显示。</p>

<p>配置一个serial console大致包括五项内容：</p>

<ul>
<li>配置BIOS使用serial console（可选）；</li>
<li>配置Bootloader使用serial console（可选）；</li>
<li>配置内核使用serial console</li>
<li>在系统启动时运行一个支持serial console登录的程序</li>
<li>一些其他系统配置，使这些功能支持serial console，或者防止它们扰乱serial console</li>
</ul>

<h3 id="1-2-串口线">1.2. 串口线</h3>

<p>使用RS232方式的DB9串口线，信号连接如下：</p>

<pre><code>     Signal ground ------------------ Signal ground
      Receive data ------------------ Transmit data
     Transmit data ------------------ Receive data
     Ready to send ------------------ Clear to send
     Clear to send ------------------ Ready to send
ata terminal ready -------------+--- Data carrier detect
                                |
                                +--- Data set ready
Data carrier detect ----+---------------- Data terminal ready
                        |
     Data set ready ----+
</code></pre>

<h3 id="1-3-串口参数的设置">1.3. 串口参数的设置</h3>

<p>选择的串口是COM1，设备名为ttyS0，波特率为9600,8位数据位，无奇偶校验，1位停止位。</p>

<h2 id="2-配置bios">2. 配置BIOS</h2>

<p>有些BIOS支持serial console，可以在serial console显示BIOS启动信息，这需要在BIOS中配置。</p>

<h2 id="3-配置bootloader">3. 配置Bootloader</h2>

<p>LILO、GRUB和SYSLINUX都支持serial console。</p>

<h3 id="3-1-grub的配置">3.1. GRUB的配置</h3>

<p>GRUB的配置文件是/boot/grub目录下的grub.conf，在配置文件的开始处添加：</p>

<pre><code>serial --unit=0 --speed=9600 --word=8 --parity=no --stop=1
terminal --timeout=10 serial console
</code></pre>

<p>Serial命令用于设置串口的参数：</p>

<pre><code>--unit：串口设备，0就表示ttyS0，如果是ttyS1就要设为1；
--speed：波特率；
--work：数据位；
--parity：奇偶校验位；
--stop：停止位。
Terminal命令用于设置终端的类型
--timeout：等待时间，单位是秒
</code></pre>

<h2 id="4-配置kernel">4. 配置Kernel</h2>

<p>Kernel的console类型可以通过console参数选择，console配置的语法如下：</p>

<pre><code>console=ttyS&lt;serial_port&gt;[,&lt;mode&gt;]
console=tty&lt;virtual_terminal&gt;
console=lp&lt;parallel_port&gt;
console=ttyUSB[&lt;usb_port&gt;[,&lt;mode&gt;] 
</code></pre>

<p>其中的ttyS就是串口设备，mode表示串口的参数；tty表示虚拟终端。</p>

<p>每个console类型指南设置一个设备，例如，可以设置为console=tty0 console=lp0 console=ttyS0，但是设为 console=ttyS0 console=ttyS1就是错误的。</p>

<p>如果没有设置console参数，内核默认使用虚拟终端，即tty0，使用组合键 Ctrl+Alt+F1 可以切换到 tty0。如果你的电脑有显示设备，最好将它设为 console，即 console=tty0。</p>

<p>根据我的设备情况可以设置为：</p>

<pre><code>console=tty0 console=ttyS0,9600n8
</code></pre>

<p>Console参数需要用bootloader在内核启动时传递给内核，对于GRUB，需要修改grub.conf文件，将参数添加到kernel命令后面即可，例如；</p>

<p>grub.conf</p>

<pre><code>title Red Hat Linux (2.4.9-21)  
  root (hd0,0)  
  kernel /vmlinuz-2.4.9-21 ro root=/dev/hda6 console=tty0 console=ttyS0,9600n8  
  initrd /initrd-2.4.9-21.img  
</code></pre>

<h2 id="5-配置getty">5. 配置getty</h2>

<p>getty会监控和等待一个连接，然后配置串口连接，发送/etc/issue的内容，并且要求输入登录名和密码，然后开始登录，如果登录失败，getty会返回等待状态。</p>

<p>getty的另一项工作是设置TERM变量的值，以指定所连接的终端的类型。</p>

<p>常用的getty有四个版本：</p>

<p>*getty：*传统的getty，需要配置文件/etc/gettydefs
*agetty：*无需配置文件，直接通过命令行传递参数
*mgetty：*支持modem的getty，需要配置文件
*minigetty：*精简版的getty，不支持serial console</p>

<p>RedHat9自带agetty和mgetty，在/etc/inittab文件中默认使用mgetty，在该文件中添加：</p>

<pre><code>co：2345：respawn：/sbin/agetty  -h -t 60 ttyS0 9600 vt102  
</code></pre>

<p>-t 60 : 60秒内无操作，agetty将会返回等待状态。</p>

<p>-h ： 使用硬件流控制（CTS/RTS握手）</p>

<h2 id="6-其他配置">6. 其他配置</h2>

<h3 id="6-1-让root可以通过serial-console登录">6.1. 让root可以通过serial console登录</h3>

<p>配置文件/etc/securetty用于管理root用户可以登录的设备，将serial console的设备名添加到该文件，即可使root用户通过serial console登录。</p>

<p>为了安全性，我们通常root用户在远程登录，而是用普通用户登录，然后用su或sudo命令切换到root。</p>

<h3 id="6-2-将启动基本改为文本方式">6.2. 将启动基本改为文本方式</h3>

<p>这个只针对在没有屏幕的服务器上运行X-Window系统，编辑/etc/inittab文件中包含initdefault的那一行，例如：</p>

<pre><code>id:5:initdefault:  
</code></pre>

<p>改为</p>

<pre><code>id:3:initdefault:  
</code></pre>

<p>如果连接了键盘和显示器，可以用start命令启动X-Window。</p>

<p>####6.2.1. 配置为运行X</p>

<p>有时，一台有serial console却没有连接显示器的电脑依然需要运行X-Window，例如，这台电脑连接有X终端。</p>

<p>这种情况下，计算机还是需要运行在第5级，但是不能为显示器运行X-server。修改/etc/X11/xdm/Xservers,删除所有以冒号开头的行，例如：</p>

<pre><code>:0 local /usr/X11R6/bin/X  
</code></pre>

<p>如果操作系统使用的是GNOME，那就要修改它的配置文件/etc/X11/gdm/gdm.conf，删除[servers] 段中的所有本地X-Server的条目，例如：</p>

<pre><code>[servers]  
0=/usr/bin/X11/X  
</code></pre>

<h3 id="6-3-删除已有的console设置">6.3. 删除已有的console设置</h3>

<p>/etc/ioctl.save包含了单用户模式中使用的串口和终端的特性，这些特性通常是有getty来设置的——在没用getty运行的单用户模式下，这个文件的内容被用来设置串口和终端。</p>

<p>因为我们已经改变了console，已有的设置已经不正确了，所以要删除这个文件：</p>

<pre><code>rm -f /etc/ioctl.save  
</code></pre>

<p>一旦我们可以从serial console登录，我们会重建这个文件。</p>

<h3 id="6-4-serial-console不是-dev-modem">6.4. serial console不是/dev/modem</h3>

<p>很多Linux会将/dev/modem链接到一个包含可用modem的串口设备。</p>

<p>虽然serial console是一个带有modem的串口，但是我们真的不希望它被用作一个呼叫设备。</p>

<p>检查/dev/modem是否指向了那个用做console的串口，如果是，将它删除。</p>

<pre><code>bash$ ls -l /dev/modem  
lrwxrwxrwx 1 root root 10 Jan 01 00:00 /dev/modem -&gt; /dev/ttyS0  
bash# rm /dev/modem  
</code></pre>

<h3 id="6-5-更改-dev-systty的目标">6.5. 更改/dev/systty的目标</h3>

<p>很多Linux将/dev/systty链接到了键盘和显示器所使用的那个终端设备。</p>

<p>如果计算机没有连接键盘和显示器，或者不想给键盘和显示器提供一个文本终端，那就修改/dev/systty，使它指向serial console。</p>

<p>相对于修改链接，修改MAKEDEV使用的配置文件更好，这样会重建链接。配置文件位于/dev/makedev.d目录下，默认配置指向第一个虚拟终端：</p>

<pre><code>l systty tty0  
</code></pre>

<p>修改它，使systty指向用作console的串口：</p>

<pre><code>bash# cd /etc/makedev.d  
bash# fgrep systty *  
linux-2.4.x:l systty tty0  
bash# vi linux-2.4.x  
</code></pre>

<p>将systty那一行改为：</p>

<pre><code>l systty ttyS0  
</code></pre>

<p>然后根据新定义重建/dev/systty:</p>

<pre><code>bash# cd /dev  
bash# rm systty  
bash# ./MAKEDEV systty  
</code></pre>

<h3 id="6-6-配置可拔插认证模块">6.6. 配置可拔插认证模块</h3>

<p>可拔插认证模块系统被用于向用户提供通过console登录系统的特权，它使得设备像软盘那样可以由console用户挂载，通常情况下，挂载磁盘需要超级用户权限。</p>

<p>PAM配置文件/etc/security/console.perms包含&lt;console&gt;变量，对于连接了键盘显示器的系统，默认的&lt;console&gt;变量为：</p>

<pre><code>&lt;console&gt;=tty[0-9][0-9]* vc/[0-9][0-9]* :[0-9]\.[0-9] :[0-9]  
</code></pre>

<p>在该文件的后面部分，console用户被赋予了使用一些设备的权限，设备权限的修改会在登录或退出后生效。
console.perms文件中默认的设备列表如下：</p>

<p>console.perms</p>

<pre><code>&lt;console&gt;  0660 &lt;floppy&gt;     0660 root.floppy  
&lt;console&gt;  0600 &lt;sound&gt;      0600 root  
&lt;console&gt;  0600 &lt;cdrom&gt;      0660 root.disk  
&lt;console&gt;  0600 &lt;pilot&gt;      0660 root.uucp  
&lt;console&gt;  0600 &lt;jaz&gt;        0660 root.disk  
&lt;console&gt;  0600 &lt;zip&gt;        0660 root.disk  
&lt;console&gt;  0600 &lt;ls120&gt;      0660 root.disk  
&lt;console&gt;  0600 &lt;scanner&gt;    0600 root  
&lt;console&gt;  0600 &lt;camera&gt;     0600 root  
&lt;console&gt;  0600 &lt;memstick&gt;   0600 root  
&lt;console&gt;  0600 &lt;flash&gt;      0600 root  
&lt;console&gt;  0600 &lt;fb&gt;         0600 root  
&lt;console&gt;  0600 &lt;kbd&gt;        0600 root  
&lt;console&gt;  0600 &lt;joystick&gt;   0600 root  
&lt;console&gt;  0600 &lt;v4l&gt;        0600 root  
&lt;console&gt;  0700 &lt;gpm&gt;        0700 root  
&lt;console&gt;  0600 &lt;mainboard&gt;  0600 root  
&lt;console&gt;  0600 &lt;rio500&gt;     0600 root  
</code></pre>

<p>以上被列出的设备分为两种：一些设备需要来自键盘和显示器的连接，而另一些设备可以方便的连接，这个配置文件无法区分逻辑console和物理console，可通过修改文件来区分二者。</p>

<p>需要键盘和显示器连接的设备如下：</p>

<pre><code>&lt;console&gt;  0600 &lt;fb&gt;         0600 root  
&lt;console&gt;  0600 &lt;kbd&gt;        0600 root  
&lt;console&gt;  0600 &lt;joystick&gt;   0600 root  
&lt;console&gt;  0600 &lt;v4l&gt;        0600 root  
&lt;console&gt;  0700 &lt;gpm&gt;        0700 root  
</code></pre>

<p>其余的设备要修改为通过serial console来控制。例如，我们不想要一个处于托管位置的非特权用户去挂载软盘。为serial console定义一个新的console类型，叫做&lt;sconsole&gt;，将它添加到console.perms：</p>

<pre><code>&lt;sconsole&gt;=ttyS0  
</code></pre>

<p>然后将其他设备的 &lt;console&gt; 改为 &lt;sconsole&gt;,使它们指向serial console:</p>

<pre><code>&lt;sconsole&gt;  0660 &lt;floppy&gt;     0660 root.floppy  
&lt;sconsole&gt;  0600 &lt;sound&gt;      0600 root  
&lt;sconsole&gt;  0600 &lt;cdrom&gt;      0660 root.disk  
&lt;sconsole&gt;  0600 &lt;pilot&gt;      0660 root.uucp  
&lt;sconsole&gt;  0600 &lt;jaz&gt;        0660 root.disk  
&lt;sconsole&gt;  0600 &lt;zip&gt;        0660 root.disk  
&lt;sconsole&gt;  0600 &lt;ls120&gt;      0660 root.disk  
&lt;sconsole&gt;  0600 &lt;scanner&gt;    0600 root  
&lt;sconsole&gt;  0600 &lt;camera&gt;     0600 root  
&lt;sconsole&gt;  0600 &lt;memstick&gt;   0600 root  
&lt;sconsole&gt;  0600 &lt;flash&gt;      0600 root  
&lt;sconsole&gt;  0600 &lt;mainboard&gt;  0600 root  
&lt;sconsole&gt;  0600 &lt;rio500&gt;     0600 root  
</code></pre>

<h3 id="6-7-针对redhat的配置">6.7. 针对RedHat的配置</h3>

<p>RedHat将一些系统初始化所需的参数存放在 /etc/sysconfig/init。</p>

<p>修改BOOTUP参数，使用独立终端命令写OK、PASSED和FAULT信息，这些信息将不再显示为绿色、黄色或红色。/etc/sysconfig/init 文件的注释说，除了color，还可以设置其他的值，但是，BOOTUP 必须被设为 serial。</p>

<p>修改PROMPT参数，禁止交互启动。</p>

<p>对 /etc/sysconfig/init 的修改如下：</p>

<pre><code>BOOTUP=serial  
PROMPT=no
</code></pre>

<p>RedHat会运行一个用于发现硬件设备的程序，叫做 kudzu。当发现一个串口时，kudzu会将其复位，这将停止 serial console。kudzu 的配置文件是 /etc/sysconfig/kudzu。</p>

<p>将配置文件中的 SAFE 设为 yes，就会阻止 kudzu 复位设备。</p>

<p>修改 /etc/sysconfig/kudzu:</p>

<pre><code>SAFE=yes  
</code></pre>

<h2 id="7-重启测试">7.  重启测试</h2>

<h3 id="7-1-验证console操作">7.1. 验证console操作</h3>

<p>有可能的话，在串口上接一个串口接线盒。在重启的过程中，DTR信号会被激活，出现console信息时，数据指示灯会闪烁。在里一台电脑上配置好终端，重启计算机。</p>

<p>重启过程中，在终端界面可以看到bootloader的启动信息，然后是kernel启动，系统初始化输出，最后会显示/etc/issue的内容，并且getty要求你登录。</p>

<p>如果没有看到login信息，可能会提示按下Return或Enter键。</p>

<h3 id="7-2-重建console设置">7.2. 重建console设置</h3>

<p>用root用户登录serial console。前面我们删除了/etc/ioctl.save，现在要重新配置console，波特率为9600,8位数据位，无奇偶校验，1位停止位。</p>

<pre><code>remote.example.edu.au ttyS0 login: root  
Password: …  
sh# rm -f /etc/ioctl.save  
bash# telinit 1  
…Telling INIT to go to single user mode.  
INIT: Going single user  
INIT: Sending processes the TERM signal  
sh# stty sane -parenb cs8 crtscts brkint -istrip -ixoff -ixon  
</code></pre>

<p>结束单用户模式返回正常运行级别后，serial console的终端配置会保存到/etc/ioctl.save。</p>

<pre><code>sh# exit  
...  
bash# ls -l /etc/ioctl.save  
-rw------- 1 root root 60 Jan 1 00:00 /etc/ioctl.save  
</code></pre>

<p>当系统以单用户模式启动后，会使用/etc/ioctl.save。</p>

<h2 id="附录">附录：</h2>

<p>我的平台：</p>

<p>两台PC，一个安装Redhat 9，bootlloader为Grub 0.93，另一个安装WindowsXP,用超级终端作为serial console显示设备，用DB9头的串口通信线将二者COM1相连，只将两端的TX和RX信号交叉相连，其他信号都直连。</p>

<p>操作步骤：</p>

<ol>
<li><p>修改/boot/grub/grub.conf</p>

<p>添加：</p>

<pre><code>serial --unit=0 --speed=9600 --word=8 --parity=no --stop=1  
terminal --timeout=10 serial console  
</code></pre>

<p>在kernel后面添加参数：</p>

<pre><code>console=tty0 console=ttyS0,9600n8  
</code></pre></li>

<li><p>修改/etc/inittab</p>

<p>添加：</p>

<pre><code>co：2345：respawn：/sbin/agetty  -t 60 ttyS0 9600 vt100  
</code></pre></li>

<li><p>在XP系统上打开超级终端，波特率为9600，8位数据位，1位停止位，无奇偶校验，无数据流控制。然后重启Redhat9，在超级终端上即可看到内核和文件系统的启动信息，最后可以用普通用户登录，登录后可以用su root命令切换到root用户。这里有个问题还未解决，文件系统的信息只能在超级终端上显示，在Redhat9的屏幕上显示完内核启动信息后就暂停输出了，最后直接显示登录信息，待解决。</p></li>

<li><p>如果想让root用户通过serial console登录，需要修改/etc/securetty，在该文件的最后一行添加ttyS0，重启后即可在超级终端用root用户登录。</p></li>

<li><p>其他设置暂未测试。</p></li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>补丁的制作和使用</title>
            <link>https://shaocheng.li/posts/2011/07/15/</link>
            <pubDate>Fri, 15 Jul 2011 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2011/07/15/</guid>
            <description>原理 现在有一个文件file1，通过修改file1得到了文件file2，然后用diff工具比较file1和file2的差异，得到一个补丁文件file.patch，它记录了两个文件的不同之处，patch工具就可以根据这个补丁文件修改file1，从而得到file2。
相关工具 diff diff [options] 源文件 目标文件  diff用于列出两个文件的不同之处，指示如何由源文件变为目标文件，可以用重定向生成补丁文件，注意：diff只能用于比较文本文件。常用选项：
-c，输出一个基于上下文的diff，即提供每处修改的前后机会内容，这样patch命令可以在打补丁前验证上下文是否匹配，而补丁文件也更容易阅读。
-b，忽略空格引起的变化
-B，忽略插入/删除空行引起的变化
-i，忽略大小写
-N，在比较目录时，如果一个文件只在其中一个目录中找到，那它被视为在第二个目录中是一个空文件
-r，在比较目录时，递归比较所有子目录
-u，使用统一的输出格式
patch patch [options] 源文件 补丁文件  patch用于根据补丁文件修改源文件，它会直接改动源文件，打补丁前请注意备份。常用选项：
-R，反向补丁，将已经打了补丁的文件恢复到原来的样子
-p[num]，忽略前几层目录，目录的层数由num指定
例1：比较两个文件 file1:
this is line1 this is line2 this is line3 this is line4  file2：
this is line1 this is line2 hello this is line3 this is line4 this is line5  执行：
diff file1 file2 &amp;gt; file.patch  生成补丁文件file.patch：
2c2 &amp;lt; this is line2 --- &amp;gt; this is line2 hello 4a5 &amp;gt; this is line5  对file1打补丁：</description>
            <content type="html"><![CDATA[

<h2 id="原理">原理</h2>

<p>现在有一个文件file1，通过修改file1得到了文件file2，然后用diff工具比较file1和file2的差异，得到一个补丁文件file.patch，它记录了两个文件的不同之处，patch工具就可以根据这个补丁文件修改file1，从而得到file2。</p>

<h2 id="相关工具">相关工具</h2>

<pre><code>diff
diff [options] 源文件 目标文件
</code></pre>

<p>diff用于列出两个文件的不同之处，指示如何由源文件变为目标文件，可以用重定向生成补丁文件，注意：diff只能用于比较文本文件。常用选项：</p>

<p>-c，输出一个基于上下文的diff，即提供每处修改的前后机会内容，这样patch命令可以在打补丁前验证上下文是否匹配，而补丁文件也更容易阅读。</p>

<p>-b，忽略空格引起的变化</p>

<p>-B，忽略插入/删除空行引起的变化</p>

<p>-i，忽略大小写</p>

<p>-N，在比较目录时，如果一个文件只在其中一个目录中找到，那它被视为在第二个目录中是一个空文件</p>

<p>-r，在比较目录时，递归比较所有子目录</p>

<p>-u，使用统一的输出格式</p>

<pre><code>patch
patch [options]  源文件 补丁文件
</code></pre>

<p>patch用于根据补丁文件修改源文件，它会直接改动源文件，打补丁前请注意备份。常用选项：</p>

<p>-R，反向补丁，将已经打了补丁的文件恢复到原来的样子</p>

<p>-p[num]，忽略前几层目录，目录的层数由num指定</p>

<h2 id="例1-比较两个文件">例1：比较两个文件</h2>

<p>file1:</p>

<pre><code>this is line1  
this is line2   
this is line3  
this is line4  
</code></pre>

<p>file2：</p>

<pre><code>this is line1  
this is line2 hello  
this is line3  
this is line4  
this is line5  
</code></pre>

<p>执行：</p>

<pre><code>diff file1 file2 &gt; file.patch  
</code></pre>

<p>生成补丁文件file.patch：</p>

<pre><code>2c2  
&lt; this is line2   
---  
&gt; this is line2 hello  
4a5  
&gt; this is line5  
</code></pre>

<p>对file1打补丁：</p>

<pre><code>patch file1 file.patch  
</code></pre>

<p>file1的内容就变成了file2，如果想把file1变为原来的样子，执行：</p>

<pre><code>patch -R file1 file.patch  
</code></pre>

<h2 id="例2-比较两个目录">例2：比较两个目录</h2>

<p>在工作路径下有两个目录：doc1和doc2。</p>

<p>执行diff命令，生成补丁文件patch：</p>

<pre><code>diff -Nur doc1 doc2 &gt; doc.patch  
</code></pre>

<p>用patch工具为doc1打补丁：</p>

<pre><code>cd doc1  
patch -p1 &lt; ../doc.patch  
</code></pre>

<h2 id="参考">参考：</h2>

<p>用Diff和Patch工具维护源码： <a href="https://www.ibm.com/developerworks/cn/linux/l-diffp/" target="_blank">https://www.ibm.com/developerworks/cn/linux/l-diffp/</a></p>
]]></content>
        </item>
        
        <item>
            <title>关于C语言的位移操作</title>
            <link>https://shaocheng.li/posts/2011/07/08/</link>
            <pubDate>Fri, 08 Jul 2011 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2011/07/08/</guid>
            <description>下面这段代码会输出什么结果？
#include &amp;lt;stdio.h&amp;gt; int main() { printf(&amp;quot;%d\n&amp;quot;,( (i-sizeof(int)) &amp;gt;&amp;gt;32)); return 0; }  答案是 0
将代码修改如下：
#include &amp;lt;stdio.h&amp;gt; int main() { printf(&amp;quot;%d\n&amp;quot;,( (i-((int)sizeof(int))) &amp;gt;&amp;gt;32)); return 0; }  结果输出 -1
解析：
sizeof是一个操作符，它返回的结果是unsigned int。
对于无符号数：右移后，高位补0；
对于有符号数：正数，右移后高位补0；负数，右移后高位补1。
建议只对无符号数做位运行，减少出错的可能。
注意：移动的位数要小于做操作数的总位数，否则结果是undefined（虽然有时也会得到正确的结果）。</description>
            <content type="html"><![CDATA[<p>下面这段代码会输出什么结果？</p>

<pre><code>#include &lt;stdio.h&gt;  

int main()  
{  
    printf(&quot;%d\n&quot;,( (i-sizeof(int)) &gt;&gt;32));  
    return 0;  
}  
</code></pre>

<p>答案是 0</p>

<p>将代码修改如下：</p>

<pre><code>#include &lt;stdio.h&gt;  

int main()  
{  
    printf(&quot;%d\n&quot;,( (i-((int)sizeof(int))) &gt;&gt;32));  
    return 0;  
}  
</code></pre>

<p>结果输出 -1</p>

<p>解析：</p>

<p>sizeof是一个操作符，它返回的结果是unsigned int。</p>

<p>对于无符号数：右移后，高位补0；</p>

<p>对于有符号数：正数，右移后高位补0；负数，右移后高位补1。</p>

<p>建议只对无符号数做位运行，减少出错的可能。</p>

<p>注意：移动的位数要小于做操作数的总位数，否则结果是undefined（虽然有时也会得到正确的结果）。</p>
]]></content>
        </item>
        
        <item>
            <title>关于函数的指针参数</title>
            <link>https://shaocheng.li/posts/2011/07/01/</link>
            <pubDate>Fri, 01 Jul 2011 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2011/07/01/</guid>
            <description>先做一道题目：
#include &amp;lt;stdio.h&amp;gt; int f(int *p) { static int i = 5; p=&amp;amp;i; return 0; } int main(void) { int *p; f(p); printf(&amp;quot;p = %d/n&amp;quot;,*p); return 0; }  该程序的输出结果是多少？
有人会认为输出的是“p = 5”，其实应该是一个不确定的数。
为了弄清为什么，先看下一个例子：
#include &amp;lt;stdio.h&amp;gt; int main(void) { int i=0x01; int *p=&amp;amp;i; printf(&amp;quot;&amp;amp;i = %x/n&amp;quot;,&amp;amp;i); //i的地址 printf(&amp;quot;p = %x/n&amp;quot;,p); printf(&amp;quot;*p = %x/n&amp;quot;,*p); printf(&amp;quot;&amp;amp;p = %x/n&amp;quot;,&amp;amp;p); return 0; }  执行结果：
&amp;amp;i = bfffe924 p = bfffe924 *p = 1 &amp;amp;p = bfffe920  解析：</description>
            <content type="html"><![CDATA[<p>先做一道题目：</p>

<pre><code>#include &lt;stdio.h&gt;  
int f(int *p)  
{  
    static int i = 5;  
    p=&amp;i;  
    return 0;  
}  
int main(void)  
{  
    int *p;  
    f(p);  
    printf(&quot;p = %d/n&quot;,*p);  
    return 0;  
}  
</code></pre>

<p>该程序的输出结果是多少？</p>

<p>有人会认为输出的是“p = 5”，其实应该是一个不确定的数。</p>

<p>为了弄清为什么，先看下一个例子：</p>

<pre><code>#include &lt;stdio.h&gt;  
int main(void)  
{  
    int i=0x01;  
    int *p=&amp;i;  
    printf(&quot;&amp;i = %x/n&quot;,&amp;i);   //i的地址  
    printf(&quot;p = %x/n&quot;,p);  
    printf(&quot;*p = %x/n&quot;,*p);  
    printf(&quot;&amp;p = %x/n&quot;,&amp;p);  
    return 0;  
}  
</code></pre>

<p>执行结果：</p>

<pre><code>&amp;i = bfffe924
p = bfffe924
*p = 1
&amp;p = bfffe920
</code></pre>

<p>解析：</p>

<p>指针占4Byte，存放着它所指向的数据的地址。P是一个指向int型变量i的指针，所以p表示该指针的内容，也就是i的地址；*p表示p指向的内容，就是i；&amp;p代表指针p本身的地址。</p>

<p>再看第一道题，main函数里的p和f函数的参数p都是指向int型的指针，当 main 函数调用f函数时：f(p),传递给f函数的是main函数中的p的内容，因为p没有初始化，所以它的内容是一个不确定的地址，所以，f函数中的p指向了这个不确定地址。</p>

<p>怎样才能让 main 函数中的p指向f函数中的静态变量i呢？</p>

<p>将程序做如下修改即可：</p>

<pre><code>#include &lt;stdio.h&gt;  
int f(int **p)  
{  
    static int i = 5;  
    *p=&amp;i;  
    return 0;  
}  
int main(void)  
{  
    int i=0x01;  
    int *p=&amp;i;  
    f(&amp;p);  
    printf(&quot;p = %d/n&quot;,*p);  
    return 0;  
}
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>神级排序算法</title>
            <link>https://shaocheng.li/posts/2011/06/28/</link>
            <pubDate>Tue, 28 Jun 2011 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2011/06/28/</guid>
            <description>下面是一个排序算法，用shell实现的：
sleepsort.sh
#!/bin/bash function f() { sleep &amp;quot;$1&amp;quot; echo &amp;quot;$1&amp;quot; } while [ -n &amp;quot;$1&amp;quot; ] do f &amp;quot;$1&amp;quot; &amp;amp; shift done wait  用法：
./sleepsort.sh 5 3 6 3 6 3 1 4 7  这个算法太NB、太BT、太搞笑了！
神马冒泡、插入、归并&amp;hellip; 全是浮云啊！
膜拜吧！
详情可见酷壳原文：http://coolshell.cn/articles/4883.html
佩服之余，我在linux下用C语言实现了一把：
sleepsort.c
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;pthread.h&amp;gt; void *f(void *opt) { sleep((*((int *)opt))); printf(&amp;quot;%d,&amp;quot;,(*((int *)opt))); pthread_exit(0); } int main() { const int len=5; pthread_t a_thread[5]; int array[5]={3,5,2,4,1}; int i=0; while(i&amp;lt;len) { pthread_create(&amp;amp;(a_thread[i]),NULL,f,&amp;amp;(array[i])); i++; } i=0; while(i&amp;lt;len) { pthread_join(a_thread[i],0); i++; } printf(&amp;quot;/n&amp;quot;); return 0; }  编译：</description>
            <content type="html"><![CDATA[<p>下面是一个排序算法，用shell实现的：</p>

<p>sleepsort.sh</p>

<pre><code>#!/bin/bash   

function f()   
{       
    sleep &quot;$1&quot;      
    echo &quot;$1&quot;  
}   
while [ -n &quot;$1&quot; ]   
do      
f &quot;$1&quot; &amp;       
shift  
done  
wait   
</code></pre>

<p>用法：</p>

<pre><code>./sleepsort.sh 5 3 6 3 6 3 1 4 7
</code></pre>

<p>这个算法太NB、太BT、太搞笑了！</p>

<p>神马冒泡、插入、归并&hellip;  全是浮云啊！</p>

<p>膜拜吧！</p>

<p>详情可见酷壳原文：<a href="http://coolshell.cn/articles/4883.html" target="_blank">http://coolshell.cn/articles/4883.html</a></p>

<p>佩服之余，我在linux下用C语言实现了一把：</p>

<p>sleepsort.c</p>

<pre><code>#include &lt;stdio.h&gt;  
#include &lt;unistd.h&gt;  
#include &lt;pthread.h&gt;  
void *f(void *opt)  
{  
    sleep((*((int *)opt)));  
    printf(&quot;%d,&quot;,(*((int *)opt)));  
    pthread_exit(0);  
}  
int main()  
{  
    const int len=5;  
    pthread_t a_thread[5];  
    int array[5]={3,5,2,4,1};  
    int i=0;  

    while(i&lt;len)  
    {  
    pthread_create(&amp;(a_thread[i]),NULL,f,&amp;(array[i]));  
    i++;  
    }  
    i=0;  
    while(i&lt;len)  
    {  
    pthread_join(a_thread[i],0);  
    i++;  
    }  
    printf(&quot;/n&quot;);  

    return 0;  
}  
</code></pre>

<p>编译：</p>

<pre><code>gcc  -Wall  -o  sleepsort  sleepsort.c   -lpthread
</code></pre>

<p>执行：</p>

<pre><code>./sleepsort
1,2,3,4,5,
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>Unicode编码字符的点阵显示</title>
            <link>https://shaocheng.li/posts/2011/06/13/</link>
            <pubDate>Mon, 13 Jun 2011 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2011/06/13/</guid>
            <description>对于unicode编码的字符，可以先将unicode编码转换为GBK编码，然后利用GBK点阵字库（gbk.bin)显示字符。一个比较好的编码转换方法是，制作一个按照unicode编码顺序排列的GBK编码表，直接根据unicode编码就可以查到对应的GBK编码，具体的制作方法如下：
1.生成一个unicode字符文件 上以篇文章中已经制作了一个GBK编码的全字符文件gbk.txt，用记事本打开gbk.txt，然后以unicode编码另存为unicode.txt文件。
这样的话，所有的GBK编码字符都用unicode编码保存在unicode.txt中了，可以用winhex打开unicode.txt，会发现前两个字节是FFFE，这是unicode编码的标识，要注意后面的unicode编码是小端存储。
2.制作unicode转gbk的文件 这里要用程序制作一个unicode与gbk编码相对应的文件，该文件每四个字节为一组，其中前两个字节为unicode编码，后两个字节是对应的gbk编码，两种编码都以小端存储，数据结构如下：
union code { unsigned int unigbk; unsigned short int uni_gbk[2]; unsigned char buffer[4]; };  这个数据结构是以gbk编码的顺序存放在文件uni2gbk.txt中，文件大小为128764Byte。程序如下：
//由unicode.txt和gbk.txt生成uni2gbk.txt #include &amp;lt;stdio.h&amp;gt; int main(void) { unsigned char buffer[2]; int count=0; FILE *fup=0; FILE *fgp=0; FILE *fwp=0; fup=fopen(&amp;quot;unicode.txt&amp;quot;,&amp;quot;rb&amp;quot;); fgp=fopen(&amp;quot;gbk.txt&amp;quot;,&amp;quot;rb&amp;quot;); fwp=fopen(&amp;quot;uni2gbk.txt&amp;quot;,&amp;quot;wb&amp;quot;); fgetc(fup); fgetc(fup); while(1) { //读取unicode编码，写入uni2gbk.txt buffer[0]=fgetc(fup); buffer[1]=fgetc(fup); fputc(buffer[0],fwp); fputc(buffer[1],fwp); //读取gbk编码，写入uni2gbk.txt buffer[0]=fgetc(fgp); buffer[1]=fgetc(fgp); fputc(buffer[1],fwp); fputc(buffer[0],fwp); count+=2; if(count==0xfb7c) printf(&amp;quot;xxxxxxxxx/n&amp;quot;); if(buffer[0]==0xfe &amp;amp;&amp;amp; buffer[1]==0xfe) { printf(&amp;quot;count = %x/n&amp;quot;,count); fclose(fup); fclose(fgp); fclose(fwp); return; } } return 0； }  3.</description>
            <content type="html"><![CDATA[

<p>对于unicode编码的字符，可以先将unicode编码转换为GBK编码，然后利用GBK点阵字库（gbk.bin)显示字符。一个比较好的编码转换方法是，制作一个按照unicode编码顺序排列的GBK编码表，直接根据unicode编码就可以查到对应的GBK编码，具体的制作方法如下：</p>

<h2 id="1-生成一个unicode字符文件">1.生成一个unicode字符文件</h2>

<p>上以篇文章中已经制作了一个GBK编码的全字符文件gbk.txt，用记事本打开gbk.txt，然后以unicode编码另存为unicode.txt文件。</p>

<p>这样的话，所有的GBK编码字符都用unicode编码保存在unicode.txt中了，可以用winhex打开unicode.txt，会发现前两个字节是FFFE，这是unicode编码的标识，要注意后面的unicode编码是小端存储。</p>

<h2 id="2-制作unicode转gbk的文件">2.制作unicode转gbk的文件</h2>

<p>这里要用程序制作一个unicode与gbk编码相对应的文件，该文件每四个字节为一组，其中前两个字节为unicode编码，后两个字节是对应的gbk编码，两种编码都以小端存储，数据结构如下：</p>

<pre><code>union code

{

unsigned int unigbk;

unsigned short int uni_gbk[2];

unsigned char buffer[4];

};
</code></pre>

<p>这个数据结构是以gbk编码的顺序存放在文件uni2gbk.txt中，文件大小为128764Byte。程序如下：</p>

<pre><code>//由unicode.txt和gbk.txt生成uni2gbk.txt
#include &lt;stdio.h&gt;

int main(void)
{
    unsigned char buffer[2];
    int count=0;

    FILE *fup=0;
    FILE *fgp=0;
    FILE *fwp=0;

    fup=fopen(&quot;unicode.txt&quot;,&quot;rb&quot;);
    fgp=fopen(&quot;gbk.txt&quot;,&quot;rb&quot;);
    fwp=fopen(&quot;uni2gbk.txt&quot;,&quot;wb&quot;);

    fgetc(fup);
    fgetc(fup);

    while(1)
    {
        //读取unicode编码，写入uni2gbk.txt
        buffer[0]=fgetc(fup);
        buffer[1]=fgetc(fup);
        fputc(buffer[0],fwp);
        fputc(buffer[1],fwp);
        //读取gbk编码，写入uni2gbk.txt
        buffer[0]=fgetc(fgp);
        buffer[1]=fgetc(fgp);
        fputc(buffer[1],fwp);
        fputc(buffer[0],fwp);

        count+=2;
        if(count==0xfb7c)
            printf(&quot;xxxxxxxxx/n&quot;);


        if(buffer[0]==0xfe &amp;&amp; buffer[1]==0xfe)
        {
            printf(&quot;count = %x/n&quot;,count);

            fclose(fup);
            fclose(fgp);
            fclose(fwp);

            return;
        }
    }
    return 0；
}
</code></pre>

<h2 id="3-将uni2gbk-txt排序">3.将uni2gbk.txt排序</h2>

<p>用程序将uni2gbk.txt文件中的union code数据结构按照unicode编码的顺序从小到大排序，程序如下：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAXSIZE (0x7DBF)  //union code的个数

union code
{
    unsigned int unigbk;
    unsigned short int uni_gbk[2];
    unsigned char buffer[4];
};


int main(void)
{
    unsigned char flag=1;

    unsigned int i=0;
    unsigned int j=0;

    union code pdata;
    union code ndata;

    FILE *fp=0;

    fp = fopen(&quot;uni2gbk.txt&quot;,&quot;rb+&quot;);

    for(i=1; i&lt;MAXSIZE &amp;&amp; flag==1; i++)
    {
        flag=0;

        for(j=0; j&lt;(MAXSIZE-i); j++)
        {
            fseek(fp,j*4,0);
            fread(pdata.buffer,1,4,fp);
            fseek(fp,j*4+4,0);
            fread(ndata.buffer,1,4,fp);

            if(pdata.uni_gbk[0]&gt;ndata.uni_gbk[0])
            {
                flag=1;

                fseek(fp,j*4,0);
                fwrite(ndata.buffer,4,1,fp);
                fseek(fp,j*4+4,0);
                fwrite(pdata.buffer,4,1,fp);

            }

        }

        printf(&quot;i=%d/n&quot;,i);
    }

    fclose(fp);

}
</code></pre>

<p>排序后，为了与没有排序的uni2gbk.txt区分，将文件名改为uni2gbkp.txt。</p>

<h2 id="4-删除无用的编码">4.删除无用的编码</h2>

<p>用winhex打开uni2gbkp.txt，可以发现，从0到第0x80EB个字节中的unicode编码都是0x0020或0x003F，这些都是无用的编码，它们所对应的gbk编码也是无用的，都可以删除。</p>

<p>删除后，uni2gbkp.txt文件中的union code数据结构的unicode编码就是从0x00A4开始，以0xFFE5结束。但是这些unicode编码不是连续的，例如0x00A4之后就是0x00A7，为了方便查找，需要在不连续的编码中间用union code填充，对应的gbk编码部分用0x0000填充，然后将union code中的unicode编码全部删除。最后生成uni2gbk.bin文件。程序如下：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

union code
{
    unsigned int unigbk;
    unsigned short int uni_gbk[2];
    unsigned char buffer[4];
};

int main()
{
    unsigned short int count=0x00A4;  //从unicode的0x00A4开始
    union code temp;

    FILE *frp=0;
    FILE *fwp=0;

    frp=fopen(&quot;uni2gbkp.txt&quot;,&quot;rb&quot;);
    fwp=fopen(&quot;uni2gbk.bin&quot;,&quot;wb&quot;);

    fseek(frp,0x80EC,SEEK_SET);  //舍弃uni2gbkp.txt文件的前0x80EC个字节
    fread(temp.buffer,1,4,frp);

    while(count&lt;=0xffe5) //以unicode的0xffe5结束
    {
        if(temp.uni_gbk[0]==count)     //判断unicode编码是否连续
        {
            fputc(temp.buffer[2],fwp);  //将对应的gbk编码写入uni2gbk.bin
            fputc(temp.buffer[3],fwp);
            fread(temp.buffer,1,4,frp);
        }
        else                        //不连续的地方填充0
        {
            fputc(0x00,fwp);
            fputc(0x00,fwp);
        }

        count++;
    }
    fclose(frp);
    fclose(fwp);
    return 0;
}
</code></pre>

<p>生成的uni2gbk.bin文件中都是gbk编码，这些gbk编码都是按照对应的unicode编码（0x00A4到0xFFE5）的顺序排列的。</p>

<h2 id="5-uni2gbk-bin的使用">5.uni2gbk.bin的使用</h2>

<p>假设一个字符的unicode编码为X，那么它对应的gbk编码在uni2gbk.bin文件中的位置就是：</p>

<p>（X-0x00A4）*2</p>

<p>从这个位置读取一个unsigned short int数据，就是它的gbk码。然后利用GBK点阵字库（gbk.bin）即可显示。</p>

<p>例如，以Linux的终端模拟点阵屏幕，程序如下：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;curses.h&gt;

#define START 0x8140
#define DATANUM 0x20

int displaychar(FILE *fp,unsigned short int dispch,char fillch,char start_x,char start_y);

int main(void)
{
    FILE * fp=0;
    unsigned short int testch = 0x7231;  //汉字'爱‘的unicode码
    unsigned short int gbkch=0;       //存放testch的gbk编码

    //将unicode转换为gbk
    fp = fopen(&quot;uni2gbk.bin&quot;,&quot;rb&quot;);
    fseek(fp,(testch-0x00A4)*((unsigned int)2),SEEK_SET);

    gbkch = fgetc(fp);
    gbkch = (fgetc(fp)&lt;&lt;8) + gbkch;

    fclose(fp);

    fp = fopen(&quot;gbk.bin&quot;,&quot;rb&quot;);

    initscr();

    displaychar(fp,gbkch,'*',0,0);

    refresh();

    while(1);
    endwin();

    fclose(fp);
    return 0;
}

/*
 * fp指向点阵字库二进制文件
 * 以点阵方式显示一个GBK字符
 * dispch是要显示的字符，fillch是填充点阵的字符
 * start_x,start_y是显示的起始坐标
 */
int displaychar(FILE *fp,unsigned short int dispch,char fillch,char start_x,char start_y)
{
    char x=start_x;
    char y=start_y;
    unsigned int location=(dispch-START)*DATANUM;

    int i=0;
    int j=0;
    char buf=0;

    fseek(fp,location,SEEK_SET);

    for(i=0;i&lt;DATANUM;i++)
    {
        buf=fgetc(fp);

        //显示一个字节
        for(j=0;j&lt;8;j++)
        {
            move(y+j,x);
            if( buf &amp; (0x01&lt;&lt;j) )
            {
                addch(fillch);
            }
        }

        if(x == (start_x+15))
        {
            x=start_x;
            y=start_y+8;
        }
        else
            x++;
    }
    return 0;

}
</code></pre>

<h2 id="下载">下载：</h2>

<p>unicode点阵字库文件：<a href="http://download.csdn.net/source/3362591" target="_blank">http://download.csdn.net/source/3362591</a></p>
]]></content>
        </item>
        
        <item>
            <title>GBK点阵显示字库的制作和使用</title>
            <link>https://shaocheng.li/posts/2011/06/12/</link>
            <pubDate>Sun, 12 Jun 2011 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2011/06/12/</guid>
            <description>GBK编码共收录汉字21003个、符号883个，并提供1894个造字码位，简、繁体字融于一库。以两个字节表示一个汉字，编码范围是0x8140~0xfefe，兼容GB2318，并覆盖了unicode中的所有汉字。Win7记事本默认以GBK保存汉字。
关于GBK的详细信息：http://baike.baidu.com/view/25421.htm
开发环境:
Win7、Eclipse、MinGW
1.生成GBK全字符文件 运行下面这段代码，生成GBK全字符文件gbk.txt,编码范围0x8140~0xfefe。
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; int main(void) { FILE *fp=0; char ch=0; unsigned short int start=0x8140; unsigned char part1=0; unsigned char part2=0; fp=fopen(&amp;quot;gbk.txt&amp;quot;,&amp;quot;wb&amp;quot;); if(fp==NULL) { perror(&amp;quot;Cann&#39;t open gbk.txt&amp;quot;); return -1; } else printf(&amp;quot;Creat file gbk.txt/n&amp;quot;); while(start &amp;lt; 0xfeff) { part1=start&amp;gt;&amp;gt;8; part2=start; fputc(part1,fp); fputc(part2,fp); start++; } fclose(fp); printf(&amp;quot;success!&amp;quot;); return 0; }  运行后，用记事本打开gbk.txt文件，可以看到其中的字符。
2.生成字模二进制文件 用“牧码字模”软件打开gbk.txt文件，选择字体为宋体，字重为1，点阵大小16*16，对齐方式为左下，取模方式为“纵向取模、高位在下”。输出格式选择bin。然后点击输出，会生成一个temp.bin文件，改名为gbk.bin。
gbk.bin文件就是GBK编码字符的点阵字库文件，每32个字节可以绘制一个字符，例如第一个字符‘丂’的显示如下：
取模的数据为：
0x02, 0x02, 0x02, 0xc2, 0xb2, 0x8e, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x80, 0x40, 0x3f, 0x00, 0x00, 0x00, 0x00,</description>
            <content type="html"><![CDATA[

<p>GBK编码共收录汉字21003个、符号883个，并提供1894个造字码位，简、繁体字融于一库。以两个字节表示一个汉字，编码范围是0x8140~0xfefe，兼容GB2318，并覆盖了unicode中的所有汉字。Win7记事本默认以GBK保存汉字。</p>

<p>关于GBK的详细信息：<a href="http://baike.baidu.com/view/25421.htm" target="_blank">http://baike.baidu.com/view/25421.htm</a></p>

<p>开发环境:</p>

<p>Win7、Eclipse、MinGW</p>

<h2 id="1-生成gbk全字符文件">1.生成GBK全字符文件</h2>

<p>运行下面这段代码，生成GBK全字符文件gbk.txt,编码范围0x8140~0xfefe。</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    FILE *fp=0;
    char ch=0;
    unsigned short int start=0x8140;
    unsigned char part1=0;
    unsigned char part2=0;

    fp=fopen(&quot;gbk.txt&quot;,&quot;wb&quot;);
    if(fp==NULL)
    {
        perror(&quot;Cann't open gbk.txt&quot;);
        return -1;
    }
    else
        printf(&quot;Creat file gbk.txt/n&quot;);
    while(start &lt; 0xfeff)
    {
        part1=start&gt;&gt;8;
        part2=start;
        fputc(part1,fp);
        fputc(part2,fp);
        start++;
    }
    fclose(fp);
    printf(&quot;success!&quot;);

    return 0;
}
</code></pre>

<p>运行后，用记事本打开gbk.txt文件，可以看到其中的字符。</p>

<h2 id="2-生成字模二进制文件">2.生成字模二进制文件</h2>

<p>用“牧码字模”软件打开gbk.txt文件，选择字体为宋体，字重为1，点阵大小16*16，对齐方式为左下，取模方式为“纵向取模、高位在下”。输出格式选择bin。然后点击输出，会生成一个temp.bin文件，改名为gbk.bin。</p>

<p>gbk.bin文件就是GBK编码字符的点阵字库文件，每32个字节可以绘制一个字符，例如第一个字符‘丂’的显示如下：</p>

<p><img src="/images/2011-06-12/2011-06-12_1.JPG" alt="" /></p>

<p>取模的数据为：</p>

<p>0x02, 0x02, 0x02, 0xc2, 0xb2, 0x8e, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x80, 0x40, 0x3f, 0x00, 0x00, 0x00, 0x00,</p>

<h2 id="3-使用字库文件">3.使用字库文件</h2>

<p>gbk.bin文件中按GBK编码的大小排列，每32个字节可以显示一个字符，假设一个字符的GBK编码为NUM，那么它的点阵数据第一个字节的位置就是：</p>

<p>（NUM-0x8240）*32</p>

<p>从这个字节开始，读取32个字节，将其按按照取模方式显示即可。</p>

<p>例如：用Linux的终端模拟点阵屏幕，每个字符位置就是一个点，程序如下：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;curses.h&gt;

#define START 0x8140
#define DATANUM 0x20

int displaychar(FILE *fp,unsigned short int dispch,char fillch,char start_x,char start_y);

int main(void)
{
    FILE * fp=0;
    unsigned short int testch = 0xb0ae;  //汉字'爱‘的gbk码

    fp = fopen(&quot;gbk.bin&quot;,&quot;rb&quot;);

    initscr();

    displaychar(fp,testch,'*',0,0);

    refresh();

    while(1);
    endwin();
    fclose(fp);
    return 0;
}

/*
 * fp指向点阵字库二进制文件
 * 以点阵方式显示一个GBK字符
 * dispch是要显示的字符，fillch是填充点阵的字符
 * start_x,start_y是显示的起始坐标
 */
int displaychar(FILE *fp,unsigned short int dispch,char fillch,char start_x,char start_y)
{
    char x=start_x;
    char y=start_y;
    unsigned int location=(dispch-START)*DATANUM;

    int i=0;
    int j=0;
    char buf=0;

    fseek(fp,location,SEEK_SET);

    for(i=0;i&lt;DATANUM;i++)
    {
        buf=fgetc(fp);

        //显示一个字节
        for(j=0;j&lt;8;j++)
        {
            move(y+j,x);
            if( buf &amp; (0x01&lt;&lt;j) )
            {
                addch(fillch);
            }
        }

        if(x == (start_x+15))
        {
            x=start_x;
            y=start_y+8;
        }
        else
            x++;
    }
    return 0;

}
</code></pre>

<p>显示效果如下：</p>

<p><img src="/images/2011-06-12/2011-06-12_2.JPG" alt="" /></p>

<h2 id="下载">下载：</h2>

<p>字库文件：<a href="http://download.csdn.net/source/3359198" target="_blank">http://download.csdn.net/source/3359198</a>
字模提取软件：<a href="http://download.csdn.net/source/3358791" target="_blank">http://download.csdn.net/source/3358791</a></p>
]]></content>
        </item>
        
        <item>
            <title>ASCII字符点阵字库的制作和使用</title>
            <link>https://shaocheng.li/posts/2011/06/08/</link>
            <pubDate>Wed, 08 Jun 2011 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2011/06/08/</guid>
            <description>开发环境：
Win7，Eclipse，MinGW
#1.生成ASCII字符文件
ASCII编码的可打印字符是0x20~0x7E,先用运行下面这段代码，生成一个包含全部可打印字符的txt文件：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; int main(int argc,char *argv[]) { FILE * fp; unsigned char i = 0; fp = fopen(&amp;quot;ascii.txt&amp;quot;,&amp;quot;w&amp;quot;); if(fp == 0) { perror(&amp;quot;open&amp;quot;); return -1; } for(i=0x20;i&amp;lt;0x7F;i++) { fputc(i,fp); } return 0; }  运行后，用记事本打开ascii.txt文件，会看到如下文本：
#2.生成字模数据
使用字模提取V2.1软件，设置字体为宋体、12，纵向取模，字节倒序（即高位在下）。这些设置可以根据实际情况设置。用C51格式生成字模，大小是8*16，每个字符用16个字节表示。如字符A的显示如下：
取模数据为：
0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20,
然后将所有的字模数据复制到一个文本文件，删除其中的空行，换行，注释等与字模数据无关的内容，并将文件最后的一个逗号改为ASCII字符的句号，得到一个纯字模数据文件ascii_zk.txt
#3.将字模数据文件转换为二进制文件
将ascii_zk.txt文件中的每个字模数据转换为占一个字节的数，将所有的数据填充为一个二进制文件ascii_zk.bin。这样，按照ASCII码的顺序，ascii_zk.bin中每16个字节就可以绘制一个字符。文件转换的程序如下：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; /* *将一个ascii字符转换为数 */ unsigned char c2x(char ch) { unsigned char temp=0; if(ch&amp;gt;=0x30 &amp;amp;&amp;amp; ch&amp;lt;=0x39) temp = ch-0x30; else if(ch&amp;gt;=0x41 &amp;amp;&amp;amp; ch&amp;lt;=0x46) temp = 0x0a+(ch-0x41); else if(ch&amp;gt;=0x61 &amp;amp;&amp;amp; ch&amp;lt;=0x66) temp = 0x0a+(ch-0x61); else temp =0xff; return temp; } //将ascii_zk.</description>
            <content type="html"><![CDATA[<p>开发环境：</p>

<p>Win7，Eclipse，MinGW</p>

<p>#1.生成ASCII字符文件</p>

<p>ASCII编码的可打印字符是0x20~0x7E,先用运行下面这段代码，生成一个包含全部可打印字符的txt文件：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc,char *argv[])
{
    FILE * fp;
    unsigned char i = 0;

    fp = fopen(&quot;ascii.txt&quot;,&quot;w&quot;);
    if(fp == 0)
    {
        perror(&quot;open&quot;);
        return -1;
    }
    for(i=0x20;i&lt;0x7F;i++)
    {
        fputc(i,fp);
    }

    return 0;
}
</code></pre>

<p>运行后，用记事本打开ascii.txt文件，会看到如下文本：</p>

<p><img src="/images/2011-06-08/2011-06-08_1.JPG" alt="" /></p>

<p>#2.生成字模数据</p>

<p>使用字模提取V2.1软件，设置字体为宋体、12，纵向取模，字节倒序（即高位在下）。这些设置可以根据实际情况设置。用C51格式生成字模，大小是8*16，每个字符用16个字节表示。如字符A的显示如下：</p>

<p><img src="/images/2011-06-08/2011-06-08_2.JPG" alt="" /></p>

<p>取模数据为：</p>

<p>0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20,</p>

<p>然后将所有的字模数据复制到一个文本文件，删除其中的空行，换行，注释等与字模数据无关的内容，并将文件最后的一个逗号改为ASCII字符的句号，得到一个纯字模数据文件ascii_zk.txt</p>

<p>#3.将字模数据文件转换为二进制文件</p>

<p>将ascii_zk.txt文件中的每个字模数据转换为占一个字节的数，将所有的数据填充为一个二进制文件ascii_zk.bin。这样，按照ASCII码的顺序，ascii_zk.bin中每16个字节就可以绘制一个字符。文件转换的程序如下：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
/*
 *将一个ascii字符转换为数
 */
unsigned char c2x(char ch)
{
    unsigned char temp=0;
    if(ch&gt;=0x30 &amp;&amp; ch&lt;=0x39)
        temp = ch-0x30;
    else if(ch&gt;=0x41 &amp;&amp; ch&lt;=0x46)
        temp = 0x0a+(ch-0x41);
    else if(ch&gt;=0x61 &amp;&amp; ch&lt;=0x66)
        temp = 0x0a+(ch-0x61);
    else
        temp =0xff;
    return temp;
}
//将ascii_zk.txt转换为二进制文件
int main(void)
{
    char buffer[5];
    unsigned char ch=0;

    int i=0;

    FILE *frp=0;
    FILE *fwp=0;

    for(i=0; i&lt;5; i++)
        buffer[i] = 0;

    frp=fopen(&quot;ascii_zk.txt&quot;,&quot;r&quot;);
    fwp=fopen(&quot;ascii_zk.bin&quot;,&quot;w&quot;);

    while(buffer[4] != 0x2e) //全部数据以句号结尾
    {
        for(i=0; i&lt;5; i++)
            buffer[i]=fgetc(frp);
        ch = c2x(buffer[2]);
        ch = ch*16;
        ch = ch+c2x(buffer[3]);

        fputc(ch,fwp);

    }

    fclose(frp);
    fclose(fwp);

    return 0;
}
</code></pre>

<p>字库文件制作完毕。</p>

<p>#4.字库文件ascii_zk.bin的使用</p>

<p>ascii_zk.bin文件从ASCII码的空格（0x20）开始，每16个字节表示一个字符的点阵字模。以字母A为例，它的ASCII码是0x41，那么，它的字模数据的开始位置就是：</p>

<p>（0x41-0x20）*16</p>

<p>从这个位置开始依次读取16个字节，就是字母A的字模数据，将其显示即可。</p>

<p>例：用Linux的终端模拟显示点阵字符，终端屏幕中的每个字符位置就是一个点，程序如下。</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;curses.h&gt;

#define START 0x20
#define DATANUM 0x10

int displaychar(FILE *fp,char dispch,char fillch,char start_x,char start_y);

int main(void)
{
    FILE* fp=0;

    int i = 0;
    const char * teststring=&quot;I love Julia&quot;;

    fp=fopen(&quot;ascii_zk.bin&quot;,&quot;r&quot;);


    initscr();

    for(i=0;(teststring[i]!=0);i++)
    {
        displaychar(fp,teststring[i],'*',0+(i*8),0);
    }

    refresh();

    while(1);

    endwin();
    fclose(fp);
    return 0;
}

/*
 * 以点阵方式显示一个ASCII字符
 * dispch是要显示的字符，fillch是填充点阵的字符
 * start_x,start_y是显示的起始坐标
 */

int displaychar(FILE *fp,char dispch,char fillch,char start_x,char start_y)
{
    int location = ((dispch-START) * DATANUM);
    char x=start_x;
    char y=start_y;

    int i=0;
    int j=0;
    char buf=0;

    //将文件流指针移到到dispch字符点阵数据的起始位置
    fseek(fp,location,SEEK_SET);

    for(i=0;i&lt;DATANUM;i++)
    {
        buf = fgetc(fp);

        //显示一个字节
        for(j=0;j&lt;8;j++)
        {
            move(y+j,x);
            if(buf &amp; (0x01&lt;&lt;j))
                addch(fillch);
        }

        if(x == (start_x+7))
        {
            x = start_x;
            y = (start_y+8);
        }
        else
        {
            x++;
        }
    }

    return 0;
}
</code></pre>

<p>该程序在Fedora12的终端中运行，效果如下：</p>

<p><img src="/images/2011-06-08/2011-06-08_3.JPG" alt="" /></p>

<p>#下载：</p>

<p><a href="http://download.csdn.net/source/3349413" target="_blank">ASCII点阵字库文件</a></p>
]]></content>
        </item>
        
        <item>
            <title>用getopt处理main函数的参数</title>
            <link>https://shaocheng.li/posts/2011/05/28/</link>
            <pubDate>Sat, 28 May 2011 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2011/05/28/</guid>
            <description>环境：Fedora12 Gcc4.4.2
在C语言中，main函数的声明如下：
int main（int argc，char *argv[]);  argc是指程序参数的个数，包括程序名本身，如果程序不带参数，argc为1；
argv的每个数组元素存放一个程序参数，程序名存放在argv[0];
例如：
$ ls -l  此时，argc为2，argv[0]是ls，argv[1]是-l。
程序的参数可以分为三种：选项，选项的关联值，非选项参数。例如：
$gcc hello.c -o hello  hello.c是非选项参数，-o是选项，hello是-o选项的关联值。
根据Linux的惯例，程序的选项应该以一个短横线开头，后面包含单个字母或数字，选项分为两种：带关联值的和不带关联值的，例如：
$gcc hello.c -o hello  选项-o必须带一个关联值。
$ls -l  选项-l无需带参数。
不带关联值的选项应该可以在一个短横线后合并使用，例如：
$ls -la  Linux系统提供了getopt函数，它用来按照上述规则处理程序的参数，相关定义如下：
#include &amp;lt;unistd.h&amp;gt; int getopt(int argc,char *const argv[],const char *optstring); extern char *optarg; extern int optind,opterr,optopt;  getopt 使用 main 函数的 argc 和 argv 作为前两个参数，optsting 是一个字符列表，每个字符代表一个单字符选项，如果一个字符后面紧跟以冒号（：），表示该字符有一个关联值作为下一个参数；
getopt的返回值是argv数组中的下一个选项参数，由optind记录argv数组的下标,如果选项参数处理完毕，函数返回-1；
如果遇到一个无法识别的选项，返回问号（？），并保存在optopt中；
如果一个选项需要一个关联值，而程序执行时没有提供，返回一个问号（？）,如果将optstring的第一个字符设为冒号（:),这种情况下，函数会返回冒号而不是问号。
选项参数处理完毕后，optind 会指向 argv 数组尾部的其他非选项参数。实际上，getopt 在执行过程中会重排 argv 数组，将非选项参数移到数组的尾部。</description>
            <content type="html"><![CDATA[<p>环境：Fedora12  Gcc4.4.2</p>

<p>在C语言中，main函数的声明如下：</p>

<pre><code>int main（int argc，char *argv[]);
</code></pre>

<p>argc是指程序参数的个数，包括程序名本身，如果程序不带参数，argc为1；</p>

<p>argv的每个数组元素存放一个程序参数，程序名存放在argv[0];</p>

<p>例如：</p>

<pre><code>$ ls -l
</code></pre>

<p>此时，argc为2，argv[0]是ls，argv[1]是-l。</p>

<p>程序的参数可以分为三种：选项，选项的关联值，非选项参数。例如：</p>

<pre><code>$gcc hello.c -o hello  
</code></pre>

<p>hello.c是非选项参数，-o是选项，hello是-o选项的关联值。</p>

<p>根据Linux的惯例，程序的选项应该以一个短横线开头，后面包含单个字母或数字，选项分为两种：带关联值的和不带关联值的，例如：</p>

<pre><code>$gcc hello.c -o hello
</code></pre>

<p>选项-o必须带一个关联值。</p>

<pre><code>$ls -l
</code></pre>

<p>选项-l无需带参数。</p>

<p>不带关联值的选项应该可以在一个短横线后合并使用，例如：</p>

<pre><code>$ls -la
</code></pre>

<p>Linux系统提供了getopt函数，它用来按照上述规则处理程序的参数，相关定义如下：</p>

<pre><code>#include &lt;unistd.h&gt;

int getopt(int argc,char *const argv[],const char *optstring);
extern char *optarg;
extern int optind,opterr,optopt;
</code></pre>

<p>getopt 使用 main 函数的 argc 和 argv 作为前两个参数，optsting 是一个字符列表，每个字符代表一个单字符选项，如果一个字符后面紧跟以冒号（：），表示该字符有一个关联值作为下一个参数；</p>

<p>getopt的返回值是argv数组中的下一个选项参数，由optind记录argv数组的下标,如果选项参数处理完毕，函数返回-1；</p>

<p>如果遇到一个无法识别的选项，返回问号（？），并保存在optopt中；</p>

<p>如果一个选项需要一个关联值，而程序执行时没有提供，返回一个问号（？）,如果将optstring的第一个字符设为冒号（:),这种情况下，函数会返回冒号而不是问号。</p>

<p>选项参数处理完毕后，optind 会指向 argv 数组尾部的其他非选项参数。实际上，getopt 在执行过程中会重排 argv 数组，将非选项参数移到数组的尾部。</p>

<p>例：</p>

<p>下面这个程序需要提供两个无关联值的选项：-v，-g；一个需要关联值的选项：-t；一个非选项参数。</p>

<pre><code>//getopttest.c
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main(int argc,char *argv[])
{

    int opt=0;
    int i=0;
    const char *optstring=&quot;:vgt:&quot;;
    //非选项参数的个数
    const int num=1;
    //调用getopt前打印argv数组
    for(i=0;i&lt;argc;i++)
        printf(&quot;%d:%s/n&quot;,i,argv[i]);

    //处理选项参数
    while((opt=getopt(argc,argv,optstring)) != -1)
    {
        switch(opt)
        {

        case 'v':
        case 'g':
            printf(&quot;option：%c/n&quot;,opt);
            break;
        case 't':
            printf(&quot;option:%c = %s/n&quot;,opt,optarg);
            break;
        case ':':
            printf(&quot;the option need a value/n&quot;);
            break;
        case '?':
            printf(&quot;unknow option：%c/n&quot;,optopt);
            break;
        }
    }

    //处理非选项参数
    for(i=0;optind&lt;argc;i++,optind++)
    {
        if(i&lt;num)
            printf(&quot;argument:%s/n&quot;,argv[optind]);
        else
            printf(&quot;excess argument:%s/n&quot;,argv[optind]);
    }

    //调用getopt后打印argv数组
    for(i=0;i&lt;argc;i++)
        printf(&quot;%d:%s/n&quot;,i,argv[i]);

    return 0;
}
</code></pre>

<p>编译：</p>

<pre><code>gcc -Wall getopttest.c -o getopttest
</code></pre>

<p>执行：</p>

<pre><code>$./getopttest arg1 -vg -t value -x arg2
0:./getopttest
1:arg1
2:-vg
3:-t
4:value
5:-x
6:arg2
option：v
option：g
option:t = value
unknow option：x
argument:arg1
excess argument:arg2
0:./getopttest
1:-vg
2:-t
3:value
4:-x
5:arg1
6:arg2
</code></pre>

<p>从执行结果可以看出，getopt 函数重排了 argv 数组，将非选项参数 arg1 排到了数组尾部。</p>
]]></content>
        </item>
        
        <item>
            <title>C语言的参数可变函数</title>
            <link>https://shaocheng.li/posts/2011/05/17/</link>
            <pubDate>Tue, 17 May 2011 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2011/05/17/</guid>
            <description>环境：fedora12，gcc4.4.4
C语言参数个数可变的函数，叫做VA函数（variable argument function），例如printf()函数。要实现VA函数需要包含stdarg.h:
#include &amp;lt;stdarg.h&amp;gt;  主要使用下面三个宏定义：
va_start(ap, A) va_arg(ap, T) va_end(ap)  ap 是类型是 va_list ，va_list 的定义如下：
typedef char *va_list;  它用来指向函数的参数。
A是函数的最后一个固定参数，一个VA函数必须有至少一个固定参数。
T是参数的类型，例如int，char&amp;hellip;,等等。
 va_start(ap,A)：初始化函数参数指针ap，使ap指向A的右边的第一个参数，即函数可变参数中的第一个； va_arg(ap,T）：返回ap指向的参数的值，参数的类型用T确定，然后将ap指向下一个参数； va_end（ap）：释放ap。  下面的例子定义了一个va函数，作用是依次打印传递给函数的int型参数。
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdarg.h&amp;gt; int va_function(const char *start,...) { int n=1; va_list arg; va_start(arg,start); printf(&amp;quot;%s/n&amp;quot;,start); while(n != 0) { n=va_arg(arg,int); printf(&amp;quot;%d/n&amp;quot;,n); } va_end(arg); return 0; } int main(void) { va_function(&amp;quot;start&amp;quot;,1,2,3,-1,-2,0); return 0; }  注意：
 VA函数的可变参数类型必须在函数中自行确定，编译器无法自动识别。 必须在VA函数中定义可变参数的结束标志，如果没有结束标志，va_arg会依次返回内存中的值，直到访问到非法内存而出错退出。  这几个宏在不同的编译器中有不同的定义，但是功能是一样的，在linux的内核源码中也用定义，可以参考。在内核源码的 /include/acpi/platform/acenv.</description>
            <content type="html"><![CDATA[<p>环境：fedora12，gcc4.4.4</p>

<p>C语言参数个数可变的函数，叫做VA函数（variable argument function），例如printf()函数。要实现VA函数需要包含stdarg.h:</p>

<pre><code>#include &lt;stdarg.h&gt;
</code></pre>

<p>主要使用下面三个宏定义：</p>

<pre><code>va_start(ap, A)
va_arg(ap, T)
va_end(ap)
</code></pre>

<p>ap 是类型是 va_list ，va_list 的定义如下：</p>

<pre><code>typedef char *va_list;
</code></pre>

<p>它用来指向函数的参数。</p>

<p>A是函数的最后一个固定参数，一个VA函数必须有至少一个固定参数。</p>

<p>T是参数的类型，例如int，char&hellip;,等等。</p>

<ul>
<li>va_start(ap,A)：初始化函数参数指针ap，使ap指向A的右边的第一个参数，即函数可变参数中的第一个；</li>
<li>va_arg(ap,T）：返回ap指向的参数的值，参数的类型用T确定，然后将ap指向下一个参数；</li>
<li>va_end（ap）：释放ap。</li>
</ul>

<p>下面的例子定义了一个va函数，作用是依次打印传递给函数的int型参数。</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

int va_function(const char *start,...)
{
    int n=1;

    va_list arg;
    va_start(arg,start);
    printf(&quot;%s/n&quot;,start);

    while(n != 0)
    {
        n=va_arg(arg,int);
        printf(&quot;%d/n&quot;,n);
    }

    va_end(arg);

    return 0;
}


int main(void)
{
    va_function(&quot;start&quot;,1,2,3,-1,-2,0);
         return 0;
}
</code></pre>

<p>注意：</p>

<ol>
<li>VA函数的可变参数类型必须在函数中自行确定，编译器无法自动识别。</li>
<li>必须在VA函数中定义可变参数的结束标志，如果没有结束标志，va_arg会依次返回内存中的值，直到访问到非法内存而出错退出。</li>
</ol>

<p>这几个宏在不同的编译器中有不同的定义，但是功能是一样的，在linux的内核源码中也用定义，可以参考。在内核源码的 <code>/include/acpi/platform/acenv.h</code> 文件内：</p>

<pre><code>typedef char *va_list;
　　
/*
Storage alignment properties 
*/
#define _AUPBND (sizeof (acpi_native_uint) - 1)
#define _ADNBND (sizeof (acpi_native_uint) - 1)
　
/*
Variable argument list macro definitions 
*/
#define _bnd(X, bnd) (((sizeof (X)) + (bnd)) &amp; (~(bnd)))
#define va_arg(ap, T) (*(T *)(((ap) += (_bnd (T, _AUPBND))) - (_bnd (T,_ADNBND))))
#define va_end(ap) (void) 0
#define va_start(ap, A) (void) ((ap) = (((char *) &amp;(A)) + (_bnd (A,_AUPBND))))
</code></pre>

<p>参考：</p>

<p><a href="http://writeblog.csdn.net/#resources" target="_blank">深入浅出VA函数</a></p>

<p><a href="http://blog.csdn.net/storylike/archive/2011/01/26/6164240.aspx" target="_blank">linux kernel中的变长参数宏</a></p>

<p>《The Open Group Base Specifications Issue 6》</p>
]]></content>
        </item>
        
        <item>
            <title>键盘上各个按键的英文名</title>
            <link>https://shaocheng.li/posts/2011/04/10/</link>
            <pubDate>Sun, 10 Apr 2011 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2011/04/10/</guid>
            <description>**Esc **：escape
**Tab **：table
**Caps Lock **：Capital Lock
**Shift **：shift
**Ctrl **：control
**Alt **：alternative
**Enter **： enter
**F1~12 **：functions
**~ **：tilde
**! **：exclamation
**@ **：at
**# **：pound ，hash
**$ **：dollar
**% **：percent
**^ **：caret
**&amp;amp; **：ampersand
*** **：star
**( **：opening parenthesis
**) **：closing parenthesis
**_ **：underscore
**+ **：plus
**- **：Minus
**= **：equals
**` **：backquote
**{ **：opening brace
**} **：closing brace
**[ **：opening bracket
**] **：closing bracket
**| **：pipe
**\ **：backslash</description>
            <content type="html"><![CDATA[<p>**Esc **：escape</p>

<p>**Tab **：table</p>

<p>**Caps Lock **：Capital Lock</p>

<p>**Shift **：shift</p>

<p>**Ctrl **：control</p>

<p>**Alt **：alternative</p>

<p>**Enter **： enter</p>

<p>**F1~12 **：functions</p>

<p>**~ **：tilde</p>

<p>**! **：exclamation</p>

<p>**@ **：at</p>

<p>**# **：pound ，hash</p>

<p>**$ **：dollar</p>

<p>**% **：percent</p>

<p>**^ **：caret</p>

<p>**&amp; **：ampersand</p>

<p>*** **：star</p>

<p>**( **：opening parenthesis</p>

<p>**) **：closing parenthesis</p>

<p>**_ **：underscore</p>

<p>**+ **：plus</p>

<p>**- **：Minus</p>

<p>**= **：equals</p>

<p>**` **：backquote</p>

<p>**{ **：opening brace</p>

<p>**} **：closing brace</p>

<p>**[ **：opening bracket</p>

<p>**] **：closing bracket</p>

<p>**| **：pipe</p>

<p>**\ **：backslash</p>

<p>**: **：colon</p>

<p>**; **：semicolon</p>

<p>**“ **：double quote</p>

<p>**‘ **：single quote</p>

<p>**&lt; **：less than</p>

<p>**, **：comma</p>

<p>**&gt; **：great than</p>

<p>**. **：dot</p>

<p>**? **：question mark</p>

<p>**/ **：slash</p>
]]></content>
        </item>
        
        <item>
            <title>判断进程是否存在的脚本</title>
            <link>https://shaocheng.li/posts/2011/03/04/</link>
            <pubDate>Fri, 04 Mar 2011 08:00:00 +0800</pubDate>
            
            <guid>https://shaocheng.li/posts/2011/03/04/</guid>
            <description>test.sh :
#!/bin/bash pid=`ps -ef | grep -v grep | grep -v &amp;quot;test.sh&amp;quot; | grep $1 | sed -n &#39;1P&#39; | awk &#39;{print $2}&#39;` if [ -z $pid ] ; then echo &amp;quot;no this process&amp;quot; else echo $pid fi  例：
查询是否存在hello进程
#./test.sh hello  如果存在 hello 进程，会输出 PID ; 不存在会输出 no this process</description>
            <content type="html"><![CDATA[<p>test.sh :</p>

<pre><code>#!/bin/bash  
pid=`ps -ef | grep -v grep | grep -v &quot;test.sh&quot; | grep $1 | sed -n  '1P' | awk '{print   $2}'`  
if [ -z $pid ] ; then  
    echo &quot;no this process&quot;  
else  
    echo $pid  
fi  
</code></pre>

<p>例：</p>

<p>查询是否存在hello进程</p>

<pre><code>#./test.sh   hello
</code></pre>

<p>如果存在 hello 进程，会输出 PID ; 不存在会输出 no  this  process</p>
]]></content>
        </item>
        
    </channel>
</rss>
