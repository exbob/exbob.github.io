<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="Shaocheng.Li"><meta name=description content="1. 工作原理 epoll 是 Linux 独有的 I/O 多路复用机制，核心概念就是 epoll 实例，它是一个内核里的数据结构，从用户角度来看它可以简单的看做包含了两个队列：
 interest list（或者叫epoll set），用户注册的感兴趣的描述符集合。 ready list，就绪的描述符集合，当有 I/O 就绪时，内核会自动将就绪的描述符加到 ready list 中。  在用户端的工作流程就是：
 向 interest list 注册感兴趣的文件描述符的 I/O 事件。 等待已注册的文件描述符就绪。 处理所有已经就绪的文件描述符。  2. 使用方法 使用 epoll 时，需要包括头文件：
#include &amp;lt;sys/epoll.h&amp;gt; 2.1 新建一个 epoll 实例 int epoll_create(int size); epoll_create() 函数会新建一个 epoll 实例，然后返回一个文件描述符，作为 epoll 操作的句柄。从 Linux 2.6.8 开始， 参数 size 可以忽略，但是必须大于 0 。当不在需要这个描述符时，应该调用 close() 函数将其关闭。
调用失败时，会返回一个负数。
2.2 操作 epoll 实例 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 这是操作 epoll 实例的接口函数，用于添加、删除和修改 interest list 中监控的文件描述符。如果调用成功，会返回 0 ，如果失败，会返回一个负数，并设置 errno 。参数的含义："><meta name=keywords content><meta name=robots content="noodp"><meta name=theme-color content="#252627"><link rel=canonical href=https://shaocheng.li/posts/2020/08/30/><title>epoll 学习笔记 :: Shaocheng.Li — Hello Friends</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=https://shaocheng.li/main.min.73f55a8d452be4a71b2960620b80252cf69abd84d63fe7501abf0a39b1a70a78.css><link rel=stylesheet type=text/css href=https://shaocheng.li/css/custom.css><link rel=apple-touch-icon sizes=180x180 href=https://shaocheng.li/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://shaocheng.li/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://shaocheng.li/favicon-16x16.png><link rel=manifest href=https://shaocheng.li/site.webmanifest><link rel=mask-icon href=https://shaocheng.li/safari-pinned-tab.svg color=#252627><link rel="shortcut icon" href=https://shaocheng.li/favicon.ico><meta name=msapplication-TileColor content="#252627"><meta name=theme-color content="#252627"><meta itemprop=name content="epoll 学习笔记"><meta itemprop=description content="1. 工作原理 epoll 是 Linux 独有的 I/O 多路复用机制，核心概念就是 epoll 实例，它是一个内核里的数据结构，从用户角度来看它可以简单的看做包含了两个队列：
 interest list（或者叫epoll set），用户注册的感兴趣的描述符集合。 ready list，就绪的描述符集合，当有 I/O 就绪时，内核会自动将就绪的描述符加到 ready list 中。  在用户端的工作流程就是：
 向 interest list 注册感兴趣的文件描述符的 I/O 事件。 等待已注册的文件描述符就绪。 处理所有已经就绪的文件描述符。  2. 使用方法 使用 epoll 时，需要包括头文件：
#include &lt;sys/epoll.h&gt; 2.1 新建一个 epoll 实例 int epoll_create(int size); epoll_create() 函数会新建一个 epoll 实例，然后返回一个文件描述符，作为 epoll 操作的句柄。从 Linux 2.6.8 开始， 参数 size 可以忽略，但是必须大于 0 。当不在需要这个描述符时，应该调用 close() 函数将其关闭。
调用失败时，会返回一个负数。
2.2 操作 epoll 实例 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 这是操作 epoll 实例的接口函数，用于添加、删除和修改 interest list 中监控的文件描述符。如果调用成功，会返回 0 ，如果失败，会返回一个负数，并设置 errno 。参数的含义："><meta itemprop=datePublished content="2020-08-30T11:53:11&#43;08:00"><meta itemprop=dateModified content="2020-08-30T11:53:11&#43;08:00"><meta itemprop=wordCount content="239"><meta itemprop=keywords content="untagged,"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://shaocheng.li"><meta name=twitter:title content="epoll 学习笔记"><meta name=twitter:description content="1. 工作原理 epoll 是 Linux 独有的 I/O 多路复用机制，核心概念就是 epoll 实例，它是一个内核里的数据结构，从用户角度来看它可以简单的看做包含了两个队列：
 interest list（或者叫epoll set），用户注册的感兴趣的描述符集合。 ready list，就绪的描述符集合，当有 I/O 就绪时，内核会自动将就绪的描述符加到 ready list 中。  在用户端的工作流程就是：
 向 interest list 注册感兴趣的文件描述符的 I/O 事件。 等待已注册的文件描述符就绪。 处理所有已经就绪的文件描述符。  2. 使用方法 使用 epoll 时，需要包括头文件：
#include &lt;sys/epoll.h&gt; 2.1 新建一个 epoll 实例 int epoll_create(int size); epoll_create() 函数会新建一个 epoll 实例，然后返回一个文件描述符，作为 epoll 操作的句柄。从 Linux 2.6.8 开始， 参数 size 可以忽略，但是必须大于 0 。当不在需要这个描述符时，应该调用 close() 函数将其关闭。
调用失败时，会返回一个负数。
2.2 操作 epoll 实例 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 这是操作 epoll 实例的接口函数，用于添加、删除和修改 interest list 中监控的文件描述符。如果调用成功，会返回 0 ，如果失败，会返回一个负数，并设置 errno 。参数的含义："><meta property="article:published_time" content="2020-08-30 11:53:11 &#43;0800 &#43;0800"></head><body><div class=container><header class=header><span class=header__inner><a href=https://shaocheng.li/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>$ cd /home/</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=https://shaocheng.li/about/>About</a></li><li><a href=https://shaocheng.li/posts/>Posts</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41C32.4934 41 41 32.4934 41 22 41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>2 minutes</p></div><article><h1 class=post-title><a href=https://shaocheng.li/posts/2020/08/30/>epoll 学习笔记</a></h1><hr><aside id=toc><div class=toc-title>Table of Contents</div><nav id=TableOfContents><ul><li><ul><li><a href=#1-工作原理>1. 工作原理</a></li><li><a href=#2-使用方法>2. 使用方法</a><ul><li><a href=#2-1-新建一个-epoll-实例>2.1 新建一个 epoll 实例</a></li><li><a href=#2-2-操作-epoll-实例>2.2 操作 epoll 实例</a></li><li><a href=#2-3-等待-i-o-事件>2.3 等待 I/O 事件</a></li></ul></li><li><a href=#3-例程>3. 例程</a></li><li><a href=#参考>参考</a></li></ul></li></ul></nav></aside><hr><div class=post-content><h2 id=1-工作原理>1. 工作原理</h2><p>epoll 是 Linux 独有的 I/O 多路复用机制，核心概念就是 epoll 实例，它是一个内核里的数据结构，从用户角度来看它可以简单的看做包含了两个队列：</p><ul><li>interest list（或者叫epoll set），用户注册的感兴趣的描述符集合。</li><li>ready list，就绪的描述符集合，当有 I/O 就绪时，内核会自动将就绪的描述符加到 ready list 中。</li></ul><p>在用户端的工作流程就是：</p><ol><li>向 interest list 注册感兴趣的文件描述符的 I/O 事件。</li><li>等待已注册的文件描述符就绪。</li><li>处理所有已经就绪的文件描述符。</li></ol><h2 id=2-使用方法>2. 使用方法</h2><p>使用 epoll 时，需要包括头文件：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/epoll.h&gt;</span></code></pre></div><h3 id=2-1-新建一个-epoll-实例>2.1 新建一个 epoll 实例</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_create</span>(<span style=color:#66d9ef>int</span> size);</code></pre></div><p><code>epoll_create()</code> 函数会新建一个 epoll 实例，然后返回一个文件描述符，作为 epoll 操作的句柄。从 Linux 2.6.8 开始， 参数 size 可以忽略，但是必须大于 0 。当不在需要这个描述符时，应该调用 <code>close()</code> 函数将其关闭。</p><p>调用失败时，会返回一个负数。</p><h3 id=2-2-操作-epoll-实例>2.2 操作 epoll 实例</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_ctl</span>(<span style=color:#66d9ef>int</span> epfd, <span style=color:#66d9ef>int</span> op, <span style=color:#66d9ef>int</span> fd, <span style=color:#66d9ef>struct</span> epoll_event <span style=color:#f92672>*</span>event);</code></pre></div><p>这是操作 epoll 实例的接口函数，用于添加、删除和修改 interest list 中监控的文件描述符。如果调用成功，会返回 0 ，如果失败，会返回一个负数，并设置 errno 。参数的含义：</p><ul><li>第一个参数 epfd 就是 <code>epoll_create()</code> 函数返回的文件描述符。</li><li>第二个参数表示操作类型，可选：<ul><li>EPOLL_CTL_ADD，将 fd 添加到 epfd 的 interest list 中。</li><li>EPOLL_CTL_MOD，从 interest list 中删除 fd 。</li><li>EPOLL_CTL_DEL，修改 fd 的监视事件。</li></ul></li><li>第三个参数是需要监听的文件描述符。</li><li>第四个参数是需要监听的事件。</li></ul><p>监视的事件通过 <code>struct epoll_event</code> 结构体设置：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>union</span> epoll_data {
<span style=color:#66d9ef>void</span>        <span style=color:#f92672>*</span>ptr;
<span style=color:#66d9ef>int</span>          fd;
uint32_t     u32;
uint64_t     u64;
} epoll_data_t;

<span style=color:#66d9ef>struct</span> epoll_event {
uint32_t     events;      <span style=color:#75715e>/* Epoll events */</span>
epoll_data_t data;        <span style=color:#75715e>/* User data variable */</span>
};</code></pre></div><p>结构成员 data 由内核负责修改，当监视的文件描述符准备就绪时返回。结构成员 event 用于设置监视的事件类型，是一个枚举的集合，可以用 <code>|</code> 来增加多种事件类型，枚举如下：</p><ul><li>EPOLLIN 表示关联的 fd 可以进行读操作了。</li><li>EPOLLOUT 表示关联的 fd 可以进行写操作了。</li><li>EPOLLRDHUP(since Linux 2.6.17) 表示套接字关闭了连接，或者关闭了正写一半的连接。</li><li>EPOLLPRI 表示关联的 fd 有紧急优先事件可以进行读操作了。</li><li>EPOLLERR 表示关联的fd发生了错误，<code>epoll_wait()</code> 会一直等待这个事件，所以一般没必要设置这个属性。</li><li>EPOLLHUP 表示关联的fd挂起了，<code>epoll_wait()</code> 会一直等待这个事件，所以一般没必要设置这个属性。</li><li>EPOLLET 设置关联的fd为ET的工作方式，epoll 的默认工作方式是LT。</li><li>EPOLLONESHOT (since Linux 2.6.2) 设置关联的 fd 为 one-shot 的工作方式。表示只监听一次事件，如果要再次监听，需要把 socket 放入到 epoll 队列中。</li></ul><h3 id=2-3-等待-i-o-事件>2.3 等待 I/O 事件</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_wait</span>(<span style=color:#66d9ef>int</span> epfd, <span style=color:#66d9ef>struct</span> epoll_event <span style=color:#f92672>*</span>events, <span style=color:#66d9ef>int</span> maxevents, <span style=color:#66d9ef>int</span> timeout);</code></pre></div><p><code>epoll_wait()</code> 用于等待监视的 I/O 事件就绪，也就是返回 ready list 中的文件描述符 。调用后，函数开始阻塞，直到：</p><ul><li>一个文件描述符触发了一个监视的事件。</li><li>被信号中断。</li><li>超时时间到。</li></ul><p>已经就绪的文件描述符会写入 <code>events</code> 指向的缓存，这是一个数组，每个元素记录了一个就绪的文件描述符的信息。<code>maxevents</code> 用于告诉内核一次最多返回多少个已经就绪的文件描述符，这个值必须大于 0 ，但不要大于已经注册的文件描述符的个数。<code>timeout</code> 设置了等待超时，单位是毫秒，0 表示立即返回，如果设为 -1 ，表示永久等待。</p><p>如果调用成功，返回值就是已经就绪的文件描述符的数量，如果返回值是 1，那 <code>events</code> 数字的长度也只有 。失败会返回一个负数。</p><h2 id=3-例程>3. 例程</h2><h2 id=参考>参考</h2><ul><li><a href=https://juejin.im/post/6844904200141438984 target=_blank>彻底理解 I/O 多路复用</a></li><li><a href=http://www.skybluues.com/epoll%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/](http://www.skybluues.com/epoll的运行机制/) target=_blank>epoll 的运行机制</a></li><li><a href=https://man7.org/linux/man-pages/man2/epoll_create.2.html target=_blank>epoll_create</a></li><li><a href=https://man7.org/linux/man-pages/man2/epoll_ctl.2.html target=_blank>epoll_ctl</a></li></ul></div></article><hr><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83.0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=https://shaocheng.li/tags/untagged>untagged</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>239 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2020-08-30 03:53 &#43;0000</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><span class="button next"><a href=https://shaocheng.li/posts/2020/08/29/><span class=button__text>uthash 学习笔记</span>
<span class=button__icon>→</span></a></span></div></div><div id=comments class=thin><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"shaocheng-li"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2020</span>
<span><a href=https://shaocheng.li>Shaocheng.Li</a></span>
<span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span>
<span><a href=https://shaocheng.li/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"/><path d="M4 4a16 16 0 0 1 16 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div><div class=footer__inner><div class=footer__content><span>Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>Made with &#10084; by <a href=https://github.com/rhazdon>rhazdon</a></span></div></div></footer></div><script type=text/javascript src=https://shaocheng.li/bundle.min.2d5469329143160ae2456a69c3c76dc2d0a3b212b46afe291a51bd68650ed6f8697e001dab54f1c272c77ce08092a8c55e5bb4314e0ee334aab4b927ec896638.js integrity="sha512-LVRpMpFDFgriRWppw8dtwtCjshK0av4pGlG9aGUO1vhpfgAdq1TxwnLHfOCAkqjFXlu0MU4O4zSqtLkn7IlmOA=="></script></body></html>