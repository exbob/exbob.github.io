<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="Shaocheng.Li"><meta name=description content="编译安装 首先要安装一些依赖的软件：
apt-get install pkg-config apt-get install lua5.1 apt-get install liblua5.1-dev apt-get install cmake apt-get install libjson-c-dev 然后要编译安装 libubox ：
git clone https://git.openwrt.org/project/libubox.git cd libubox cmake . make make install ulog 头文件 ulog.h 提供了打印日志的方法。使用时，先调用 ulog_open() 函数初始化一些 ulog 需要的变量：
void ulog_open(int channels, int facility, const char *ident); channels 用于设置日志消息的输出目标，取值：
 ULOG_KMSG，内核日志，输出到了 /dev/kmsg 文件。 ULOG_SYSLOG，系统日志，调用了 vsyslog() 产生系统日志。 ULOG_STDIO，标准输出，输出到了 stderr 。  facility 用于设置记录日志的程序的类型，只有当 channels 的值为 ULOG_SYSLOG 时，这个参数有效。取值与 openlog() 的第三个参数一致，它们是定义在 &amp;lt;syslog.h&amp;gt; 中的宏："><meta name=keywords content><meta name=robots content="noodp"><meta name=theme-color content="#252627"><link rel=canonical href=https://shaocheng.li/posts/2020/07/16/><title>libubox 学习笔记 :: Shaocheng.Li — Hello Friends</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=https://shaocheng.li/main.min.73f55a8d452be4a71b2960620b80252cf69abd84d63fe7501abf0a39b1a70a78.css><link rel=stylesheet type=text/css href=https://shaocheng.li/css/custom.css><link rel=apple-touch-icon sizes=180x180 href=https://shaocheng.li/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://shaocheng.li/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://shaocheng.li/favicon-16x16.png><link rel=manifest href=https://shaocheng.li/site.webmanifest><link rel=mask-icon href=https://shaocheng.li/safari-pinned-tab.svg color=#252627><link rel="shortcut icon" href=https://shaocheng.li/favicon.ico><meta name=msapplication-TileColor content="#252627"><meta name=theme-color content="#252627"><meta itemprop=name content="libubox 学习笔记"><meta itemprop=description content="编译安装 首先要安装一些依赖的软件：
apt-get install pkg-config apt-get install lua5.1 apt-get install liblua5.1-dev apt-get install cmake apt-get install libjson-c-dev 然后要编译安装 libubox ：
git clone https://git.openwrt.org/project/libubox.git cd libubox cmake . make make install ulog 头文件 ulog.h 提供了打印日志的方法。使用时，先调用 ulog_open() 函数初始化一些 ulog 需要的变量：
void ulog_open(int channels, int facility, const char *ident); channels 用于设置日志消息的输出目标，取值：
 ULOG_KMSG，内核日志，输出到了 /dev/kmsg 文件。 ULOG_SYSLOG，系统日志，调用了 vsyslog() 产生系统日志。 ULOG_STDIO，标准输出，输出到了 stderr 。  facility 用于设置记录日志的程序的类型，只有当 channels 的值为 ULOG_SYSLOG 时，这个参数有效。取值与 openlog() 的第三个参数一致，它们是定义在 &lt;syslog.h&gt; 中的宏："><meta itemprop=datePublished content="2020-07-16T21:23:11&#43;08:00"><meta itemprop=dateModified content="2020-07-16T21:23:11&#43;08:00"><meta itemprop=wordCount content="709"><meta itemprop=keywords content="untagged,"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://shaocheng.li"><meta name=twitter:title content="libubox 学习笔记"><meta name=twitter:description content="编译安装 首先要安装一些依赖的软件：
apt-get install pkg-config apt-get install lua5.1 apt-get install liblua5.1-dev apt-get install cmake apt-get install libjson-c-dev 然后要编译安装 libubox ：
git clone https://git.openwrt.org/project/libubox.git cd libubox cmake . make make install ulog 头文件 ulog.h 提供了打印日志的方法。使用时，先调用 ulog_open() 函数初始化一些 ulog 需要的变量：
void ulog_open(int channels, int facility, const char *ident); channels 用于设置日志消息的输出目标，取值：
 ULOG_KMSG，内核日志，输出到了 /dev/kmsg 文件。 ULOG_SYSLOG，系统日志，调用了 vsyslog() 产生系统日志。 ULOG_STDIO，标准输出，输出到了 stderr 。  facility 用于设置记录日志的程序的类型，只有当 channels 的值为 ULOG_SYSLOG 时，这个参数有效。取值与 openlog() 的第三个参数一致，它们是定义在 &lt;syslog.h&gt; 中的宏："><meta property="article:published_time" content="2020-07-16 21:23:11 &#43;0800 &#43;0800"></head><body><div class=container><header class=header><span class=header__inner><a href=https://shaocheng.li/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>$ cd /home/</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=https://shaocheng.li/about/>About</a></li><li><a href=https://shaocheng.li/posts/>Posts</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41C32.4934 41 41 32.4934 41 22 41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>4 minutes</p></div><article><h1 class=post-title><a href=https://shaocheng.li/posts/2020/07/16/>libubox 学习笔记</a></h1><hr><aside id=toc><div class=toc-title>Table of Contents</div><nav id=TableOfContents><ul><li><ul><li><a href=#编译安装>编译安装</a></li><li><a href=#ulog>ulog</a></li><li><a href=#utils>utils</a><ul><li><a href=#base64>base64</a></li></ul></li><li><a href=#list>list</a></li><li><a href=#usock>usock</a></li></ul></li></ul></nav></aside><hr><div class=post-content><h2 id=编译安装>编译安装</h2><p>首先要安装一些依赖的软件：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>apt-get install pkg-config
apt-get install lua5.1
apt-get install liblua5.1-dev
apt-get install cmake
apt-get install libjson-c-dev</code></pre></div><p>然后要编译安装 libubox ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>git clone https://git.openwrt.org/project/libubox.git
cd libubox
cmake .
make
make install</code></pre></div><h2 id=ulog>ulog</h2><p>头文件 <code>ulog.h</code> 提供了打印日志的方法。使用时，先调用 <code>ulog_open()</code> 函数初始化一些 ulog 需要的变量：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ulog_open</span>(<span style=color:#66d9ef>int</span> channels, <span style=color:#66d9ef>int</span> facility, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>ident);</code></pre></div><p><code>channels</code> 用于设置日志消息的输出目标，取值：</p><ul><li><code>ULOG_KMSG</code>，内核日志，输出到了 <code>/dev/kmsg</code> 文件。</li><li><code>ULOG_SYSLOG</code>，系统日志，调用了 <code>vsyslog()</code> 产生系统日志。</li><li><code>ULOG_STDIO</code>，标准输出，输出到了 <code>stderr</code> 。</li></ul><p><code>facility</code> 用于设置记录日志的程序的类型，只有当 <code>channels</code> 的值为 <code>ULOG_SYSLOG</code> 时，这个参数有效。取值与 <code>openlog()</code> 的第三个参数一致，它们是定义在 <code>&lt;syslog.h&gt;</code> 中的宏：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/* facility codes */</span>
<span style=color:#75715e>#define LOG_KERN        (0&lt;&lt;3)  </span><span style=color:#75715e>/* kernel messages */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define LOG_USER        (1&lt;&lt;3)  </span><span style=color:#75715e>/* random user-level messages */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define LOG_MAIL        (2&lt;&lt;3)  </span><span style=color:#75715e>/* mail system */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define LOG_DAEMON      (3&lt;&lt;3)  </span><span style=color:#75715e>/* system daemons */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define LOG_AUTH        (4&lt;&lt;3)  </span><span style=color:#75715e>/* security/authorization messages */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define LOG_SYSLOG      (5&lt;&lt;3)  </span><span style=color:#75715e>/* messages generated internally by syslogd */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define LOG_LPR         (6&lt;&lt;3)  </span><span style=color:#75715e>/* line printer subsystem */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define LOG_NEWS        (7&lt;&lt;3)  </span><span style=color:#75715e>/* network news subsystem */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define LOG_UUCP        (8&lt;&lt;3)  </span><span style=color:#75715e>/* UUCP subsystem */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define LOG_CRON        (9&lt;&lt;3)  </span><span style=color:#75715e>/* clock daemon */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define LOG_AUTHPRIV    (10&lt;&lt;3) </span><span style=color:#75715e>/* security/authorization messages (private) */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define LOG_FTP         (11&lt;&lt;3) </span><span style=color:#75715e>/* ftp daemon */</span></code></pre></div><p><code>ident</code> 用于设置日志消息的标识，当 <code>channels</code> 的值为 <code>ULOG_STDIO</code> 时，这个参数无效。可以设置为程序名的字符串，如果为空，它会从 <code>/proc/self/status</code> 文件读取当前进程的名称作为默认值。</p><p>初始化完毕后，就可以调用 <code>ulog</code> 打印一条日志：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> ulog(<span style=color:#66d9ef>int</span> priority, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>fmt, ...)</code></pre></div><p><code>priority</code> 表示这条日志的类型，当 <code>channels</code> 的值为 <code>ULOG_STDIO</code> 时，这个参数无效。取值与 <code>syslog()</code> 的第一个参数一致，它们是定义在 <code>&lt;syslog.h&gt;</code> 中的宏：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define LOG_EMERG       0       </span><span style=color:#75715e>/* system is unusable */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define LOG_ALERT       1       </span><span style=color:#75715e>/* action must be taken immediately */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define LOG_CRIT        2       </span><span style=color:#75715e>/* critical conditions */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define LOG_ERR         3       </span><span style=color:#75715e>/* error conditions */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define LOG_WARNING     4       </span><span style=color:#75715e>/* warning conditions */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define LOG_NOTICE      5       </span><span style=color:#75715e>/* normal but significant condition */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define LOG_INFO        6       </span><span style=color:#75715e>/* informational */</span><span style=color:#75715e>
</span><span style=color:#75715e>#define LOG_DEBUG       7       </span><span style=color:#75715e>/* debug-level messages */</span></code></pre></div><p>为了调用方便，ulog 提供了不同类型的宏定义：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define ULOG_INFO(fmt, ...) ulog(LOG_INFO, fmt, ## __VA_ARGS__)
</span><span style=color:#75715e>#define ULOG_NOTE(fmt, ...) ulog(LOG_NOTICE, fmt, ## __VA_ARGS__)
</span><span style=color:#75715e>#define ULOG_WARN(fmt, ...) ulog(LOG_WARNING, fmt, ## __VA_ARGS__)
</span><span style=color:#75715e>#define ULOG_ERR(fmt, ...) ulog(LOG_ERR, fmt, ## __VA_ARGS__)</span></code></pre></div><p>程序结束时，应该调用 <code>ulog_close()</code> 关闭日志，对于 <code>ULOG_SYSLOG</code> 来说，它会调用 <code>closelog()</code> 函数完成任务。</p><p>ulog 还提供了一个函数来控制程序打印日志的级别：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ulog_threshold</span>(<span style=color:#66d9ef>int</span> threshold);</code></pre></div><p><code>threshold</code> 可选的值与 <code>ulog()</code> 的 <code>priority</code> 参数一致，默认值是 <code>LOG_DEBUG</code> 。设置后，再调动 <code>ulog()</code> 时，如果 <code>priority</code> 的数值大于 <code>threshold</code> ，就不会打印任何消息。我们可以在开发调试阶段设置为 <code>LOG_DEBUG</code> ，调试结束发布程序时再设为 <code>LOG_INFO</code> ，调试信息就直接关闭了。</p><p>下面是一个例程：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// main.c
</span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdarg.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;libubox/ulog.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
{
    ulog_open(ULOG_SYSLOG, LOG_USER, NULL);
    ULOG_INFO(<span style=color:#e6db74>&#34;hello ulog&#34;</span>);
    ulog_close();
}</code></pre></div><p>编译后执行：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>~$ gcc -Wall main.c  -o main -lubox
~$ ./main</code></pre></div><p>然后，在系统日志中可以查看到这条消息：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>Jul <span style=color:#ae81ff>02</span> <span style=color:#ae81ff>10</span>:58:06 ubuntu main<span style=color:#f92672>[</span><span style=color:#ae81ff>25733</span><span style=color:#f92672>]</span>: hello ulog</code></pre></div><h2 id=utils>utils</h2><p><code>utils.h</code> 类似一个工具库，提供很多使用的方法。</p><h3 id=base64>base64</h3><p>utils 提供了 base64 的编解码方法。</p><p>编码函数是 <code>b64_encode()</code> ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> b64_encode(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>_src, size_t srclength, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dest, size_t targsize)</code></pre></div><p>参数 <code>_src</code> 是指向源数据的指针，<code>srclength</code> 是源数据的长度，单位是字节。<code>dest</code> 指向编码后的字符串存放位置，<code>targsize</code> 是 <code>dest</code> 的空间大小，单位是字节。<code>targsize</code> 应该不小于 <code>(((srclength) + 2) / 3) * 4 + 1</code> ，除法取整，最后要加字符串结束符 <code>'\0'</code> ，所以要加 1 。如果调用成功，返回值是编码后的字符串长度，失败则返回 -1 。例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>b64_encode(<span style=color:#e6db74>&#34;food&#34;</span>, <span style=color:#ae81ff>4</span>, buf, <span style=color:#ae81ff>9</span>);</code></pre></div><p>解码函数是 <code>b64_decode()</code> ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>b64_decode</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>_src, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>dest, size_t targsize);</code></pre></div><p>参数的含义与编码函数一致，不需要设置源数据的长度，函数以 <code>_src</code> 字符串中的 <code>'\0'</code> 字符为结束符。如果调用成功，返回值是编码后的字符串长度，失败则返回 -1 。</p><p><code>util.h</code> 文件提供了计算编解码后字符串长度的宏：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define B64_ENCODE_LEN(_len)	((((_len) + 2) / 3) * 4 + 1)
</span><span style=color:#75715e>#define B64_DECODE_LEN(_len)	(((_len) / 4) * 3 + 1)</span></code></pre></div><h2 id=list>list</h2><p>ubox 用 <code>list.h</code> 提供了一种侵入式链表结构，结点中不含任何数据 ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> list_head {
    <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>next; <span style=color:#75715e>// 下一个元素
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>prev; <span style=color:#75715e>// 上一个元素
</span><span style=color:#75715e></span>};</code></pre></div><p>可以用一个宏初始化链表：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) }</span></code></pre></div><p>它定义了链表的 head ，next 和 prev 都指向本身，调用方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> list_head test_list <span style=color:#f92672>=</span> LIST_HEAD_INIT(test_list);</code></pre></div><p>ubox 的 list 还是一个双向循环链表：</p><p><img src=https://shaocheng.li/images/2020-07-16/image-20200716214206248.png alt=image-20200716214206248></p><p>在链表 head 的头部插入 new 结点，实际上是在 head 与 first 之间插入 new 结点：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>list_add</span>(<span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>_new, <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>head);</code></pre></div><p>在链表 head 的末尾追加 new 结点，实际上是在 head 与 last 之间插入 new 结点 ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>list_add_tail</span>(<span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>_new, <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>head);</code></pre></div><p>将 entry 结点从原有的列表中删除：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>list_del</span>(<span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>entry);</code></pre></div><p>将 list 结点移动列表头部，就是 head 与 first 之间：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>list_move</span>(<span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>list, <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>head);</code></pre></div><p>将 list 结点移动到列表末尾，就是 head 与 last 之间：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>list_move_tail</span>(<span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>entry, <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>head);</code></pre></div><p>判断一个链表是否为空，它会判断 head 结点的 next 指针是否指向本身。：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>list_empty</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>head);</code></pre></div><p>判断 list 结点是否是 head 链表的头结点：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>list_is_first</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>list, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>head);</code></pre></div><p>判断 list 结点是否是 head 链表的尾结点：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>list_is_last</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>list, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>head);</code></pre></div><p>对于侵入式链表，通常的使用方法是将 list 结点嵌入到特定的数据结构中，例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> item {
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>data;
    <span style=color:#66d9ef>struct</span> list_head list;
};</code></pre></div><h2 id=usock>usock</h2><p><code>usock.h</code> 提供便于新建 socket 的方法，是对 Linux socket API 的封装：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>usock</span>(<span style=color:#66d9ef>int</span> type, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>host, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>service);</code></pre></div><p>如果调用成功，就返回一个 socket 文件描述符，失败返回 -1。</p><p>参数 <code>type</code> 用于设置 socket 类型，可选的值是下面这些宏定义的组合：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define USOCK_IPV6ONLY      0x2000 </span><span style=color:#75715e>// IPv4 地址域的套接字
</span><span style=color:#75715e></span><span style=color:#75715e>#define USOCK_IPV4ONLY      0x4000 </span><span style=color:#75715e>// IPv6 地址域的套接字
</span><span style=color:#75715e></span><span style=color:#75715e>#define USOCK_UNIX          0x8000 </span><span style=color:#75715e>// UNIX 域的套接字
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define USOCK_TCP 0  </span><span style=color:#75715e>// 字节流
</span><span style=color:#75715e></span><span style=color:#75715e>#define USOCK_UDP 1  </span><span style=color:#75715e>// 报文
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define USOCK_SERVER        0x0100
</span><span style=color:#75715e>#define USOCK_NOCLOEXEC     0x0200
</span><span style=color:#75715e>#define USOCK_NONBLOCK      0x0400  </span><span style=color:#75715e>// 非阻塞
</span><span style=color:#75715e></span><span style=color:#75715e>#define USOCK_NUMERIC       0x0800</span></code></pre></div><p><code>host</code> 是本机地址，如果是网络 socket，这里应该是一个 IP 地址或者域名，如果是 UNIX socket ，这里应该是 socket 文件的路径。</p><p><code>service</code> 是本机端口，也可以是协议名称的字符串，例如 <code>http</code> 和 <code>ftp</code> 等。对于 UNIX socket ，这个参数无效。</p><p>对于非阻塞的 socket ，usock 提供了一个等待描述符就绪的方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>usock_wait_ready</span>(<span style=color:#66d9ef>int</span> fd, <span style=color:#66d9ef>int</span> msecs);</code></pre></div><p><code>fd</code> 是要等待的 socket 描述符，<code>msecs</code> 是等待超时，单位是微秒。这个方法是对 <code>poll()</code> 函数的封装。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>usock_port</span>(<span style=color:#66d9ef>int</span> port);</code></pre></div><p><code>usock_port()</code> 函数可以把数字表示的端口号转换为一个字符串。</p></div></article><hr><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83.0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=https://shaocheng.li/tags/untagged>untagged</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>709 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2020-07-16 13:23 &#43;0000</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://shaocheng.li/posts/2020/08/29/><span class=button__icon>←</span>
<span class=button__text>uthash 学习笔记</span></a></span>
<span class="button next"><a href=https://shaocheng.li/posts/2020/06/29/><span class=button__text>CMake 学习笔记</span>
<span class=button__icon>→</span></a></span></div></div><div id=comments class=thin><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"shaocheng-li"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2021</span>
<span><a href=https://shaocheng.li>Shaocheng.Li</a></span>
<span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span>
<span><a href=https://shaocheng.li/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"/><path d="M4 4a16 16 0 0 1 16 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div><div class=footer__inner><div class=footer__content><span>Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>Made with &#10084; by <a href=https://github.com/rhazdon>rhazdon</a></span></div></div></footer></div><script type=text/javascript src=https://shaocheng.li/bundle.min.2d5469329143160ae2456a69c3c76dc2d0a3b212b46afe291a51bd68650ed6f8697e001dab54f1c272c77ce08092a8c55e5bb4314e0ee334aab4b927ec896638.js integrity="sha512-LVRpMpFDFgriRWppw8dtwtCjshK0av4pGlG9aGUO1vhpfgAdq1TxwnLHfOCAkqjFXlu0MU4O4zSqtLkn7IlmOA=="></script></body></html>