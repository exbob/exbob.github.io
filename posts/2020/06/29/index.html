<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="Shaocheng.Li"><meta name=description content="本教程提供了一个渐进式的指导，参考的是官方教程 CMake Tutorial ，然后加入学习过程的笔记。涵盖了使用 CMake 构建一个工程时经常遇到的问题 。通过一个示例项目，展示各种功能是如何一起工作的，这对理解 CMake 非常有用。
1. 最简单的工程 最简单工程是从源码文件直接编译生成一个可执行的问题，最简单的解决方案只需要在 CMakeLists.txt 文件中添加三行。
新建一个工程目录，在目录下新建一个源文件 Tutorial.c ：
#include &amp;lt;stdio.h&amp;gt; int main (int argc, char *argv[]) { printf(&amp;#34;Hello World!\n&amp;#34;); return 0; } 新建一个 CMakeLists.txt ：
cmake_minimum_required(VERSION 3.1)project(Tutorial)add_executable(Tutorial Tutorial.c) CMakeLists.txt 是 cmake 生成 Makefile 所依赖的描述性文件，文件内容由一行一行的命令组成，命令不区分大小写。
 cmake_minimum_required 表示该项目对 CMake 的最低版本要求。 project 用于设置项目名称。 add_executable 添加了一个生成的可执行文件，和依赖的源码。  这样的话，执行 cmake . 生成 Makefile ，再执行 make 开始编译，就可以使用 Tutorial.c 生成的可执行文件 Tutorial 。
cmake 执行过程中会生成大量的缓存文件，又没有提供类似 cmake clean 的命令来清除生成的文件，有一个简单的方法可以解决这个问题。在工程目录下新建一个名为 build 的子目录，进入这个子目录中执行 cmake ."><meta name=keywords content><meta name=robots content="noodp"><meta name=theme-color content="#252627"><link rel=canonical href=https://shaocheng.li/posts/2020/06/29/><title>CMake 学习笔记 :: Shaocheng.Li — Hello Friends</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=https://shaocheng.li/main.min.e9b3dfcc5ffe9d55eb281ecaf47cf6179d26eec497e087299934d581c987aa0b.css><link rel=stylesheet type=text/css href=https://shaocheng.li/css/custom.css><link rel=apple-touch-icon sizes=180x180 href=https://shaocheng.li/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://shaocheng.li/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://shaocheng.li/favicon-16x16.png><link rel=manifest href=https://shaocheng.li/site.webmanifest><link rel=mask-icon href=https://shaocheng.li/safari-pinned-tab.svg color=#252627><link rel="shortcut icon" href=https://shaocheng.li/favicon.ico><meta name=msapplication-TileColor content="#252627"><meta name=theme-color content="#252627"><meta itemprop=name content="CMake 学习笔记"><meta itemprop=description content="本教程提供了一个渐进式的指导，参考的是官方教程 CMake Tutorial ，然后加入学习过程的笔记。涵盖了使用 CMake 构建一个工程时经常遇到的问题 。通过一个示例项目，展示各种功能是如何一起工作的，这对理解 CMake 非常有用。
1. 最简单的工程 最简单工程是从源码文件直接编译生成一个可执行的问题，最简单的解决方案只需要在 CMakeLists.txt 文件中添加三行。
新建一个工程目录，在目录下新建一个源文件 Tutorial.c ：
#include &lt;stdio.h&gt; int main (int argc, char *argv[]) { printf(&#34;Hello World!\n&#34;); return 0; } 新建一个 CMakeLists.txt ：
cmake_minimum_required(VERSION 3.1)project(Tutorial)add_executable(Tutorial Tutorial.c) CMakeLists.txt 是 cmake 生成 Makefile 所依赖的描述性文件，文件内容由一行一行的命令组成，命令不区分大小写。
 cmake_minimum_required 表示该项目对 CMake 的最低版本要求。 project 用于设置项目名称。 add_executable 添加了一个生成的可执行文件，和依赖的源码。  这样的话，执行 cmake . 生成 Makefile ，再执行 make 开始编译，就可以使用 Tutorial.c 生成的可执行文件 Tutorial 。
cmake 执行过程中会生成大量的缓存文件，又没有提供类似 cmake clean 的命令来清除生成的文件，有一个简单的方法可以解决这个问题。在工程目录下新建一个名为 build 的子目录，进入这个子目录中执行 cmake ."><meta itemprop=datePublished content="2020-06-29T22:25:11&#43;08:00"><meta itemprop=dateModified content="2020-06-29T22:25:11&#43;08:00"><meta itemprop=wordCount content="808"><meta itemprop=keywords content="untagged,"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://shaocheng.li"><meta name=twitter:title content="CMake 学习笔记"><meta name=twitter:description content="本教程提供了一个渐进式的指导，参考的是官方教程 CMake Tutorial ，然后加入学习过程的笔记。涵盖了使用 CMake 构建一个工程时经常遇到的问题 。通过一个示例项目，展示各种功能是如何一起工作的，这对理解 CMake 非常有用。
1. 最简单的工程 最简单工程是从源码文件直接编译生成一个可执行的问题，最简单的解决方案只需要在 CMakeLists.txt 文件中添加三行。
新建一个工程目录，在目录下新建一个源文件 Tutorial.c ：
#include &lt;stdio.h&gt; int main (int argc, char *argv[]) { printf(&#34;Hello World!\n&#34;); return 0; } 新建一个 CMakeLists.txt ：
cmake_minimum_required(VERSION 3.1)project(Tutorial)add_executable(Tutorial Tutorial.c) CMakeLists.txt 是 cmake 生成 Makefile 所依赖的描述性文件，文件内容由一行一行的命令组成，命令不区分大小写。
 cmake_minimum_required 表示该项目对 CMake 的最低版本要求。 project 用于设置项目名称。 add_executable 添加了一个生成的可执行文件，和依赖的源码。  这样的话，执行 cmake . 生成 Makefile ，再执行 make 开始编译，就可以使用 Tutorial.c 生成的可执行文件 Tutorial 。
cmake 执行过程中会生成大量的缓存文件，又没有提供类似 cmake clean 的命令来清除生成的文件，有一个简单的方法可以解决这个问题。在工程目录下新建一个名为 build 的子目录，进入这个子目录中执行 cmake ."><meta property="article:published_time" content="2020-06-29 22:25:11 &#43;0800 &#43;0800"></head><body><div class=container><header class=header><span class=header__inner><a href=https://shaocheng.li/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>$ cd /home/</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=https://shaocheng.li/about/>About</a></li><li><a href=https://shaocheng.li/posts/>Posts</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41C32.4934 41 41 32.4934 41 22 41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>4 minutes</p></div><article><h1 class=post-title><a href=https://shaocheng.li/posts/2020/06/29/>CMake 学习笔记</a></h1><hr><aside id=toc><div class=toc-title>Table of Contents</div><nav id=TableOfContents><ul><li><ul><li><a href=#1-最简单的工程>1. 最简单的工程</a><ul><li><a href=#添加一个版本号>添加一个版本号</a></li><li><a href=#测试>测试</a></li></ul></li><li><a href=#2-添加一个库>2. 添加一个库</a><ul><li><a href=#提供可选项>提供可选项</a></li><li><a href=#设置库文件的使用要求>设置库文件的使用要求</a></li></ul></li><li><a href=#3-安装和测试>3. 安装和测试</a></li></ul></li></ul></nav></aside><hr><div class=post-content><p>本教程提供了一个渐进式的指导，参考的是官方教程 <a href=https://cmake.org/cmake/help/latest/guide/tutorial/index.html#id1 target=_blank>CMake Tutorial</a> ，然后加入学习过程的笔记。涵盖了使用 CMake 构建一个工程时经常遇到的问题 。通过一个示例项目，展示各种功能是如何一起工作的，这对理解 CMake 非常有用。</p><h2 id=1-最简单的工程>1. 最简单的工程</h2><p>最简单工程是从源码文件直接编译生成一个可执行的问题，最简单的解决方案只需要在 CMakeLists.txt 文件中添加三行。</p><p>新建一个工程目录，在目录下新建一个源文件 <code>Tutorial.c</code> ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span> (<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[])
{
    printf(<span style=color:#e6db74>&#34;Hello World!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}</code></pre></div><p>新建一个 <code>CMakeLists.txt</code> ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake>cmake_minimum_required(<span style=color:#e6db74>VERSION</span> <span style=color:#e6db74>3.1</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>project(<span style=color:#e6db74>Tutorial</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>add_executable(<span style=color:#e6db74>Tutorial</span> <span style=color:#e6db74>Tutorial.c</span>)</code></pre></div><p><code>CMakeLists.txt</code> 是 cmake 生成 Makefile 所依赖的描述性文件，文件内容由一行一行的命令组成，命令不区分大小写。</p><ul><li>cmake_minimum_required 表示该项目对 CMake 的最低版本要求。</li><li>project 用于设置项目名称。</li><li>add_executable 添加了一个生成的可执行文件，和依赖的源码。</li></ul><p>这样的话，执行 <code>cmake .</code> 生成 Makefile ，再执行 <code>make</code> 开始编译，就可以使用 <code>Tutorial.c</code> 生成的可执行文件 <code>Tutorial</code> 。</p><p>cmake 执行过程中会生成大量的缓存文件，又没有提供类似 <code>cmake clean</code> 的命令来清除生成的文件，有一个简单的方法可以解决这个问题。在工程目录下新建一个名为 <code>build</code> 的子目录，进入这个子目录中执行 <code>cmake ..</code> ，这样生成的文件都会输出到 <code>build</code> 子目录中，方便清理。</p><h3 id=添加一个版本号>添加一个版本号</h3><p>一个软件工程通常需要版本号，可以直接写在源码里，但是 CMake 提供了更便捷的方法。可以在 <a href=https://cmake.org/cmake/help/latest/command/project.html#command:project target=_blank><code>project()</code></a> 命令中添加版本号，例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake>project(<span style=color:#e6db74>Tutorial</span> <span style=color:#e6db74>VERSION</span> <span style=color:#e6db74>1.0</span>)</code></pre></div><p>其实，还可以在该命令中添加项目的描述等，它的语法是：</p><pre><code>project(&lt;PROJECT-NAME&gt;
        [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]
        [DESCRIPTION &lt;project-description-string&gt;]
        [HOMEPAGE_URL &lt;url-string&gt;]
        [LANGUAGES &lt;language-name&gt;...])
</code></pre><p>这样添加的版本号，被 cmake 存放在特定的变量中：</p><ul><li><code>&lt;PROJECT-NAME&gt;_VERSION</code> ，存放完整的版本号 。</li><li><code>&lt;PROJECT-NAME&gt;_VERSION_MAJOR</code> ，存放 major 。</li><li><code>&lt;PROJECT-NAME&gt;_VERSION_MINOR</code> ，存放 minor 。</li><li><code>&lt;PROJECT-NAME&gt;_VERSION_PATCH</code> ， 存放 patch 。</li><li><code>&lt;PROJECT-NAME&gt;_VERSION_TWEAK</code> ，存放 tweak 。</li></ul><p><code>&lt;PROJECT-NAME&gt;</code>表示工程的名称，这里的值为 Tutorial ，所以 <code>Tutorial_VERSION_MAJOR</code> 的值就是 <code>1</code> ， <code>Tutorial_VERSION_MINOR</code> 的值就是 <code>0</code> 。我们需要新建一个名为 <code>TutorialConfig.h.in</code> 的文件传递这些变量：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@ 
</span><span style=color:#75715e>#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@ </span></code></pre></div><p>然后，在 <code>CMakeLists.txt</code> 中添加一条命令：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake>configure_file(<span style=color:#e6db74>TutorialConfig.h.in</span> <span style=color:#e6db74>TutorialConfig.h</span>)</code></pre></div><p>cmake 执行这条命令的时候，会读取 <code>TutorialConfig.h.in</code> 文件，并将其中的变量替换成真实的值，然后在执行目录下生成头文件 <code>TutorialConfig.h</code> ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define Tutorial_VERSION_MAJOR 1
</span><span style=color:#75715e>#define Tutorial_VERSION_MINOR 0</span></code></pre></div><p>下一步，我们需要在源码文件 <code>Tutorial.c</code> 中导入头文件，然后使用头文件里定义的宏打印版本号：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;TutorialConfig.h&#34; # 导入头文件</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span> (<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[])
{
    printf(<span style=color:#e6db74>&#34;Hello World!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
    printf(<span style=color:#e6db74>&#34;MAJOR Version is %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, Tutorial_VERSION_MAJOR); <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>引用版本号的宏定义</span>
    printf(<span style=color:#e6db74>&#34;MINOR Version is %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, Tutorial_VERSION_MINOR);
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}</code></pre></div><p>如果你是在源码目录下执行 cmake ，这样修改就可以了。如果是在 <code>build</code> 目录下执行 cmake ，生成的 <code>TutorialConfig.h</code> 文件位于 <code>build</code> 目录下，源文件中的 <code>#include &quot;TutorialConfig.h&quot;</code> 语句会找不到头文件，这时，需要将 <code>build</code> 目录页加入到头文件的检索路径中，可以在 <code>CMakeLists.txt</code> 的末尾加一行：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake>target_include_directories(<span style=color:#e6db74>Tutorial</span> <span style=color:#e6db74>PUBLIC</span> <span style=color:#e6db74>&#34;${PROJECT_BINARY_DIR}&#34;</span>)</code></pre></div><p><code>target_include_directories()</code> 的语法是：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake>target_include_directories(<span style=color:#e6db74>&lt;target&gt;</span> <span style=color:#e6db74>[SYSTEM]</span> <span style=color:#e6db74>[BEFORE]</span>
  <span style=color:#e6db74>&lt;INTERFACE|PUBLIC|PRIVATE&gt;</span> <span style=color:#e6db74>[items1...]</span>
  <span style=color:#e6db74>[&lt;INTERFACE|PUBLIC|PRIVATE&gt;</span> <span style=color:#e6db74>[items2...]</span> <span style=color:#e6db74>...]</span>)</code></pre></div><p>它的作用是向目标文件添加头文件检索路径。当编译 <code>target</code> 目标文件时，去指定的 <code>iters*</code> 路径下检索头文件。<code>target</code> 的值必须是通过 <a href=https://cmake.org/cmake/help/latest/command/add_executable.html#command:add_executable target=_blank><code>add_executable()</code></a> 或 <a href=https://cmake.org/cmake/help/latest/command/add_library.html#command:add_library target=_blank><code>add_library()</code></a> 命令添加的目标文件名称。</p><p><code>PROJECT_BINARY_DIR</code> 是指 cmake 提供的一个变量，表示目标文件输出的路径，通常就是执行 cmake 命令时的路径。还有一个变量 <code>PROJECT_SOURCE_DIR</code> ，表示源码的路径。它们的值都是由 <code>project()</code> 命令自动设置的。在 cmake 中，应用变量的语法是 <code>${variable-name}</code> 。</p><h3 id=测试>测试</h3><p>修改完毕后，<code>CMakeLists.txt</code> 的完整内容是：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake>cmake_minimum_required(<span style=color:#e6db74>VERSION</span> <span style=color:#e6db74>3.1</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>project(<span style=color:#e6db74>Tutorial</span> <span style=color:#e6db74>VERSION</span> <span style=color:#e6db74>1.0</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>configure_file(<span style=color:#e6db74>TutorialConfig.h.in</span> <span style=color:#e6db74>TutorialConfig.h</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>add_executable(<span style=color:#e6db74>Tutorial</span> <span style=color:#e6db74>Tutorial.c</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>target_include_directories(<span style=color:#e6db74>Tutorial</span> <span style=color:#e6db74>PUBLIC</span> <span style=color:#e6db74>&#34;${PROJECT_BINARY_DIR}&#34;</span>)</code></pre></div><p>然后，我们在 <code>build</code> 子目录下依次执行 <code>cmake ..</code> 和 <code>make</code> （或者 <code>cmake --build .</code>） ，生成的文件如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>~$ ls
CMakeCache.txt      Tutorial            inc
CMakeFiles          TutorialConfig.h
Makefile            cmake_install.cmake
~$ ./Tutorial
Hello World!
MAJOR Version is <span style=color:#ae81ff>1</span>
MINOR Version is <span style=color:#ae81ff>0</span></code></pre></div><h2 id=2-添加一个库>2. 添加一个库</h2><p>下面我们在工程中添加一个用于数学计算的链接库，把库的源码放在 <code>MathFunctions</code> 子目录中，工程结构如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>~$ tree
.
├── CMakeLists.txt
├── MathFunctions
│   ├── MathFunctions.h
│   └── mysqrt.c
├── Tutorial.c
└── TutorialConfig.h.in</code></pre></div><p>头文件 <code>MathFunctions.h</code> 中声明了一个计算平方根的函数 <code>mysqrt()</code> ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>mysqrt</span>(<span style=color:#66d9ef>double</span> x);</code></pre></div><p>它定义在 <code>mysqrt.c</code> 文件中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;MathFunctions.h&#34;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#75715e>// a hack square root calculation using simple operations
</span><span style=color:#75715e></span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>mysqrt</span>(<span style=color:#66d9ef>double</span> x) {
    <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) {
        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
    }

    <span style=color:#66d9ef>double</span> result <span style=color:#f92672>=</span> x;

    <span style=color:#75715e>// do ten iterations
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10</span>; <span style=color:#f92672>++</span>i) {
        <span style=color:#66d9ef>if</span> (result <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) {
            result <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.1</span>;
        }
        <span style=color:#66d9ef>double</span> delta <span style=color:#f92672>=</span> x <span style=color:#f92672>-</span> (result <span style=color:#f92672>*</span> result);
        result <span style=color:#f92672>=</span> result <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> delta <span style=color:#f92672>/</span> result;
        printf(<span style=color:#e6db74>&#34;Computing sqrt of %f to be %f .</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, x, result);
    }
    <span style=color:#66d9ef>return</span> result;
}</code></pre></div><p>然后，我们在 <code>Tutorial.c</code> 文件中调用这个函数计算一个数的平方根：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;TutorialConfig.h&#34;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;MathFunctions/MathFunctions.h&#34;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span> (<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[])
{
    <span style=color:#66d9ef>double</span> input <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
    printf(<span style=color:#e6db74>&#34;Hello World!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
    printf(<span style=color:#e6db74>&#34;Version %d.%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, Tutorial_VERSION_MAJOR, Tutorial_VERSION_MINOR);

    <span style=color:#66d9ef>double</span> output <span style=color:#f92672>=</span> mysqrt(input);
    printf(<span style=color:#e6db74>&#34;The square root of %f is %f .</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, input, output);
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}</code></pre></div><p>编译的时候，我们希望将 <code>mysqrt.c</code> 生成一个共享库，再连接到 <code>Tutorial</code> 目标中。所以，需要对 CMake 的描述文件做如下修改：</p><ol><li>在 <code>MathFunctions</code> 子目录下新建一个 <code>CMakeLists.txt</code> ，内容是 <code>add_library(MathFunctions mysqrt.c)</code> ，表示将 <code>mysqrt.c</code> 编译为库文件。</li><li>在顶层目录的 <code>CMakeLists.txt</code> 文件中如下内容：<ol><li><code>add_subdirectory(MathFunctions)</code> ，表示向 CMake 工程添加一个子目录，执行时会调用子目录中的 <code>CMakeLists.txt</code> 。</li><li><code>target_link_libraries(Tutorial PUBLIC MathFunctions)</code> ，表示目标文件 <code>Tutorial</code> 要链接 <code>MathFunctions</code> 。</li><li>因为 <code>Tutorial.c</code> 文件中导入了 <code>MathFunctions</code> 子目录下的头文件，所以，要用 <code>target_include_directories()</code> 命令将这个子目录也加入头文件检索路径。</li></ol></li></ol><p>完整的顶层目录 <code>CMakeLists.txt</code> 文件内容如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake>cmake_minimum_required(<span style=color:#e6db74>VERSION</span> <span style=color:#e6db74>3.1</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>project(<span style=color:#e6db74>Tutorial</span> <span style=color:#e6db74>VERSION</span> <span style=color:#e6db74>1.0</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>add_subdirectory(<span style=color:#e6db74>MathFunctions</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>configure_file(<span style=color:#e6db74>TutorialConfig.h.in</span> <span style=color:#e6db74>TutorialConfig.h</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>add_executable(<span style=color:#e6db74>Tutorial</span> <span style=color:#e6db74>Tutorial.c</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>target_link_libraries(<span style=color:#e6db74>Tutorial</span> <span style=color:#e6db74>PUBLIC</span> <span style=color:#e6db74>MathFunctions</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>target_include_directories(<span style=color:#e6db74>Tutorial</span> <span style=color:#e6db74>PUBLIC</span> 
                            <span style=color:#e6db74>&#34;${PROJECT_BINARY_DIR}&#34;</span>
                            <span style=color:#e6db74>&#34;${PROJECT_SOURCE_DIR}/MathFunctions&#34;</span>
                            )</code></pre></div><p>然后，在 <code>build</code> 目录下依次执行 <code>cmake ..</code> 和 <code>cmake --build .</code> ，编译生成可执行文件 <code>Tutorial</code> ，执行：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>~$ ./Tutorial
Hello World!
Version <span style=color:#ae81ff>1</span>.0
Computing sqrt of <span style=color:#ae81ff>4</span>.000000 to be <span style=color:#ae81ff>2</span>.500000 .
Computing sqrt of <span style=color:#ae81ff>4</span>.000000 to be <span style=color:#ae81ff>2</span>.050000 .
Computing sqrt of <span style=color:#ae81ff>4</span>.000000 to be <span style=color:#ae81ff>2</span>.000610 .
Computing sqrt of <span style=color:#ae81ff>4</span>.000000 to be <span style=color:#ae81ff>2</span>.000000 .
Computing sqrt of <span style=color:#ae81ff>4</span>.000000 to be <span style=color:#ae81ff>2</span>.000000 .
Computing sqrt of <span style=color:#ae81ff>4</span>.000000 to be <span style=color:#ae81ff>2</span>.000000 .
Computing sqrt of <span style=color:#ae81ff>4</span>.000000 to be <span style=color:#ae81ff>2</span>.000000 .
Computing sqrt of <span style=color:#ae81ff>4</span>.000000 to be <span style=color:#ae81ff>2</span>.000000 .
Computing sqrt of <span style=color:#ae81ff>4</span>.000000 to be <span style=color:#ae81ff>2</span>.000000 .
Computing sqrt of <span style=color:#ae81ff>4</span>.000000 to be <span style=color:#ae81ff>2</span>.000000 .
The square root of <span style=color:#ae81ff>4</span>.000000 is <span style=color:#ae81ff>2</span>.000000 .</code></pre></div><h3 id=提供可选项>提供可选项</h3><p>上一步添加的 <code>MathFunctions</code> 库可以做成一个可选的模块，这是大型工程里的常见做法。</p><p>首先需要用 <code>option()</code> 命令设置一个选项：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake>option(<span style=color:#e6db74>USE_MYMATH,</span> <span style=color:#e6db74>&#34;Use tutorial provided math implementation&#34;</span><span style=color:#e6db74>,</span> <span style=color:#e6db74>ON</span>)</code></pre></div><p>这样就设置了一个名为 <code>USE_MYMATH</code> 的选项，初始值是 <code>ON</code> 。<code>option()</code> 的作用是新建一个用户可以选择的选项，语法很简单：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake>option(<span style=color:#e6db74>&lt;variable&gt;</span> <span style=color:#e6db74>&#34;&lt;help_text&gt;&#34;</span> <span style=color:#e6db74>[value]</span>)</code></pre></div><p>三个参数依次是选项的变量名，选项的描述，选项的初始值。选项的值只有两个：<code>ON</code> 和 <code>OFF</code> ，如果没有设置初始值，默认就是 <code>OFF</code> 。</p><p>然后可以通过这个选项，把模块相关的语句包裹在一个选择语句中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake>option(<span style=color:#e6db74>USE_MYMATH</span> <span style=color:#e6db74>&#34;Use tutorial provided math implementation&#34;</span> <span style=color:#e6db74>ON</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>if(<span style=color:#e6db74>USE_MYMATH</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>    add_subdirectory(<span style=color:#e6db74>MathFunctions</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>    list(<span style=color:#e6db74>APPEND</span> <span style=color:#e6db74>EXTRA_LIBS</span> <span style=color:#e6db74>MathFunctions</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>    list(<span style=color:#e6db74>APPEND</span> <span style=color:#e6db74>EXTRA_INCLUDES</span> <span style=color:#e6db74>&#34;${PROJECT_SOURCE_DIR}/MathFunctions&#34;</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>endif()<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>target_link_libraries(<span style=color:#e6db74>Tutorial</span> <span style=color:#e6db74>PUBLIC</span> <span style=color:#f92672>${</span>EXTRA_LIBS<span style=color:#f92672>}</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>target_include_directories(<span style=color:#e6db74>Tutorial</span> <span style=color:#e6db74>PUBLIC</span> 
                            <span style=color:#e6db74>&#34;${PROJECT_BINARY_DIR}&#34;</span>
                            <span style=color:#e6db74>&#34;${EXTRA_INCLUDES}&#34;</span>
                            )</code></pre></div><p><code>list()</code> 命令用于操作列表，<code>APPEND</code> 可以将一个元素追加到一个列表的尾部。后面通过新建的列表调用模块，这样的话，只有 <code>USE_MYMATH</code> 的值为 <code>ON</code> 时，才会将模块包含在编译过程中。</p><p>源码中的修改比较简单，只需修改 <code>Tutorial.c</code> 文件，通过宏定义将模块相关的语句做成可选项：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#ifdef USE_MYMATH
</span><span style=color:#75715e></span>    <span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;MathFunctions/MathFunctions.h&#34;</span><span style=color:#75715e>
</span><span style=color:#75715e>#endif
</span><span style=color:#75715e></span>
<span style=color:#75715e>#ifdef USE_MYMATH
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> output <span style=color:#f92672>=</span> mysqrt(input);
    printf(<span style=color:#e6db74>&#34;The square root of %f is %f .</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, input, output);
<span style=color:#75715e>#endif</span></code></pre></div><p>这个宏定义的值也需要通过 <code>TutorialConfig.h.in</code> 文件传递给源码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=color:#960050;background-color:#1e0010>#cmakedefine</span> <span style=color:#960050;background-color:#1e0010>USE_MYMATH</span></code></pre></div><p>执行到 <code>configure_file()</code> 命令的时候，如果 <code>USE_MYMATH</code> 的值是 <code>ON</code> ，这条语句会被替换为 <code>#define USE_MYMATH</code> ；如果 <code>USE_MYMATH</code> 的值是 <code>OFF</code> ，这条语句会被替换为一行注释 <code>/* #undef USE_MYMATH */</code> 。</p><h3 id=设置库文件的使用要求>设置库文件的使用要求</h3><p>构建 C 语言的工程时，应该清晰的规划模块之间的关系，在编译时，先编译出子模块的目标文件，再由这些目标文件链接起来生成上一层的目标文件，层层递进，最终编译出可执行文件。目标文件包括 <a href=https://cmake.org/cmake/help/latest/command/add_executable.html#command:add_executable target=_blank><code>add_executable()</code></a> 和 <a href=https://cmake.org/cmake/help/latest/command/add_library.html#command:add_library target=_blank><code>add_library()</code></a> 命令生成的可执行文件和库。目标文件的依赖关系是通过两条命令控制的：</p><ul><li><a href=https://cmake.org/cmake/help/latest/command/target_include_directories.html#command:target_include_directories target=_blank><code>target_include_directories()</code></a> ，向目标文件添加编译时的头文件检索目录。</li><li><a href=https://cmake.org/cmake/help/latest/command/target_link_libraries.html#command:target_link_libraries target=_blank><code>target_link_libraries()</code></a> ，向目标文件添加编译时依赖的库。</li></ul><p>这两条命令需要一个控制传递属性的参数，可选三种关键字：</p><ul><li><code>PRIVATE</code> ，私有。库文件提供的方法只供目标文件使用，不会暴露给更上层目标文件。即生产者需要，消费者不需要。</li><li><code>INTERFACE</code> ，接口。库文件提供的方法会暴露给上层文件使用，本目标文件只用到了库文件提供的一些数据结构和声明等。即生产者不需要，消费者需要。</li><li><code>PUBLIC</code> ，公开。库文件提供的方法可以供所有目标文件使用。即生产者和消费者都需要。</li></ul><p>以上一节的工程为例，目录结果是：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>.
├── build
├── CMakeLists.txt
├── MathFunctions      <span style=color:#75715e># 生成 libMathFunctions.a</span>
│   ├── CMakeLists.txt
│   ├── MathFunctions.h
│   └── mysqrt.c
├── Tutorial.c
└── TutorialConfig.h.in</code></pre></div><p>目标 <code>MathFunctions</code> 需要的头文件 <code>MathFunctions.h</code> 中的声明，并将方法暴露给上一层的 <code>Tutorial.c</code> 使用。所以，目标 <code>MathFunctions</code> 对头文件 <code>MathFunctions.h</code> 的使用要求就是 <code>INTERFACE</code> ，目标 <code>Tutrial</code> 对目标 <code>MathFunctions</code> 的使用要求是 <code>PRIVATE</code> 。</p><p>那么，可以在 <code>MathFunctions/CMakeLists.txt</code> 中添加一行：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake>target_include_directories(<span style=color:#e6db74>MathFunctions</span>
        <span style=color:#e6db74>INTERFACE</span> <span style=color:#f92672>${</span>CMAKE_CURRENT_SOURCE_DIR<span style=color:#f92672>}</span>
        )</code></pre></div><p>然后就可以把顶层 <code>CMakeLists.txt</code> 中包含头文件的部分删除，并将库文件的使用要求改为私有：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake>if(<span style=color:#e6db74>USE_MYMATH</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>    add_subdirectory(<span style=color:#e6db74>MathFunctions</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>    list(<span style=color:#e6db74>APPEND</span> <span style=color:#e6db74>EXTRA_LIBS</span> <span style=color:#e6db74>MathFunctions</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>endif()<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>target_link_libraries(<span style=color:#e6db74>Tutorial</span> <span style=color:#e6db74>PRIVATE</span> <span style=color:#f92672>${</span>EXTRA_LIBS<span style=color:#f92672>}</span>)<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>target_include_directories(<span style=color:#e6db74>Tutorial</span> <span style=color:#e6db74>PRIVATE</span> 
                            <span style=color:#e6db74>&#34;${PROJECT_BINARY_DIR}&#34;</span>
                            )</code></pre></div><h2 id=3-安装和测试>3. 安装和测试</h2><p>这个工程只需要把可执行文件安装到指定的目录，所以，在顶层 <code>CMakeLists.txt</code> 目录下添加一行：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake>install(<span style=color:#e6db74>TARGETS</span> <span style=color:#e6db74>Tutorial</span> <span style=color:#e6db74>DESTINATION</span> <span style=color:#e6db74>bin</span>)</code></pre></div><p>这样，在执行 <code>make install</code> 时，就会把 <code>Tutorial</code> 文件安装到 <code>/usr/local/bin/</code> 目录下，默认的前缀是 <code>/usr/local/</code> ，如果要换别的目录，可以写上绝对路径。</p></div></article><hr><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83.0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=https://shaocheng.li/tags/untagged>untagged</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>808 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2020-06-29 14:25 &#43;0000</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://shaocheng.li/posts/2020/07/16/><span class=button__icon>←</span>
<span class=button__text>libubox 学习笔记</span></a></span>
<span class="button next"><a href=https://shaocheng.li/posts/2020/04/12/><span class=button__text>tcpdump 使用笔记</span>
<span class=button__icon>→</span></a></span></div></div><div id=comments class=thin><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"shaocheng-li"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2021</span>
<span><a href=https://shaocheng.li>Shaocheng.Li</a></span>
<span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span>
<span><a href=https://shaocheng.li/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"/><path d="M4 4a16 16 0 0 1 16 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div><div class=footer__inner><div class=footer__content><span>Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>Made with &#10084; by <a href=https://github.com/rhazdon>rhazdon</a></span></div></div></footer></div><script type=text/javascript src=https://shaocheng.li/bundle.min.2d5469329143160ae2456a69c3c76dc2d0a3b212b46afe291a51bd68650ed6f8697e001dab54f1c272c77ce08092a8c55e5bb4314e0ee334aab4b927ec896638.js integrity="sha512-LVRpMpFDFgriRWppw8dtwtCjshK0av4pGlG9aGUO1vhpfgAdq1TxwnLHfOCAkqjFXlu0MU4O4zSqtLkn7IlmOA=="></script></body></html>