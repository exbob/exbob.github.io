<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="Shaocheng.Li"><meta name=description content="Linux 内核实现了一个循环双向链表，而且是侵入式链表，核心数据结构定义在 include/linux/types.h 文件：
struct list_head { struct list_head *next, *prev; }; 实现方法都定义在 include/linux/list.h 文件。
1. 初始化链表 内核提供了两种初始化链表节点的方法。
一种是初始化宏：
#define LIST_HEAD_INIT(name) { &amp;amp;(name), &amp;amp;(name) }  #define LIST_HEAD(name) \ struct list_head name = LIST_HEAD_INIT(name) 展开后就是：
#define LIST_HEAD(name) \ struct list_head name = { &amp;amp;(name), &amp;amp;(name) } 它的作用是新建一个 struct list_head 变量 name ，让两个指针指向自己，通常用户新建一个链表的 head ：
另一种是初始化函数 ：
static inline void INIT_LIST_HEAD(struct list_head *list) { WRITE_ONCE(list-&amp;gt;next, list); list-&amp;gt;prev = list; } 它的作用是让节点 struct list_head *list 的两个指针指向自己，通常用于初始一个节点。"><meta name=keywords content><meta name=robots content="noodp"><meta name=theme-color content="#252627"><link rel=canonical href=https://shaocheng.li/posts/2022/04/20/><title>Linux 内核数据结构-链表 :: Shaocheng.Li — Hello Friends</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=https://shaocheng.li/main.min.e9b3dfcc5ffe9d55eb281ecaf47cf6179d26eec497e087299934d581c987aa0b.css><link rel=stylesheet type=text/css href=https://shaocheng.li/css/custom.css><link rel=apple-touch-icon sizes=180x180 href=https://shaocheng.li/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://shaocheng.li/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://shaocheng.li/favicon-16x16.png><link rel=manifest href=https://shaocheng.li/site.webmanifest><link rel=mask-icon href=https://shaocheng.li/safari-pinned-tab.svg color=#252627><link rel="shortcut icon" href=https://shaocheng.li/favicon.ico><meta name=msapplication-TileColor content="#252627"><meta name=theme-color content="#252627"><meta itemprop=name content="Linux 内核数据结构-链表"><meta itemprop=description content="Linux 内核实现了一个循环双向链表，而且是侵入式链表，核心数据结构定义在 include/linux/types.h 文件：
struct list_head { struct list_head *next, *prev; }; 实现方法都定义在 include/linux/list.h 文件。
1. 初始化链表 内核提供了两种初始化链表节点的方法。
一种是初始化宏：
#define LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) }  #define LIST_HEAD(name) \ struct list_head name = LIST_HEAD_INIT(name) 展开后就是：
#define LIST_HEAD(name) \ struct list_head name = { &amp;(name), &amp;(name) } 它的作用是新建一个 struct list_head 变量 name ，让两个指针指向自己，通常用户新建一个链表的 head ：
另一种是初始化函数 ：
static inline void INIT_LIST_HEAD(struct list_head *list) { WRITE_ONCE(list-&gt;next, list); list-&gt;prev = list; } 它的作用是让节点 struct list_head *list 的两个指针指向自己，通常用于初始一个节点。"><meta itemprop=datePublished content="2022-04-20T18:34:49&#43;08:00"><meta itemprop=dateModified content="2022-04-20T18:34:49&#43;08:00"><meta itemprop=wordCount content="489"><meta itemprop=keywords content="untagged,"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://shaocheng.li"><meta name=twitter:title content="Linux 内核数据结构-链表"><meta name=twitter:description content="Linux 内核实现了一个循环双向链表，而且是侵入式链表，核心数据结构定义在 include/linux/types.h 文件：
struct list_head { struct list_head *next, *prev; }; 实现方法都定义在 include/linux/list.h 文件。
1. 初始化链表 内核提供了两种初始化链表节点的方法。
一种是初始化宏：
#define LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) }  #define LIST_HEAD(name) \ struct list_head name = LIST_HEAD_INIT(name) 展开后就是：
#define LIST_HEAD(name) \ struct list_head name = { &amp;(name), &amp;(name) } 它的作用是新建一个 struct list_head 变量 name ，让两个指针指向自己，通常用户新建一个链表的 head ：
另一种是初始化函数 ：
static inline void INIT_LIST_HEAD(struct list_head *list) { WRITE_ONCE(list-&gt;next, list); list-&gt;prev = list; } 它的作用是让节点 struct list_head *list 的两个指针指向自己，通常用于初始一个节点。"><meta property="article:published_time" content="2022-04-20 18:34:49 &#43;0800 &#43;0800"></head><body><div class=container><header class=header><span class=header__inner><a href=https://shaocheng.li/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>$ cd /home/</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=https://shaocheng.li/about/>About</a></li><li><a href=https://shaocheng.li/posts/>Posts</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41C32.4934 41 41 32.4934 41 22 41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>3 minutes</p></div><article><h1 class=post-title><a href=https://shaocheng.li/posts/2022/04/20/>Linux 内核数据结构-链表</a></h1><hr><aside id=toc><div class=toc-title>Table of Contents</div><nav id=TableOfContents><ul><li><ul><li><a href=#1-初始化链表>1. 初始化链表</a></li><li><a href=#2-添加节点>2. 添加节点</a></li><li><a href=#3-删除节点>3. 删除节点</a></li><li><a href=#4-判断节点的位置>4. 判断节点的位置</a></li><li><a href=#5-查找节点>5. 查找节点</a></li><li><a href=#6-遍历链表>6. 遍历链表</a></li><li><a href=#7-例程>7. 例程</a></li></ul></li></ul></nav></aside><hr><div class=post-content><p>Linux 内核实现了一个循环双向链表，而且是侵入式链表，核心数据结构定义在 <code>include/linux/types.h</code> 文件：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> list_head {
  <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>next, <span style=color:#f92672>*</span>prev;
};</code></pre></div><p>实现方法都定义在 <code>include/linux/list.h</code> 文件。</p><p><img src="https://shaocheng.li/images/2022-04-20/绘图文件 (1)_MJv1V110Os.jpg" alt></p><h2 id=1-初始化链表>1. 初始化链表</h2><p>内核提供了两种初始化链表节点的方法。</p><p>一种是初始化宏：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) }
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define LIST_HEAD(name) \
</span><span style=color:#75715e>    struct list_head name = LIST_HEAD_INIT(name)</span></code></pre></div><p>展开后就是：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define LIST_HEAD(name) \
</span><span style=color:#75715e>    struct list_head name = { &amp;(name), &amp;(name) }</span></code></pre></div><p>它的作用是新建一个 <code>struct list_head</code> 变量 name ，让两个指针指向自己，通常用户新建一个链表的 head ：</p><p><img src=https://shaocheng.li/images/2022-04-20/绘图文件_nQobzytDTU.jpg alt></p><p>另一种是初始化函数 ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>INIT_LIST_HEAD</span>(<span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>list)
{
  WRITE_ONCE(list<span style=color:#f92672>-&gt;</span>next, list);
  list<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> list;
}</code></pre></div><p>它的作用是让节点 <code>struct list_head *list</code> 的两个指针指向自己，通常用于初始一个节点。</p><p>内核的 <code>struct list_head</code> 保持了最简的结构，其他数据结构要表示为链表时，需要将 <code>struct list_head</code> 元素嵌入到自己的数据结构中，例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// 新建一个链表，head 就是 students_list
</span><span style=color:#75715e></span>LIST_HEAD(students_list);
    
<span style=color:#75715e>// 新建两个节点，并初始化
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> student <span style=color:#f92672>*</span>student_1 <span style=color:#f92672>=</span> kmalloc(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> student), GFP_KERNEL);
<span style=color:#66d9ef>struct</span> student <span style=color:#f92672>*</span>student_2 <span style=color:#f92672>=</span> kmalloc(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> student), GFP_KERNEL);

student_1<span style=color:#f92672>-&gt;</span>id <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
strcpy(student_1<span style=color:#f92672>-&gt;</span>name, <span style=color:#e6db74>&#34;Bob&#34;</span>);
INIT_LIST_HEAD(<span style=color:#f92672>&amp;</span>student_1<span style=color:#f92672>-&gt;</span>list);
    
student_2<span style=color:#f92672>-&gt;</span>id <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
strcpy(student_2<span style=color:#f92672>-&gt;</span>name, <span style=color:#e6db74>&#34;Alice&#34;</span>);
INIT_LIST_HEAD(<span style=color:#f92672>&amp;</span>student_2<span style=color:#f92672>-&gt;</span>list);

<span style=color:#75715e>// 将两个节点依次插入队尾
</span><span style=color:#75715e></span>list_add_tail(<span style=color:#f92672>&amp;</span>student_1<span style=color:#f92672>-&gt;</span>list, <span style=color:#f92672>&amp;</span>students_list);
list_add_tail(<span style=color:#f92672>&amp;</span>student_2<span style=color:#f92672>-&gt;</span>list, <span style=color:#f92672>&amp;</span>students_list);</code></pre></div><p>实际构造的链表结构如下：</p><p><img src="https://shaocheng.li/images/2022-04-20/绘图文件 (4)_ULgPNVvQd1.jpg" alt></p><h2 id=2-添加节点>2. 添加节点</h2><p>在 head 后面（也就是队头）添加一个 new 节点：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> list_add(<span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>new, <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>head)</code></pre></div><p><img src="https://shaocheng.li/images/2022-04-20/绘图文件 (2)_rKgYQjqfsc.jpg" alt></p><p>在 head 前面（也就是队尾）添加一个 new 节点：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> list_add_tail(<span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>new, <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>head)</code></pre></div><p><img src="https://shaocheng.li/images/2022-04-20/绘图文件 (3)_F4GTz4yKYb.jpg" alt></p><p>例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>list_add(<span style=color:#f92672>&amp;</span>student_1<span style=color:#f92672>-&gt;</span>list, <span style=color:#f92672>&amp;</span>students_list);</code></pre></div><h2 id=3-删除节点>3. 删除节点</h2><p>删除一个节点：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> list_del(<span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>entry)</code></pre></div><p>例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>list_del(<span style=color:#f92672>&amp;</span>student_1<span style=color:#f92672>-&gt;</span>list);</code></pre></div><h2 id=4-判断节点的位置>4. 判断节点的位置</h2><p>判断 list 节点是否是 head 链表的 firts/last 节点，如果正确会返回 1 ，错误返回 0 ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> list_is_first(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>list, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>head)
<span style=color:#66d9ef>int</span> list_is_last(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>list, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>head)</code></pre></div><p>判断一个链表是否为空格，如果为空会返回 1 ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> list_empty(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> list_head <span style=color:#f92672>*</span>head)</code></pre></div><h2 id=5-查找节点>5. 查找节点</h2><p>作为侵入式链表，需要通过 <code>struct list_head</code> 结构的节点地址获得真正的数据节点，内核提供了 container_of 的重新封装：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define list_entry(ptr, type, member) container_of(ptr, type, member)</span></code></pre></div><p>三个参数分别表示：</p><ul><li><p>ptr ：结构体成员变量 member 的地址，就是 <code>struct list_head</code> 成员的地址，</p></li><li><p>type ：数据节点的结构体类型的名称</p></li><li><p>member ：结构体成员变量的名称</p></li></ul><p>例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>list_entry(<span style=color:#f92672>&amp;</span>student_1<span style=color:#f92672>-&gt;</span>list, <span style=color:#66d9ef>struct</span> student, list)</code></pre></div><p>返回队头/队尾的节点：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>list_first_entry(head, type, member)
list_last_entry(head, type, member)</code></pre></div><p>三个参数分别表示：</p><ul><li><p>head ：链表头的地址，</p></li><li><p>type ：结构体类型的名称</p></li><li><p>member ：结构体中的成员变量的名称</p></li></ul><p>例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> student <span style=color:#f92672>*</span>entry;
entry <span style=color:#f92672>=</span> list_first_entry(<span style=color:#f92672>&amp;</span>students_list, <span style=color:#66d9ef>struct</span> student, list);</code></pre></div><p>获取下一个/上一个节点：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>list_next_entry(pos, member)
list_prev_entry(pos, member) </code></pre></div><p>两个参数的含义：</p><ul><li><p>pos ：数据节点的地址</p></li><li><p>member：数据节点内 <code>sturct list_head</code> 成员的名称</p></li></ul><p>例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> student <span style=color:#f92672>*</span>entry;
entry <span style=color:#f92672>=</span> list_first_entry(<span style=color:#f92672>&amp;</span>students_list, <span style=color:#66d9ef>struct</span> student, list);
entry <span style=color:#f92672>=</span> list_next_entry(entry, list);</code></pre></div><h2 id=6-遍历链表>6. 遍历链表</h2><p>内核定义了一个宏，用于从队头开始遍历链表：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define list_for_each_entry(pos, head, member)        \
</span><span style=color:#75715e>  for (pos = list_first_entry(head, typeof(*pos), member);  \
</span><span style=color:#75715e>       &amp;pos-&gt;member != (head);          \
</span><span style=color:#75715e>       pos = list_next_entry(pos, member))</span></code></pre></div><p>三个参数的含义：</p><ul><li><p>pos ：一个数据节点类型的指针，用于遍历链表中的每个节点</p></li><li><p>head ：链表的 head&#x20;</p></li><li><p>member ：数据节点内 <code>sturct list_head</code> 成员的名称</p></li></ul><p>例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>list_for_each_entry(entry, <span style=color:#f92672>&amp;</span>students_list, list)
{
    printk(<span style=color:#e6db74>&#34;entry %d:%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, entry<span style=color:#f92672>-&gt;</span>id, entry<span style=color:#f92672>-&gt;</span>name);
}</code></pre></div><h2 id=7-例程>7. 例程</h2><p>hellomod.c ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;linux/init.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;linux/module.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;linux/slab.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;linux/string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>struct</span> student {
    <span style=color:#66d9ef>int</span> id;
    <span style=color:#66d9ef>char</span> name[<span style=color:#ae81ff>10</span>];
    <span style=color:#66d9ef>struct</span> list_head list;
};

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> __init <span style=color:#a6e22e>hellomod_init</span>(<span style=color:#66d9ef>void</span>)
{
    <span style=color:#66d9ef>struct</span> student <span style=color:#f92672>*</span>entry;
    <span style=color:#75715e>// 新建一个链表
</span><span style=color:#75715e></span>    LIST_HEAD(students_list);
    
    <span style=color:#75715e>// 新建两个节点，并初始化
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> student <span style=color:#f92672>*</span>student_1 <span style=color:#f92672>=</span> kmalloc(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> student), GFP_KERNEL);
    <span style=color:#66d9ef>struct</span> student <span style=color:#f92672>*</span>student_2 <span style=color:#f92672>=</span> kmalloc(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> student), GFP_KERNEL);

    student_1<span style=color:#f92672>-&gt;</span>id <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
    strcpy(student_1<span style=color:#f92672>-&gt;</span>name, <span style=color:#e6db74>&#34;Bob&#34;</span>);
    INIT_LIST_HEAD(<span style=color:#f92672>&amp;</span>student_1<span style=color:#f92672>-&gt;</span>list);
    
    student_2<span style=color:#f92672>-&gt;</span>id <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
    strcpy(student_2<span style=color:#f92672>-&gt;</span>name, <span style=color:#e6db74>&#34;Alice&#34;</span>);
    INIT_LIST_HEAD(<span style=color:#f92672>&amp;</span>student_2<span style=color:#f92672>-&gt;</span>list);

    <span style=color:#75715e>// 将两个节点依次插入队尾
</span><span style=color:#75715e></span>    list_add_tail(<span style=color:#f92672>&amp;</span>student_1<span style=color:#f92672>-&gt;</span>list, <span style=color:#f92672>&amp;</span>students_list);
    list_add_tail(<span style=color:#f92672>&amp;</span>student_2<span style=color:#f92672>-&gt;</span>list, <span style=color:#f92672>&amp;</span>students_list);

    entry <span style=color:#f92672>=</span> list_first_entry(<span style=color:#f92672>&amp;</span>students_list, <span style=color:#66d9ef>struct</span> student, list);
    printk(<span style=color:#e6db74>&#34;first entry is %d:%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, entry<span style=color:#f92672>-&gt;</span>id, entry<span style=color:#f92672>-&gt;</span>name);

    entry <span style=color:#f92672>=</span> list_next_entry(entry, list);
    printk(<span style=color:#e6db74>&#34;next entry of first entry is %d:%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, entry<span style=color:#f92672>-&gt;</span>id, entry<span style=color:#f92672>-&gt;</span>name);

    list_for_each_entry(entry, <span style=color:#f92672>&amp;</span>students_list, list)
    {
        printk(<span style=color:#e6db74>&#34;entry %d:%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, entry<span style=color:#f92672>-&gt;</span>id, entry<span style=color:#f92672>-&gt;</span>name);
    }
    printk(<span style=color:#e6db74>&#34;hellomod init</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
    
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> __exit <span style=color:#a6e22e>hellomod_exit</span>(<span style=color:#66d9ef>void</span>)
{
    printk(<span style=color:#e6db74>&#34;hellomod exit</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
}

module_init(hellomod_init);
module_exit(hellomod_exit);

MODULE_LICENSE(<span style=color:#e6db74>&#34;GPL&#34;</span>);</code></pre></div><p>Makefile ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>KERDIR<span style=color:#f92672>=/</span>lib<span style=color:#f92672>/</span>modules<span style=color:#f92672>/</span><span style=color:#960050;background-color:#1e0010>$</span>(shell uname <span style=color:#f92672>-</span>r)<span style=color:#f92672>/</span>build
PWD<span style=color:#f92672>=</span><span style=color:#960050;background-color:#1e0010>$</span>(shell pwd)

obj<span style=color:#f92672>-</span>m:<span style=color:#f92672>=</span>hellomod.o

<span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
  make <span style=color:#f92672>-</span>C <span style=color:#960050;background-color:#1e0010>$</span>{KERDIR} M<span style=color:#f92672>=</span><span style=color:#960050;background-color:#1e0010>$</span>{PWD} modules
clean:
  make <span style=color:#f92672>-</span>C <span style=color:#960050;background-color:#1e0010>$</span>{KERDIR} M<span style=color:#f92672>=</span><span style=color:#960050;background-color:#1e0010>$</span>{PWD} clean</code></pre></div><p>编译后加载驱动：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#960050;background-color:#1e0010>$</span> make
<span style=color:#960050;background-color:#1e0010>$</span> sudo insmod hellomod.ko
<span style=color:#960050;background-color:#1e0010>$</span> dmesg
[<span style=color:#ae81ff>35509.579609</span>] first entry is <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>Bob
[<span style=color:#ae81ff>35509.579610</span>] next entry of first entry is <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span>Alice
[<span style=color:#ae81ff>35509.579611</span>] entry <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>Bob
[<span style=color:#ae81ff>35509.579611</span>] entry <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span>Alice
[<span style=color:#ae81ff>35509.579611</span>] hellomod init</code></pre></div></div></article><hr><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83.0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=https://shaocheng.li/tags/untagged>untagged</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>489 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2022-04-20 10:34 &#43;0000</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://shaocheng.li/posts/2022/05/07/><span class=button__icon>←</span>
<span class=button__text>Linux 进程调度的学习笔记</span></a></span>
<span class="button next"><a href=https://shaocheng.li/posts/2022/03/13/><span class=button__text>Linux 内核镜像的类型和区别</span>
<span class=button__icon>→</span></a></span></div></div><div id=comments class=thin><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"shaocheng-li"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2022</span>
<span><a href=https://shaocheng.li>Shaocheng.Li</a></span>
<span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span>
<span><a href=https://shaocheng.li/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"/><path d="M4 4a16 16 0 0 1 16 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div><div class=footer__inner><div class=footer__content><span>Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>Made with &#10084; by <a href=https://github.com/rhazdon>rhazdon</a></span></div></div></footer></div><script type=text/javascript src=https://shaocheng.li/bundle.min.2d5469329143160ae2456a69c3c76dc2d0a3b212b46afe291a51bd68650ed6f8697e001dab54f1c272c77ce08092a8c55e5bb4314e0ee334aab4b927ec896638.js integrity="sha512-LVRpMpFDFgriRWppw8dtwtCjshK0av4pGlG9aGUO1vhpfgAdq1TxwnLHfOCAkqjFXlu0MU4O4zSqtLkn7IlmOA=="></script></body></html>