<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="Shaocheng.Li"><meta name=description content="以 NXP 的 iMX Yocto 4.9.88 系统版本为例，启动分为三个阶段：U-Boot ，内核，根文件系统，每个阶段都可以设置自己的显示画面。
U-Boot 的启动画面 u-boot 阶段的运行时很短，一般不用修改。待补充。
内核的启动画面 PPM 图片格式 如果开启了 FrameBuffer ，Linux 内核启动时会在屏幕左上角显示企鹅图标，图标的数量等于 CPU 的核心数量。这个图标来自于内核源码的 driver/video/logo/ 目录下的 ppm 格式图片：
$ ls drivers/video/logo/ clut_vga16.ppm logo_linux_mono.pbm logo_sun_clut224.ppm Kconfig logo_linux_vga16.ppm logo_superh_clut224.ppm logo_blackfin_clut224.ppm logo_m32r_clut224.ppm logo_superh_mono.pbm logo_blackfin_vga16.ppm logo_mac_clut224.ppm logo_superh_vga16.ppm logo.c logo_parisc_clut224.ppm Makefile logo_dec_clut224.ppm logo_sgi_clut224.ppm logo_linux_clut224.ppm logo_spe_clut224.ppm 这里的 ppm 格式是一种 ASCII 编码的图片文件格式，可以用文本编辑器打开，以 logo_linux_clut224.ppm 为例 ：
P3 # Standard 224-color Linux logo 80 80 255 0 0 0 0 0 0 0 0 0 0 0 0  井号 # 开头的是注释，忽略注释后，前三行文本是文件头："><meta name=keywords content><meta name=robots content="noodp"><meta name=theme-color content="#252627"><link rel=canonical href=https://shaocheng.li/posts/2021/05/07/><title>如何修改 ARM Linux 系统的启动画面 :: Shaocheng.Li — Hello Friends</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=https://shaocheng.li/main.min.e9b3dfcc5ffe9d55eb281ecaf47cf6179d26eec497e087299934d581c987aa0b.css><link rel=stylesheet type=text/css href=https://shaocheng.li/css/custom.css><link rel=apple-touch-icon sizes=180x180 href=https://shaocheng.li/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://shaocheng.li/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://shaocheng.li/favicon-16x16.png><link rel=manifest href=https://shaocheng.li/site.webmanifest><link rel=mask-icon href=https://shaocheng.li/safari-pinned-tab.svg color=#252627><link rel="shortcut icon" href=https://shaocheng.li/favicon.ico><meta name=msapplication-TileColor content="#252627"><meta name=theme-color content="#252627"><meta itemprop=name content="如何修改 ARM Linux 系统的启动画面"><meta itemprop=description content="以 NXP 的 iMX Yocto 4.9.88 系统版本为例，启动分为三个阶段：U-Boot ，内核，根文件系统，每个阶段都可以设置自己的显示画面。
U-Boot 的启动画面 u-boot 阶段的运行时很短，一般不用修改。待补充。
内核的启动画面 PPM 图片格式 如果开启了 FrameBuffer ，Linux 内核启动时会在屏幕左上角显示企鹅图标，图标的数量等于 CPU 的核心数量。这个图标来自于内核源码的 driver/video/logo/ 目录下的 ppm 格式图片：
$ ls drivers/video/logo/ clut_vga16.ppm logo_linux_mono.pbm logo_sun_clut224.ppm Kconfig logo_linux_vga16.ppm logo_superh_clut224.ppm logo_blackfin_clut224.ppm logo_m32r_clut224.ppm logo_superh_mono.pbm logo_blackfin_vga16.ppm logo_mac_clut224.ppm logo_superh_vga16.ppm logo.c logo_parisc_clut224.ppm Makefile logo_dec_clut224.ppm logo_sgi_clut224.ppm logo_linux_clut224.ppm logo_spe_clut224.ppm 这里的 ppm 格式是一种 ASCII 编码的图片文件格式，可以用文本编辑器打开，以 logo_linux_clut224.ppm 为例 ：
P3 # Standard 224-color Linux logo 80 80 255 0 0 0 0 0 0 0 0 0 0 0 0  井号 # 开头的是注释，忽略注释后，前三行文本是文件头："><meta itemprop=datePublished content="2021-05-07T20:49:11&#43;08:00"><meta itemprop=dateModified content="2021-05-07T20:49:11&#43;08:00"><meta itemprop=wordCount content="2681"><meta itemprop=keywords content="untagged,"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://shaocheng.li"><meta name=twitter:title content="如何修改 ARM Linux 系统的启动画面"><meta name=twitter:description content="以 NXP 的 iMX Yocto 4.9.88 系统版本为例，启动分为三个阶段：U-Boot ，内核，根文件系统，每个阶段都可以设置自己的显示画面。
U-Boot 的启动画面 u-boot 阶段的运行时很短，一般不用修改。待补充。
内核的启动画面 PPM 图片格式 如果开启了 FrameBuffer ，Linux 内核启动时会在屏幕左上角显示企鹅图标，图标的数量等于 CPU 的核心数量。这个图标来自于内核源码的 driver/video/logo/ 目录下的 ppm 格式图片：
$ ls drivers/video/logo/ clut_vga16.ppm logo_linux_mono.pbm logo_sun_clut224.ppm Kconfig logo_linux_vga16.ppm logo_superh_clut224.ppm logo_blackfin_clut224.ppm logo_m32r_clut224.ppm logo_superh_mono.pbm logo_blackfin_vga16.ppm logo_mac_clut224.ppm logo_superh_vga16.ppm logo.c logo_parisc_clut224.ppm Makefile logo_dec_clut224.ppm logo_sgi_clut224.ppm logo_linux_clut224.ppm logo_spe_clut224.ppm 这里的 ppm 格式是一种 ASCII 编码的图片文件格式，可以用文本编辑器打开，以 logo_linux_clut224.ppm 为例 ：
P3 # Standard 224-color Linux logo 80 80 255 0 0 0 0 0 0 0 0 0 0 0 0  井号 # 开头的是注释，忽略注释后，前三行文本是文件头："><meta property="article:published_time" content="2021-05-07 20:49:11 &#43;0800 &#43;0800"></head><body><div class=container><header class=header><span class=header__inner><a href=https://shaocheng.li/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>$ cd /home/</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=https://shaocheng.li/about/>About</a></li><li><a href=https://shaocheng.li/posts/>Posts</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41C32.4934 41 41 32.4934 41 22 41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>13 minutes</p></div><article><h1 class=post-title><a href=https://shaocheng.li/posts/2021/05/07/>如何修改 ARM Linux 系统的启动画面</a></h1><hr><aside id=toc><div class=toc-title>Table of Contents</div><nav id=TableOfContents><ul><li><ul><li><a href=#u-boot-的启动画面>U-Boot 的启动画面</a></li><li><a href=#内核的启动画面>内核的启动画面</a><ul><li><a href=#ppm-图片格式>PPM 图片格式</a></li><li><a href=#显示启动画面的过程>显示启动画面的过程</a></li><li><a href=#更换启动画面>更换启动画面</a></li><li><a href=#动态修改启动画面>动态修改启动画面</a></li><li><a href=#一些问题>一些问题</a></li><li><a href=#关于保留内存>关于保留内存</a></li></ul></li><li><a href=#用户空间的启动画面>用户空间的启动画面</a></li></ul></li></ul></nav></aside><hr><div class=post-content><p>以 NXP 的 iMX Yocto 4.9.88 系统版本为例，启动分为三个阶段：U-Boot ，内核，根文件系统，每个阶段都可以设置自己的显示画面。</p><h2 id=u-boot-的启动画面>U-Boot 的启动画面</h2><p>u-boot 阶段的运行时很短，一般不用修改。待补充。</p><h2 id=内核的启动画面>内核的启动画面</h2><h3 id=ppm-图片格式>PPM 图片格式</h3><p>如果开启了 FrameBuffer ，Linux 内核启动时会在屏幕左上角显示企鹅图标，图标的数量等于 CPU 的核心数量。这个图标来自于内核源码的 <code>driver/video/logo/</code> 目录下的 ppm 格式图片：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ls drivers/video/logo/
clut_vga16.ppm             logo_linux_mono.pbm      logo_sun_clut224.ppm
Kconfig                    logo_linux_vga16.ppm     logo_superh_clut224.ppm
logo_blackfin_clut224.ppm  logo_m32r_clut224.ppm    logo_superh_mono.pbm
logo_blackfin_vga16.ppm    logo_mac_clut224.ppm     logo_superh_vga16.ppm
logo.c                     logo_parisc_clut224.ppm  Makefile
logo_dec_clut224.ppm       logo_sgi_clut224.ppm
logo_linux_clut224.ppm     logo_spe_clut224.ppm</code></pre></div><p>这里的 ppm 格式是一种 ASCII 编码的图片文件格式，可以用文本编辑器打开，以 logo_linux_clut224.ppm 为例 ：</p><pre><code>P3
# Standard 224-color Linux logo
80 80
255
  0   0   0   0   0   0   0   0   0   0   0   0
</code></pre><p>井号 <code>#</code> 开头的是注释，忽略注释后，前三行文本是文件头：</p><ol><li>第一行表示文件类型，P3 表示 ASCII 编码的 RGB 三色色显现图像</li><li>第二行表示图像的宽度和高度，单位是像素</li><li>第三行表示最大的像素值</li></ol><p>文件头后面所有像素点的数据，每个像素点是由 RGB三个数据组成，RGB 中间用一个空格隔开，像素点之间由两个空格隔开，每一行用回车隔开。</p><p>这样的文件不能供内核直接使用，需要转换成 C 语音的格式。编译内核时，执行的 <code>drivers/video/logo/Makefile</code> 文件会调用 <code>scripts/pnmtologo</code> 工具：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>pnmtologo :<span style=color:#f92672>=</span> scripts/pnmtologo
<span style=color:#75715e># Create commands like &#34;pnmtologo -t mono -n logo_mac_mono -o ...&#34;</span>
quiet_cmd_logo <span style=color:#f92672>=</span> LOGO    $@
    cmd_logo <span style=color:#f92672>=</span> <span style=color:#66d9ef>$(</span>pnmtologo<span style=color:#66d9ef>)</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>         -t <span style=color:#66d9ef>$(</span>patsubst $*_%,%,<span style=color:#66d9ef>$(</span>notdir <span style=color:#66d9ef>$(</span>basename $&lt;<span style=color:#66d9ef>)))</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>         -n <span style=color:#66d9ef>$(</span>notdir <span style=color:#66d9ef>$(</span>basename $&lt;<span style=color:#66d9ef>))</span> -o $@ $&lt;</code></pre></div><p><code>scripts/pnmtologo</code> 是用 <code>scripts/pnmtologo.c</code> 编译生成的二进制工具，执行的语法是：</p><pre><code>./pnmtologo [options] &lt;filename&gt;
可选项:
    -h          : 显示帮助信息
    -n &lt;name&gt;   : 生成的 struct linux_logo 类型变量的名字 (default: linux_logo)
    -o &lt;output&gt; : 生成的 C 语音源文件的名字
    -t &lt;type&gt;   : 启动画面的类型
                      mono    : monochrome black/white
                      vga16   : 16 colors VGA text palette
                      clut224 : 224 colors (default)
                      gray256 : 256 levels grayscale
&lt;filename&gt; 是要解析的 ppm 图片的文件名
</code></pre><p>它会把 <code>driver/video/logo/</code> 目录下 <code>.ppm</code> 文件转换为同名的 <code>.c</code> 文件，例如，logo_linux_clut224.ppm 会转换为 logo_linux_clut224.c ，通过一个 <code>struct linux_logo</code> 变量保存图片的数据。</p><h3 id=显示启动画面的过程>显示启动画面的过程</h3><p>内核绘制 logo 是由 <code>drivers/video/fbdev/core/fbmem.c</code> 文件中的 <code>fb_show_logo()</code> 完成的：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>fb_show_logo</span>(<span style=color:#66d9ef>struct</span> fb_info <span style=color:#f92672>*</span>info, <span style=color:#66d9ef>int</span> rotate)
{
	<span style=color:#66d9ef>int</span> y;

	y <span style=color:#f92672>=</span> fb_show_logo_line(info, rotate, fb_logo.logo, <span style=color:#ae81ff>0</span>,
			      num_online_cpus());
	y <span style=color:#f92672>=</span> fb_show_extra_logos(info, y, rotate);

	<span style=color:#66d9ef>return</span> y;
}</code></pre></div><p>参数 <code>info</code> 传递的 FrameBuffer 的属性，<code>rotate</code> 则表示屏幕的旋转方向。这个函数又调用了 <code>fb_show_logo_line()</code> 函数，参数 <code>num_online_cpus()</code> 是一个宏，它返回了 CPU 的核心数量，参数 <code>fb_logo.logo</code> 是一个 <code>struct linux_logo</code> 指针，这个结构记录了 logo 图片的分辨率和像素数据，它是在 <code>fb_prepare_logo()</code> 函数中由 <code>fb_find_logo()</code> 赋值：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>fb_prepare_logo</span>(<span style=color:#66d9ef>struct</span> fb_info <span style=color:#f92672>*</span>info, <span style=color:#66d9ef>int</span> rotate)
{
...
	<span style=color:#75715e>/* Return if no suitable logo was found */</span>
	fb_logo.logo <span style=color:#f92672>=</span> fb_find_logo(depth);
...
}</code></pre></div><p>参数 <code>depth</code> 表示 FrameBuffer 的颜色深度，基本是由屏幕的素质决定，<code>fb_find_logo()</code> 函数定义在 <code>drivers/video/logo/logo.c</code> 中，它的作用是根据 <code>depth</code> 的值和内核配置决定用那个图片作为 logo ，如果颜色深度是 16 ，且内核配置了 <code>CONFIG_LOGO_LINUX_CLUT224</code> 选项，就用 <code>logo_linux_clut224</code> 作为 logo ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> linux_logo <span style=color:#f92672>*</span> __ref <span style=color:#a6e22e>fb_find_logo</span>(<span style=color:#66d9ef>int</span> depth)
{
	<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> linux_logo <span style=color:#f92672>*</span>logo <span style=color:#f92672>=</span> NULL;
	...
	<span style=color:#66d9ef>if</span> (depth <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>8</span>) {
<span style=color:#75715e>#ifdef CONFIG_LOGO_LINUX_CLUT224
</span><span style=color:#75715e></span>		<span style=color:#75715e>/* Generic Linux logo */</span>
		logo <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>logo_linux_clut224;
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>	...
	<span style=color:#66d9ef>return</span> logo;
}</code></pre></div><p>配置选项是在 menuconfig 中的 <code>Device Drivers &gt; Graphics support &gt; Bootup logo</code> 中设置的：</p><p><img src=https://shaocheng.li/images/2021-05-07/image-20210509122339357.png alt=image-20210509122339357.png></p><p><code>logo_linux_clut224</code> 是一个 <code>struct linux_logo</code> 类型的变量，定义在 <code>logo_linux_clut224.c</code> 文件中，它是在编译时，由 <code>drivers/video/logo/Makefile</code> 文件调用 <code>scripts/pnmtologo</code> 工具，读取 <code>drivers/video/logo/</code> 目录下的同名图片 <code>logo_linux_clut224.ppm</code> 解析后生成的。内容类似如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> logo_linux_clut224_data[] __initdata <span style=color:#f92672>=</span> {
    <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x20</span>,
    ... ...
};
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> logo_linux_clut224_clut[] __initdata <span style=color:#f92672>=</span> {
    <span style=color:#ae81ff>0xff</span>, <span style=color:#ae81ff>0xff</span>, <span style=color:#ae81ff>0xff</span>, <span style=color:#ae81ff>0xff</span>, <span style=color:#ae81ff>0xff</span>, <span style=color:#ae81ff>0xfd</span>, <span style=color:#ae81ff>0xfe</span>, <span style=color:#ae81ff>0xff</span>, <span style=color:#ae81ff>0xff</span>, <span style=color:#ae81ff>0xff</span>, <span style=color:#ae81ff>0xfe</span>, <span style=color:#ae81ff>0xff</span>,
    ... ...
}
<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> linux_logo logo_linux_clut224 __initconst <span style=color:#f92672>=</span> {
     .type       <span style=color:#f92672>=</span> LINUX_LOGO_CLUT224,
     .width      <span style=color:#f92672>=</span> <span style=color:#ae81ff>800</span>,
     .height     <span style=color:#f92672>=</span> <span style=color:#ae81ff>590</span>,
     .clutsize   <span style=color:#f92672>=</span> <span style=color:#ae81ff>223</span>,
     .clut       <span style=color:#f92672>=</span> logo_linux_clut224_clut,
     .data       <span style=color:#f92672>=</span> logo_linux_clut224_data
};</code></pre></div><p>确定了 logo 用的图片后， <code>fb_show_logo_line()</code> 函数会改用 <code>struct fb_image</code> 结构保存要显示的图片：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>fb_show_logo_line</span>(<span style=color:#66d9ef>struct</span> fb_info <span style=color:#f92672>*</span>info, <span style=color:#66d9ef>int</span> rotate,
			     <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> linux_logo <span style=color:#f92672>*</span>logo, <span style=color:#66d9ef>int</span> y,
			     <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> n)
{
	<span style=color:#66d9ef>struct</span> fb_image image;
	...
    image.depth <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>;    <span style=color:#75715e>//图片的颜色深度固定为 8
</span><span style=color:#75715e></span>    image.data <span style=color:#f92672>=</span> logo<span style=color:#f92672>-&gt;</span>data;    <span style=color:#75715e>//图片的数据
</span><span style=color:#75715e></span>    image.dx <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;        <span style=color:#75715e>//绘制图片的起始横坐标，屏幕的左上角为 0
</span><span style=color:#75715e></span>    image.dy <span style=color:#f92672>=</span> y;        <span style=color:#75715e>//绘制图片的起始纵坐标，也是 0 ，表示从左上角开始显示
</span><span style=color:#75715e></span>    image.width <span style=color:#f92672>=</span> logo<span style=color:#f92672>-&gt;</span>width;    <span style=color:#75715e>//图片的横向分辨率
</span><span style=color:#75715e></span>    image.height <span style=color:#f92672>=</span> logo<span style=color:#f92672>-&gt;</span>height;    <span style=color:#75715e>//图片的纵向分辨率
</span><span style=color:#75715e></span>    ...
    fb_do_show_logo(info, <span style=color:#f92672>&amp;</span>image, rotate, n);
}</code></pre></div><p>最后调用 <code>fb_do_show_logo()</code> 函数横向的绘制 n 个 image 。如果屏幕是正向的，图片会按如下方式绘制：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>fb_do_show_logo</span>(<span style=color:#66d9ef>struct</span> fb_info <span style=color:#f92672>*</span>info, <span style=color:#66d9ef>struct</span> fb_image <span style=color:#f92672>*</span>image,
			    <span style=color:#66d9ef>int</span> rotate, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> num)
{
    ...
	<span style=color:#66d9ef>if</span> (rotate <span style=color:#f92672>==</span> FB_ROTATE_UR) {
		<span style=color:#66d9ef>for</span> (x <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
		     x <span style=color:#f92672>&lt;</span> num <span style=color:#f92672>&amp;&amp;</span> image<span style=color:#f92672>-&gt;</span>dx <span style=color:#f92672>+</span> image<span style=color:#f92672>-&gt;</span>width <span style=color:#f92672>&lt;=</span> info<span style=color:#f92672>-&gt;</span>var.xres;
		     x<span style=color:#f92672>++</span>) {
			info<span style=color:#f92672>-&gt;</span>fbops<span style=color:#f92672>-&gt;</span>fb_imageblit(info, image);
			image<span style=color:#f92672>-&gt;</span>dx <span style=color:#f92672>+=</span> image<span style=color:#f92672>-&gt;</span>width <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>;
		}
	} 
	...
}</code></pre></div><h3 id=更换启动画面>更换启动画面</h3><p>根据 logo 的显示原理，我们可以按如下步骤更换内核的启动画面。</p><p>首先准备一张小于等于屏幕分辨率的 png 格式图片，命名为 logo.png ，执行如下命令将其转换为 ppm 格式：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>~$ pngtopnm logo.png &gt; logo_linux_clut.pnm
~$ pnmquant <span style=color:#ae81ff>224</span> logo_linux_clut.pnm &gt; logo_linux_clut224.pnm
~$ pnmtoplainpnm logo_linux_clut224.pnm &gt; logo_linux_clut224.ppm</code></pre></div><p>将生成的 logo_linux_clut224.ppm 覆盖到内核源码的 <code>drivers/video/logo/</code> 目录下。</p><p>如果 CPU 是多核，且 logo 图片跟屏幕分辨率相同，想要全屏显示，就修改 <code>drivers/video/fbdev/core/fbmem.c</code> 文件中的 <code>fb_show_logo()</code> 函数，将绘制 logo 的数量设为 1 ：</p><pre><code>@@ -665,7 +665,7 @@ int fb_show_logo(struct fb_info *info, int rotate)
        int y;

        y = fb_show_logo_line(info, rotate, fb_logo.logo, 0,
-                             num_online_cpus());
+                             1);
        y = fb_show_extra_logos(info, y, rotate);

        return y;

</code></pre><p>默认情况下，图片会贴着屏幕的左上角 <code>&lt;0,0&gt;</code> 显示。如果需要居中显示，可以在 <code>drivers/video/fbdev/core/fbmem.c</code> 文件的 <code>fb_show_logo_line()</code> 函数中修改图片显示的起始坐标：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=color:#f92672>-image.dx=0;
</span><span style=color:#f92672>-image.dy=y;
</span><span style=color:#f92672></span><span style=color:#a6e22e>+image.dx = (info-&gt;var.xres / 2) - (image.width / 2);
</span><span style=color:#a6e22e>+image.dy = (info-&gt;var.yres / 2) - (image.height / 2);
</span></code></pre></div><h3 id=动态修改启动画面>动态修改启动画面</h3><p>上面的方法中，启动画面的数据必须编译到内核中，每次修改启动画面都要重新编译内核，不太方便。eMMC 中有一个用于放置内核和设备树文件的 FAT 分区，我们可以利用这个分区和 u-boot 的 load 命令，实现动态修改启动画面的功能，大致原理是：</p><ol><li>将 ppm 格式的 logo 图片转换成二进制格式的 ppmlogo.bin 文件，放到 FAT 分区中。</li><li>u-boot 启动时，读取 ppmlogo.bin 文件，并写入内核的保留内存中。</li><li>kernel 启动时，从保留内存的特定位置读取 ppmlogo.bin 的数据，用这个数据初始化 linux_logo 变量。</li></ol><p>首先写一个名为 ppmtobin 的程序，可以借用 <code>script/pnmtologo.c</code> 进行修改。它的作用是把一个 ppm 格式的 logo 图片转换成内核能够直接读取的二进制格式文件 ppmlogo.bin ，把这个文件放到 eMMC 的 FAT 分区，该文件的存储布局与 <code>struct linux_logo</code> 相同：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash> * ---------------------------------------------
 *         |    <span style=color:#ae81ff>0</span>        <span style=color:#ae81ff>1</span>        <span style=color:#ae81ff>2</span>        <span style=color:#ae81ff>3</span>    <span style=color:#f92672>(</span>byte<span style=color:#f92672>)</span>
 * ---------------------------------------------
 *        <span style=color:#ae81ff>0</span>|             logo type
 * ---------------------------------------------
 *        <span style=color:#ae81ff>4</span>|             logo width<span style=color:#f92672>(</span>w<span style=color:#f92672>)</span>
 * ---------------------------------------------
 *        <span style=color:#ae81ff>8</span>|             logo height<span style=color:#f92672>(</span>h<span style=color:#f92672>)</span>
 * ---------------------------------------------
 *       <span style=color:#ae81ff>12</span>|             logo clutsize
 * ---------------------------------------------
 *       <span style=color:#ae81ff>16</span>| 
 *      ...|             logo data
 *      ...|            <span style=color:#f92672>(</span>size <span style=color:#f92672>=</span> w*h<span style=color:#f92672>)</span>
 * ---------------------------------------------
 *   w*h+16| 
 *      ...|             logo clut
 *      ...|        <span style=color:#f92672>(</span>size <span style=color:#f92672>=</span> clutsize*3<span style=color:#f92672>)</span>
 * ---------------------------------------------</code></pre></div><p>下一步就是 u-boot 中操作。先确认一下板卡的内存信息，可以在 u-boot 中执行 bdinfo 命令：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#f92672>=</span>&gt; bdinfo
arch_number <span style=color:#f92672>=</span> 0x00000F8C
boot_params <span style=color:#f92672>=</span> 0x10000100
DRAM bank   <span style=color:#f92672>=</span> 0x00000000
-&gt; start    <span style=color:#f92672>=</span> 0x10000000   <span style=color:#75715e># 内存起始地址</span>
-&gt; size     <span style=color:#f92672>=</span> 0x40000000   <span style=color:#75715e># 内存大小 1GB ，我们可以把 logo 文件加载到 4f000000 地址后面的内存里</span>
baudrate    <span style=color:#f92672>=</span> <span style=color:#ae81ff>115200</span> bps
TLB addr    <span style=color:#f92672>=</span> 0x4FFF0000
relocaddr   <span style=color:#f92672>=</span> 0x4FF40000
reloc off   <span style=color:#f92672>=</span> 0x38740000
irq_sp      <span style=color:#f92672>=</span> 0x4EF318C0
sp start    <span style=color:#f92672>=</span> 0x4EF318B0
FB base     <span style=color:#f92672>=</span> 0x4EF46580
Early malloc usage: <span style=color:#ae81ff>114</span> / <span style=color:#ae81ff>400</span></code></pre></div><p>然后确认分区和文件，明确 ppplog.bin 文件的路径：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#f92672>=</span>&gt; mmc part

Partition Map <span style=color:#66d9ef>for</span> MMC device <span style=color:#ae81ff>2</span>  --   Partition Type: DOS

Part    Start Sector    Num Sectors     UUID            Type
  <span style=color:#ae81ff>1</span>     <span style=color:#ae81ff>20480</span>           <span style=color:#ae81ff>1024000</span>         bcd6138c-01     0c
  <span style=color:#ae81ff>2</span>     <span style=color:#ae81ff>1228800</span>         <span style=color:#ae81ff>6324224</span>         bcd6138c-02     83

<span style=color:#f92672>=</span>&gt; fatls mmc <span style=color:#ae81ff>2</span>:1
  <span style=color:#ae81ff>7679712</span>   zimage
    <span style=color:#ae81ff>52298</span>   imx6dl-sabresd.dtb
   <span style=color:#ae81ff>472688</span>   ppmlogo.bin
    <span style=color:#ae81ff>51391</span>   imx6q-sabresd.dtb</code></pre></div><p>先试试手动加载，将 ppmlogo.bin 文件加载 <code>4f00000</code> 的地址上：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#f92672>=</span>&gt; load mmc <span style=color:#ae81ff>2</span>:1 4f000000 ppmlogo.bin
reading ppmlogo.bin
<span style=color:#ae81ff>472688</span> bytes read in <span style=color:#ae81ff>29</span> ms <span style=color:#f92672>(</span><span style=color:#ae81ff>15</span>.5 MiB/s<span style=color:#f92672>)</span></code></pre></div><p>加载成功后可以读一下这段内存的值，看一下写入的值是否正确：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#f92672>=</span>&gt; md.l 4f000000 <span style=color:#ae81ff>4</span>
4f000000: <span style=color:#ae81ff>00000003</span> <span style=color:#ae81ff>00000320</span> 0000024e 000000df    .... ...N.......</code></pre></div><p>手动加载成功后，就可以新建一个环境变量，保存加载 logo 文件的操作：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#f92672>=</span>&gt; env set load_logo load mmc <span style=color:#ae81ff>2</span>:1 4f000000 ppmlogo.bin
<span style=color:#f92672>=</span>&gt; env save</code></pre></div><p>手动执行一次，确保命令可以正常执行：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#f92672>=</span>&gt; run load_logo
reading ppmlogo.bin
<span style=color:#ae81ff>472688</span> bytes read in <span style=color:#ae81ff>29</span> ms <span style=color:#f92672>(</span><span style=color:#ae81ff>15</span>.5 MiB/s<span style=color:#f92672>)</span></code></pre></div><p>最后，编辑 bootcmd 环境变量，添加 <code>run load_logo;</code> ，让 u-boot 启动时自动执行 load_logo ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#f92672>=</span>&gt; env edit bootcmd
edit: run findfdt;run findtee;mmc dev <span style=color:#e6db74>${</span>mmcdev<span style=color:#e6db74>}</span>; run load_logo; <span style=color:#66d9ef>if</span> mmc rescan; <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>if</span> run loadbootscript; <span style=color:#66d9ef>then</span> run bootscript; <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> run loadimage; <span style=color:#66d9ef>then</span> run mmcboot; <span style=color:#66d9ef>else</span> run netboot; <span style=color:#66d9ef>fi</span>; <span style=color:#66d9ef>fi</span>; <span style=color:#66d9ef>else</span> run netboot; <span style=color:#66d9ef>fi</span>
<span style=color:#f92672>=</span>&gt; env save</code></pre></div><p>保存后重启，可以看到加载 ppmlogo.bin 时，u-boot 打印的如下信息：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>reading ppmlogo.bin
<span style=color:#ae81ff>472688</span> bytes read in <span style=color:#ae81ff>28</span> ms <span style=color:#f92672>(</span><span style=color:#ae81ff>16</span>.1 MiB/s<span style=color:#f92672>)</span></code></pre></div><p>最后就是修改内核。我们需要在设备树的 <code>/reserved-memory</code> 中添加一个字节点，申请一段保留内存，将地址 <code>0x4f000000</code> 开始的 3MB 内存留給 u-boot 存放的 ppmlogo.bin ，避免内核启动后将这段内存覆盖：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>reserved<span style=color:#f92672>-</span>memory {
    linux<span style=color:#f92672>-</span>logo {
        compatible <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;cs-logo&#34;</span>;
        reusable;
        reg <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0x4f000000</span> <span style=color:#ae81ff>0x300000</span><span style=color:#f92672>&gt;</span>;
    }
}</code></pre></div><p>然后修改 <code>drivers/video/logo/logo.c</code> 文件中的 <code>fb_find_logo()</code> 函数，读取 <code>0x4f000000</code> 内存中的数据，并结构化为 <code>struct linux_logo</code> 格式：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff>diff --git a/drivers/video/logo/logo.c b/drivers/video/logo/logo.c
index b6bc4a0..d304272 100644
<span style=color:#f92672>--- a/drivers/video/logo/logo.c
</span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/drivers/video/logo/logo.c
</span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -28,6 +28,8 @@ MODULE_PARM_DESC(nologo, &#34;Disables startup logo&#34;);
</span><span style=color:#75715e></span>
 static bool logos_freed;

<span style=color:#a6e22e>+struct linux_logo cs_logo; //存放内存中读取的 logo 数据，一定要全局变量
</span><span style=color:#a6e22e>+
</span><span style=color:#a6e22e></span> static int __init fb_logo_late_init(void)
 {
        logos_freed = true;
<span style=color:#75715e>@@ -43,6 +45,7 @@ late_initcall(fb_logo_late_init);
</span><span style=color:#75715e></span> const struct linux_logo * __ref fb_find_logo(int depth)
 {
        const struct linux_logo *logo = NULL;
<span style=color:#a6e22e>+    char *logo_addr = NULL;  
</span><span style=color:#a6e22e></span>
        if (nologo || logos_freed)
                return NULL;
<span style=color:#75715e>@@ -76,7 +79,17 @@ const struct linux_logo * __ref fb_find_logo(int depth)
</span><span style=color:#75715e></span>        if (depth &gt;= 8) {
 #ifdef CONFIG_LOGO_LINUX_CLUT224
                /* Generic Linux logo */
<span style=color:#f92672>-               logo = &amp;logo_linux_clut224;
</span><span style=color:#f92672></span><span style=color:#a6e22e>+        logo_addr = phys_to_virt((phys_addr_t)(0x4f000000));  // 将物理地址转换为虚拟地址
</span><span style=color:#a6e22e>+        memcpy(&amp;cs_logo.type, logo_addr, 4);
</span><span style=color:#a6e22e>+        memcpy(&amp;cs_logo.width, logo_addr+4, 4);
</span><span style=color:#a6e22e>+        memcpy(&amp;cs_logo.height, logo_addr+8, 4);
</span><span style=color:#a6e22e>+        memcpy(&amp;cs_logo.clutsize,logo_addr+12, 4);
</span><span style=color:#a6e22e>+        printk(&#34;load cs_logo head: %d,%d,%d,%d \n&#34;, cs_logo.type, cs_logo.width, cs_logo.height, cs_logo.clutsize);
</span><span style=color:#a6e22e>+
</span><span style=color:#a6e22e>+        cs_logo.data = logo_addr+16;
</span><span style=color:#a6e22e>+        cs_logo.clut = logo_addr+16+cs_logo.width*cs_logo.height;
</span><span style=color:#a6e22e>+        logo = &amp;cs_logo;
</span><span style=color:#a6e22e>+
</span><span style=color:#a6e22e></span> #endif
 #ifdef CONFIG_LOGO_BLACKFIN_CLUT224
</code></pre></div><p>修改完毕，下面是 ppmtobin 的程序的源码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/*
</span><span style=color:#75715e> * ppmtobin.c
</span><span style=color:#75715e> * compile: gcc -Wall ppmtobin.c -o ppmtobin
</span><span style=color:#75715e> * Author: LiShaocheng
</span><span style=color:#75715e> * 
</span><span style=color:#75715e> * Convert a logo in ASCII PNM format to binary file, format is 
</span><span style=color:#75715e> * ---------------------------------------------
</span><span style=color:#75715e> *         |    0        1        2        3    
</span><span style=color:#75715e> * ---------------------------------------------
</span><span style=color:#75715e> *        0|             logo type
</span><span style=color:#75715e> * ---------------------------------------------
</span><span style=color:#75715e> *        4|             logo width(w)
</span><span style=color:#75715e> * ---------------------------------------------
</span><span style=color:#75715e> *        8|             logo height(h)
</span><span style=color:#75715e> * ---------------------------------------------
</span><span style=color:#75715e> *       12|             logo clutsize
</span><span style=color:#75715e> * ---------------------------------------------
</span><span style=color:#75715e> *       16| 
</span><span style=color:#75715e> *      ...|             logo data
</span><span style=color:#75715e> *      ...|            (size = w*h)
</span><span style=color:#75715e> * ---------------------------------------------
</span><span style=color:#75715e> *   w*h+16| 
</span><span style=color:#75715e> *      ...|             logo clut
</span><span style=color:#75715e> *      ...|        (size = clutsize*3)
</span><span style=color:#75715e> * ---------------------------------------------
</span><span style=color:#75715e>*/</span>

<span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;ctype.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdarg.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>struct</span> bin_header
{
    <span style=color:#66d9ef>int</span> type; <span style=color:#75715e>/* one of LINUX_LOGO_* */</span>
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> width;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> height;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> clutsize;     <span style=color:#75715e>/* LINUX_LOGO_CLUT224 only */</span>
};

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>appname;
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>filename;
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>outputname;
<span style=color:#66d9ef>static</span> FILE <span style=color:#f92672>*</span>out;

<span style=color:#75715e>#define MAX_LINUX_LOGO_COLORS 224
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>struct</span> color
{
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> red;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> green;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> blue;
};

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> logo_width;
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> logo_height;
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> color <span style=color:#f92672>**</span>logo_data;
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> color logo_clut[MAX_LINUX_LOGO_COLORS];
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> logo_clutsize;
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> is_plain_pbm <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>die</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>fmt, ...)
    __attribute__((noreturn)) __attribute((format(printf, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>)));
<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>usage</span>(<span style=color:#66d9ef>void</span>) __attribute((noreturn));

<span style=color:#75715e>// read data from PNG file
</span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>get_number</span>(FILE <span style=color:#f92672>*</span>fp)
{
    <span style=color:#66d9ef>int</span> c, val;

    <span style=color:#75715e>/* Skip leading whitespace */</span>
    <span style=color:#66d9ef>do</span>
    {
        c <span style=color:#f92672>=</span> fgetc(fp);
        <span style=color:#66d9ef>if</span> (c <span style=color:#f92672>==</span> EOF)
            die(<span style=color:#e6db74>&#34;%s: end of file</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, filename);
        <span style=color:#66d9ef>if</span> (c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;#&#39;</span>)
        {
            <span style=color:#75715e>/* Ignore comments &#39;till end of line */</span>
            <span style=color:#66d9ef>do</span>
            {
                c <span style=color:#f92672>=</span> fgetc(fp);
                <span style=color:#66d9ef>if</span> (c <span style=color:#f92672>==</span> EOF)
                    die(<span style=color:#e6db74>&#34;%s: end of file</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, filename);
            } <span style=color:#66d9ef>while</span> (c <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;\n&#39;</span>);
        }
    } <span style=color:#66d9ef>while</span> (isspace(c));

    <span style=color:#75715e>/* Parse decimal number */</span>
    val <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>while</span> (isdigit(c))
    {
        val <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> val <span style=color:#f92672>+</span> c <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;0&#39;</span>;
        <span style=color:#75715e>/* some PBM are &#39;broken&#39;; GiMP for example exports a PBM without space
</span><span style=color:#75715e>	 * between the digits. This is Ok cause we know a PBM can only have a &#39;1&#39;
</span><span style=color:#75715e>	 * or a &#39;0&#39; for the digit. */</span>
        <span style=color:#66d9ef>if</span> (is_plain_pbm)
            <span style=color:#66d9ef>break</span>;
        c <span style=color:#f92672>=</span> fgetc(fp);
        <span style=color:#66d9ef>if</span> (c <span style=color:#f92672>==</span> EOF)
            die(<span style=color:#e6db74>&#34;%s: end of file</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, filename);
    }
    <span style=color:#66d9ef>return</span> val;
}

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>get_number255</span>(FILE <span style=color:#f92672>*</span>fp, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> maxval)
{
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> val <span style=color:#f92672>=</span> get_number(fp);
    <span style=color:#66d9ef>return</span> (<span style=color:#ae81ff>255</span> <span style=color:#f92672>*</span> val <span style=color:#f92672>+</span> maxval <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>/</span> maxval;
}

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>read_image</span>(<span style=color:#66d9ef>void</span>)
{
    FILE <span style=color:#f92672>*</span>fp;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> i, j;
    <span style=color:#66d9ef>int</span> magic;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> maxval;

    <span style=color:#75715e>/* open image file */</span>
    fp <span style=color:#f92672>=</span> fopen(filename, <span style=color:#e6db74>&#34;r&#34;</span>);
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>fp)
        die(<span style=color:#e6db74>&#34;Cannot open file %s: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, filename, strerror(errno));

    <span style=color:#75715e>/* check file type and read file header */</span>
    magic <span style=color:#f92672>=</span> fgetc(fp);
    <span style=color:#66d9ef>if</span> (magic <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;P&#39;</span>)
        die(<span style=color:#e6db74>&#34;%s is not a PNM file</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, filename);
    magic <span style=color:#f92672>=</span> fgetc(fp);
    <span style=color:#66d9ef>switch</span> (magic)
    {
    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;1&#39;</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;2&#39;</span><span style=color:#f92672>:</span>
        <span style=color:#75715e>/* Plain PBM/PGM */</span>
        die(<span style=color:#e6db74>&#34;%s: Plain PBM/PGM is not supported</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
            <span style=color:#e6db74>&#34;Use pnmnoraw(1) to convert it to ASCII PNM</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
            filename);
    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;3&#39;</span><span style=color:#f92672>:</span>
        <span style=color:#75715e>/* Plain PPM */</span>
        <span style=color:#66d9ef>break</span>;
    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;4&#39;</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;5&#39;</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;6&#39;</span><span style=color:#f92672>:</span>
        <span style=color:#75715e>/* Binary PBM/PGM/PPM */</span>
        die(<span style=color:#e6db74>&#34;%s: Binary PNM is not supported</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
            <span style=color:#e6db74>&#34;Use pnmnoraw(1) to convert it to ASCII PNM</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
            filename);

    <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
        die(<span style=color:#e6db74>&#34;%s is not a PNM file</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, filename);
    }
    logo_width <span style=color:#f92672>=</span> get_number(fp);
    logo_height <span style=color:#f92672>=</span> get_number(fp);

    <span style=color:#75715e>/* allocate image data */</span>
    logo_data <span style=color:#f92672>=</span> (<span style=color:#66d9ef>struct</span> color <span style=color:#f92672>**</span>)malloc(logo_height <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> color <span style=color:#f92672>*</span>));
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>logo_data)
        die(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, strerror(errno));
    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> logo_height; i<span style=color:#f92672>++</span>)
    {
        logo_data[i] <span style=color:#f92672>=</span> malloc(logo_width <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> color));
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>logo_data[i])
            die(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, strerror(errno));
    }

    <span style=color:#75715e>/* read Plain PPM data */</span>
    maxval <span style=color:#f92672>=</span> get_number(fp);
    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> logo_height; i<span style=color:#f92672>++</span>)
        <span style=color:#66d9ef>for</span> (j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> logo_width; j<span style=color:#f92672>++</span>)
        {
            logo_data[i][j].red <span style=color:#f92672>=</span> get_number255(fp, maxval);
            logo_data[i][j].green <span style=color:#f92672>=</span> get_number255(fp, maxval);
            logo_data[i][j].blue <span style=color:#f92672>=</span> get_number255(fp, maxval);
        }

    <span style=color:#75715e>/* close file */</span>
    fclose(fp);
}

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>is_equal</span>(<span style=color:#66d9ef>struct</span> color c1, <span style=color:#66d9ef>struct</span> color c2)
{
    <span style=color:#66d9ef>return</span> c1.red <span style=color:#f92672>==</span> c2.red <span style=color:#f92672>&amp;&amp;</span> c1.green <span style=color:#f92672>==</span> c2.green <span style=color:#f92672>&amp;&amp;</span> c1.blue <span style=color:#f92672>==</span> c2.blue;
}

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>write_logo_clut224</span>(<span style=color:#66d9ef>void</span>)
{
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> i, j, k;
    <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>int</span> write_hex_cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>struct</span> bin_header header;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> bin_data[logo_width<span style=color:#f92672>*</span>logo_height];
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> bin_clut[MAX_LINUX_LOGO_COLORS<span style=color:#f92672>*</span><span style=color:#ae81ff>3</span>];

    <span style=color:#75715e>/* validate image */</span>
    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> logo_height; i<span style=color:#f92672>++</span>)
        <span style=color:#66d9ef>for</span> (j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> logo_width; j<span style=color:#f92672>++</span>)
        {
            <span style=color:#66d9ef>for</span> (k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; k <span style=color:#f92672>&lt;</span> logo_clutsize; k<span style=color:#f92672>++</span>)
                <span style=color:#66d9ef>if</span> (is_equal(logo_data[i][j], logo_clut[k]))
                    <span style=color:#66d9ef>break</span>;
            <span style=color:#66d9ef>if</span> (k <span style=color:#f92672>==</span> logo_clutsize)
            {
                <span style=color:#66d9ef>if</span> (logo_clutsize <span style=color:#f92672>==</span> MAX_LINUX_LOGO_COLORS)
                    die(<span style=color:#e6db74>&#34;Image has more than %d colors</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
                        <span style=color:#e6db74>&#34;Use ppmquant(1) to reduce the number of colors</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
                        MAX_LINUX_LOGO_COLORS);
                logo_clut[logo_clutsize<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> logo_data[i][j];
            }
        }

    <span style=color:#75715e>/* open bin file */</span>
    <span style=color:#66d9ef>if</span> (outputname)
    {
        printf(<span style=color:#e6db74>&#34;Creat %s file</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, outputname);
        out <span style=color:#f92672>=</span> fopen(outputname, <span style=color:#e6db74>&#34;wb&#34;</span>);
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>out)
            die(<span style=color:#e6db74>&#34;Cannot create file %s: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, outputname, strerror(errno));
    }
    <span style=color:#66d9ef>else</span>
    {
        printf(<span style=color:#e6db74>&#34;Creat ppmlogo.bin file</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
        out <span style=color:#f92672>=</span> fopen(<span style=color:#e6db74>&#34;ppmlogo.bin&#34;</span>, <span style=color:#e6db74>&#34;wb&#34;</span>);
        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>out)
            die(<span style=color:#e6db74>&#34;Cannot create file %s: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, outputname, strerror(errno));        
    }

    <span style=color:#75715e>/* write logo header to bin file*/</span>
    header.type <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
    header.width <span style=color:#f92672>=</span> logo_width;
    header.height <span style=color:#f92672>=</span> logo_height;
    header.clutsize <span style=color:#f92672>=</span> logo_clutsize;
    printf(<span style=color:#e6db74>&#34;logo_width is %d </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, logo_width);
    printf(<span style=color:#e6db74>&#34;logo_height is %d </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, logo_height);
    printf(<span style=color:#e6db74>&#34;logo_clutsize is %d </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, logo_clutsize);
    len <span style=color:#f92672>=</span> fwrite(<span style=color:#f92672>&amp;</span>header, <span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>sizeof</span>(header), out);
    printf(<span style=color:#e6db74>&#34;write logo header len is %d bytes</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#34;</span>, len);

    <span style=color:#75715e>/* write logo data to bin file*/</span>
    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> logo_height; i<span style=color:#f92672>++</span>)
        <span style=color:#66d9ef>for</span> (j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> logo_width; j<span style=color:#f92672>++</span>)
        {
            <span style=color:#66d9ef>for</span> (k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; k <span style=color:#f92672>&lt;</span> logo_clutsize; k<span style=color:#f92672>++</span>)
                <span style=color:#66d9ef>if</span> (is_equal(logo_data[i][j], logo_clut[k]))
                    <span style=color:#66d9ef>break</span>;
            bin_data[write_hex_cnt<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> k <span style=color:#f92672>+</span> <span style=color:#ae81ff>32</span>;
        }
    printf(<span style=color:#e6db74>&#34;bin data len is %d bytes</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, write_hex_cnt);
    len <span style=color:#f92672>=</span> fwrite(<span style=color:#f92672>&amp;</span>bin_data, <span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>sizeof</span>(bin_data), out);
    printf(<span style=color:#e6db74>&#34;write bin data len is %d bytes</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#34;</span>, len);

    <span style=color:#75715e>/* write logo clut to bin file*/</span>
    write_hex_cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> logo_clutsize; i<span style=color:#f92672>++</span>)
    {
        bin_clut[write_hex_cnt<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> logo_clut[i].red;
        bin_clut[write_hex_cnt<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> logo_clut[i].green;
        bin_clut[write_hex_cnt<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> logo_clut[i].blue;
    }
    printf(<span style=color:#e6db74>&#34;bin clut len is %d bytes</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, write_hex_cnt);
    len <span style=color:#f92672>=</span> fwrite(<span style=color:#f92672>&amp;</span>bin_clut, <span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>sizeof</span>(bin_clut), out);
    printf(<span style=color:#e6db74>&#34;write bin clut len is %d bytes</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, len);

    fclose(out);
}

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>die</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>fmt, ...)
{
    va_list ap;

    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    va_end(ap);

    exit(<span style=color:#ae81ff>1</span>);
}

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>usage</span>(<span style=color:#66d9ef>void</span>)
{
    die(<span style=color:#e6db74>&#34;Convert a logo in ASCII PNM format to binary file</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
        <span style=color:#e6db74>&#34;Usage: %s [options] &lt;filename&gt;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
        <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
        <span style=color:#e6db74>&#34;Valid options:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
        <span style=color:#e6db74>&#34;    -h          : display this usage information</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
        <span style=color:#e6db74>&#34;    -o &lt;output&gt; : output to file &lt;output&gt; instead of default ppmlogo.bin</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
        <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
        appname);
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[])
{
    <span style=color:#66d9ef>int</span> opt;

    appname <span style=color:#f92672>=</span> argv[<span style=color:#ae81ff>0</span>];

    opterr <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>)
    {
        opt <span style=color:#f92672>=</span> getopt(argc, argv, <span style=color:#e6db74>&#34;ho:&#34;</span>);
        <span style=color:#66d9ef>if</span> (opt <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
            <span style=color:#66d9ef>break</span>;

        <span style=color:#66d9ef>switch</span> (opt)
        {
        <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;h&#39;</span><span style=color:#f92672>:</span>
            usage();
            <span style=color:#66d9ef>break</span>;
        <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;o&#39;</span><span style=color:#f92672>:</span>
            outputname <span style=color:#f92672>=</span> optarg;
            <span style=color:#66d9ef>break</span>;
        <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
            usage();
            <span style=color:#66d9ef>break</span>;
        }
    }
    <span style=color:#66d9ef>if</span> (optind <span style=color:#f92672>!=</span> argc <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
        usage();

    filename <span style=color:#f92672>=</span> argv[optind];

    read_image();
    write_logo_clut224();

    exit(<span style=color:#ae81ff>0</span>);
}</code></pre></div><h3 id=一些问题>一些问题</h3><p>如果你的屏幕分辨率是 800x600 ，而你准备了一张 800x600 的图片，替换后会发现启动画面没有显示，查看内核信息会提示：</p><pre><code>fbcon_init: disable boot-logo (boot-logo bigger than screen).
</code></pre><p>这条信息来自 <code>drivers/video/console/fbcon.c</code> 文件的 <code>fbcon_prepare_logo()</code> 函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>if</span> (logo_lines <span style=color:#f92672>&gt;</span> vc<span style=color:#f92672>-&gt;</span>vc_bottom) {
	logo_shown <span style=color:#f92672>=</span> FBCON_LOGO_CANSHOW;
	printk(KERN_INFO <span style=color:#e6db74>&#34;fbcon_init: disable boot-logo (boot-logo bigger than screen).</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
}</code></pre></div><p>logo_lines 的值来自：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>logo_lines <span style=color:#f92672>=</span> DIV_ROUND_UP(logo_height, vc<span style=color:#f92672>-&gt;</span>vc_font.height);</code></pre></div><p><code>logo_height</code> 表示图片的高度，就是 600 ，<code>vc-&gt;vc_font.height</code> 的默认值是 16 ，DIV_ROUND_UP 的定义是：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define DIV_ROUND_UP __KERNEL_DIV_ROUND_UP#define __KERNEL_DIV_ROUND_UP(n, d) (((n) + (d) - 1) / (d))</span></code></pre></div><p>计算后得到的 logo_lines 就是 38 。打印 vc-&gt;vc_bottom 的值发现是 37 ，所有需要把图片的纵向分辨率调小到 592 ，这样计算出的 logo_lines 就是 37 。</p><h3 id=关于保留内存>关于保留内存</h3><p>参考内核文档 <a href=https://www.kernel.org/doc/Documentation/devicetree/bindings/reserved-memory/reserved-memory.txt target=_blank>reserved-memory.txt</a> 。</p><p>可以在设备树的 <code>/reserved-memory</code> 节点下面新建子节点，用于描述特定的内存区域，Linux 会将这部分内存排除在正常使用之外。 <code>/reserved-memory</code> 节点的定义如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>reserved<span style=color:#f92672>-</span>memory {
	<span style=color:#75715e>#address-cells = &lt;1&gt;; # 标准定义，用于设置子节点的 reg 属性的书写格式
</span><span style=color:#75715e></span>	<span style=color:#75715e>#size-cells = &lt;1&gt;; # 标准定义，用于设置子节点的 reg 属性的书写格式
</span><span style=color:#75715e></span>	ranges; <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>标准定义，空属性</span>

	<span style=color:#75715e>#子节点
</span><span style=color:#75715e></span>}</code></pre></div><p>在下面的子节点中，可以使用 <code>reg</code> 属性来指定保留内存的范围，或者用 <code>size</code> 属性请求动态分配一段特定大小的内存，如果两个都存在，则 <code>reg</code> 优先，<code>size</code> 会被忽略。按照推荐的做法，节点名称应该反映节点的目的，如果是静态分配，应该附加上单位地址 <code>@&lt;address&gt;</code> 。</p><p>可用的属性如下：</p><ol><li>静态分配<ul><li>reg - 标准定义，必须设置。语法是 <code>&lt;address offset&gt;</code> ，例如 <code>reg = &lt;0x10000000 0x40000000&gt;;</code> 表示从 0x10000000 开始，分配 1GB 内存。</li></ul></li><li>动态分配<ul><li>size - 基于父类的 #size-cells 的长度，要保留的内存的字节数，必须设置。</li><li>alignment - 基于父类的#size-cells的长度，用于对齐分配的地址边界，可选设置。</li><li>alloc-ranges - 设置一个地址和长度，请求在这个特定区域内分配保留内存，可选设置。</li></ul></li></ol><p>可选的附加属性：</p><ol><li><p>compatible - 可以包含以下字符串。</p><ul><li><p>shared-dma-pool 。这表示一个内存区域，旨在作为一组设备的DMA缓冲区的共享池使用。如果有必要，它可以被操作系统用来实例化必要的池管理子系统。</p></li><li><p>厂商特定的字符串，形式为 <code>&lt;vendor&gt;,[&lt;device&gt;-]&lt;usage&gt;</code> 。</p></li></ul></li><li><p>no-map - 空属性，表示操作系统不得创建该区域的虚拟映射作为其系统内存标准映射的一部分，也不允许在使用该区域的设备驱动程序控制之外的任何情况下对其进行投机访问。</p></li><li><p>reusable - 空属性，操作系统可以使用该区域的内存，但有一个限制，即拥有该区域的设备驱动程序需要能够将其收回。通常情况下，这意味着操作系统可以使用该区域来存储易失性或缓存的数据，这些数据可以通过其他方式重新生成或迁移到其他地方。</p></li></ol><blockquote><p>no-map 和 reusable 两个属性不能共存，因为它们的逻辑是矛盾的。</p></blockquote><p>Linux 还有特定的实现：</p><ul><li><p>如果 &ldquo;linux,cma-default &ldquo;属性存在，那么 Linux 将使用该区域作为连续内存分配器的默认池。</p></li><li><p>如果 &ldquo;linux,dma-default &ldquo;属性存在，那么 Linux 将使用该区域作为一致 DMA 分配器的默认池。</p></li></ul><p>其他设备节点可以通过 <code>memory-region</code> 属性引用已定义的保留内存：</p><ul><li>memory-region - 它的值应该是保留内存子节点的名称</li><li>memory-region-names - 保留内存子节点的名称的列表。</li></ul><p>下面是一个例子，定义了三个保留内存：</p><ul><li>一个是所有设备驱动的默认区域（名为linux,cma@72000000，大小为64MB）。</li><li>一个专门用于帧缓冲设备（命名为framebuffer@78000000，8MB）。</li><li><p>一个用于多媒体处理（名为multimedia-memory@77000000，64MB）。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#f92672>/</span> {
	<span style=color:#75715e>#address-cells = &lt;1&gt;;
</span><span style=color:#75715e></span>	<span style=color:#75715e>#size-cells = &lt;1&gt;;
</span><span style=color:#75715e></span>
	memory {
		reg <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0x40000000</span> <span style=color:#ae81ff>0x40000000</span><span style=color:#f92672>&gt;</span>;
	};

	reserved<span style=color:#f92672>-</span>memory {
		<span style=color:#75715e>#address-cells = &lt;1&gt;;
</span><span style=color:#75715e></span>		<span style=color:#75715e>#size-cells = &lt;1&gt;;
</span><span style=color:#75715e></span>		ranges;

		<span style=color:#75715e>/* global autoconfigured region for contiguous allocations */</span>
		linux,cma {
			compatible <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;shared-dma-pool&#34;</span>;
			reusable;
			size <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0x4000000</span><span style=color:#f92672>&gt;</span>;
			alignment <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0x2000</span><span style=color:#f92672>&gt;</span>;
			linux,cma<span style=color:#f92672>-</span><span style=color:#66d9ef>default</span>;
		};

		display_reserved: framebuffer<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>78000000</span> {
			reg <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0x78000000</span> <span style=color:#ae81ff>0x800000</span><span style=color:#f92672>&gt;</span>;
		};

		multimedia_reserved: multimedia<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>77000000</span> {
			compatible <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;acme,multimedia-memory&#34;</span>;
			reg <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0x77000000</span> <span style=color:#ae81ff>0x4000000</span><span style=color:#f92672>&gt;</span>;
		};
	};

	<span style=color:#75715e>/* ... */</span>

	fb0: video<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>12300000</span> {
		memory<span style=color:#f92672>-</span>region <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;&amp;</span>display_reserved<span style=color:#f92672>&gt;</span>;
		<span style=color:#75715e>/* ... */</span>
	};

	scaler: scaler<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>12500000</span> {
		memory<span style=color:#f92672>-</span>region <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;&amp;</span>multimedia_reserved<span style=color:#f92672>&gt;</span>;
		<span style=color:#75715e>/* ... */</span>
	};

	codec: codec<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#ae81ff>12600000</span> {
		memory<span style=color:#f92672>-</span>region <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;&amp;</span>multimedia_reserved<span style=color:#f92672>&gt;</span>;
		<span style=color:#75715e>/* ... */</span>
	};
};</code></pre></div></li></ul><h2 id=用户空间的启动画面>用户空间的启动画面</h2><p>用户空间的启动画面是用 psplash 实现的，它的原理就是使用 FrameBuffer 的 API 在屏幕上绘制图片。源码可以用 git 下载：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>git://git.yoctoproject.org/psplash</code></pre></div><p>源文件比较简单，比较重要的有：</p><ul><li>make-image-header.sh ，它的作用是把 png 格式的图片转换为 C 语言头文件，这样就可以把图片编译到可执行的二进制文件中。</li><li>psplash.c ，main 函数所在的源文件，可以在这里查看绘制启动画面的流程。</li><li>psplash-config.h ，基本的配置宏定义。</li><li>psplash-colors.h ，颜色相关的配置宏定义。</li><li>psplash-poky-img.h ，包含图片数据的头文件。</li><li>psplash-fb.c ，定义了 framebuffer 绘图函数。</li></ul><p><code>psplash-config.h</code> 头文件定义了显示配置：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/* 设置启动画面中文本信息，默认是空的。如果不用，最好注释掉，否则会在启动画面中显示一行背景色 */</span>
<span style=color:#75715e>#define PSPLASH_STARTUP_MSG &#34;&#34;
</span><span style=color:#75715e></span>
<span style=color:#75715e>/* 一个布尔值，用于指示图片的显示位置，如果图片的分辨率等于屏幕分辨率，最好设为 1 ，如果图片的分辨率小于屏幕分辨率 ，可以设置为 0 ，然后用后面的参数调整显示效果*/</span>
<span style=color:#75715e>#define PSPLASH_IMG_FULLSCREEN 0
</span><span style=color:#75715e></span>
 <span style=color:#75715e>/* 设置分屏显示的分子 */</span>
<span style=color:#75715e>#define PSPLASH_IMG_SPLIT_NUMERATOR 5
</span><span style=color:#75715e></span>
<span style=color:#75715e>/* 设置分屏显示的分母 */</span>
<span style=color:#75715e>#define PSPLASH_IMG_SPLIT_DENOMINATOR 6</span></code></pre></div><p><code>psplash-colors.h</code> 头文件定义了画面元素的颜色：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/* 设置背景颜色，RGB */</span>
<span style=color:#75715e>#define PSPLASH_BACKGROUND_COLOR 0xec,0xec,0xe1
</span><span style=color:#75715e></span>
<span style=color:#75715e>/* 设置文字的颜色，RGB */</span>
<span style=color:#75715e>#define PSPLASH_TEXT_COLOR 0x6d,0x6d,0x70
</span><span style=color:#75715e></span>
<span style=color:#75715e>/* 设置进度条的颜色，RGB */</span>
<span style=color:#75715e>#define PSPLASH_BAR_COLOR 0x6d,0x6d,0x70
</span><span style=color:#75715e></span>
<span style=color:#75715e>/* 设置进度条的背景颜色，RGB */</span>
<span style=color:#75715e>#define PSPLASH_BAR_BACKGROUND_COLOR 0xec,0xec,0xe1</span></code></pre></div><p><code>psplash-poky-img.h</code> 文件用 make-image-header.sh 脚本生成的，根据图片的属性定义了一些宏：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/* 图片的横向分辨率 */</span>
<span style=color:#75715e>#define POKY_IMG_WIDTH (800)
</span><span style=color:#75715e></span><span style=color:#75715e>/* 图片的纵向分辨率 */</span>
<span style=color:#75715e>#define POKY_IMG_HEIGHT (600)
</span><span style=color:#75715e></span><span style=color:#75715e>/* 一个像素的数据大小，单位是字节 */</span>
<span style=color:#75715e>#define POKY_IMG_BYTES_PER_PIXEL (3) </span><span style=color:#75715e>/* 3:RGB, 4:RGBA */</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#75715e>/* 一行像素占用的数据大小，就是 POKY_IMG_WIDTH*POKY_IMG_BYTES_PER_PIXEL ，单位是字节 */</span>
<span style=color:#75715e>#define POKY_IMG_ROWSTRIDE (2400)
</span><span style=color:#75715e></span><span style=color:#75715e>/* 一张图片的像素数据 */</span>
<span style=color:#75715e>#define POKY_IMG_RLE_PIXEL_DATA ((uint8*) &#34;&#34;</span></code></pre></div><p><code>psplash.c</code> 中的 main 函数绘制了启动画面，基本流程如下：</p><ol><li>初始化 framebuffer</li><li>调用 psplash_fb_draw_rect 函数，将屏幕上的每个像素部设为 PSPLASH_BACKGROUND_COLOR 颜色</li><li>调用 psplash_fb_draw_image 函数，将 POKY_IMG_RLE_PIXEL_DATA 的所有数据绘制到屏幕上：<ol><li>横向是居中显示。</li><li>如果 PSPLASH_IMG_FULLSCREEN 为 1 ，横向也是居中显示。</li><li>如果 PSPLASH_IMG_FULLSCREEN 为 0 ，纵向占用屏幕的 PSPLASH_IMG_SPLIT_NUMERATOR/PSPLASH_IMG_SPLIT_DENOMINATOR 部分</li></ol></li><li>调用 psplash_fb_draw_image 函数，绘制进度条。</li><li>调用 psplash_draw_progress 函数，绘制进度条的动画。</li><li>如果定义了 PSPLASH_STARTUP_MSG ，调用 psplash_draw_msg 函数，在进度条上方显示文本信息。</li></ol><p>如果要更换启动画面，首先要准备一张 png 格式的图片，重命名为 psplash-poky.png ，分辨率应该小于等于屏幕的分辨率。然后使用 <code>make-image-header.sh</code> 脚本将图片转换为 C 语音的格式：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>./make-image-header.sh psplash-poky.png POKY</code></pre></div><blockquote><p>这个脚本使用 gdk-pixbuf-csource 工具进行转换，需要安装 gdk-pixbuf-csource ：<code>sudo apt install libgdk-pixbuf2.0-dev</code></p></blockquote><p>处理完毕会生成 <code>psplash-poky-img.h</code> 头文件，直接编译，生成的 psplash 二进制文件就包含了启动画面，在系统启动时执行就可以显示。iMX Yocto 把这个文件名改成了 psplash-default ，安装在 <code>/usr/bin</code> 目录下，通过 <code>psplash-start.service</code> 服务启动。</p></div></article><hr><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83.0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=https://shaocheng.li/tags/untagged>untagged</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>2681 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2021-05-07 12:49 &#43;0000</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><span class="button next"><a href=https://shaocheng.li/posts/2021/04/10/><span class=button__text>Linux 系统的 SPI 设备编程</span>
<span class=button__icon>→</span></a></span></div></div><div id=comments class=thin><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"shaocheng-li"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2021</span>
<span><a href=https://shaocheng.li>Shaocheng.Li</a></span>
<span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span>
<span><a href=https://shaocheng.li/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"/><path d="M4 4a16 16 0 0 1 16 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div><div class=footer__inner><div class=footer__content><span>Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>Made with &#10084; by <a href=https://github.com/rhazdon>rhazdon</a></span></div></div></footer></div><script type=text/javascript src=https://shaocheng.li/bundle.min.2d5469329143160ae2456a69c3c76dc2d0a3b212b46afe291a51bd68650ed6f8697e001dab54f1c272c77ce08092a8c55e5bb4314e0ee334aab4b927ec896638.js integrity="sha512-LVRpMpFDFgriRWppw8dtwtCjshK0av4pGlG9aGUO1vhpfgAdq1TxwnLHfOCAkqjFXlu0MU4O4zSqtLkn7IlmOA=="></script></body></html>