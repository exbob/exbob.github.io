<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="Shaocheng.Li"><meta name=description content="UCI 和 ubus 都是 Openwrt 项目提供的软件，UCI 提供了统一的配置文件格式和读写工具，ubus 提供了基于 Unix Socket 的进程间通信框架。两个软件都可以方便的移植到其他 Linux 系统，以 Ubuntu20.04 为例，首先要安装一些依赖的软件：
apt-get install pkg-config apt-get install lua5.1 apt-get install liblua5.1-dev apt-get install cmake apt-get install libjson-c-dev 然后要编译安装 libubox ：
git clone https://git.openwrt.org/project/libubox.git cd libubox cmake . make make install 编译时可能出现找不到头文件的错误：
/root/libubox/lua/uloop.c:21:17: fatal error: lua.h: No such file or directory 这是路径问题，因为 lua 的头文件在 /usr/include/lua5.1 目录下，所有修改 uloop.c 文件，为 lua.h 等头文件前面加上 lua5.1/ 路径：
#include &amp;lt;lua5.1/lua.h&amp;gt;#include &amp;lt;lua5.1/lualib.h&amp;gt;#include &amp;lt;lua5.1/lauxlib.h&amp;gt; 1. UCI 官方文档：https://openwrt."><meta name=keywords content><meta name=robots content="noodp"><meta name=theme-color content="#252627"><link rel=canonical href=https://shaocheng.li/posts/2019/12/24/><title>UCI 和 ubus 学习笔记 :: Shaocheng.Li — Hello Friends</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=https://shaocheng.li/main.min.e9b3dfcc5ffe9d55eb281ecaf47cf6179d26eec497e087299934d581c987aa0b.css><link rel=stylesheet type=text/css href=https://shaocheng.li/css/custom.css><link rel=apple-touch-icon sizes=180x180 href=https://shaocheng.li/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://shaocheng.li/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://shaocheng.li/favicon-16x16.png><link rel=manifest href=https://shaocheng.li/site.webmanifest><link rel=mask-icon href=https://shaocheng.li/safari-pinned-tab.svg color=#252627><link rel="shortcut icon" href=https://shaocheng.li/favicon.ico><meta name=msapplication-TileColor content="#252627"><meta name=theme-color content="#252627"><meta itemprop=name content="UCI 和 ubus 学习笔记"><meta itemprop=description content="UCI 和 ubus 都是 Openwrt 项目提供的软件，UCI 提供了统一的配置文件格式和读写工具，ubus 提供了基于 Unix Socket 的进程间通信框架。两个软件都可以方便的移植到其他 Linux 系统，以 Ubuntu20.04 为例，首先要安装一些依赖的软件：
apt-get install pkg-config apt-get install lua5.1 apt-get install liblua5.1-dev apt-get install cmake apt-get install libjson-c-dev 然后要编译安装 libubox ：
git clone https://git.openwrt.org/project/libubox.git cd libubox cmake . make make install 编译时可能出现找不到头文件的错误：
/root/libubox/lua/uloop.c:21:17: fatal error: lua.h: No such file or directory 这是路径问题，因为 lua 的头文件在 /usr/include/lua5.1 目录下，所有修改 uloop.c 文件，为 lua.h 等头文件前面加上 lua5.1/ 路径：
#include &lt;lua5.1/lua.h&gt;#include &lt;lua5.1/lualib.h&gt;#include &lt;lua5.1/lauxlib.h&gt; 1. UCI 官方文档：https://openwrt."><meta itemprop=datePublished content="2019-12-24T08:00:00&#43;08:00"><meta itemprop=dateModified content="2019-12-24T08:00:00&#43;08:00"><meta itemprop=wordCount content="718"><meta itemprop=keywords content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://shaocheng.li"><meta name=twitter:title content="UCI 和 ubus 学习笔记"><meta name=twitter:description content="UCI 和 ubus 都是 Openwrt 项目提供的软件，UCI 提供了统一的配置文件格式和读写工具，ubus 提供了基于 Unix Socket 的进程间通信框架。两个软件都可以方便的移植到其他 Linux 系统，以 Ubuntu20.04 为例，首先要安装一些依赖的软件：
apt-get install pkg-config apt-get install lua5.1 apt-get install liblua5.1-dev apt-get install cmake apt-get install libjson-c-dev 然后要编译安装 libubox ：
git clone https://git.openwrt.org/project/libubox.git cd libubox cmake . make make install 编译时可能出现找不到头文件的错误：
/root/libubox/lua/uloop.c:21:17: fatal error: lua.h: No such file or directory 这是路径问题，因为 lua 的头文件在 /usr/include/lua5.1 目录下，所有修改 uloop.c 文件，为 lua.h 等头文件前面加上 lua5.1/ 路径：
#include &lt;lua5.1/lua.h&gt;#include &lt;lua5.1/lualib.h&gt;#include &lt;lua5.1/lauxlib.h&gt; 1. UCI 官方文档：https://openwrt."><meta property="article:published_time" content="2019-12-24 08:00:00 &#43;0800 &#43;0800"></head><body><div class=container><header class=header><span class=header__inner><a href=https://shaocheng.li/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>$ cd /home/</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=https://shaocheng.li/about/>About</a></li><li><a href=https://shaocheng.li/posts/>Posts</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41C32.4934 41 41 32.4934 41 22 41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>4 minutes</p></div><article><h1 class=post-title><a href=https://shaocheng.li/posts/2019/12/24/>UCI 和 ubus 学习笔记</a></h1><hr><aside id=toc><div class=toc-title>Table of Contents</div><nav id=TableOfContents><ul><li><ul><li><a href=#1-uci>1. UCI</a><ul><li><a href=#1-1-配置文件语法>1.1 配置文件语法</a></li><li><a href=#1-2-shell-命令>1.2 shell 命令</a></li><li><a href=#1-3-c-编程接口>1.3 C 编程接口</a></li><li><a href=#1-4-lua-编程接口>1.4 Lua 编程接口</a></li></ul></li><li><a href=#2-ubus>2. ubus</a></li></ul></li></ul></nav></aside><hr><div class=post-content><p>UCI 和 ubus 都是 Openwrt 项目提供的软件，UCI 提供了统一的配置文件格式和读写工具，ubus 提供了基于 Unix Socket 的进程间通信框架。两个软件都可以方便的移植到其他 Linux 系统，以 Ubuntu20.04 为例，首先要安装一些依赖的软件：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>apt-get install pkg-config
apt-get install lua5.1
apt-get install liblua5.1-dev
apt-get install cmake
apt-get install libjson-c-dev</code></pre></div><p>然后要编译安装 libubox ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>git clone https://git.openwrt.org/project/libubox.git
cd libubox
cmake .
make
make install</code></pre></div><p>编译时可能出现找不到头文件的错误：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>/root/libubox/lua/uloop.c:21:17: fatal error: lua.h: No such file or directory</code></pre></div><p>这是路径问题，因为 lua 的头文件在 <code>/usr/include/lua5.1</code> 目录下，所有修改 uloop.c 文件，为 lua.h 等头文件前面加上 <code>lua5.1/</code> 路径：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;lua5.1/lua.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;lua5.1/lualib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;lua5.1/lauxlib.h&gt;</span></code></pre></div><h2 id=1-uci>1. UCI</h2><p>官方文档：<a href=https://openwrt.org/docs/guide-user/base-system/uci target=_blank>https://openwrt.org/docs/guide-user/base-system/uci</a></p><p>编译安装 uci ：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>git clone https://git.openwrt.org/project/uci.git
cd uci
cmake .
make 
make install <span style=color:#75715e># 默认都安装在 /usr/local 路径下</span></code></pre></div><p>安装完成后执行一次 <code>sudo ldconfig -v</code> ，否则可能找不到刚安装的共享库。</p><p>UCI 的全称叫做统一配置接口（Unified Configuration Interface），它的作用为各种不同的服务单元提供统一的配置文件格式和编程方法。配置文件是纯文本文件，只支持 ASCII 字符，UCI 提供了 shell 命令，C 语言和 Lua 语言编程接口，不推荐手动编辑配置文件，避免出现语法错误。</p><h3 id=1-1-配置文件语法>1.1 配置文件语法</h3><p>UCI 的配置文件默认都放在 <code>/etc/config</code> 路径下，也可以自定义。配置文件的语法是 <code>config -&gt; section -&gt; option</code> 这样的层级关系，一个配置文件就是一个 <code>config</code>，由多个 <code>section</code> 段组成的，每个 <code>section</code> 内包含了一组选项和值，以井号 <code>#</code> 开头的行是注释，语法如下：</p><pre><code>config &lt;type&gt; [&quot;name&quot;]    # section
        option &lt;name&gt; &quot;&lt;value&gt;&quot;    # option
</code></pre><p>以 openwrt 系统的 <code>/etc/confg/network</code> 文件为例，系统的网络配置程序在启动时会读取并解析这个配置文件，然后根据文件内的选项来设置网卡参数：</p><pre><code>config interface 'lan'
        option ifname 'eth0'
        option proto 'static'
        option netmask '255.255.255.0'
        option ipaddr '192.168.1.1'
 
config interface 'wan'
        option ifname 'eth1'
        option proto 'dhcp'
</code></pre><p>这里包含了两个 <code>section</code> , 每个 <code>section</code> 必须以 <code>config</code> 关键字开头，后面两个元素分别是 section 的 type 和 name ，由用户自定义，name 必须用引号包裹，如果没有定义 name，UCI 会自动分配一个 ID 作为它的 name ，这叫做匿名 section 。</p><p>每个 <code>section</code> 下包含了若干选项，以行为单位，必须以 <code>option</code> 关键字开头，后面两个元素分别是 option 的 name 和 vlaue ，由用户自定义，value 必须用引号包裹，不能为空，否则解析时会报错。</p><p>要获取 wan 口网卡的名称，可以用 <code>network.wan.ifname</code> 定位：</p><pre><code>$ uci get network.wan.ifname
eth1
</code></pre><h3 id=1-2-shell-命令>1.2 shell 命令</h3><p>UCI 提供了 uci 命令读写配置文件，语法可以直接用 <code>uci -h</code> 获得，常用的命令：</p><ul><li><code>batch</code> ，进入一个交互环境，可以连续执行多条 uci 命令，用 exit 命令退出。</li><li><code>export [&lt;config&gt;]</code> ，以 uci 配置文件的语法显示 config 的内容。</li><li><code>import [&lt;config&gt;]</code> ，导入配置文件。</li><li><code>changes [&lt;config&gt;]</code> ，显示已修改未保存的内容。</li><li><code>commit [&lt;config&gt;]</code> ，将修改内容提交保存到配置文件。</li><li><code>add &lt;config&gt; &lt;section-type&gt;</code> ，添加一个匿名 section 。</li><li><code>add_list &lt;config&gt;.&lt;section&gt;.&lt;option&gt;=&lt;string&gt;</code> ，添加 list 。</li><li><code>del_list &lt;config&gt;.&lt;section&gt;.&lt;option&gt;=&lt;string&gt;</code> ，删除 list 。</li><li><code>show [&lt;config&gt;[.&lt;section&gt;[.&lt;option&gt;]]]</code> ，以编程可读的语法显示 config，section 或者 option 的内容</li><li><code>get &lt;config&gt;.&lt;section&gt;[.&lt;option&gt;]</code> ，获取 section 的 type ，或者 option 的 value 。</li><li><code>set &lt;config&gt;.&lt;section&gt;[.&lt;option&gt;]=&lt;value&gt;</code> ，设置 section 的 type ，或者 option 的 value</li><li><code>delete &lt;config&gt;[.&lt;section&gt;[[.&lt;option&gt;][=&lt;id&gt;]]]</code> ，删除一个 section，option 或者 option 的 type</li><li><code>rename &lt;config&gt;.&lt;section&gt;[.&lt;option&gt;]=&lt;name&gt;</code> ，重命名 section 或者 option 。</li><li><code>revert &lt;config&gt;[.&lt;section&gt;[.&lt;option&gt;]]</code> ，恢复未保存的修改内容</li><li><code>reorder &lt;config&gt;.&lt;section&gt;=&lt;position&gt;</code></li></ul><p>新建一个 <code>/etc/config/system</code> 文件，然后做一次配置测试：</p><pre><code># 添加一个匿名 section
$ sudo uci add system system
cfg01e48a

# 设置一个选项 hostname 为 openwrt
$ sudo uci set system.@system[0].hostname=&quot;openwrt&quot;

# 查看已修改未保存的内容
$ sudo uci changes system
system.cfg01e48a='system'
system.cfg01e48a.hostname='openwrt'

# 将修改内容提交保存到配置文件
$ sudo uci commit system

# 获取一个选项的值
$ uci get system.@system[0].hostname
openwrt

# 查看文件内容
$ cat /etc/config/system

config system
        option hostname 'openwrt'
</code></pre><blockquote><p>uci 默认先将修改内容保存在 /tmp/.uci/ 目录下的临时文件中，使用 commit 命令后，才会将修改内容合并到 /etc/confg/ 下的文件。还没有 commit 的内容，可以用 revert 命令恢复，原理就是删除临时文件。</p></blockquote><p>将匿名 section 重命名 ：</p><pre><code>$ uci rename system.@system[0]=info
$ uci changes
system.cfg01e48a='info'
$ uci show
system.info=system
system.info.hostname='openwrt'
$ uci commit
$ cat /etc/config/system

config system 'info'
        option hostname 'openwrt'
</code></pre><p>UCI 还支持一种特别的选项 list ，通常用于记录一组常量。以设置 ntp 服务器为例：</p><pre><code>$ sudo uci add system timeserver
cfg02096b
$ sudo uci rename system.@timeserver[0]=ntp
$ sudo uci add_list system.ntp.server='0.de.pool.ntp.org'
$ sudo uci add_list system.ntp.server='1.de.pool.ntp.org'
$ sudo uci add_list system.ntp.server='2.de.pool.ntp.org'
$ sudo uci export system
package system

config system 'info'
        option hostname 'openwrt'

config timeserver 'ntp'
        list server '0.de.pool.ntp.org'
        list server '1.de.pool.ntp.org'
        list server '2.de.pool.ntp.org'
$ sudo uci commit
</code></pre><p>同名的 list 可以一次读取：</p><pre><code>$ uci get system.ntp.server
0.de.pool.ntp.org 1.de.pool.ntp.org 2.de.pool.ntp.org
</code></pre><h3 id=1-3-c-编程接口>1.3 C 编程接口</h3><p>使用 C 语言解析 UCI 非常复杂，不推荐。下面是一个简单的例子，可以读取一个选项的值：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// uci-example.c
</span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;uci.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv)
{
    <span style=color:#66d9ef>struct</span> uci_context <span style=color:#f92672>*</span>ctx;
    <span style=color:#66d9ef>struct</span> uci_ptr ptr;
    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>opt <span style=color:#f92672>=</span> strdup(<span style=color:#e6db74>&#34;system.@system[0].hostname&#34;</span>);

    <span style=color:#75715e>// 申请一个 uci_context 
</span><span style=color:#75715e></span>    ctx <span style=color:#f92672>=</span> uci_alloc_context();

    <span style=color:#75715e>// 获取并打印选项的值
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(UCI_OK <span style=color:#f92672>!=</span> uci_lookup_ptr(ctx, <span style=color:#f92672>&amp;</span>ptr, opt, true))
    {
        uci_perror(ctx, <span style=color:#e6db74>&#34;uci_lookup_ptr():&#34;</span>);
    }
    <span style=color:#66d9ef>else</span>
    {
        printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, ptr.o<span style=color:#f92672>-&gt;</span>v.string);
    }

    <span style=color:#75715e>// 释放指针
</span><span style=color:#75715e></span>    uci_free_context(ctx);
    free(opt);

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}</code></pre></div><p>要包含 uci.h 头文件，关键的数据结构和 API 都定义在这个文件中。</p><p>首先要调用 <code>uci_alloc_context()</code> 函数申请一个 <code>struct uci_context</code> 类型的指针，该结构存储了使用 UCI 过程中的各种状态数据，其他方法都要通过这个指针获得上下文数据。使用完毕用 <code>uci_free_context()</code> 函数释放。</p><p><code>uci_lookup_ptr()</code> 函数的作用是解析 opt 传入的 uci 元素定位字符串，查找配置文件，将该元素下的树形结构保存到一个 <code>struct uci_ptr</code> 结构变量中，原型如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>uci_lookup_ptr</span>(<span style=color:#66d9ef>struct</span> uci_context <span style=color:#f92672>*</span>ctx, <span style=color:#66d9ef>struct</span> uci_ptr <span style=color:#f92672>*</span>ptr, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>str, <span style=color:#66d9ef>bool</span> extended);</code></pre></div><p>最后一个参数用于使能 UCI 扩展语法，设为 true 才可以解析 <code>@system[0]</code> 这种匿名 section 。函数调用成功会返回 <code>UCI_OK</code> ，调用失败会返回错误代码，可以用 <code>uci_perror()</code> 打印最新的错误代码对应的错误信息，原型如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>uci_perror</span>(<span style=color:#66d9ef>struct</span> uci_context <span style=color:#f92672>*</span>ctx, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>str);</code></pre></div><p>第二个参数用于设置错误信息的前缀，可以设为空。</p><p>编译执行：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ gcc -Wall uci-example.c -o uci-example -luci
$ ./uci-example
openwrt</code></pre></div><h3 id=1-4-lua-编程接口>1.4 Lua 编程接口</h3><p>使用 lua 编程更为简便，只需导入 uci 包，就可以调用 uci 的 lua 语言 API ，下面是一个简单的例子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#75715e>#!/usr/bin/lua</span>
<span style=color:#75715e>-- uci-example.lua</span>

require(<span style=color:#e6db74>&#34;uci&#34;</span>)

print(<span style=color:#e6db74>&#34;Hello World!&#34;</span>)

<span style=color:#75715e>-- 新建一个 uci 操作实例</span>
ctx <span style=color:#f92672>=</span> uci.cursor()

<span style=color:#75715e>-- 获取一个选项的值</span>
hostname <span style=color:#f92672>=</span> ctx:get(<span style=color:#e6db74>&#34;system&#34;</span>,<span style=color:#e6db74>&#34;@system[0]&#34;</span>,<span style=color:#e6db74>&#34;hostname&#34;</span>)
print(hostname)</code></pre></div><p>保存后执行：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ chmod +x uci-example.lua
$ ./uci-example.lua
Hello World!
openwrt</code></pre></div><p>更多的 API 可以参考官方文档：<a href=https://openwrt.org/docs/techref/uci target=_blank>https://openwrt.org/docs/techref/uci</a> 。</p><h2 id=2-ubus>2. ubus</h2><p>ubus 是基于 unix socket 的进程间通信框架，包含守护进程、命令行工具和链接库，守护进程 ubusd 作为 socket server ，用户可用 lua 或者 C 语言的 API 实现 socket client ，client 和 server 之间用 json 格式进行通信，client 端的消息处理抽象处理对象（object）和方法（method）。ubus 通过对 socket 的封装，简化了进程间通信的步骤，只需按照固定模式调用 ubus 提供的API即可。有两种常见的应用场景：</p><ol><li>服务器-客户端的形式，进程 A 注册一系列服务，进程 B 调用这些服务</li><li>订阅-通知的形式，进程 A 提供订阅服务，其他进程可用订阅或者退订这些服务，进程 A 可用向所有订阅者发布消息</li></ol><p>编译安装 ubus</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>git clone https://git.openwrt.org/project/ubus.git
cd ubus
cmake .
make
make install</code></pre></div><p>默认安装在 <code>/usr/local</code> 目录下，主要有四种文件：
* ubusd ，守护进程
* ubus ，命令行工具
* libubus.h 等，一些头文件
* libubus.so 等，一些链接库</p></div></article><hr><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>718 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2019-12-24 00:00 &#43;0000</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://shaocheng.li/posts/2020/01/08/><span class=button__icon>←</span>
<span class=button__text>iproute2 学习笔记</span></a></span>
<span class="button next"><a href=https://shaocheng.li/posts/2019/11/26/><span class=button__text>Python Socket 编程笔记</span>
<span class=button__icon>→</span></a></span></div></div><div id=comments class=thin><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"shaocheng-li"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2023</span>
<span><a href=https://shaocheng.li>Shaocheng.Li</a></span>
<span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span>
<span><a href=https://shaocheng.li/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"/><path d="M4 4a16 16 0 0 1 16 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div><div class=footer__inner><div class=footer__content><span>Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>Made with &#10084; by <a href=https://github.com/rhazdon>rhazdon</a></span></div></div></footer></div><script type=text/javascript src=https://shaocheng.li/bundle.min.2d5469329143160ae2456a69c3c76dc2d0a3b212b46afe291a51bd68650ed6f8697e001dab54f1c272c77ce08092a8c55e5bb4314e0ee334aab4b927ec896638.js integrity="sha512-LVRpMpFDFgriRWppw8dtwtCjshK0av4pGlG9aGUO1vhpfgAdq1TxwnLHfOCAkqjFXlu0MU4O4zSqtLkn7IlmOA=="></script></body></html>