<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Shaocheng.Li</title><link>https://shaocheng.li/</link><description>Recent content on Shaocheng.Li</description><generator>Hugo -- gohugo.io</generator><copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright><lastBuildDate>Sat, 12 Dec 2020 18:40:11 +0800</lastBuildDate><atom:link href="https://shaocheng.li/index.xml" rel="self" type="application/rss+xml"/><item><title>在 i.MX 6ULL 上学习 Yocto</title><link>https://shaocheng.li/posts/2020/12/12/</link><pubDate>Sat, 12 Dec 2020 18:40:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/12/12/</guid><description>1. 概述 NXP 为官方评估板 i.MX6ULL EVK 提供了完整的 Yocto 项目源码和文档 ，板卡的外观和接口如图：
特性：
参考板是 iMX6ULL EVK ：https://www.nxp.com/design/development-boards/i-mx-evaluation-and-development-boards/evaluation-kit-for-the-i-mx-6ull-and-6ulz-applications-processor:MCIMX6ULL-EVK 芯片是 NXP 的 iMX6ULL : https://www.nxp.com/products/processors-and-microcontrollers/arm-processors/i-mx-applications-processors/i-mx-6-processors:IMX6X_SERIES 软件使用最新的 Linux 5.4.47_2.2.0 : https://www.nxp.com/design/software/embedded-software/i-mx-software/embedded-linux-for-i-mx-applications-processors:IMXLINUX 2. 构建系统 我们先为这个板卡编译一个可以运行的系统。
2.1. 准备宿主机 使用 Ubuntu 20.04 （至少要用 18.04 ，低版本系统会遇到很多问题），安装必要的开发包：
$ sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib \ build-essential chrpath socat cpio python python3 python3-pip python3-pexpect \ xz-utils debianutils iputils-ping python3-git python3-jinja2 libegl1-mesa libsdl1.2-dev \ pylint3 xterm 安装 repo :</description></item><item><title>使用 Docker 学习 Redis</title><link>https://shaocheng.li/posts/2020/09/01/</link><pubDate>Tue, 01 Sep 2020 09:53:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/09/01/</guid><description># 1. 安装 Docker 的安装比较简单，访问 ，按照指引安装相应系统的版本即可。安装完毕后，我们先拉取 Redis 的镜像：
$ docker pull redis 这个命令默认是拉取 Redis 官方的 Docker 镜像最新版，也可以在后面指定具体的版本：
$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE docker101tutorial latest 8e9d20f8bd52 38 hours ago 27.3MB nginx alpine 6f715d38cfe0 2 weeks ago 22.1MB nginx latest 4bb46517cac3 2 weeks ago 133MB python alpine 44fceb565b2a 2 weeks ago 42.7MB redis latest 1319b1eaa0b7 3 weeks ago 104MB node 12-alpine 18f4bc975732 4 weeks ago 89.3MB 然后启动这个进行容器:</description></item><item><title>epoll 学习笔记</title><link>https://shaocheng.li/posts/2020/08/30/</link><pubDate>Sun, 30 Aug 2020 11:53:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/08/30/</guid><description>1. 工作原理 epoll 是 Linux 独有的 I/O 多路复用机制，核心概念就是 epoll 实例，它是一个内核里的数据结构，从用户角度来看它可以简单的看做包含了两个队列：
interest list（或者叫epoll set），用户注册的感兴趣的描述符集合。 ready list，就绪的描述符集合，当有 I/O 就绪时，内核会自动将就绪的描述符加到 ready list 中。 在用户端的工作流程就是：
向 interest list 注册感兴趣的文件描述符的 I/O 事件。 等待已注册的文件描述符就绪。 处理所有已经就绪的文件描述符。 2. 使用方法 使用 epoll 时，需要包括头文件：
#include &amp;lt;sys/epoll.h&amp;gt; 2.1 新建一个 epoll 实例 int epoll_create(int size); epoll_create() 函数会新建一个 epoll 实例，然后返回一个文件描述符，作为 epoll 操作的句柄。从 Linux 2.6.8 开始， 参数 size 可以忽略，但是必须大于 0 。当不在需要这个描述符时，应该调用 close() 函数将其关闭。
调用失败时，会返回一个负数。
2.2 操作 epoll 实例 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 这是操作 epoll 实例的接口函数，用于添加、删除和修改 interest list 中监控的文件描述符。如果调用成功，会返回 0 ，如果失败，会返回一个负数，并设置 errno 。参数的含义：</description></item><item><title>uthash 学习笔记</title><link>https://shaocheng.li/posts/2020/08/29/</link><pubDate>Sat, 29 Aug 2020 11:23:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/08/29/</guid><description>uthash 是一个 C 语言的哈希表函数库，支持哈希表的各种操作，包括添加，删除，查找，排序等。你可以在 github 上下载到它的源码：
源码：https://github.com/troydhanson/uthash 文档：https://troydhanson.github.io/uthash/userguide.html 这个函数库在使用时只需要包含 uthash.h 头文件即可，没有二进制的库文件。
1. 数据结构 uthash 的哈希表是由多个结构体组成的双向链表实现的，一个结构体就是一个键值对，例如：
#include &amp;#34;uthash.h&amp;#34; struct my_struct { int id; /* key */ char name[10]; UT_hash_handle hh; /* makes this structure hashable */ }; id 就是键（key），名称和数据类型没有限制； name 就是值（value），也可以是任何数据类型； hh 是内部使用的 hash 处理句柄，UT_hash_handle 字段必须存在于你的结构中。它用于内部记录，使哈希表正常工作，它不需要初始化。可以被命名为任何标识符； 哈希句柄在 32 位系统中每个元素消耗约 32 个字节，在 64 位系统中每个元素消耗 56 个字节。其他的开销成本&amp;ndash;桶和表&amp;ndash;相比之下可以忽略不计。你可以使用 HASH_OVERHEAD 来获取哈希表的开销大小，单位是字节。
2. 基本操作 完整的例子可以在源码下的 tests/exapmle.c 文件中找到，可以执行 make example 进行编译。
2.1 声明 定义一个结构体类型的空指针，即声明了一个哈希表：</description></item><item><title>libubox 学习笔记</title><link>https://shaocheng.li/posts/2020/07/16/</link><pubDate>Thu, 16 Jul 2020 21:23:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/07/16/</guid><description>编译安装 首先要安装一些依赖的软件：
apt-get install pkg-config apt-get install lua5.1 apt-get install liblua5.1-dev apt-get install cmake apt-get install libjson-c-dev 然后要编译安装 libubox ：
git clone https://git.openwrt.org/project/libubox.git cd libubox cmake . make make install ulog 头文件 ulog.h 提供了打印日志的方法。使用时，先调用 ulog_open() 函数初始化一些 ulog 需要的变量：
void ulog_open(int channels, int facility, const char *ident); channels 用于设置日志消息的输出目标，取值：
ULOG_KMSG，内核日志，输出到了 /dev/kmsg 文件。 ULOG_SYSLOG，系统日志，调用了 vsyslog() 产生系统日志。 ULOG_STDIO，标准输出，输出到了 stderr 。 facility 用于设置记录日志的程序的类型，只有当 channels 的值为 ULOG_SYSLOG 时，这个参数有效。取值与 openlog() 的第三个参数一致，它们是定义在 &amp;lt;syslog.h&amp;gt; 中的宏：</description></item><item><title>CMake 学习笔记</title><link>https://shaocheng.li/posts/2020/06/29/</link><pubDate>Mon, 29 Jun 2020 22:25:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/06/29/</guid><description>本教程提供了一个渐进式的指导，参考的是官方教程 CMake Tutorial ，然后加入学习过程的笔记。涵盖了使用 CMake 构建一个工程时经常遇到的问题 。通过一个示例项目，展示各种功能是如何一起工作的，这对理解 CMake 非常有用。
1. 最简单的工程 最简单工程是从源码文件直接编译生成一个可执行的问题，最简单的解决方案只需要在 CMakeLists.txt 文件中添加三行。
新建一个工程目录，在目录下新建一个源文件 Tutorial.c ：
#include &amp;lt;stdio.h&amp;gt; int main (int argc, char *argv[]) { printf(&amp;#34;Hello World!\n&amp;#34;); return 0; } 新建一个 CMakeLists.txt ：
cmake_minimum_required(VERSION 3.1)project(Tutorial)add_executable(Tutorial Tutorial.c) CMakeLists.txt 是 cmake 生成 Makefile 所依赖的描述性文件，文件内容由一行一行的命令组成，命令不区分大小写。
cmake_minimum_required 表示该项目对 CMake 的最低版本要求。 project 用于设置项目名称。 add_executable 添加了一个生成的可执行文件，和依赖的源码。 这样的话，执行 cmake . 生成 Makefile ，再执行 make 开始编译，就可以使用 Tutorial.c 生成的可执行文件 Tutorial 。
cmake 执行过程中会生成大量的缓存文件，又没有提供类似 cmake clean 的命令来清除生成的文件，有一个简单的方法可以解决这个问题。在工程目录下新建一个名为 build 的子目录，进入这个子目录中执行 cmake .</description></item><item><title>Markdown Syntax Guide</title><link>https://shaocheng.li/posts/2020/01/15/</link><pubDate>Wed, 15 Jan 2020 14:31:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/01/15/</guid><description>This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.
Headings The following HTML &amp;lt;h1&amp;gt;—&amp;lt;h6&amp;gt; elements represent six levels of section headings. &amp;lt;h1&amp;gt; is the highest section level while &amp;lt;h6&amp;gt; is the lowest.
H1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo.</description></item><item><title>iproute2 学习笔记</title><link>https://shaocheng.li/posts/2020/01/08/</link><pubDate>Wed, 08 Jan 2020 08:00:00 +0800</pubDate><guid>https://shaocheng.li/posts/2020/01/08/</guid><description>iproute2 是一个 Linux 网络管理工具包，提供了 ip 、tc 、ss 等组件，集成了原有的 ifconfg 、arp 、route 、netstat 等多种命令的功能，并新增了很多特性。
1. ip 命令 ip 命令的语法是：
ip [OPTIONS] OBJECT {COMMAND|help} 其中：
OBJECT 表示操作对象，可选的值有 { link | addr | addrlabel | route | rule | neigh | ntable | tunnel | maddr | mroute | mrule | monitor | xfrm | token } ，常用的对象包括： link：网络设备 addr：设备上的协议（IP或IPv6）地址 addrlabel：协议地址选择的标签配置 route：路由表条目 rule：路由策略数据库中的规则 neigh: ARP 表 OPTIONS 表示选项，可选的值有 { -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] | -h[uman-readable] | -iec | -f[amily] { inet | inet6 | ipx | dnet | link } | -o[neline] | -t[imestamp] | -b[atch] [filename] | -rc[vbuf] [size] } 常用的选项包括： -V，-Version：显示指令版本信息 -s，-stats，statistics：输出详细信息 -h，-human，-human-readable：输出人类可读的统计信息和后缀 -o，-oneline：将每条记录输出到一行，用 \字符替换换行符 1.</description></item><item><title>UCI 和 ubus 学习笔记</title><link>https://shaocheng.li/posts/2019/12/24/</link><pubDate>Tue, 24 Dec 2019 08:00:00 +0800</pubDate><guid>https://shaocheng.li/posts/2019/12/24/</guid><description>UCI 和 ubus 都是 Openwrt 项目提供的软件，UCI 提供了统一的配置文件格式和读写工具，ubus 提供了基于 Unix Socket 的进程间通信框架。两个软件都可以方便的移植到其他 Linux 系统，以 Ubuntu 系统为例，首先要安装一些依赖的软件：
apt-get install pkg-config apt-get install lua5.1 apt-get install liblua5.1-dev apt-get install cmake apt-get install libjson-c-dev 然后要编译安装 libubox ：
git clone https://git.openwrt.org/project/libubox.git cd libubox cmake . make make install 编译时可能出现找不到头文件的错误：
/root/libubox/lua/uloop.c:21:17: fatal error: lua.h: No such file or directory 这是路径问题，因为 lua 的头文件在 /usr/include/lua5.1 目录下，所有修改 uloop.c 文件，为 lua.h 等头文件前面加上 lua5.1/ 路径：
#include &amp;lt;lua5.1/lua.h&amp;gt;#include &amp;lt;lua5.1/lualib.h&amp;gt;#include &amp;lt;lua5.1/lauxlib.h&amp;gt; 1. UCI 编译安装 uci</description></item><item><title>Python Socket 编程笔记</title><link>https://shaocheng.li/posts/2019/11/26/</link><pubDate>Tue, 26 Nov 2019 08:00:00 +0800</pubDate><guid>https://shaocheng.li/posts/2019/11/26/</guid><description>1. 套接字 套接字（Socket）是一种操作系统提供的进程间通信机制，可以用于不同主机间的进程通信，最早由 UNIX 提出，现在广泛用于各种操作系统，同时也特指这种机制下的通信端点。根据通信地址的不同种类，Socket 可以分为三类：
INET ，这是 IPv4 地址域的套接字，用于 IPv4 网络间的通信。 INET6 ，这是 IPv6 地址域的套接字，用于 IPv6 网络间的通信。 UNIX ，这是 UNIX 域的套接字，用于主机内的进程间通信。 套接字常用的报文类型有两种：
SOCK_DGRAM，固定长度，无连接不可靠的报文传递，两个对等进程之间通信时不需要建立逻辑连接，直接向对方的套接字发送报文即可。在 INET 套接字中，这种报文使用的默认协议是 UDP 。 SOCK_STREAM，有序的，可靠的，双向的，面向连接的字节流，两个对等进程在正式通信之前，要先建立逻辑连接。在 INET 套接字中，这种报文使用的默认协议是 TCP 。 Python 提供了 socket 模块用于底层 socket 通信，模块提供了一个同名的类，以及其他读写 socket 的方法。
2. 获得主机信息 获取本机的名字和 IP ：
$ python3 Python 3.7.4 (default, Jul 9 2019, 18:13:23) [Clang 10.0.1 (clang-1001.0.46.4)] on darwin Type &amp;#34;help&amp;#34;, &amp;#34;copyright&amp;#34;, &amp;#34;credits&amp;#34; or &amp;#34;license&amp;#34; for more information.</description></item></channel></rss>