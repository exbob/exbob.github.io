<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Shaocheng.Li</title><link>https://shaocheng.li/</link><description>Recent content on Shaocheng.Li</description><generator>Hugo -- gohugo.io</generator><copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright><lastBuildDate>Tue, 26 Oct 2021 20:09:49 +0800</lastBuildDate><atom:link href="https://shaocheng.li/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux 下使用 ioctl 接口访问指定网卡</title><link>https://shaocheng.li/posts/2021/10/26/</link><pubDate>Tue, 26 Oct 2021 20:09:49 +0800</pubDate><guid>https://shaocheng.li/posts/2021/10/26/</guid><description>netdevice 是 glibc 提供的访问网卡设备的低级接口，支持标准 ioctl 函数，需要的头文件是：
#include &amp;lt;sys/ioctl.h&amp;gt;#include &amp;lt;net/if.h&amp;gt; 使用方法是调用 ioctl 函数访问 socket 文件，基本语法是：
ioctl(int fd, int request, struct ifreq *); int fd 应该是一个 socket 文件描述符，主要通过 struct ifreq 结构传递数据：
struct ifreq { char ifr_name[IFNAMSIZ]; /* Interface name */ union { struct sockaddr ifr_addr; // IP 地址 struct sockaddr ifr_dstaddr; struct sockaddr ifr_broadaddr; // 广播地址 struct sockaddr ifr_netmask; // 子网掩码 struct sockaddr ifr_hwaddr; // MAC 地址 short ifr_flags; int ifr_ifindex; int ifr_metric; int ifr_mtu; struct ifmap ifr_map; char ifr_slave[IFNAMSIZ]; char ifr_newname[IFNAMSIZ]; char *ifr_data; }; }; 使用方法：</description></item><item><title>iMX8MM 的 Fuse/OCOPT 学习笔记</title><link>https://shaocheng.li/posts/2021/07/16/</link><pubDate>Fri, 16 Jul 2021 22:22:49 +0800</pubDate><guid>https://shaocheng.li/posts/2021/07/16/</guid><description>Fuse 就是熔丝位，是一种只能写入一次的寄存器，写入后不可更改，所以写入操作也叫做烧毁（burned）。iMX8MM 的 Fuse 由 on-chip eFuse OTP 控制读写，简称 OCOPT ，结构框图如下：
可以通过 APB 接口读写 OCOTP 的寄存器，寄存器的布局可以在芯片手册的 《6.3.4 OCOTP Memory Map/Register Definition》中查看，起始地址是 0x30350000，分为两个部分，前半部分 0x30350000~0x3035009C 是 OCOTP Control Register ，是配置 OCOTP 本身的寄存器：
从 0x30350400 到 0x303507B0 是 Shadow Regs 寄存器：
在硬件上，Shadow Regs 和 Fuse 是两个独立的存储设备，但是 OCOTP 的内部机制实现了二者之间的映射，Fuse 的所有内容都被映射到了这段寄存器中，完整的映射如下：
总大小是 4x256 bytes，大部分是保留状态，不可读写。需要注意的是，在 Fuse 中，32bits 组成一个 Word ，4Words 组成一个 Bank ，读写时也要用 Bank:Word 的格式寻址。可以在 u-boot 中执行 fuse 命令读写 fuse ，语法如下：
fuse - Fuse sub-system Usage: fuse read &amp;lt;bank&amp;gt; &amp;lt;word&amp;gt; [&amp;lt;cnt&amp;gt;] - read 1 or &amp;#39;cnt&amp;#39; fuse words, starting at &amp;#39;word&amp;#39; fuse sense &amp;lt;bank&amp;gt; &amp;lt;word&amp;gt; [&amp;lt;cnt&amp;gt;] - sense 1 or &amp;#39;cnt&amp;#39; fuse words, starting at &amp;#39;word&amp;#39; fuse prog [-y] &amp;lt;bank&amp;gt; &amp;lt;word&amp;gt; &amp;lt;hexval&amp;gt; [&amp;lt;hexval&amp;gt;.</description></item><item><title>iMX8MM 从 eMMC 启动系统和烧写的笔记</title><link>https://shaocheng.li/posts/2021/07/15/</link><pubDate>Thu, 15 Jul 2021 22:32:49 +0800</pubDate><guid>https://shaocheng.li/posts/2021/07/15/</guid><description>1. iMX8MM 的启动流程 iMX8MM 系统启动的详细流程可以参考 IMX8MMRM.pdf
上电复位后，硬件复位逻辑迫使 SoC 从片上的 Boot ROM 开始执行，Boot ROM 使用 BOOT_MODE 和 eFUSEs 的状态来决定启动设备。在 POR_B 信号的上升沿采集两个外部输入引脚 BOOT_MODE0 和 BOOT_MODE1 的电平，用于设置启动模式：
BOOT_MODE 的值可以在 SRC_SBMR2 寄存器的 IPP_BOOT_MODE[1:0] 中读到。在 Boot From Fuses 模式下，启动流程完全由 Fuse 控制，GPIO boot overrides 引脚的状态会被忽略。在 internal Boot 模式下，使用 Fuse 中的启动配置，但是为了开发方便，用于确定启动设备的 Fuse 可以通过 GPIO boot overrides 引脚的输入被覆盖，这时启动流程由 Fuse 或者 GPIO 控制的 BOOT_CFG 寄存器决定。首先会读取 BOOT_CFG[14:12] ，决定启动设备的类型：
如果是从 eMMC/SD 启动，它们都使用 USDHC 接口与 SoC 连接，Boot ROM 会读取 BOOT_CFG[11:10] 的值，确定从哪个接口上的设备启动：</description></item><item><title>使用 VSCode 绘制数字电路时序图</title><link>https://shaocheng.li/posts/2021/07/03/</link><pubDate>Sat, 03 Jul 2021 18:32:49 +0800</pubDate><guid>https://shaocheng.li/posts/2021/07/03/</guid><description>在 VSCode 中安装 Waveform Render 插件：
它可以解析 WaveJSON 语法的 json 文件，绘制一幅数字电路时序图。官网提供了一个完整教程：https://wavedrom.com/tutorial.html ，还有一个在线的编辑器：https://wavedrom.com/editor.html 。
开始 在 vscode 中新建一个名为 demo.json 的文件，内容如下：
{ &amp;#34;signal&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;clk&amp;#34;, &amp;#34;wave&amp;#34;: &amp;#34;p.......&amp;#34; }, { &amp;#34;name&amp;#34;: &amp;#34;data&amp;#34;, &amp;#34;wave&amp;#34;: &amp;#34;01010101&amp;#34; } ] } 保存后用 Command+Shift+P 组合键打开命令面板，选择执行 Waveform Render:Draw ，就可以看到渲染后的时序图，也可以选择执行 Waveform Render:Toggle Live Preview ，实时查看渲染结果：
这个例子展示了基本的 WaveJSON 语法：
signal 是必须的关键词，它用一个数组表示一幅时序图。 数组内每个元素描述一个信号。 每个元素至少要包含 name 和 wave 两个变量： name 定义了信号的名称。 wave 用来描述信号的样子。 wave 定义的字符串中，每个字符代表一个时钟周期（1bit），通过不同的字符来描述信号的样子：
0 表示低电平，1 表示高电平。 p 表示上升沿开始的一个时钟周期。 .</description></item><item><title>如何修改 ARM Linux 系统的启动画面</title><link>https://shaocheng.li/posts/2021/05/07/</link><pubDate>Fri, 07 May 2021 20:49:11 +0800</pubDate><guid>https://shaocheng.li/posts/2021/05/07/</guid><description>以 NXP 的 iMX Yocto 4.9.88 系统版本为例，启动分为三个阶段：U-Boot ，内核，根文件系统，每个阶段都可以设置自己的显示画面。
U-Boot 的启动画面 u-boot 阶段的运行时很短，一般不用修改。待补充。
内核的启动画面 PPM 图片格式 如果开启了 FrameBuffer ，Linux 内核启动时会在屏幕左上角显示企鹅图标，图标的数量等于 CPU 的核心数量。这个图标来自于内核源码的 driver/video/logo/ 目录下的 ppm 格式图片：
$ ls drivers/video/logo/ clut_vga16.ppm logo_linux_mono.pbm logo_sun_clut224.ppm Kconfig logo_linux_vga16.ppm logo_superh_clut224.ppm logo_blackfin_clut224.ppm logo_m32r_clut224.ppm logo_superh_mono.pbm logo_blackfin_vga16.ppm logo_mac_clut224.ppm logo_superh_vga16.ppm logo.c logo_parisc_clut224.ppm Makefile logo_dec_clut224.ppm logo_sgi_clut224.ppm logo_linux_clut224.ppm logo_spe_clut224.ppm 这里的 ppm 格式是一种 ASCII 编码的图片文件格式，可以用文本编辑器打开，以 logo_linux_clut224.ppm 为例 ：
P3 # Standard 224-color Linux logo 80 80 255 0 0 0 0 0 0 0 0 0 0 0 0 井号 # 开头的是注释，忽略注释后，前三行文本是文件头：</description></item><item><title>Linux 系统的 SPI 设备编程</title><link>https://shaocheng.li/posts/2021/04/10/</link><pubDate>Sat, 10 Apr 2021 21:19:11 +0800</pubDate><guid>https://shaocheng.li/posts/2021/04/10/</guid><description>SPI 通信协议 SPI 的全称是 Serial Peripheral Interface，是一个带时钟同步的全双工串行链接，使用主/从结构，用于连接微控制器和传感器、存储器和外设。常见的连接结构如下：
通信时需要四个信号：
SCLK，Serial Clock，时钟信号，SPI 的时钟频率通常可以达到 10MHz，实际情况还依赖从机能够支持的时钟频率。 MISO，Master In Slave Out，从机向主机发出的数据。 MOSI，Master Out Slave In，主机向从机发出的数据。 SS，Slave Select，从机选择，也叫做片选信号。一条 SPI 总线可以连接多个从设备，SCLK、MISO 和 MOSI 是共用的，每个从机需要一个独立的片选信号，当从机的 SS 信号拉低时，表示从机被选中，才开始接收总线上的信号。 在一个SPI时钟周期内，收发是同时进行的：
主机通过 MOSI 线发送 1bit 数据，从机通过该线读取这 1bit 数据； 从机通过 MISO 线发送 1bit 数据，主机通过该线读取这 1bit 数据。 这个过程是 SPI 设备内的移位寄存器实现的，当寄存器中的内容全部移出时，相当于完成了两个寄存器内容的交换，如下图所示。
下面是一个典型的主机模型的通信时序，描述了主机的 0xD2 的数据被移出，从 MISO 信号移入了 0x66 ：
SCLK 、MOSI 和 SS 信号由主机产生，MISO 是从机发出的信号，主机从这个信号读取从机的数据。通信开始前，SCLK 为低电平，当 SS 拉低后，从机被选中，通信开始，MOSI 和 MISO 信号在 SCLK 的上升沿发生变化，MISO 信号在 SCLK 的下降沿被采样锁存，通信结束后，SS 信号拉高，SCLK 信号重回低电平，一次通信发出的 bit 数为一个 word ，也叫字长。这只是一种情况，在 SCLK 下降沿和上升沿所做的事情由 CPOL 和 CPHA 的值决定，可以在 SPI 设备内的寄存器配置：</description></item><item><title>Systemd 中实现自动登录和程序自启动</title><link>https://shaocheng.li/posts/2021/03/06/</link><pubDate>Sat, 06 Mar 2021 21:19:11 +0800</pubDate><guid>https://shaocheng.li/posts/2021/03/06/</guid><description>以 NXP 的 Yocto Linux 4.9.88 为例。
Systemd 管理系统资源的基本单元是 Unit ，分为 12 种：
Service unit：系统服务 Target unit：多个 Unit 构成的一个组 Device Unit：硬件设备 Mount Unit：文件系统的挂载点 Automount Unit：自动挂载点 Path Unit：文件或路径 Scope Unit：不是由 Systemd 启动的外部进程 Slice Unit：进程组 Snapshot Unit：Systemd 快照，可以切回某个快照 Socket Unit：进程间通信的 socket Swap Unit：swap 文件 Timer Unit：定时器 我们可以使用 systemd-analyze 命令来分析系统启动的过程：
# 查看启动耗时 $ systemd-analyze # 查看每个服务的启动耗时 $ systemd-analyze blame # 显示瀑布状的启动过程流 $ systemd-analyze critical-chain # 显示指定服务的启动流 $ systemd-analyze critical-chain atd.service # 将系统启动流程输出为 svg 格式，可以通过浏览器查看 systemd-analyze plot &amp;gt; .</description></item><item><title>在 i.MX 6ULL 上学习 Yocto</title><link>https://shaocheng.li/posts/2020/12/12/</link><pubDate>Sat, 12 Dec 2020 18:40:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/12/12/</guid><description>1. 概述 NXP 为官方评估板 i.MX6ULL EVK 提供了完整的 Yocto 项目源码和文档 ，板卡的外观和接口如图：
特性：
参考板是 iMX6ULL EVK ：https://www.nxp.com/design/development-boards/i-mx-evaluation-and-development-boards/evaluation-kit-for-the-i-mx-6ull-and-6ulz-applications-processor:MCIMX6ULL-EVK 芯片是 NXP 的 iMX6ULL : https://www.nxp.com/products/processors-and-microcontrollers/arm-processors/i-mx-applications-processors/i-mx-6-processors:IMX6X_SERIES 软件使用最新的 Linux 5.4.47_2.2.0 : https://www.nxp.com/design/software/embedded-software/i-mx-software/embedded-linux-for-i-mx-applications-processors:IMXLINUX 2. 构建系统 我们先为这个板卡编译一个可以运行的系统。
2.1. 准备宿主机 使用 Ubuntu 20.04 （至少要用 18.04 ，低版本系统会遇到很多问题），安装必要的开发包：
$ sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib \ build-essential chrpath socat cpio python python3 python3-pip python3-pexpect \ xz-utils debianutils iputils-ping python3-git python3-jinja2 libegl1-mesa libsdl1.2-dev \ pylint3 xterm 安装 repo :</description></item><item><title>使用 Docker 学习 Redis</title><link>https://shaocheng.li/posts/2020/09/01/</link><pubDate>Tue, 01 Sep 2020 09:53:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/09/01/</guid><description># 1. 安装 Docker 的安装比较简单，访问 ，按照指引安装相应系统的版本即可。安装完毕后，我们先拉取 Redis 的镜像：
$ docker pull redis 这个命令默认是拉取 Redis 官方的 Docker 镜像最新版，也可以在后面指定具体的版本：
$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE docker101tutorial latest 8e9d20f8bd52 38 hours ago 27.3MB nginx alpine 6f715d38cfe0 2 weeks ago 22.1MB nginx latest 4bb46517cac3 2 weeks ago 133MB python alpine 44fceb565b2a 2 weeks ago 42.7MB redis latest 1319b1eaa0b7 3 weeks ago 104MB node 12-alpine 18f4bc975732 4 weeks ago 89.3MB 然后启动这个进行容器:</description></item><item><title>epoll 学习笔记</title><link>https://shaocheng.li/posts/2020/08/30/</link><pubDate>Sun, 30 Aug 2020 11:53:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/08/30/</guid><description>1. 工作原理 epoll 是 Linux 独有的 I/O 多路复用机制，核心概念就是 epoll 实例，它是一个内核里的数据结构，从用户角度来看它可以简单的看做包含了两个队列：
interest list（或者叫epoll set），用户注册的感兴趣的描述符集合。 ready list，就绪的描述符集合，当有 I/O 就绪时，内核会自动将就绪的描述符加到 ready list 中。 在用户端的工作流程就是：
向 interest list 注册感兴趣的文件描述符的 I/O 事件。 等待已注册的文件描述符就绪。 处理所有已经就绪的文件描述符。 2. 使用方法 使用 epoll 时，需要包括头文件：
#include &amp;lt;sys/epoll.h&amp;gt; 2.1 新建一个 epoll 实例 int epoll_create(int size); epoll_create() 函数会新建一个 epoll 实例，然后返回一个文件描述符，作为 epoll 操作的句柄。从 Linux 2.6.8 开始， 参数 size 可以忽略，但是必须大于 0 。当不在需要这个描述符时，应该调用 close() 函数将其关闭。
调用失败时，会返回一个负数。
2.2 操作 epoll 实例 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 这是操作 epoll 实例的接口函数，用于添加、删除和修改 interest list 中监控的文件描述符。如果调用成功，会返回 0 ，如果失败，会返回一个负数，并设置 errno 。参数的含义：</description></item></channel></rss>