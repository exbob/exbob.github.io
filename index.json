[{"content":"进程调度的概念比较简单。假设在只有单核处理器的系统中，同一时刻只有一个进程可以拥有处理器资源，那么其他的进程只能在就绪队列（runqueue）中等待，等到处理器空闲之后才有机会获取处理器资源并运行。在这种场景下，操作系统就需要从众多的就绪进程中选择一个最合适的进程来运行，这就是进程调度器（scheduler）。进程调度器产生的最大原因是为了提高处理器的利用率。一个进程在运行的过程中有可能需要等待某些资源，比如等待磁盘操作的完成、等待键盘输入、等待物理页面的分配等。如果处理器和进程一起等待，那么明显会浪费处理器资源，所以一个进程在睡眠等待时，调度器可以调度其他进程来运行，这样就提高了处理器的利用率。\n1. 进程的分类 #站在处理器的角度看进程的行为，你会发现有的进程一直占用处理器，有的进程只需要处理器的一部分计算资源即可。所以进程按照这个标准可以分成两类：一类是 CPU 消耗型（CPU-Bound），另外一类是 I/O 消耗型（I/O-Bound）。 CPU消耗型的进程会把大部分时间用在执行代码上，也就是一直占用CPU。比如一个while死循环。实际上，常用的例子就是执行大量数学计算的程序，比如MATLAB等。 I/O消耗型的进程大部分时间在提交 I/O 请求或者等待 I/O 请求，所以这类进程通常只需要很少的处理器计算资源即可，比如需要键盘输入的进程或者等待网络 I/O 的进程。\n有时候，鉴别一个进程是 CPU 消耗型还是 I/O 消耗型其实挺困难的，一个典型的例子就是Linux图形服务器X-window进程，它既是I/O消耗型也是CPU消耗型。所以，调度器有必要在系统吞吐率和系统响应性方面做出一些妥协和平衡。Linux内核的调度器通常倾向于提高系统的响应性。\n2. 进程的状态 #在 Linux 系统中，一个进程就是一个正在执行的程序实例，当进程被创建后，它可能处于五种状态之一：\nRunning or Runnable (R)，运行或者准备就绪的状态\nUninterruptible Sleep (D)，不可中断的睡眠状态\nInterruptable Sleep (S)，可中断的睡眠状态\nStopped (T)，暂停状态\nZombie (Z)，僵尸状态\n下面用一张状态图展示一个进程的生命周期：\n对于任何 Linux 进程来说，它们的起点就是被创建的那一刻。例如，一个父进程可以使用 fork() 系统调用来启动一个子进程。一旦启动，该进程就进入运行或准备就绪的状态，当进程运行时，它可能会进入一个代码路径，要求它在继续运行前等待特定的资源或信号。在等待资源时，进程将自愿放弃 CPU 周期，进入两种睡眠状态之一。此外，我们可以向进程发送SIGSTOP 信号来让它进入暂停状态，处于这种状态的进程将继续存在，直到它被杀死或用 SIGCONT 恢复。最后，当进程被终止并进入僵尸状态时，它的生命周期就结束了，然后，直到它的父进程会将它从进程表中清除。如果它的父进程先退出了，它会成为孤儿进程，一直处于僵尸状态。\n有很多工具可以查看进程状态，他们都是是利用了 /proc 文件系统（可以执行 man proc 查看 /proc 文件系统的详细说明），每个进程的信息都放在以 PID 命名的子文件夹下，例如，查看 PID 为 2780 的进程状态：\n$ cat /proc/2780/status | grep State State: S (sleeping) 2.1 Running or Runnable (R) #当一个进程启动后，为了确保每个进程可以公平地分享 CPU 资源，内核会将其放入就绪队列，此时，进程处于准备就绪的状态等待调度，内核依据进程调度算法，依次调度队列中的进程使用 CPU 执行代码，此时进程处于运行状态。\n尽管运行和准备就绪的状态是不同的，但它们被统统归入一个由字符 R 表示的状态。\n2.2 Sleeping State: Interruptible (S) and Uninterruptible (D) #在进程执行过程中，它可能会遇到其代码中需要请求外部资源的部分。通常来说，对这些资源的请求是基于 IO 的，如从磁盘上读取文件或进行网络请求，或者是单纯的 sleep 。由于进程在没有资源的情况下无法进行，它就会停滞不前什么也不做。这种情况下，为例把 CPU 资源让给其他可运行的进程，内核会把进程从就绪队列中移出，进入睡觉状态，等待被唤醒。\n有两种不同的睡眠状态：不可中断的睡眠状态（D）和可中断的睡眠状态（S）。不可中断的睡眠状态只等待资源的可用性，然后再转入可运行状态，它对任何信号都没有反应。另一方面，可中断的睡眠状态（S）将对信号和资源的可用性做出反应。\n2.3 Stopped State (T) #从 R 状态，我们可以使用 SIGSTOP 或 SIGTSTP 信号将一个进程放入暂停状态（T）。这两个信号的区别在于，我们发送 SIGSTOP 是程序化的，比如运行 kill -STOP {pid}，进程不能忽略这个信号，将进入停止状态。如果我们用键盘 CTRL+Z 发送 SIGTSTP 信号，进程可以选择忽略这个信号，在收到 SIGTSTP 后继续执行。\n在暂停状态下，我们可以通过发送 SIGCONT 信号使进程重新进入运行或可运行状态。\n2.4 Zombie State (Z) #当一个进程完成其执行或被终止时，它将向父进程发送 SIGCHLD 信号并进入僵尸状态。僵尸进程，也被称为失效进程，将一直处于这种状态，直到父进程将其从进程表中清除。为了从进程表中清除已终止的子进程，父进程必须使用 wait() 或 waitpid() 系统调用读取子进程的退出值。\n3. CPU 使用率 #单个进程的 CPU 使用率，是指在一段时间内，进程占用 CPU （即运行状态）的时长占总时长的百分比，因为进程在这段时间内会在三种状态之间切换，也可以表示为:\nCPU 使用率 = 运行状态/(运行状态+就绪状态+睡眠状态) 3.1 实验 #下面做一个实验，在一个 2.3GHz 主频的四核 CPU 上，如果没有其他进程影响，下面这段代码会让 CPU 使用率维持在 50% 左右：\n//cpu_test.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { for(;;) { for(int i=0;i\u0026lt;=(2.3*100000000)/2;i++) //busy ; usleep(100000); //idle } return 0; } 其中， usleep(100000) 会让进程处于 S 状态 100ms，然后进程会进入 R 状态，busy 部分的循环执行时间大约是 100ms ，因为没有其他进程影响，可以认为就绪状态持续的时间为零，这样 CPU 的使用率可以估算：\n100ms/(100ms+0+100ms) = 50% 如果把延时缩短到 50ms，CPU 的使用率会上升到 70% 左右：\n如果再开启一个同样的进程，用 taskset 命令让两个进程都锁定再 Cpu0 上运行，每个进程的 CPU 使用率会下降到 40 左右，这是因为进程在就绪队列里的等待时间变长了：\n3.2 计算单个进程的 CPU 使用率 #很多工具可以查看 CPU 使用率，他们都是依赖 /proc 下的文件计算得到的。在 /proc/{pid}/stat 文件中，记录了进程的很多信息，以 gnome-shell 进程为例：\n$ cat /proc/1751/stat 1751 (gnome-shell) S 1673 1669 1669 1026 1669 4194304 123945 69225 28 178 2801 623 244 90 20 0 13 0 26476 4092280832 48528 18446744073709551615 93953806516224 93953806530024 140723185486304 0 0 0 0 16781312 33637616 0 0 0 17 2 0 0 4 0 0 93953808628368 93953808630032 93953822617600 140723185490640 140723185490661 140723185490661 140723185491939 0 每一项数据都用空格隔开，几个关键项的含义（参考 man proc）：\n(3) state %c ，数据类型是字符，显示了进程的状态，常见的状态有：\nR Running\nS Sleeping in an interruptible wait\nD Waiting in uninterruptible disk sleep\nZ Zombie\nT Stopped (on a signal) or (before Linux 2.6.33) trace stopped\n(14) utime %lu ，无符号长整形数据，显示了该进程启动以来，用户态代码执行的时长，单位是 clock tick\n(15) stime %lu ，无符号长整形数据，显示了该进程启动以来，内核态代码执行的时长，单位是 clock tick\n可以通过sysconf(_SC_CLK_TCK)获取 1 秒内有多少个 clock tick ，大部分系统上是 100 .\n那么，我们可以每隔 n 秒读取一次 /proc/{pid}/stat 文件，解析其中的 utime 和 stime ，相加后（utime+stime）减去上一次采样得到的两项和（prev_utime+prev_stime），这就是 n 秒内该进程占用 CPU 的时间，单位是 clock tick，再除以总时长就是 CPU 使用率，用公式可以表达为：\n某进程 CPU 使用率 = ((utime+stime) - (prev_utime + prev_stime)) / (n * sysconf(_SC_CLK_TCK)) 3.3 计算每个 CPU 核的使用率 #在 /proc/stat 文件中记录了每个CPU核心所处不同状态的累计时间。以一个四核 CPU 系统为例：\n$ head -n 5 /proc/stat cpu 389079 306 24073 16922376 8047 0 2427 0 0 0 cpu0 160840 80 7066 4165808 1429 0 648 0 0 0 cpu1 109391 11 6220 4215843 2778 0 894 0 0 0 cpu2 13407 26 4699 4317280 1604 0 326 0 0 0 cpu3 105440 187 6088 4223444 2234 0 557 0 0 0 前五行记录了整个 CPU（cpu 行）和每个 CPU 核（cpu[n] 行）在各种状态下花费的时间，单位是 USER_HZ （通常是百分之一秒，可以用 sysconf(_SC_CLK_TCK) 获得正确的值）。每一行有十个数据，每一列的含义如下：\nuser nice system idle iowait irq softirq steal guest guest_nice cpu 389079 306 24073 16922376 8047 0 2427 0 0 0 cpu0 160840 80 7066 4165808 1429 0 648 0 0 0 cpu1 109391 11 6220 4215843 2778 0 894 0 0 0 cpu2 13407 26 4699 4317280 1604 0 326 0 0 0 cpu3 105440 187 6088 4223444 2234 0 557 0 0 0 user，执行用户态进程消耗的时间\nnice，执行低优先级用户态进程花费的时间\nsystem，执行内核态进程消耗的时间\nidle，空闲的时间\niowait, 等待 I/O 的时间\n我们可以定时采集该文件的数据，通过计算两次采样数据，得出这段时间内的 CPU 使用率 。这是 top 工具默认的计算方法，也是最常见CPU使用率统计方法。\n4. 系统负载平均值 #执行 top 或者 uptime 命令，可以查看系统负载平均值（load average），这三个数值分别表示过去一分钟，五分钟和十五分钟内的系统负载平均值 ：\n$ uptime 14:38:23 up 4 min, 1 user, load average: 0.09, 0.53, 0.30 系统负载平均值是指处于 R 状态和 D 状态的进程的平均数量。 处于 R 状态的进程要么正在使用 CPU，要么正在等待使用 CPU。 处于 D 状态的进程正在等待一些 I/O 访问，例如等待磁盘。 取三个时间间隔的平均值。 负载平均值未针对系统中的 CPU 数量进行标准化，因此负载平均值为 1 意味着单个 CPU 系统一直在加载，而在 4 CPU 系统上则意味着它有 75% 的时间处于空闲状态。\n如果启动一个 CPU 使用率 100% 的进程，持续运行一分钟后，一分钟的系统负载平均值就会变为 1.00 左右。可以做个实验，执行 stress 启动一个进程：\n~$ stress -c 1 然后执行 uptime 查看。\n$ uptime 15:27:57 up 53 min, 2 users, load average: 0.18, 0.38, 0.30 $ uptime 15:30:02 up 55 min, 2 users, load average: 0.98, 0.62, 0.40 $ uptime 15:33:55 up 59 min, 2 users, load average: 1.01, 0.85, 0.55 5. 进程的优先级 #操作系统的进程调度策略有很多种，最经典是基于优先级调度。就是说在同一个调度周期中，优先级高的进程占用 CPU 的时间长些，而优先级低的进程占用 CPU 的时间短些。\n在内核中，进程优先级的相关宏定义：\n/* include/linux/sched/prio.h */ #define MAX_NICE 19 #define MIN_NICE -20 #define NICE_WIDTH (MAX_NICE - MIN_NICE + 1) #define MAX_USER_RT_PRIO 100 #define MAX_RT_PRIO MAX_USER_RT_PRIO #define MAX_PRIO (MAX_RT_PRIO + NICE_WIDTH) #define DEFAULT_PRIO (MAX_RT_PRIO + NICE_WIDTH / 2) 进程优先级的取值范围是 MAX_PRIO 定义的，它的值为140 ，就是说，Linux 内核实现了 140 个优先级范围（ 0~139） ，数值越小，优先级越高。其中 ，0~99 是实时进程的优先级范围，100~139 是非实时进程的优先级范围。对于非实时进程，当我们新建一个非实时进程时，内核为它分配的默认优先级是 DEFAULT_PRIO 定义的，就是 120 ，也就是 nice 为 0 时的值，可以在用户空间通过 nice 值（取值 -20~19）调整进程的优先级。\n在 top 命令中，使用 PR 和 NI 分别表示用户视角的优先级和 nice 值，二者相差 20 ：\n可以看出，在 top 命令中显示的进程优先级与内核中的优先级是不一致的，存在的映射关系如下：\n实时进程优先级是负值，范围在 -100 到 -2 之间，对应内核中的 0~99，其中最高优先级 -100 显示为RT； 非实时进程优先级范围是 0~39，对应用户设置的nice值是 -20~19，对应内核中的 100~139 。\n如果用 ps 命令查看进程的优先级信息，显示结果根 top 命令是不一样的：\n$ ps -l F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD 0 S 1000 15399 15386 0 80 0 - 5771 wait pts/1 00:00:00 bash 0 R 1000 15488 15399 0 80 0 - 7229 - pts/1 00:00:00 ps 其中，PRI 表示优先级，取值范围是 -40 到 100 ，对应内核中的 0~139 ，当 nice 值为 0 时，就会显示 80 。\n可以用 nice 命令设置进程启动时的优先级，例如：\n$ nice -n 10 stress -c 1 然后查看这个进程优先级：\n$ ps -efl | grep stress 0 S sbs 3288 2819 0 90 10 - 2061 wait 17:07 pts/1 00:00:00 stress -c 1 1 R sbs 3289 3288 99 90 10 - 2061 - 17:07 pts/1 00:00:08 stress -c 1 还可以用 renice 命令修改正在运行的进程的优先级，例如：\n$ sudo renice -n 0 -p 3289 3289 (process ID) old priority 10, new priority 0 $ ps -lfp 3289 F S UID PID PPID C PRI NI ADDR SZ WCHAN STIME TTY TIME CMD 1 R sbs 3289 3288 99 80 0 - 2061 - 17:07 pts/1 00:06:48 stress -c 1 6. CFS 调度器 #进程调度依赖于调度策略，Linux 内核把相同的调度策略抽象成了调度类（schedule class）。不同类型的进程采用不同的调度策略，目前 Linux 内核中默认实现了 5 个调度类，分别是 stop、 deadline、realtime、CFS 和 idle，它们分别使用 sched_class 来定义，并且通过 next 指针串联在一起，如图所示：\nstop\n最高优先级，比deadline进程的优先级高。\n可以抢占任何进程。\n在每个CPU上实现一个名为“migration/N”的内核线程，N表示CPU的编号。该内核线程的优先级最高，可以抢占任何进程的执行，一般用来执行特殊的功能。\n用于负载均衡机制中的进程迁移、softlockup检测、CPU热插拔、RCU等。\ndeadline(SCHED_DEADLINE )\n最高优先级的实时进程，优先级为-1。\n用于调度有严格时间要求的实时进程，如视频编解码等。\nrealtime(SCHED_FIFO、SCHED_RR)\n普通实时进程，优先级为0~99。\n用于普通的实时进程，比如IRO线程化。\nCFS(SCHED_NORMAL、SCHED_BATCH、SCHED_IDLE)\n普通进程，优先级为100~139，由CFS来调度。 idle\n最低优先级的进程。\n当就绪队列中没有其他进程时进入idle调度类，idle调度类会让CPU进入低功耗模式。\n一般的非实时进程是由完全公平调度器 CFS(Completely Fair Scheduler) 调度执行的，核心代码在内核的 kernel/sched 目录下，它的目的是让每个进程尽可能“公平”地获得运行时间。\n如果当前有 n 个进程需要调度执行，那么调度器应该在一个比较小的时间范围内，把这 n 个进程全都调度执行一遍，尽量公平的分配执行时长，这个时间范围也叫做调度周期。进程越多，每个进程在周期内被执行的时间就会被分的越小。在一个调度周期里，一个进程分配的时间是由进程的权重决定的，可以表示为：\n运行时间tn=调度周期T * 进程权重w / 运行队列中全部进程的权重之和S 权重跟进程的 nice 值有关，在内核的 kernel/sched/core.c 文件定义了 nice 值转换为权重的映射表：\nconst int sched_prio_to_weight[40] = { /* -20 */ 88761, 71755, 56483, 46273, 36291, /* -15 */ 29154, 23254, 18705, 14949, 11916, /* -10 */ 9548, 7620, 6100, 4904, 3906, /* -5 */ 3121, 2501, 1991, 1586, 1277, /* 0 */ 1024, 820, 655, 526, 423, /* 5 */ 335, 272, 215, 172, 137, /* 10 */ 110, 87, 70, 56, 45, /* 15 */ 36, 29, 23, 18, 15, }; 其中，nice 值为 0 的权重是 1024，nice值每差1，权重大约差1.25倍，运行时间相差10% 。\n确定了每个进程分配的时间后，还有一个问题需要解决，就是下一个运行的进程是谁？CFS 会对所有进程维护一个累积占用 CPU 时间数，可以衡量出每个进程目前占用的CPU时间总量是不是过大或者过小，这个数字记录在每个进程的 vruntime 中。所有待执行进程都以 vruntime 为key放到一个由红黑树组成的队列中，每次被调度执行的进程，都是这个红黑树的最左子树上的那个进程，即 vruntime 时间最少的进程，这样就保证了所有进程的相对公平。进程每次运行完毕后就会更新vruntime变量，至于如何挑选出vruntime最少的进程，这将由红黑树完成。\n总的来说，优先级高的进程，每次被调度后执行的时间更长，总执行时间最短的进程会被优先调度。\n为了避免过度频繁的抢占发生，Linux内核还设置了每个Task（进程）的最小运行时间（或称运行时间粒度），在这个时间内，这个进程的 CPU 资源是不可被抢占的。除非进程主动让出CPU或者执行了阻塞的系统调用，一般而言进程都可以执行这个最小时间。这个时间可以通过内核参数sched_min_granularity_ns来查看：\n$ cat /proc/sys/kernel/sched_min_granularity_ns 2250000 7. 实时进程的调度 #优先级在 0~99 范围内的都是实时进程。\n8. top 命令 #top 命令是用于显示 Linux 系统经常信息的工具，执行 top 命令后，即可进入一个基本的交互界面：\n这个界面是动态更新的，默认是 1.5 秒刷新一次，显示的内容分为两个区域：\n上半部分显示统计信息，包括所有进程对 CPU 和 Memery 的总体使用情况。\n下半部分显示进程列表，如果进程比较多，没有显示全，可以按 Up/Down 或者 PageUp/PageDown 键上下翻页。\n按 q 键可以退出。\n执行 top 命令时，可以设置一些选项：\n-d [secs.tenths]，刷新的间隔时间，单位是秒，支持小数，必须大于默认值（1.5s）。\n-n [X]，默认情况下，top 会一直保持运行，用 -n 选项可以指定一个整数 X ，表示 top 命令会在刷新 X 次后退出。\n-u [user name]，只显示某个用户的进程列表，也可以启动后按下 u 键，选择用户。\n8.1 统计信息解析 #以如下信息为例：\ntop - 14:12:35 up 3:33, 2 users, load average: 0.06, 0.06, 0.01 Tasks: 343 total, 1 running, 257 sleeping, 0 stopped, 0 zombie %Cpu(s): 0.1 us, 0.1 sy, 0.0 ni, 99.8 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem : 16362568 total, 14239488 free, 1374568 used, 748512 buff/cache KiB Swap: 2097148 total, 2097148 free, 0 used. 14697252 avail Mem 第一行：\n14:12:35 ，系统当前时间\nup 3:33 ，系统开机到现在经过的时间\n2 users ，当前有两个用户在线\nload average: 0.06, 0.06, 0.01，过去 1 分钟，5 分钟和 15 分钟的 CPU 平均负载。\n第二行：\nTasks ，进程信息\n343 total ，当前系统有 343 给进程\n1 running ，有 1 个进程处于运行状态（R）\n257 sleeping ，有 257 个进程处于睡眠状态（S）\n0 stopped ，有 0 个进程进程处于停止状态（T）\n0 zombie ，有 0 个进程处于僵尸状态（Z）\n第三行：\n%Cpu(s) ，CPU 使用率的信息，对于多核 CPU ，这里显示的是所有核心的平均值，可以按 1 键，显示每个 CPU 核的状态。\n0.1 us ，CPU 执行用户空间进程的时间百分比\n0.1 sy ，CPU 执行内核空间任务的时间百分比\n0.0 ni ，手动设置过 \u0026ldquo;nice\u0026rdquo; 值的进程的执行时间百分比。Linux 使用一个 \u0026ldquo;nice\u0026rdquo; 值来决定一个进程的优先级。\u0026ldquo;nice\u0026rdquo; 值越小的进程优先级越高，\u0026ldquo;nice\u0026rdquo; 值可以手动设置。\n99.8 id ，CPU 空闲的时间百分比\n中断是向处理器发出的关于一个需要立即注意的事件的信号。硬件中断通常被外设用来告诉系统有关事件，如键盘上的按键。另一方面，软件中断是由于在处理器上执行特定指令而产生的。在任何一种情况下，操作系统都会处理它们，处理硬件和软件中断的时间分别由hi和si给出。\n在虚拟化环境中，CPU的一部分资源被赋予每个虚拟机（VM）。操作系统检测到它有工作要做，但它不能执行这些工作，因为CPU在其他虚拟机上很忙。以这种方式损失的时间是 \u0026ldquo;偷 \u0026ldquo;的时间，显示为st。\n8.2 进程列表解析 #默认情况下，进程列表显示的信息包括如下内容：\nPID：进程的ID\nUSER：进程所有者\nPR：进程的优先级\nNI：nice 值\nVIRT：进程占用的虚拟内存\nRES：进程占用的物理内存\nSHR：进程使用的共享内存\nS：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数\n%CPU：进程的CPU使用率\n%MEM：进程使用的物理内存和总内存的百分比\nTIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。\nCOMMAND：进程启动命令名称\n还有很多信息没有显示出来，可以按 f 键打开 Fields Management 窗口，这里列出了所有可选的进程信息，可以通过上下键移动光标，按下空格键选中相应选项。\n8.3 应用实例 #8.3.1 进程排序 #默认情况下，进程列表按 %CPU 列的值，由大到小排序，可以通过按键改变排序依据：\nM，按 %MEM 排序\nN，按 PID 排序\nT，按 TIME+ 排序\nP，按 %CPU 排序\n8.3.2 按用户筛选 #按下 u 键后，根据提示输入用户名或者用户 ID ，可以在进程列表中筛选出特定用户的进程，例如，只列出 root 用户的进程：\n8.3.3 改变显示单位 #按下 E 键，可以改变系统信息部分显示的内存大小单位，按下 e 键，可以改变进程信息部分显示的内存大小单位。支持的单位有：\nkibibytes (KiB)\nmebibytes (MiB)\ngibibytes (GiB)\ntebibytes (TiB)\npebibytes (PiB)\nexbibytes (EiB - applies only for memory values)\n例如：\n8.3.5 查看进程运行在哪个 CPU 核 #默认情况下，显示的进程信息有限，可以按 f 键打开 Fields Management 窗口，这里列出了所有可选的进程信息，然后通过上下键将光标移动到 P = Last Use CPU ，按下空格键选中这个选项，前面会出现一个星号：\n然后按 q 键退出，回到主界面，就会在左右边显示每个进程最近使用的 CPU 核：\n参考 # https://phoenixnap.com/kb/top-command-in-linux#change-display-units\nhttps://www.booleanworld.com/guide-linux-top-command/#CPU_usage\nhttps://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/top.html\nhttps://www.howtogeek.com/668986/how-to-use-the-linux-top-command-and-understand-its-output/\nhttp://blog.foool.net/2020/09/利用-proc精确计算linux系统的cpu利用率/\nhttps://scoutapm.com/blog/understanding-load-averages\nhttps://www.baeldung.com/linux/process-states\nhttps://carlyleliu.github.io/2021/Linux进程管理（七）多核调度/\nhttps://linux.cn/article-7325-1.html\nhttps://scoutapm.com/blog/understanding-load-averages\n","date":"2022 May 7","permalink":"/posts/2022/05/07/","section":"Posts","summary":"进程调度的概念比较简单。假设在只有单核处理器的系统中，同一时刻只有一个进程可以拥有处理器资源，那么其他的进程只能在就绪队列（runqueue）中等待，等到处理器空闲之后才有机会获取处理器资源并运行。在这种场景下，操作系统就需要从众多的就绪进程中选择一个最合适的进程来运行，这就是进程调度器（scheduler）。进程调度器产生的最大原因是为了提高处理器的利用率。一个进程在运行的过程中有可能需要等待某些资源，比如等待磁盘操作的完成、等待键盘输入、等待物理页面的分配等。如果处理器和进程一起等待，那么明显会浪费处理器资源，所以一个进程在睡眠等待时，调度器可以调度其他进程来运行，这样就提高了处理器的利用率。","title":"Linux 进程调度的学习笔记"},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/","section":"Shaocheng.Li","summary":"","title":"Shaocheng.Li"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":null,"permalink":"/tags/untagged/","section":"Tags","summary":"","title":"untagged"},{"content":"Linux 内核实现了一个循环双向链表，而且是侵入式链表，核心数据结构定义在 include/linux/types.h 文件：\nstruct list_head { struct list_head *next, *prev; }; 实现方法都定义在 include/linux/list.h 文件。\n1. 初始化链表 #内核提供了两种初始化链表节点的方法。\n一种是初始化宏：\n#define LIST_HEAD_INIT(name) { \u0026amp;(name), \u0026amp;(name) } #define LIST_HEAD(name) \\ struct list_head name = LIST_HEAD_INIT(name) 展开后就是：\n#define LIST_HEAD(name) \\ struct list_head name = { \u0026amp;(name), \u0026amp;(name) } 它的作用是新建一个 struct list_head 变量 name ，让两个指针指向自己，通常用户新建一个链表的 head ：\n另一种是初始化函数 ：\nstatic inline void INIT_LIST_HEAD(struct list_head *list) { WRITE_ONCE(list-\u0026gt;next, list); list-\u0026gt;prev = list; } 它的作用是让节点 struct list_head *list 的两个指针指向自己，通常用于初始一个节点。\n内核的 struct list_head 保持了最简的结构，其他数据结构要表示为链表时，需要将 struct list_head 元素嵌入到自己的数据结构中，例如：\n// 新建一个链表，head 就是 students_list LIST_HEAD(students_list); // 新建两个节点，并初始化 struct student *student_1 = kmalloc(sizeof(struct student), GFP_KERNEL); struct student *student_2 = kmalloc(sizeof(struct student), GFP_KERNEL); student_1-\u0026gt;id = 1; strcpy(student_1-\u0026gt;name, \u0026#34;Bob\u0026#34;); INIT_LIST_HEAD(\u0026amp;student_1-\u0026gt;list); student_2-\u0026gt;id = 2; strcpy(student_2-\u0026gt;name, \u0026#34;Alice\u0026#34;); INIT_LIST_HEAD(\u0026amp;student_2-\u0026gt;list); // 将两个节点依次插入队尾 list_add_tail(\u0026amp;student_1-\u0026gt;list, \u0026amp;students_list); list_add_tail(\u0026amp;student_2-\u0026gt;list, \u0026amp;students_list); 实际构造的链表结构如下：\n2. 添加节点 #在 head 后面（也就是队头）添加一个 new 节点：\nvoid list_add(struct list_head *new, struct list_head *head) 在 head 前面（也就是队尾）添加一个 new 节点：\nvoid list_add_tail(struct list_head *new, struct list_head *head) 例如：\nlist_add(\u0026amp;student_1-\u0026gt;list, \u0026amp;students_list); 3. 删除节点 #删除一个节点：\nvoid list_del(struct list_head *entry) 例如：\nlist_del(\u0026amp;student_1-\u0026gt;list); 4. 判断节点的位置 #判断 list 节点是否是 head 链表的 firts/last 节点，如果正确会返回 1 ，错误返回 0 ：\nint list_is_first(const struct list_head *list, const struct list_head *head) int list_is_last(const struct list_head *list, const struct list_head *head) 判断一个链表是否为空格，如果为空会返回 1 ：\nint list_empty(const struct list_head *head) 5. 查找节点 #作为侵入式链表，需要通过 struct list_head 结构的节点地址获得真正的数据节点，内核提供了 container_of 的重新封装：\n#define list_entry(ptr, type, member) container_of(ptr, type, member) 三个参数分别表示：\nptr ：结构体成员变量 member 的地址，就是 struct list_head 成员的地址，\ntype ：数据节点的结构体类型的名称\nmember ：结构体成员变量的名称\n例如：\nlist_entry(\u0026amp;student_1-\u0026gt;list, struct student, list) 返回队头/队尾的节点：\nlist_first_entry(head, type, member) list_last_entry(head, type, member) 三个参数分别表示：\nhead ：链表头的地址，\ntype ：结构体类型的名称\nmember ：结构体中的成员变量的名称\n例如：\nstruct student *entry; entry = list_first_entry(\u0026amp;students_list, struct student, list); 获取下一个/上一个节点：\nlist_next_entry(pos, member) list_prev_entry(pos, member) 两个参数的含义：\npos ：数据节点的地址\nmember：数据节点内 sturct list_head 成员的名称\n例如：\nstruct student *entry; entry = list_first_entry(\u0026amp;students_list, struct student, list); entry = list_next_entry(entry, list); 6. 遍历链表 #内核定义了一个宏，用于从队头开始遍历链表：\n#define list_for_each_entry(pos, head, member) \\ for (pos = list_first_entry(head, typeof(*pos), member); \\ \u0026amp;pos-\u0026gt;member != (head); \\ pos = list_next_entry(pos, member)) 三个参数的含义：\npos ：一个数据节点类型的指针，用于遍历链表中的每个节点\nhead ：链表的 head member ：数据节点内 sturct list_head 成员的名称\n例如：\nlist_for_each_entry(entry, \u0026amp;students_list, list) { printk(\u0026#34;entry %d:%s\\n\u0026#34;, entry-\u0026gt;id, entry-\u0026gt;name); } 7. 例程 #hellomod.c ：\n#include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/slab.h\u0026gt; #include \u0026lt;linux/string.h\u0026gt; struct student { int id; char name[10]; struct list_head list; }; static int __init hellomod_init(void) { struct student *entry; // 新建一个链表 LIST_HEAD(students_list); // 新建两个节点，并初始化 struct student *student_1 = kmalloc(sizeof(struct student), GFP_KERNEL); struct student *student_2 = kmalloc(sizeof(struct student), GFP_KERNEL); student_1-\u0026gt;id = 1; strcpy(student_1-\u0026gt;name, \u0026#34;Bob\u0026#34;); INIT_LIST_HEAD(\u0026amp;student_1-\u0026gt;list); student_2-\u0026gt;id = 2; strcpy(student_2-\u0026gt;name, \u0026#34;Alice\u0026#34;); INIT_LIST_HEAD(\u0026amp;student_2-\u0026gt;list); // 将两个节点依次插入队尾 list_add_tail(\u0026amp;student_1-\u0026gt;list, \u0026amp;students_list); list_add_tail(\u0026amp;student_2-\u0026gt;list, \u0026amp;students_list); entry = list_first_entry(\u0026amp;students_list, struct student, list); printk(\u0026#34;first entry is %d:%s\\n\u0026#34;, entry-\u0026gt;id, entry-\u0026gt;name); entry = list_next_entry(entry, list); printk(\u0026#34;next entry of first entry is %d:%s\\n\u0026#34;, entry-\u0026gt;id, entry-\u0026gt;name); list_for_each_entry(entry, \u0026amp;students_list, list) { printk(\u0026#34;entry %d:%s\\n\u0026#34;, entry-\u0026gt;id, entry-\u0026gt;name); } printk(\u0026#34;hellomod init\\n\u0026#34;); return 0; } static void __exit hellomod_exit(void) { printk(\u0026#34;hellomod exit\\n\u0026#34;); } module_init(hellomod_init); module_exit(hellomod_exit); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); Makefile ：\nKERDIR=/lib/modules/$(shell uname -r)/build PWD=$(shell pwd) obj-m:=hellomod.o default: make -C ${KERDIR} M=${PWD} modules clean: make -C ${KERDIR} M=${PWD} clean 编译后加载驱动：\n$ make $ sudo insmod hellomod.ko $ dmesg [35509.579609] first entry is 1:Bob [35509.579610] next entry of first entry is 2:Alice [35509.579611] entry 1:Bob [35509.579611] entry 2:Alice [35509.579611] hellomod init ","date":"2022 April 20","permalink":"/posts/2022/04/20/","section":"Posts","summary":"Linux 内核实现了一个循环双向链表，而且是侵入式链表，核心数据结构定义在 include/linux/types.","title":"Linux 内核数据结构-链表"},{"content":"原文：https://ineclabs.com/image-zimage-uimage-vmlinuz-linux-kernel/\nLinux 内核是宏内核。在建立内核镜像时，我们可以选择多种格式的内核镜像。通常情况下，初学者会因为这些不同的名称和格式而感到疑惑。在 Ubuntu 中，内核文件存储在 /boot 文件夹中，被称为 vmlinuz-version ，以 ubuntu 18 为例：\nsbs@ubuntu:~$ ls /boot/ config-5.4.0-100-generic initrd.img-5.4.0-104-generic System.map-5.4.0-100-generic config-5.4.0-104-generic memtest86+.bin System.map-5.4.0-104-generic grub memtest86+.elf vmlinuz-5.4.0-100-generic initrd.img-5.4.0-100-generic memtest86+_multiboot.bin vmlinuz-5.4.0-104-generic vmlinuz 这个名字来自于 Unix 世界，在 60 年代，他们曾经把内核简单地称为 \u0026ldquo;Unix\u0026rdquo;，所以 Linux 在90年代首次开发时开始把他们的内核称为 \u0026ldquo;Linux\u0026rdquo;。当虚拟内存被开发出来以提高多任务处理能力时，\u0026ldquo;vm \u0026ldquo;被放在文件的前面以表明内核支持虚拟内存。有一段时间，Linux 内核被称为 vmlinux ，但是内核越来越大，无法容纳在可用的启动内存中，所以内核图像被压缩，结尾的 x 被改成了 z ，以显示它是用 zlib 压缩的。在嵌入式系统中，更常用的是 LZMA 和 BZIP2 格式，有些内核干脆被称为 zImage 。在内核配置选项中，可以选择所需的格式。\n在这里，我们可以对各种内核图像有一个简单的概述：\nImage ，通用的 Linux 内核二进制镜像文件。\nvmlinux ，这是一个静态链接的可执行文件格式的 Linux 内核。一般来说，你不需要担心这个文件，它只是启动过程中的一个中间步骤。原始的 vmlinux 文件可能对调试有用。\nvmlinux.bin ，与 vmlinux 相同，但采用可启动的原始二进制文件格式。所有的符号和重定位信息都被丢弃了。通过 objcopy -O binary vmlinux vmlinux.bin 从 vmlinux 生成。\nvmlinuz，vmlinux 文件通常用 zlib 进行压缩。从 2.6.30 开始，LZMA 和 bzip2 也可用。生成 zImage 或 bzImage 时，也是对vmlinux 的压缩。通过给 vmlinuz 添加进一步的启动和解压缩功能，可以用来启动带有 vmlinux 内核的系统。内核函数 decompress_kernel() 在启动时处理 vmlinuz 的解压过程，会打印如下信息：\nDecompressing Linux... done Booting the kernel. zImage ，执行 make zImage 时生成的内核，这是小内核的旧格式（压缩的，低于512KB）。在启动时，这个镜像会被加载到内存的低位（RAM 的前 640KB）。\nbzImage，执行 make bzImage 时生成的内核，大的 zImage（这与 bzip2 无关），如果内核镜像超过 512KB ，就应该用这个格式。该镜像在内存中被加载得很高（超过1MB RAM）。由于今天的内核已经远远超过 512KB，这通常是首选的方式。\nuImage：一个具有 U-Boot 包装器（由 mkimage 工具安装）的镜像文件，包括操作系统类型和引导程序的信息。\n常用的做法（例如典型的 Linux Kernel Makefile）是使用 zImage 文件。 由于 zImage 文件是自解压的（即不需要外部解压缩器），因此包装器会指示该内核“未压缩”，即使它实际上已经压缩了。\n内核启动过程如下：\n总结\n","date":"2022 March 13","permalink":"/posts/2022/03/13/","section":"Posts","summary":"原文：https://ineclabs.com/image-zimage-uimage-vmlinuz-linux-kernel/","title":"Linux 内核镜像的类型和区别"},{"content":"1. 在客户端电脑生成密钥对 #在客户端电脑上执行如下命令，生成一个密钥对：\nssh-keygen -t ed25519 -C \u0026#34;lishaocheng_20220201\u0026#34; -t 选项指定了加密类型，我们选择 ed25519 ，也可以选择其他类型。 -C 选项是设置密钥对的注释，我习惯设置用户名和日期。 设置一个便于记忆的文件名，密码可以跳过，生成的密钥对文件位于当前目录下。后缀为 .pub 的文件是公钥，另一个是私钥，把两个文件复制到 ~/.ssh/ 目录下。\n如果在 Linux 下使用，需要设置密钥文件的权限，否则添加时会报错：\nchmod 600 ~/.ssh/lishaocheng_20220201 2. 将公钥添加到 SSH 服务器 #在客户电脑的在 ~/.ssh/ 目录下执行 ssh-copy-id -i [public key] username@[server ip] ，将公钥添加到服务器上，例如：\n~/.ssh $ ssh-copy-id -i lishaocheng_20220201.pub sbs@192.168.42.131 /usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: \u0026#34;lishaocheng_20220201.pub\u0026#34; /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed /usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys sbs@192.168.42.131\u0026#39;s password: Number of key(s) added: 1 Now try logging into the machine, with: \u0026#34;ssh \u0026#39;sbs@192.168.42.131\u0026#39;\u0026#34; and check to make sure that only the key(s) you wanted were added. 执行成功后，公钥会复制到服务器的 ~/.ssh 目录下的 authorized_keys 文件中。\n3. 修改客户端配置文件 #在客户端配置文件 ~/.ssh/config 中添加如下内容：\nHost vm_ubuntu18 HostName 192.168.42.131 Port 22 User sbs PreferredAuthentications publickey IdentityFile ~/.ssh/lishaocheng_20220201 Host 设置为服务器 IP Hostname 设置为服务器名称 Port 是服务器 SSH 的端口 User 是用户名 PreferredAuthentications 设为公钥验证 IdentityFile 设置私钥文件的路径 保存后，在客户端执行 ssh vm_ubuntu18 即可登录。\n","date":"2022 March 11","permalink":"/posts/2022/03/11/","section":"Posts","summary":"1. 在客户端电脑生成密钥对 #在客户端电脑上执行如下命令，生成一个密钥对：","title":"配置 SSH 密钥登录"},{"content":"1. 概述 #硬件平台使用 iMX8MM 参考开发板，带有 M.2 接口，软件平台是 iMX Yocto Linux 5.4.47 。调试海华的 AW-CM276MA 模块，该模块基于 NXP 88W8997，PCIe 2.0 接口，M.2 2230 封装，外观如下：\n模块结构：\n具有如下特性：\n基于 88W8997 IEEE 802.11ac (wave2)，BlueTooth 5.2 Wi-Fi PCIe 接口，BlueTooth UART 接口 Wi-Fi 2.4/5 GHz 双频，2x2 双天线 支持 20/40/80Mhz 带宽，80MHz 2x2时最高速率 866.7Mbps WPA/WPA2 和 WEP 64/128 bit 加密 支持STA（Wi-Fi站点）, AP（Wi-Fi热点）和 P2P（Wi-Fi直连）三种模式 其他参考：\nNXP 的 Wi-Fi 产品列表：https://www.nxp.com/products/wireless/wi-fi-plus-bluetooth:WIFI-BLUETOOTH 88W8997 ：https://www.nxp.com/products/wireless/wi-fi-plus-bluetooth/2-4-5-ghz-dual-band-2x2-wi-fi-5-802-11ac-plus-bluetooth-5-3-solution:88W8997 2. 驱动和固件 #模块使用的驱动是 mxm_wifiex ，位于内核的drivers/net/wireless/nxp/mxm_wifiex 目录下。这个驱动是 NXP 开发并维护，支持 NXP 的多种无线模块，通常，新的模块需要新的驱动版本支持，可以在 https://source.codeaurora.org/external/imx/mwifiex 下载源码。此外，还需要提供相应模块的固件，NXP 的固件通过 https://github.com/NXP/imx-firmware 发布，也分不同的版本，需要与驱动版本匹配。\n加载驱动时，通过模块参数指定固件的路径，当 SDIO/PCIe 总线驱动检测到模块的 SDIO/PCIe 接口时，MLAN 模块将固件二进制文件下载到 SD8987/PCIE8997 中。模块驱动程序支持多种接口向用户提供控制和配置模块的通道，可以通过 CFG80211 子系统与网络协议栈相连，向 iw 、hostapt 和 wpa_supplicant(nl80211) 提供编程接口，也可以通过 IOCTL 向 iwconfig、iwpriv 和 wpa_supplicant(wext) 提供编程接口。如下是整个软件栈的图式：\n使用 git 下载驱动源码：\n$ git clone https://source.codeaurora.org/external/imx/mwifiex 源码有多个分支：\n$ git branch -a * master remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/imx_5.4.70_2.3.0 remotes/origin/lf-5.10.52_2.1.0 remotes/origin/lf-5.10.72_2.2.0 remotes/origin/lf-5.10.y_1.0.0 remotes/origin/lf-5.10.y_2.0.0 remotes/origin/master 直接使用 master 分支，对应的标签 lf-5.10.35-2.0.0 表示这个版本已经集成到了 iMX Yocto L5.10.35 的内核里：\n从 git 记录可以看到当前的驱动版本是 mxm5x17247.p5 ：\ncommit a63cac065978149d9c4c1064eddcdc1f11dda57c Author: Sherry Sun \u0026lt;sherry.sun@nxp.com\u0026gt; Date: Wed Jun 2 09:47:10 2021 +0800 mxm_wifiex: update to mxm5x17247.p5 release 5X - Linux 5.x Kernel 17 - card type 247 - Release version p5 - Patch Number 然后将驱动源码中 wlan_src 目录下的所有文件复制到 iMX Yocto L5.4.47 内核源码的 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/ 目录下。编译出的内核模块是 mlan.ko 和 moal.ko ，复制到目标板的如下目录，覆盖原文件：\n/lib/modules/5.4.47-2.2.0+g5ec03d06f54e/kernel/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/ 打开 https://github.com/NXP/imx-firmware 页面，在 tag 中找到对应的版本 lf-5.10.35-2.0.0 ：\n对应的固件版本是 PCIE-UART W8997 Firmware version 16.92.10.p213 :\n16 - Major revision 92 - Feature pack 10 - Release version p213 - Patch number 下载后解压，在 nxp 目录下有多种模块的固件：\n其中，FwImage_8997 下是 PCIe 接口的 88W8997 模块的固件，wifi_mod_para.conf 是传递模块参数的配置文件。将这三个复制到目标板的 /lib/firmware/nxp/ 目录下，修改 wifi_mod_para.conf 中 PCIE8997 的 fw_name 参数，设置正确的固件路径：\nPCIE8997 = { cfg80211_wext=0xf wfd_name=p2p max_vir_bss=1 cal_data_cfg=none drv_mode=7 ps_mode=2 auto_ds=2 fw_name=nxp/FwImage_8997/pcieuart8997_combo_v4.bin } 关于这些模块参数的含义，在驱动源码的 READM_MLAN 文件里有详细说明。常用的参数有：\ndrv_mode：设置驱动支持模式，低三位有效，设为 7 表示支持三种模式： Bit 0 : STA Bit 1 : AP Bit 2 : P2P sta_name：STA 模式的接口名称 (default: \u0026ldquo;mlan\u0026rdquo;) uap_name：AP 模式的接口名称 (default: \u0026ldquo;uap\u0026rdquo;) wfd_name：P2P 模式的接口名称 (default: \u0026ldquo;wfd\u0026rdquo;) cfg80211_wext= Bit 0: STA WEXT Bit 1: AP WEXT Bit 2: STA CFG80211 Bit 3: AP CFG80211 auto_ds=0|1|2 \u0026lt;use MLAN default | enable auto deepsleep | disable auto deepsleep\u0026gt; ps_mode=0|1|2 \u0026lt;use MLAN default | enable IEEE PS mode | disable IEEE PS mode\u0026gt; fw_name = ，固件的相对路径（/lib/firmware/ 目录下） 确保插入模块后，可以看到 PCIe 设备：\n~# lspci -v 00:00.0 PCI bridge: Synopsys, Inc. DWC_usb3 (rev 01) (prog-if 00 [Normal decode]) Flags: bus master, fast devsel, latency 0, IRQ 232 Memory at 18000000 (32-bit, non-prefetchable) [size=1M] Bus: primary=00, secondary=01, subordinate=ff, sec-latency=0 I/O behind bridge: None Memory behind bridge: None Prefetchable memory behind bridge: 18100000-182fffff [size=2M] [virtual] Expansion ROM at 18300000 [disabled] [size=64K] Capabilities: [40] Power Management version 3 Capabilities: [50] MSI: Enable- Count=1/1 Maskable+ 64bit- Capabilities: [70] Express Root Port (Slot-), MSI 00 Capabilities: [100] Advanced Error Reporting Capabilities: [148] L1 PM Substates Kernel driver in use: pcieport 01:00.0 Ethernet controller: Marvell Technology Group Ltd. Device 2b42 (rev 11) Flags: bus master, fast devsel, latency 0, IRQ 232 Memory at 18100000 (64-bit, prefetchable) [size=1M] Memory at 18200000 (64-bit, prefetchable) [size=1M] Capabilities: [40] Power Management version 3 Capabilities: [50] MSI: Enable- Count=1/32 Maskable+ 64bit+ Capabilities: [70] Express Endpoint, MSI 00 Capabilities: [b0] MSI-X: Enable- Count=32 Masked- Capabilities: [100] Advanced Error Reporting Capabilities: [148] Device Serial Number 00-00-00-00-00-00-00-00 Capabilities: [158] Power Budgeting \u0026lt;?\u0026gt; Capabilities: [168] Latency Tolerance Reporting Capabilities: [170] L1 PM Substates Kernel driver in use: wlan_pcie 然后加载驱动：\n~# modprobe moal mod_para=nxp/wifi_mod_para.conf 驱动加载成功后，内核会打印如下信息：\n[ 232.184958] wlan: Loading MWLAN driver [ 232.189377] wlan_pcie 0000:01:00.0: enabling device (0000 -\u0026gt; 0002) [ 232.195726] Attach moal handle ops, card interface type: 0x204 [ 232.205187] PCIE8997: init module param from usr cfg [ 232.210209] card_type: PCIE8997, config block: 0 [ 232.214848] cfg80211_wext=0xf [ 232.217837] wfd_name=p2p [ 232.220381] max_vir_bss=1 [ 232.223001] cal_data_cfg=none [ 232.225986] drv_mode = 7 [ 232.228546] ps_mode = 2 [ 232.230991] auto_ds = 2 [ 232.233455] fw_name=nxp/FwImage_8997/pcieuart8997_combo_v4.bin [ 232.239350] rx_work=1 cpu_num=4 [ 232.242530] Attach mlan adapter operations.card_type is 0x204. [ 232.256329] Request firmware: nxp/FwImage_8997/pcieuart8997_combo_v4.bin [ 233.115916] FW download over, size 553604 bytes [ 233.984767] WLAN FW is active [ 233.987752] on_time is 233983459875 [ 234.031562] fw_cap_info=0x181c3fa3, dev_cap_mask=0xffffffff [ 234.037181] max_p2p_conn = 8, max_sta_conn = 8 [ 234.068698] wlan: version = PCIE8997--16.92.10.p213-MM5X16247.p5-GPL-(FP92) [ 234.078130] wlan: Driver loaded successfully 可以看到三个网络接口：\n~# ifconfig -a eth0 Link encap:Ethernet HWaddr 7a:ac:85:59:55:fb BROADCAST MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:82 errors:0 dropped:0 overruns:0 frame:0 TX packets:82 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:6220 (6.0 KiB) TX bytes:6220 (6.0 KiB) mlan0 Link encap:Ethernet HWaddr d8:c0:a6:6e:8f:7d BROADCAST MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) p2p0 Link encap:Ethernet HWaddr da:c0:a6:6e:8f:7d BROADCAST MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) uap0 Link encap:Ethernet HWaddr d8:c0:a6:6e:90:7d BROADCAST MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) mlan0 是 STA 模式的接口，p2p0 是 P2P 模式的接口，uap0 是 AP 模式的接口。\n查看驱动信息：\n~# cat /proc/mwlan/adapter0/mlan0/info driver_name = \u0026#34;wlan\u0026#34; driver_version = PCIE8997--16.92.10.p213-MM5X16247.p5-GPL-(FP92) interface_name=\u0026#34;mlan0\u0026#34; firmware_major_version=16.92.10 bss_mode =\u0026#34;Managed\u0026#34; media_state=\u0026#34;Disconnected\u0026#34; mac_address=\u0026#34;d8:c0:a6:6e:8f:7d\u0026#34; 驱动源码里有大量的调试信息，是通过 PRINTM 函数打印的，分为多种类型，下表列出了所有的调试信息类型：\nBit Message type Log format Description Bit 0 MMSG PRINTM(MMSG,\u0026hellip;) Set bit 0 to enable all driver logs with log level MMSG. Bit 1 MFATAL PRINTM(MFATAL,\u0026hellip;) Set bit 1 to enable all driver logs with log level MFATAL. Bit 2 MERROR PRINTM(MERROR,\u0026hellip;) Set bit 2 to enable all driver logs with log level MERROR. Bit 3 MDATA PRINTM(MDATA,\u0026hellip;) Set bit 3 to enable all driver logs with log level MDATA. Bit 4 MCMND PRINTM(MCMND,\u0026hellip;) Set bit 4 to enable all driver logs with log level MCMND. Bit 5 MEVENT PRINTM(MEVENT,\u0026hellip;) Set bit 5 to enable all driver logs with log level MEVENT. Bit 6 MINTR PRINTM(MINTR,\u0026hellip;) Set bit 6 to enable all driver logs with log level MINTR. Bit 7 MIOCTL PRINTM(MIOCTL,\u0026hellip;) Set bit 7 to enable all driver logs with log level MIOCTL. Bit 16 MDAT_D PRINTM(MDAT_D,\u0026hellip;), DBG_HEXDUMP(MDAT_D,\u0026hellip;) Set bit 16 to enable all driver logs with log level MDAT_D and provide the corresponding hexdump in dmesg logs. Bit 17 MCMD_D PRINTM(MCMD_D,\u0026hellip;), DBG_HEXDUMP(MCMD_D,\u0026hellip;) Set bit 17 to enable all driver logs with log level MCMD_D and provide the corresponding hexdump in dmesg logs. Bit 18 MEVT_D PRINTM(MEVT_D,\u0026hellip;), DBG_HEXDUMP(MEVT_D,\u0026hellip;) Set bit 18 to enable all driver logs with log level MEVT_D and provide the corresponding hexdump in dmesg logs. Bit 19 MFW_D PRINTM(MFW_D,\u0026hellip;), DBG_HEXDUMP(MFW_D,\u0026hellip;) Set bit 19 to enable all driver logs with log level MFW_D and provide the corresponding hexdump in dmesg logs. Bit 20 MIF_D PRINTM(MIF_D,\u0026hellip;), DBG_HEXDUMP(MIF_D,\u0026hellip;) Set bit 20 to enable all driver logs with log level MIF_D and provide the corresponding hexdump in dmesg logs. Bit 28 MENTRY PRINTM(MENTRY,\u0026hellip;), ENTER(), LEAVE() Set bit 28 to enable all driver logs with API entry and exit. Bit 29 MWARN PRINTM(MWARN,\u0026hellip;) Set bit 29 to enable all driver logs with log level MWARN. Bit 30 MINFO PRINTM(MINFO,\u0026hellip;) Set bit 30 to enable all driver logs with log level MINFO. 模块参数 drvdbg ，按位使能或者关闭特定的信息类型，例如 drvdbg=0x6 ，表示只打开 MFATAL 和 MERROR 类型的调试信息。加载驱动后，可以在 /sys/ 文件系统中查看这个参数的值：\n~# cat /sys/module/moal/parameters/drvdbg 519 这个参数不能在驱动配置文件中设置，只能通过 /proc 文件系统修改，例如关闭 MMSG 信息：\n~# echo \u0026#34;drvdbg=518\u0026#34; \u0026gt;\u0026gt; /proc/mwlan/adapter0/uap0/debug ~# cat /sys/module/moal/parameters/drvdbg 518 3. STA 模式 #使用 STA 模式可以让 Wi-Fi 模块连接 Wi-Fi 热点。\n3.1 连接 #首先使用 iw 扫描热点：\n~# iw dev mlan0 scan BSS 60:3a:7c:63:c2:86(on mlan0) TSF: 1394835875 usec (0d, 00:23:14) freq: 2412 beacon interval: 100 TUs capability: ESS Privacy ShortSlotTime RadioMeasure (0x1411) signal: -29.00 dBm last seen: 4 ms ago SSID: TP-LINK_5G_C286 Supported rates: 1.0* 2.0* 5.5* 11.0* 9.0 18.0 36.0 54.0 DS Parameter set: channel 1 ERP: Use_Protection Barker_Preamble_Mode Extended supported rates: 6.0 12.0 24.0 48.0 WPA: * Version: 1 * Group cipher: CCMP * Pairwise ciphers: CCMP * Authentication suites: PSK RSN: * Version: 1 * Group cipher: CCMP * Pairwise ciphers: CCMP * Authentication suites: PSK * Capabilities: 1-PTKSA-RC 1-GTKSA-RC (0x0000) 新建一个 wpa_supplicant 的配置文件 /etc/wpa_supplicant/wpa_supplicant-mlan0.conf，内容如下：\nctrl_interface=/var/run/wpa_supplicant ctrl_interface_group=wheel update_config=1 设置 Wi-Fi 热点的名称和密码：\nwpa_passphrase \u0026lt;ESSID\u0026gt; \u0026lt;PASSWORD\u0026gt; \u0026gt;\u0026gt; /etc/wpa_supplicant/wpa_supplicant-mlan0.conf 手动执行 wpa_supplicant ：\n~# wpa_supplicant -i mlan0 -Dnl80211 -c /etc/wpa_supplicant/wpa_supplicant-mlan0.conf -B 或者使用 systemd 连接：\n~# systemctl start wpa_supplicant@mlan0 如果连接成功，内核会打印如下信息：\n[ 1657.514313] wlan: mlan0 START SCAN [ 1661.922914] wlan: SCAN COMPLETED: scanned AP count=17 [ 1661.957185] wlan: Connected to bssid 60:XX:XX:XX:c2:88 successfully [ 1662.062877] mlan0: [ 1662.062888] wlan: Send EAPOL pkt to 60:XX:XX:XX:c2:88 [ 1662.072089] mlan0: [ 1662.072092] wlan: Send EAPOL pkt to 60:XX:XX:XX:c2:88 [ 1662.080127] IPv6: ADDRCONF(NETDEV_CHANGE): mlan0: link becomes ready [ 1662.087172] woal_cfg80211_set_rekey_data return: gtk_rekey_offload is DISABLE 驱动信息里可以看到连接成功：\n~# more /proc/mwlan/adapter0/mlan0/info driver_name = \u0026#34;wlan\u0026#34; driver_version = PCIE8997--16.92.10.p213-MM5X16247.p5-GPL-(FP92) interface_name=\u0026#34;mlan0\u0026#34; firmware_major_version=16.92.10 bss_mode =\u0026#34;Managed\u0026#34; media_state=\u0026#34;Connected\u0026#34; mac_address=\u0026#34;d8:c0:a6:6e:8f:7d\u0026#34; multicast_count=\u0026#34;10\u0026#34; essid=\u0026#34;TP-LINK_5G_C286\u0026#34; bssid=\u0026#34;60:3a:7c:63:c2:88\u0026#34; channel=\u0026#34;157\u0026#34; 启动 wpa_supplicant 后，可以用 wpa_cli 命令调试 Wi-Fi 连接，比如查看连接状态：\n~# wpa_cli -i mlan0 status bssid=60:3a:7c:63:c2:88 freq=5785 ssid=TP-LINK_5G_C286 id=1 mode=station pairwise_cipher=CCMP group_cipher=CCMP key_mgmt=WPA2-PSK wpa_state=COMPLETED p2p_device_address=d8:c0:a6:6e:8f:7d address=d8:c0:a6:6e:8f:7d uuid=15f39fc6-08ec-59cd-82d8-8991c864b6c3 ieee80211ac=1 使用 iw 可以看到更底层的状态数据：\n~# iw dev mlan0 info Interface mlan0 ifindex 3 wdev 0x1 addr d8:c0:a6:6e:8f:7d ssid TP-LINK_5G_C286 type managed wiphy 0 channel 157 (5785 MHz), width: 80 MHz, center1: 5775 MHz txpower 24.00 dBm ~# iw dev mlan0 link Connected to 60:3a:7c:63:c2:88 (on mlan0) SSID: TP-LINK_5G_C286 freq: 5785 RX: 111781 bytes (1487 packets) TX: 44737 bytes (734 packets) signal: -37 dBm rx bitrate: 6.0 MBit/s tx bitrate: 702.0 MBit/s VHT-MCS 8 80MHz VHT-NSS 2 bss flags: dtim period: 1 beacon int: 100 3.2 获取 IP #连接成成功后，还需要通过 DHCP 获得 IP 。可以用 udhcpc 命令获取 IP ：\n~# udhcpc -i mlan0 -b udhcpc: started, v1.31.0 udhcpc: sending discover udhcpc: sending select for 192.168.1.103 udhcpc: lease of 192.168.1.103 obtained, lease time 7200 /etc/udhcpc.d/50default: Adding DNS 192.168.0.99 /etc/udhcpc.d/50default: Adding DNS 223.5.5.5 如果系统支持 systemd-networkd 服务管理网卡，也可以在 /etc/systemd/network/ 目录下新建一个网卡的配置文件 12-mlan0.network ，内容如下：\n[Match] Name=mlan0 [Network] DHCP=yes 然后重启服务：\n~# systemctl restart systemd-networkd 可以看到网卡成功获取 IP ：\n~# ifconfig lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:82 errors:0 dropped:0 overruns:0 frame:0 TX packets:82 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:6220 (6.0 KiB) TX bytes:6220 (6.0 KiB) mlan0 Link encap:Ethernet HWaddr d8:c0:a6:6e:8f:7d inet addr:192.168.1.103 Bcast:192.168.1.255 Mask:255.255.255.0 inet6 addr: fe80::dac0:a6ff:fe6e:8f7d/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:17 errors:0 dropped:0 overruns:0 frame:0 TX packets:45 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:3261 (3.1 KiB) TX bytes:5822 (5.6 KiB) 3.3 使用 wpa_cli #配置文件的 ctrl_interface 选项指定了 socket 文件（/var/run/wpa_supplicant），wpa_supplicant 启动后，可以使用 wpa_cli 与 wpa_supplicant 通讯，调试和维护 Wi-Fi 连接。\n扫描热点，然后打印扫描结果：\n~# wpa_cli -i mlan0 scan ~# wpa_cli -i mlan0 scan_result 效果如下：\n向 wpa_supplicant 添加一个网络连接：\n~# wpa_cli -i mlan0 add_network 2 该命令会返回一个新的网络 ID 号，如果 wpa_supplicant.conf 文件为空，则返回 0 ，表示第一个网络连接。因为已经有两个连接，所以返回了 2 ：\n~# wpa_cli -i mlan0 list_network network id / ssid / bssid / flags 0 TP-LINK_C286 any 1 TP-LINK_5G_C286 any [CURRENT] 2 any [DISABLED] 然后向这个网络连接添加一个 Wi-Fi 热点的配置：\n~# wpa_cli -i mlan0 set_network 2 ssid \u0026#39;\u0026#34;Shaocheng\u0026#34;\u0026#39; OK ~# wpa_cli -i mlan0 set_network 2 psk \u0026#39;\u0026#34;1234567890\u0026#34;\u0026#39; OK 如果是没有密码的 Wi-Fi 热点，按如下设置：\nwpa_cli -i mlan0 set_network 2 key_mgmt NONE 如果要修改密码可以执行：\nwpa_cli -i mlan0 set_network 2 key_mgmt NONE 设置网络优先级，数值越大，优先级越高：\n~# wpa_cli -i mlan0 set_network 2 priority 2 OK 设置 scan_ssid 为 1 ，表示扫描这个 SSID ，如果为 0 ，表示忽略这个 SSID：\n~# wpa_cli -i mlan0 set_network 2 scan_ssid 1 OK 使能这个网络：\n~# wpa_cli -i mlan0 enable_network 2 OK 选中这个网络连接后，开始连接：\n~# wpa_cli -i mlan0 select_network 2 OK 当前连接的网络变为 ID 2 ：\n~# wpa_cli -i mlan0 list_network network id / ssid / bssid / flags 0 TP-LINK_C286 any [DISABLED] 1 TP-LINK_5G_C286 any [DISABLED] 2 Shaocheng any [CURRENT] 连接成功后，还需要重新获取 IP :\n~# udhcpc -i mlan0 -b -q udhcpc: started, v1.31.0 udhcpc: sending discover udhcpc: sending select for 172.20.10.9 udhcpc: lease of 172.20.10.9 obtained, lease time 86400 /etc/udhcpc.d/50default: Adding DNS 172.20.10.1 调试成功后，可以将当前的网络配置保存到配置文件：\n~# wpa_cli -i mlan0 save_config OK 想要断开热点时可以执行如下命令：\nwpa_cli -i mlan0 disable_network 2 //与 ID 2 的网络进行断开 wpa_cli -i mlan0 remove_network 2 //将 ID 2 的网络移除掉,必须先断开才行 wpa_cli -i mlan0 save_config //更新配置文件 如果直接执行 wpa_cli ，不带参数，会进入交互模式，执行 help 查看所有指令，方便调试。\n4. AP 模式 #使用 AP 模式可以将 Wi-Fi 模块作为热点，AP 模式的接口是 uap0 ，需要先设置一个静态 IP ：\nifconfig uap0 172.31.255.1 netmask 255.255.255.0 up 4.1 启动 hostapd #新建 /etc/hostapd-uap0.conf 文件，添加 WPA/WPA2-PSK 认证方式的配置选项，内容如下：\nctrl_interface=/var/run/hostapd interface=uap0 driver=nl80211 ieee80211n=1 country_code=CN ssid=NXP_AP hw_mode=a channel=0 macaddr_acl=0 auth_algs=1 ignore_broadcast_ssid=0 wpa=3 wpa_passphrase=12345678 wpa_key_mgmt=WPA-PSK wpa_pairwise=TKIP rsn_pairwise=CCMP 启动 hostapd ：\n~# hostapd /etc/hostapd-uap0.conf -B 启动过程中，内核会打印如下信息：\n[ 100.479639] wlan: SCAN COMPLETED: scanned AP count=5 [ 100.872225] wlan: SCAN COMPLETED: scanned AP count=6 [ 101.264337] wlan: SCAN COMPLETED: scanned AP count=3 [ 101.661716] wlan: SCAN COMPLETED: scanned AP count=1 [ 102.056751] wlan: SCAN COMPLETED: scanned AP count=4 [ 102.093045] wlan: Starting AP [ 102.096548] Get ht_cap from beacon ies: 0xc [ 102.101107] fw doesn\u0026#39;t support 11ax [ 102.114610] wlan: AP started [ 102.117540] IPv6: ADDRCONF(NETDEV_CHANGE): uap0: link becomes ready [ 102.125433] Set AC=3, txop=47 cwmin=3, cwmax=7 aifs=1 [ 102.132663] Set AC=2, txop=94 cwmin=7, cwmax=15 aifs=1 [ 102.139977] Set AC=0, txop=0 cwmin=15, cwmax=63 aifs=3 [ 102.147327] Set AC=1, txop=0 cwmin=15, cwmax=1023 aifs=7 启动成功后，用 hostapd_cli 查看状态：\n~# hostapd_cli -i uap0 status state=ENABLED phy=mwiphy0 freq=5180 num_sta_non_erp=0 num_sta_no_short_slot_time=0 num_sta_no_short_preamble=0 olbc=0 num_sta_ht_no_gf=0 num_sta_no_ht=0 num_sta_ht_20_mhz=0 num_sta_ht40_intolerant=0 olbc_ht=0 ht_op_mode=0x0 cac_time_seconds=0 cac_time_left_seconds=N/A channel=36 secondary_channel=0 ieee80211n=1 ieee80211ac=0 ieee80211ax=0 beacon_int=100 dtim_period=2 ht_caps_info=000c ht_mcs_bitmask=ffff0000010000000000 supported_rates=0c 12 18 24 30 48 60 6c max_txpower=23 bss[0]=uap0 bssid[0]=d8:c0:a6:6e:90:7d ssid[0]=NXP_AP num_sta[0]=0 此时，用手机可以搜到名为 NXP_AP 的热点，密码 12345678，可以连接，但是无法获取 IP ，因为本机没有提供 DHCP 服务。\n4.2 分配 IP #可以使用 udhcpd 启动 DHCP 服务，想 Wi-Fi 终端分配 IP。新建配置文件 /etc/udhcpd-uap0.conf ，内容如下：\ninterface uap0 start 192.168.1.100 end 192.168.1.199 remaining yes lease_file\t/var/lib/misc/udhcpd.leases 启动 udhcpd ：\n~# udhcpd /etc/udhcpd-uap0.conf 用手机重新连接，可以获得 IP 。用 hostapd_cli 可以列出已连接的 STA 设备：\n~# hostapd_cli -i uap0 list_sta ce:53:7d:79:65:a5 udhcpd 是 busybox 提供的 DHCP Server ，如果对功能和稳定性有要求，可以使用 dnsmasq 。\n4.3 使用 hostapd_cli #配置文件的 ctrl_interface 选项指定了 socket 文件（/var/run/hostapd），hostapd 启动后，可以使用 hostapd_cli 与 hostapd 通讯，调试和维护 hostapd 。\n列出所有 STA 的详细信息：\n~# hostapd_cli -i uap0 all_sta ce:53:7d:79:65:a5 flags=[AUTH][ASSOC][AUTHORIZED] aid=0 capability=0x0 listen_interval=0 supported_rates=0c 18 30 timeout_next=NULLFUNC POLL dot11RSNAStatsSTAAddress=ce:53:7d:79:65:a5 dot11RSNAStatsVersion=1 dot11RSNAStatsSelectedPairwiseCipher=00-0f-ac-4 dot11RSNAStatsTKIPLocalMICFailures=0 dot11RSNAStatsTKIPRemoteMICFailures=0 wpa=2 AKMSuiteSelector=00-0f-ac-2 hostapdWPAPTKState=11 hostapdWPAPTKGroupState=0 rx_packets=83 tx_packets=18 rx_bytes=9712 tx_bytes=2031 inactive_msec=0 signal=-56 rx_rate_info=0 tx_rate_info=0 connected_time=515 4.4 udhcpd.leases #因为配置文件中设置了 lease_file 选项，有 STA 设备接入热点后，在 /var/lib/misc/ 目录下就会生成一个 udhcpd.leases 文件，这是一个二进制文件，记录了所有接入设备的信息：\n~# hexdump -C /var/lib/misc/udhcpd.leases 00000000 00 00 00 00 60 e3 d2 49 00 0d 2e cc ac 1f ff 64 |....`..I.......d| 00000010 ce 53 7d 79 65 a5 00 00 00 00 00 00 00 00 00 00 |.S}ye...........| 00000020 00 00 00 00 00 00 00 00 00 00 00 00 |............| 0000002c 文件的前 8 个字节为本文件的修改时间，0x60e3d249 转换为整数是1,625,543,241，就是 2021-07-06 11:47:21 ，每当有新的 sta 接入，或者 auto_time 到时（默认 7200 秒），该文件就会更新。从第9个字节开始就是 struct dyn_lease 的内容:\ntypedef uint32_t leasetime_t; struct dyn_lease { /* \u0026#34;nip\u0026#34;: IP in network order */ /* Unix time when lease expires. Kept in memory in host order. * When written to file, converted to network order * and adjusted (current time subtracted) */ leasetime_t expires; uint32_t lease_nip; /* We use lease_mac[6], since e.g. ARP probing uses * only 6 first bytes anyway. We check received dhcp packets * that their hlen == 6 and thus chaddr has only 6 significant bytes * (dhcp packet has chaddr[16], not [6]) */ uint8_t lease_mac[6]; char hostname[20]; uint8_t pad[2]; /* total size is a multiply of 4 */ }； 该结构体的大小为 36 个字节，当有新的 sta 接入热点时，会向 udhcpd.leases 增加 36 字节的信息，后面接入的 sta 会放在文件的前面，但是当 sta 离开时，不会把该 sta 的信息删除。\n注意，这个文件并不稳定，不能保证及时更新。\n5. 参考 #wpa_supplicant ：\n官网：https://w1.fi/wpa_supplicant/\n配置文件：https://w1.fi/cgit/hostap/plain/wpa_supplicant/wpa_supplicant.conf\nhostapd：\n官网：https://w1.fi/hostapd/\n配置文件：https://w1.fi/cgit/hostap/plain/hostapd/hostapd.conf\nudhcp：\n官网：https://udhcp.busybox.net/ udhcpd：https://udhcp.busybox.net/README.udhcpd udhcpd.conf：https://udhcp.busybox.net/udhcpd.conf udhcpc：https://udhcp.busybox.net/README.udhcpc ","date":"2022 February 1","permalink":"/posts/2022/02/01/","section":"Posts","summary":"1. 概述 #硬件平台使用 iMX8MM 参考开发板，带有 M.","title":"在 iMX8MM 平台调试 AW-CM276MA Wi-Fi 模块"},{"content":"netdevice 是 glibc 提供的访问网卡设备的低级接口，支持标准 ioctl 函数，需要的头文件是：\n#include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;net/if.h\u0026gt; 使用方法是调用 ioctl 函数访问 socket 文件，基本语法是：\nioctl(int fd, int request, struct ifreq *); int fd 应该是一个 socket 文件描述符，主要通过 struct ifreq 结构传递数据：\nstruct ifreq { char ifr_name[IFNAMSIZ]; /* Interface name */ union { struct sockaddr ifr_addr; // IP 地址 struct sockaddr ifr_dstaddr; struct sockaddr ifr_broadaddr; // 广播地址 struct sockaddr ifr_netmask; // 子网掩码 struct sockaddr ifr_hwaddr; // MAC 地址 short ifr_flags; int ifr_ifindex; int ifr_metric; int ifr_mtu; struct ifmap ifr_map; char ifr_slave[IFNAMSIZ]; char ifr_newname[IFNAMSIZ]; char *ifr_data; }; }; 使用方法：\n新建一个 AF_INET 地址的 socket 文件 新建一个 struct ifreq 结构，并设置 ifr_name 为指定的网卡名称，例如 eth0 调用 ioctl ，通过 request 指定要访问的信息，通过 struct ifreq 结构传递数据 解析 struct ifreq 结构。 支持的 request 包括：\nSIOCGIFFLAGS, SIOCSIFFLAGS ：获取、设置网卡的 Flag ，通过 ifreq-\u0026gt;ifr_flags 传递数据，ifr_flags 包含一个由以下数值组成的位掩码。\nIFF_UP Interface is running. IFF_BROADCAST Valid broadcast address set. IFF_DEBUG Internal debugging flag. IFF_LOOPBACK Interface is a loopback interface. IFF_POINTOPOINT Interface is a point-to-point link. IFF_RUNNING Resources allocated. IFF_NOARP No arp protocol, L2 destination address not set. IFF_PROMISC Interface is in promiscuous mode. IFF_NOTRAILERS Avoid use of trailers. IFF_ALLMULTI Receive all multicast packets. IFF_MASTER Master of a load balancing bundle. IFF_SLAVE Slave of a load balancing bundle. IFF_MULTICAST Supports multicast IFF_PORTSEL Is able to select media type via ifmap. IFF_AUTOMEDIA Auto media selection active. IFF_DYNAMIC The addresses are lost when the interface goes down. SIOCGIFADDR, SIOCSIFADDR, SIOCDIFADDR ：获取、设置和删除网卡的 IP ，通过 ifreq-\u0026gt;ifr_addr 传递数据\nSIOCGIFNETMASK, SIOCSIFNETMASK ：获取、设置子网掩码，通过 ifreq-\u0026gt;ifr_netmask 传递数据\nSIOCGIFBRDADDR, SIOCSIFBRDADDR ：获取、设置广播地址，通过 ifreq-\u0026gt;ifr_broadaddr 传递数据\nSIOCGIFHWADDR, SIOCSIFHWADDR ：获取、设置 MAC 地址，通过 ifreq-\u0026gt;ifr_hwaddr 传递数据\nSIOCGIFMTU, SIOCSIFMTU ：获取、设置 MTU ，通过 ifreq-\u0026gt;ifr_mtu 传递数据\n例如 SIOCGIFADDR 可以获得 IP 地址：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;net/if.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; int main() { int fd; struct ifreq ifr; struct in_addr addr; // 1. 新建一个 socket fd = socket(AF_INET, SOCK_DGRAM, 0); // 2. 设置网卡名称 strncpy(ifr.ifr_name, \u0026#34;enp3s0\u0026#34;, IFNAMSIZ - 1); // 3. 读取指定网卡的 IP ioctl(fd, SIOCGIFADDR, \u0026amp;ifr); // 4. IP 存放在 ifr.ifr_addr 里 addr = ((struct sockaddr_in *)\u0026amp;ifr.ifr_addr)-\u0026gt;sin_addr; // 5. 转换格式，并打印 printf(\u0026#34;ip address is : %s \u0026lt;%08x\u0026gt;\\n\u0026#34;, inet_ntoa(addr), addr.s_addr); close(fd); } 编译和执行：\n~# gcc test.c -o test ~# ./test ip address is : 172.16.1.1 \u0026lt;010110ac\u0026gt; 一个完整的例程：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;net/if.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; struct ifinfo_t { struct in_addr addr; // IP 地址 struct in_addr netmask; // 子网掩码 struct in_addr broadaddr; // 广播地址 struct in_addr net; // 网段 unsigned char hwaddr[6]; // MAC 地址 int netmask_len; // 十进制格式的子网掩码 }; // 获得指定网卡的 IP 信息 int getifinfo(const char *ifname, struct ifinfo_t *ifinfo) { int fd; int i; int len; unsigned int netmask = 0; struct ifreq ifr; fd = socket(AF_INET, SOCK_DGRAM, 0); strncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1); ioctl(fd, SIOCGIFADDR, \u0026amp;ifr); ifinfo-\u0026gt;addr = ((struct sockaddr_in *)\u0026amp;ifr.ifr_addr)-\u0026gt;sin_addr; ioctl(fd, SIOCGIFNETMASK, \u0026amp;ifr); ifinfo-\u0026gt;netmask = ((struct sockaddr_in *)\u0026amp;ifr.ifr_netmask)-\u0026gt;sin_addr; ioctl(fd, SIOCGIFBRDADDR, \u0026amp;ifr); ifinfo-\u0026gt;broadaddr = ((struct sockaddr_in *)\u0026amp;ifr.ifr_broadaddr)-\u0026gt;sin_addr; ioctl(fd, SIOCGIFHWADDR, \u0026amp;ifr); memcpy(ifinfo-\u0026gt;hwaddr, ifr.ifr_hwaddr.sa_data, 6); netmask = ifinfo-\u0026gt;netmask.s_addr; len = 0; for (i = 0; i \u0026lt; 32; i++) { if (netmask \u0026amp; 0x00000001) len++; netmask = netmask \u0026gt;\u0026gt; 1; } ifinfo-\u0026gt;netmask_len = len; ifinfo-\u0026gt;net.s_addr = ifinfo-\u0026gt;addr.s_addr \u0026amp; ifinfo-\u0026gt;netmask.s_addr; close(fd); return 0; } //判断两个 ip 是否属于同一子网 int issamenet(struct in_addr *addr_1, struct in_addr *addr_2, struct in_addr *netmask) { return (addr_1-\u0026gt;s_addr \u0026amp; netmask-\u0026gt;s_addr) == (addr_2-\u0026gt;s_addr \u0026amp; netmask-\u0026gt;s_addr); } int main() { struct ifinfo_t ifinfo; getifinfo(\u0026#34;enp3s0\u0026#34;, \u0026amp;ifinfo); printf(\u0026#34;address : \u0026lt;%08x\u0026gt; %s\\n\u0026#34;, ifinfo.addr.s_addr, inet_ntoa(ifinfo.addr)); printf(\u0026#34;netmask : \u0026lt;%08x\u0026gt; %s\\n\u0026#34;, ifinfo.netmask.s_addr, inet_ntoa(ifinfo.netmask)); printf(\u0026#34;hwaddr : %02x:%02x:%02x:%02x:%02x:%02x\\n\u0026#34;, ifinfo.hwaddr[0],ifinfo.hwaddr[1],ifinfo.hwaddr[2],ifinfo.hwaddr[3],ifinfo.hwaddr[4],ifinfo.hwaddr[5]); printf(\u0026#34;broadaddr : \u0026lt;%08x\u0026gt; %s\\n\u0026#34;, ifinfo.broadaddr.s_addr, inet_ntoa(ifinfo.broadaddr)); printf(\u0026#34;net : \u0026lt;%08x\u0026gt; %s\\n\u0026#34;, ifinfo.net.s_addr, inet_ntoa(ifinfo.net)); printf(\u0026#34;netmask_len : %d\\n\u0026#34;, ifinfo.netmask_len); // 判断两个 IP 是否属于同一个子网 struct in_addr addr_1; struct in_addr addr_2; struct in_addr netmask; int ret = 0; addr_1.s_addr = inet_addr(\u0026#34;172.16.144.138\u0026#34;); addr_2.s_addr = inet_addr(\u0026#34;172.16.144.1\u0026#34;); netmask.s_addr = inet_addr(\u0026#34;255.255.255.240\u0026#34;); ret = issamenet(\u0026amp;addr_1, \u0026amp;addr_2, \u0026amp;netmask); printf(\u0026#34;ret is %d\\n\u0026#34;, ret); return 0; } 编译和执行：\n~# gcc test.c -o test ~# ./test address : \u0026lt;010110ac\u0026gt; 172.16.1.1 netmask : \u0026lt;00ffffff\u0026gt; 255.255.255.0 hwaddr : 00:1d:f3:52:99:0c broadaddr : \u0026lt;ff0110ac\u0026gt; 172.16.1.255 net : \u0026lt;000110ac\u0026gt; 172.16.1.0 netmask_len : 24 ret is 0 参考：\nhttps://man7.org/linux/man-pages/man7/netdevice.7.html\nhttp://www.microhowto.info/howto/get_the_ip_address_of_a_network_interface_in_c_using_siocgifaddr.html\n","date":"2021 October 26","permalink":"/posts/2021/10/26/","section":"Posts","summary":"netdevice 是 glibc 提供的访问网卡设备的低级接口，支持标准 ioctl 函数，需要的头文件是：","title":"Linux 下使用 ioctl 接口访问指定网卡"},{"content":"Fuse 就是熔丝位，是一种只能写入一次的寄存器，写入后不可更改，所以写入操作也叫做烧毁（burned）。iMX8MM 的 Fuse 由 on-chip eFuse OTP 控制读写，简称 OCOPT ，结构框图如下：\n可以通过 APB 接口读写 OCOTP 的寄存器，寄存器的布局可以在芯片手册的 《6.3.4 OCOTP Memory Map/Register Definition》中查看，起始地址是 0x30350000，分为两个部分，前半部分 0x30350000~0x3035009C 是 OCOTP Control Register ，是配置 OCOTP 本身的寄存器：\n从 0x30350400 到 0x303507B0 是 Shadow Regs 寄存器：\n在硬件上，Shadow Regs 和 Fuse 是两个独立的存储设备，但是 OCOTP 的内部机制实现了二者之间的映射，Fuse 的所有内容都被映射到了这段寄存器中，完整的映射如下：\n总大小是 4x256 bytes，大部分是保留状态，不可读写。需要注意的是，在 Fuse 中，32bits 组成一个 Word ，4Words 组成一个 Bank ，读写时也要用 Bank:Word 的格式寻址。可以在 u-boot 中执行 fuse 命令读写 fuse ，语法如下：\nfuse - Fuse sub-system Usage: fuse read \u0026lt;bank\u0026gt; \u0026lt;word\u0026gt; [\u0026lt;cnt\u0026gt;] - read 1 or \u0026#39;cnt\u0026#39; fuse words, starting at \u0026#39;word\u0026#39; fuse sense \u0026lt;bank\u0026gt; \u0026lt;word\u0026gt; [\u0026lt;cnt\u0026gt;] - sense 1 or \u0026#39;cnt\u0026#39; fuse words, starting at \u0026#39;word\u0026#39; fuse prog [-y] \u0026lt;bank\u0026gt; \u0026lt;word\u0026gt; \u0026lt;hexval\u0026gt; [\u0026lt;hexval\u0026gt;...] - program 1 or several fuse words, starting at \u0026#39;word\u0026#39; (PERMANENT) fuse override \u0026lt;bank\u0026gt; \u0026lt;word\u0026gt; \u0026lt;hexval\u0026gt; [\u0026lt;hexval\u0026gt;...] - override 1 or several fuse words, starting at \u0026#39;word\u0026#39; read - 读取，表示从 Shadow Regs 中读取。 sense - 感应，表示跳过 Shadow Regs ，直接从 Fuse 中读取。 prog - 烧毁，表示直接烧写 Fuse ，写入一次后就无法更改。 override - 改写，表示修改 Shadow Regs 中的值，不会影响到 Fuse ，所以，在这个操作之后，Shadow Regs 可能与 Fuse 中的值不同。 第一个寄存器（Bank0，Word0）是 OCOTP_LOCK ：\n它的作用是设置其他 fuse 寄存器的锁定状态，例如，Bit[1:0] 用于设置 Tester 寄存器的锁定状态，Bit[10] 用于设置 SJC 寄存器的锁定状态：\n支持五种锁定状态：\nUnlock - 受控字段可以在 Shadow Regs 中被读取、感应、烧毁或改写。 Lock - 受控字段不能被读取、烧毁或改写。 OP - override protect，受控字段可以在 Shadow Regs 中被读取、感应或烧毁。 WP - write protect，受控字段可以在 Shadow Regs 中被读取、感应或改写。 OP+WP - 受控字段只能在 Shadow Regs 中被读取或感应到，但是不能被烧毁或改写。 这个寄存器在芯片出厂时已经被写入了特定的值，无法更改，可以读取查看：\nu-boot=\u0026gt; fuse sense 0 0 Sensing bank 0: Word 0x00000000: feafa9eb 几个关键的字段：\nBit[1:0] TESTER_LOCK = 11，所有 TESTER 寄存器只读 Bit[3:2] BOOT_CFG_LOCK = 10，所有 BOOT_CFG 寄存器可读可烧毁，不可改写。 Bit[15:14] MAC_ADDR_LOCK= 10，所有 MAC_ADDR 寄存器可读可烧毁，不可改写。 存储 MAC 地址是 Fuse 的重要用途，默认情况下，以太网驱动获得 MAC 地址的顺序是：\n从设备树的以太网节点属性 \u0026ldquo;local-mac-address\u0026rdquo; 中获取 MAC 地址。 如果设备树没有这个属性，驱动就从 fuse 中获取 MAC 地址。 如果 fuse 没有烧写 MAC 地址，驱动从 u-boot 设置的环境变量中获得MAC地址。 如果不存在合法的MAC地址，会发生错误。 Fuse 用了三个 Word（Bank9 Word0~2）存储以太网卡的 MAC 地址，可以存储两个 MAC 地址：\niMX8MM 本身只要一个以太网卡，占用了 FEC1_MAC 的位置，例如 MAC 地址为 00-04-9F-05-FB-39 时：\nu-boot=\u0026gt; fuse read 9 0 4 Reading bank 9: Word 0x00000000: 9f05fb39 00000004 00000000 00000000 因为 Fuse 只能烧写一次，所有最好一次烧写两个 MAC 地址，防止日后增加网卡时无法烧写。假设要烧写的两个地址是：\nFEC1: 001DF3513075 FEC2: 001DF3513089 在u-boot 中执行如下命令：\nfuse prog 9 2 001DF351 fuse prog 9 1 3089001D fuse prog 9 0 F3513075 启动后：\nroot@imx8mmevk:~# ifconfig eth0 Link encap:Ethernet HWaddr 00:1d:f3:51:30:75 UP BROADCAST MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) 批量生产时，用 uuu 烧写更方便，下面是一个脚本的实例：\nSDP: boot -f imx-boot FB: ucmd fuse prog 9 2 -y 001DF351 FB: ucmd fuse prog 9 1 -y 3089001D FB: ucmd fuse prog 9 0 -y F3513075 参考：\nUnderstanding how to burn eFuses on i.MX8 and i.MX8x families i.MX8 uuu ","date":"2021 July 16","permalink":"/posts/2021/07/16/","section":"Posts","summary":"Fuse 就是熔丝位，是一种只能写入一次的寄存器，写入后不可更改，所以写入操作也叫做烧毁（burned）。iMX8MM 的 Fuse 由 on-chip eFuse OTP 控制读写，简称 OCOPT ，结构框图如下：","title":"iMX8MM 的 Fuse/OCOPT 学习笔记"},{"content":"1. iMX8MM 的启动流程 # iMX8MM 系统启动的详细流程可以参考 IMX8MMRM.pdf\n上电复位后，硬件复位逻辑迫使 SoC 从片上的 Boot ROM 开始执行，Boot ROM 使用 BOOT_MODE 和 eFUSEs 的状态来决定启动设备。在 POR_B 信号的上升沿采集两个外部输入引脚 BOOT_MODE0 和 BOOT_MODE1 的电平，用于设置启动模式：\nBOOT_MODE 的值可以在 SRC_SBMR2 寄存器的 IPP_BOOT_MODE[1:0] 中读到。在 Boot From Fuses 模式下，启动流程完全由 Fuse 控制，GPIO boot overrides 引脚的状态会被忽略。在 internal Boot 模式下，使用 Fuse 中的启动配置，但是为了开发方便，用于确定启动设备的 Fuse 可以通过 GPIO boot overrides 引脚的输入被覆盖，这时启动流程由 Fuse 或者 GPIO 控制的 BOOT_CFG 寄存器决定。首先会读取 BOOT_CFG[14:12] ，决定启动设备的类型：\n如果是从 eMMC/SD 启动，它们都使用 USDHC 接口与 SoC 连接，Boot ROM 会读取 BOOT_CFG[11:10] 的值，确定从哪个接口上的设备启动：\n对于 eMMC 设备，Boot ROM 会读取 ECSD[179]:PARTITION_CONFIG 寄存器的 BOOT_PARTITION_ENABLE 字段来确定从 eMMC 的哪个位置获得用户程序，例如 BootLoader 代码，然后将用户程序从 eMMC 读到内存，由用户程序引导系统启动。\n2. eMMC #eMMC 是一种可以管理的存储设备，与 SD 卡类似，它还支持单独的启动分区来存储 BootLoader 程序。以 eMMC5.0 为例，参考标准文件 JESD84-B50(eMMC-Spec-V5.0).pdf ，eMMC 的整体架构如下：\nSoC 作为主设备，通过 eMMC 控制模块向 eMMC 的设备管理接口发送指令和数据，各个信号的作用如下：\nCLK，用于同步的时钟信号。 Data Strobe，从 Device 端输出的时钟信号，频率必须和 CLK 相同，用于同步从 Device 端输出的数据。 eMMC 5.0 中引入。 CMD，此信号用于发送 Host 的 command 和 Device 的 response。 DATA0-7，用于传输数据的 8bit 总线。 eMMC 的设备管理器定义了六种寄存器：OCR、CID、CSD、ECSD、RCA 和 DSR，只能通过相应的命令访问，OCR、CID 和 CSD 寄存器携带有设备/内容的具体信息，而 RCA 和 DSR 寄存器是存储实际配置参数的配置寄存器，EXT_CSD 寄存器同时携带设备特定信息和实际配置参数，设备控制器还集成了 Flash 读写，坏块管理，ECC 校验等功能，下面是 Micron 8GB eMMC MTFC8GAKAJCN-1M WT 数据手册中的描述：\nFlash Memory 的最小读写单位是块（block），1 block = 512 Bytes 。eMMC 内部对 Flash Memory 划分了几个硬件分区：\nu-boot 和 Linux 都提供了相应的 mmc 命令来读写 eMMC 。在 u-boot 阶段，可以查看 eMMC 的信息：\nu-boot=\u0026gt; mmc list # 列出当前系统的 MMC 设备 FSL_SDHC: 1 FSL_SDHC: 2 (eMMC) u-boot=\u0026gt; mmc dev 2 # 切换到 2 号 eMMC 设备 u-boot=\u0026gt; mmc info # 打印当前 MMC 设备的信息 Device: FSL_SDHC Manufacturer ID: 13 # 厂商 ID OEM: 14e Name: Q2J55 Bus Speed: 200000000 # 总线速率 Mode: HS400 (200MHz) # 速率模式 Rd Block Len: 512 # block 的大小，单位是字节 MMC version 5.0 # eMMC 版本 High Capacity: Yes Capacity: 7.1 GiB # 容量 Bus Width: 8-bit DDR # 总线宽度 Erase Group Size: 512 KiB HC WP Group Size: 8 MiB User Capacity: 7.1 GiB WRREL # User Data Area Boot Capacity: 2 MiB ENH # Boot Area Partition RPMB Capacity: 4 MiB ENH # RPMB Partition Linux 系统启动后，可以看到：\nroot@imx8mmevk:~# ls -l /dev/mmcblk2* brw-rw---- 1 root disk 179, 0 Jul 6 03:33 /dev/mmcblk2 # User Data Area ，用户可以此基础上新建逻辑分区 brw-rw---- 1 root disk 179, 32 Jul 6 03:33 /dev/mmcblk2boot0 # Boot Area Partition 1 brw-rw---- 1 root disk 179, 64 Jul 6 03:33 /dev/mmcblk2boot1 # Boot Area Partition 2 brw-rw---- 1 root disk 179, 1 Jul 6 03:33 /dev/mmcblk2p1 # UDA 区域的逻辑分区，用于存放内核镜像和设备树 brw-rw---- 1 root disk 179, 2 Jul 6 03:33 /dev/mmcblk2p2 # UDA 区域的逻辑分区，用于存放根文件系统 crw------- 1 root root 237, 0 Jul 6 03:33 /dev/mmcblk2rpmb # RPMB Partition 内核启动信息中也会打印各分区的大小：\nroot@imx8mmevk:~# dmesg | grep mmcblk2 [ 0.000000] Kernel command line: console=ttymxc1,115200 root=/dev/mmcblk2p2 rootwait rw [ 1.986681] mmcblk2: mmc2:0001 Q2J55L 7.13 GiB [ 1.992485] mmcblk2boot0: mmc2:0001 Q2J55L partition 1 2.00 MiB [ 2.002296] mmcblk2boot1: mmc2:0001 Q2J55L partition 2 2.00 MiB [ 2.011031] mmcblk2rpmb: mmc2:0001 Q2J55L partition 3 4.00 MiB, chardev (237:0) 一般情况下，Boot Area Partitions 的大小都为 2MB 或者 4MB，部分芯片厂家也会提供配置的机会。RPMB 通常也是 4M ，用于保存安全相关的数据。General Purpose Partitions (GPP) 则在出厂时默认不被支持，即不存在这些分区，需要用户主动使能，并配置其所要使用的 GPP 的容量大小，GPP 的数量可以为 1 - 4 个，各个 GPP 的容量大小可以不一样。User Data Area (UDA) 的容量大小则为总容量大小减去其他分区所占用的容量。每一个硬件分区的存储空间都是独立编址的，即访问地址为 0 - partition size。具体的数据读写操作实际访问哪一个硬件分区，是由 ECSD[179] 的 PARTITION_CONFIG[2:0]:PARTITION_ACCESS 决定的，也就是说，用户在访问特定的分区前，需要先发送命令，配置 PARTITION_ACCESS，然后再发送相关的数据访问请求。PARTITION_CONFIG 寄存器的定义如下：\nBit 7: Reserved Bit 6: BOOT_ACK (R/W/E) 0x0 : No boot acknowledge sent (default) 0x1 : Boot acknowledge sent during boot operation Bit[5:3] : BOOT_PARTITION_ENABLE (R/W/E), User selects boot data that will be sent to master 0x0 : Device not boot enabled (default) 0x1 : Boot partition 1 enabled for boot 0x2 : Boot partition 2 enabled for boot 0x3–0x6 : Reserved 0x7 : User area enabled for boot Bit[2:0] : PARTITION_ACCESS (before BOOT_PARTITION_ACCESS, R/W/E_P), User selects partitions to access 0x0 : No access to boot partition (default) 0x1 : R/W boot partition 1 0x2 : R/W boot partition 2 0x3 : R/W Replay Protected Memory Block (RPMB) 0x4 : Access to General Purpose partition 1 0x5 : Access to General Purpose partition 2 0x6 : Access to General Purpose partition 3 0x7 : Access to General Purpose partition 4 如果要擦除 Boot Area Partition 1 可以执行如下命令\nu-boot=\u0026gt; mmc partconf 2 0 0 1 # 设置访问 boot partition 1 u-boot=\u0026gt; mmc erase 0 10 # 擦除 boot 分区的前十个 block u-boot=\u0026gt; mmc partconf 2 0 0 0 # 设置会默认值 这个寄存器的值也可以在 Linux 系统中读取：\nroot@imx8mmevk:~# mmc extcsd read /dev/mmcblk2 | grep PARTITION_CONFIG Boot configuration bytes [PARTITION_CONFIG: 0x08] 3. 启动和烧写 #BOOT Area Partition 主要是为了支持从 eMMC 启动系统而设计的。该分区的数据，在 eMMC 上电后，可以通过很简单的协议就可以读取出来。同时，大部分的 SoC 都可以通过 GPIO 或者 Fuse 的配置，让 Boot ROM 代码在上电后，将 BOOT Area Partition 分区的内容加载到 SoC 的内存中执行。Boot Area Partition 有两个，大小是完全一致的，大小由 ECSD 的 BOOT_SIZE_MULT 决定：\n大小的计算公式如下：\nSize = 128Kbytes x BOOT_SIZE_MULT 可以在 Linux 下读取这个寄存器的值：\nroot@imx8mmevk:~# mmc extcsd read /dev/mmcblk2 | grep BOOT_SIZE Boot partition size [BOOT_SIZE_MULTI: 0x10] # 0x10 表示 2MB 使用 NXP 提供的 uuu 工具，执行 uuu -b emmc imx-boot 向 eMMC 烧写 BootLoader 时，就是将 imx-boot 写入 BOOT Area Partition 1 ，并将 BOOT_PARTITION_ENABLE 设为 1 ，这样上电复位后，Boot ROM 代码就会把 BOOT Area Partition 1 中的代码加载的内存执行。\n这里需要注意，如果 BootLoader 文件的大小超出了 BOOT Area Partition 的大小，烧写时调试串口输出的信息信息：\nMMC write: dev # 2, block # 66, count 6550 ... MMC: block number 0x19d8 exceeds max(0x1000) 0 blocks written: ERROR Writing \u0026#39;bootloader\u0026#39; FAILED! 要解决这个问题，有两种方法：\n更换 Boot Area Partition 更大的 eMMC 将 BootLoader 文件写入 User Data Area 分区，设置从 User Data Area 分区启动。 从使用的角度，如果 eMMC 不使用 Boot Area Partition ，那么它就和 SD 卡基本一样，SD 卡没有独立的启动分区，需要在 SoC 规定的地址放入用户程序，SoC 从这个地址去加载启动。根据 iMX8MM 的要求，用户程序的第一个部分必须是一个镜像向量表 (IVT，位于 BootLoader 文件的头部) 数据结构，IVT 包含了执行成功启动所需的数据成分，包括程序镜像的入口点，设备配置数据（DCD）的指针以及启动过程中使用的其他指针。下面是对于不同存储介质的地址要求：\n对于 eMMC ，必须放 UDA 分区在 0x8400 地址，然后将 IVT 从 eMMC 读到内存，根据 IVT 中设置执行 BootLoader 的其他代码。IVT 的存储地址是用户程序中唯一要求固定地址的部分，用户程序的其余部分可以灵活布局，由 IVT 的内容决定。推荐如下布局，BootLoader 文件放置在 0x8400 地址，从 0xa00000 开始新建 FAT 和 Ext3 分区，放置内核、设备树和根文件系统：\n可以从 SD 卡启动一个 Linux 系统，然后对 eMMC 进行烧写。用 dd 命令烧写 BootLoader ：\nroot@imx8mmevk:~# dd if=./imx-boot of=/dev/mmcblk2 bs=1k seek=33 conv=fsync # dd 命令只会从 UDA 分区开始寻址，不会烧写到其他分区 如果编译 u-boot 时选择了 CONFIG_ENV_IS_IN_MMC ，u-boot 的环境变量会保存到 eMMC ，存储的位置由如下两个选项决定：\nCONFIG_ENV_OFFSET , Offset from the start of the device (or partition) CONFIG_ENV_SIZE , Size of the environment storage area . 烧写 u-boot 时，如果没有擦除这个区域，重启后的 u-boot 还会使用原来保存的环境变量。\nFAT 和 Ext3 分区可以用 fdisk 命令新建，然后将相关文件夹拷贝到分区中，最后将 BOOT_PARTITION_ENABLE 设为 0 或者 7 ，Boot ROM 就会从 UDA 分区启动：\nroot@imx8mmevk:~# mmc bootpart enable 7 0 /dev/mmcblk2 也可以在 u-boot 中设置：\nu-boot=\u0026gt; mmc partconf 2 0 7 0 写入后可以读出来确认一下：\nroot@imx8mmevk:~# mmc extcsd read /dev/mmcblk2 | grep PARTITION_CONFIG Boot configuration bytes [PARTITION_CONFIG: 0x38] 上面是手动写入系统镜像的步骤，NXP 提供的 UUU 工具可以使用串行下载模式，通过 USB OTG 接口从上位机执行自定义脚本对 eMMC 进行烧写，执行语法是 uuu \u0026lt;script file name\u0026gt; ，基本的原理和步骤是：\n使用 SDP 协议把一个 BootLoader 文件写入内存并启动。 内存中的 BootLoader 使用 FB 协议把一个临时 Linux 系统（包括内核、设备树和根文件系统）写入内存并启动。 内存中的临时系统通过 FBK 协议执行指令，烧写 BootLoader ，对 eMMC 格式化，然后把最终要运行的系统文件（包括内核、设备树和根文件系统等）复制到相应的分区 。 设置 BOOT_PARTITION_ENABLE 的值。 UUU 的使用方法可以在 https://github.com/NXPmicro/mfgtools/wiki 查看，下面是一个脚本实例：\nuuu_version 1.4.72 # 用于烧写 iMX8MM 的 eMMC ，从 User data area 启动 # tools 下的文件是临时系统 # imx-boot\t| BootLoader # Image-imx8mmevk.bin | kernel image, arm64 is Image, arm32 it is zImage # imx8mm-evk.dtb | board dtb file # fsl-image-mfgtool-initramfs-imx_mfgtools.cpio.gz.u-boot\t| mfgtool init ramfs # image 下的文件用于烧写到 eMMC # imx-boot\t| BootLoader # Image\t| kernel image, arm64 is Image, arm32 it is zImage # imx8mm-evk.dtb\t| board dtb file # rootfs.tar.bz2\t| rootfs # tee.bin\t| optee image, put dummy _uTee.tar file here if platform is not MX6/MX7* # 将 BootLoader 加载到内存并启动 # This command will be run when i.MX6/7 i.MX8MM, i.MX8MQ SDP: boot -f tools/imx-boot # This command will be run when ROM support stream mode # i.MX8QXP, i.MX8QM SDPS: boot -f tools/imx-boot # These commands will be run when use SPL and will be skipped if no spl # SDPU will be deprecated. please use SDPV instead of SDPU # { SDPU: delay 1000 SDPU: write -f tools/imx-boot -offset 0x57c00 SDPU: jump # } # These commands will be run when use SPL and will be skipped if no spl # if (SPL support SDPV) # { SDPV: delay 1000 SDPV: write -f tools/imx-boot -skipspl SDPV: jump SDPV: delay 1000 # } # 切换到 eMMC 设备 FB: ucmd setenv fastboot_dev mmc FB: ucmd setenv mmcdev ${emmc_dev} FB: ucmd mmc dev ${emmc_dev} # 配置在 eMMC 从用户分区启动 FB: ucmd if env exists emmc_ack; then ; else setenv emmc_ack 0; fi; FB: ucmd setenv emmc_cmd mmc partconf ${emmc_dev} ${emmc_ack} 7 0 FB: ucmd if test \u0026#34;${emmc_skip_fb}\u0026#34; != \u0026#34;yes\u0026#34;; then run emmc_cmd; fi # 加载内核、设备树、rootfs 到内存上，并启动 FB: ucmd setenv fastboot_buffer ${loadaddr} FB: download -f tools/Image FB: ucmd setenv fastboot_buffer ${fdt_addr} FB: download -f tools/imx8mm-evk.dtb FB: ucmd setenv fastboot_buffer ${initrd_addr} FB: download -f tools/fsl-image-mfgtool-initramfs-imx_mfgtools.cpio.gz.u-boot # FB: ucmd setenv bootargs console=${console},${baudrate} earlycon=${earlycon},${baudrate} FB: acmd ${kboot} ${loadaddr} ${initrd_addr} ${fdt_addr} # get mmc dev number from kernel command line # 等待启动完毕 FBK: ucmd while [ ! -e /dev/mmcblk*boot0 ]; do sleep 1; echo \u0026#34;wait for /dev/mmcblk*boot* appear\u0026#34;; done; # serach emmc device number, if your platform have more than two emmc chip, please echo dev number \u0026gt;/tmp/mmcdev FBK: ucmd dev=`ls /dev/mmcblk*boot*`; dev=($dev); dev=${dev[0]}; dev=${dev#/dev/mmcblk}; dev=${dev%boot*}; echo $dev \u0026gt; /tmp/mmcdev; # dd to clear the possible MBR FBK: ucmd mmc=`cat /tmp/mmcdev`; dd if=/dev/zero of=/dev/mmcblk${mmc} bs=512 count=1 # 新建分区 # 前面 10M 留给 BootLoader ，从 0xa00000Bytes 开始新建一个 500M 的 FAT 分区，从 600M 开始新建一个 ext3 分区 FBK: ucmd mmc=`cat /tmp/mmcdev`; PARTSTR=$\u0026#39;10M,500M,0c\\n600M,,83\\n\u0026#39;; echo \u0026#34;$PARTSTR\u0026#34; | sfdisk --force /dev/mmcblk${mmc} # 格式化 fat 分区并挂载 FBK: ucmd mmc=`cat /tmp/mmcdev`; while [ ! -e /dev/mmcblk${mmc}p1 ]; do sleep 1; done FBK: ucmd mmc=`cat /tmp/mmcdev`; mkfs.vfat /dev/mmcblk${mmc}p1 FBK: ucmd mmc=`cat /tmp/mmcdev`; mkdir -p /mnt/fat FBK: ucmd mmc=`cat /tmp/mmcdev`; mount -t vfat /dev/mmcblk${mmc}p1 /mnt/fat # 将 BootLoader 复制到 fat 分区，并写入 eMMC FBK: ucp image/imx-boot t:/mnt/fat FBK: ucmd mmc=`cat /tmp/mmcdev`; dd if=/mnt/fat/imx-boot of=/dev/mmcblk${mmc} bs=1k seek=33 conv=fsync # 将内核、设备树复制到 fat 分区 FBK: ucp image/fat/Image t:/mnt/fat FBK: ucp image/fat/imx8mm-evk.dtb t:/mnt/fat FBK: ucp image/fat/tee.bin t:/tmp/fat FBK: ucmd umount /mnt/fat # 格式化 ext3 分区 FBK: ucmd mmc=`cat /tmp/mmcdev`; mkfs.ext3 -F -E nodiscard /dev/mmcblk${mmc}p2 FBK: ucmd mkdir -p /mnt/ext3 FBK: ucmd mmc=`cat /tmp/mmcdev`; mount /dev/mmcblk${mmc}p2 /mnt/ext3 FBK: acmd export EXTRACT_UNSAFE_SYMLINKS=1; tar -jx -C /mnt/ext3 FBK: ucp image/rootfs.tar.bz2 t:- FBK: Sync FBK: ucmd umount /mnt/ext3 FBK: DONE 如果要从 boot partitions 1 启动，可以用下面的脚本：\nuuu_version 1.4.72 # 用于烧写 iMX8MM 的 eMMC ，从 boot 分区启动 # tools 下的文件是临时系统 # imx-boot\t| BootLoader # Image-imx8mmevk.bin | kernel image, arm64 is Image, arm32 it is zImage # imx8mm-evk.dtb | board dtb file # fsl-image-mfgtool-initramfs-imx_mfgtools.cpio.gz.u-boot\t| mfgtool init ramfs # image 下的文件用于烧写到 eMMC # imx-boot\t| BootLoader # Image\t| kernel image, arm64 is Image, arm32 it is zImage # imx8mm-evk.dtb\t| board dtb file # rootfs.tar.bz2\t| rootfs # tee.bin\t| optee image, put dummy _uTee.tar file here if platform is not MX6/MX7* # 将 BootLoader 加载到内存并启动 # This command will be run when i.MX6/7 i.MX8MM, i.MX8MQ SDP: boot -f tools/imx-boot # This command will be run when ROM support stream mode # i.MX8QXP, i.MX8QM SDPS: boot -f tools/imx-boot # These commands will be run when use SPL and will be skipped if no spl # SDPU will be deprecated. please use SDPV instead of SDPU # { SDPU: delay 1000 SDPU: write -f tools/imx-boot -offset 0x57c00 SDPU: jump # } # These commands will be run when use SPL and will be skipped if no spl # if (SPL support SDPV) # { SDPV: delay 1000 SDPV: write -f tools/imx-boot -skipspl SDPV: jump SDPV: delay 1000 # } # 将 BootLoader 烧入到 eMMC FB: ucmd setenv fastboot_dev mmc FB: ucmd setenv mmcdev ${emmc_dev} FB: flash bootloader image/imx-boot # 配置在 eMMC 引导分区 1 启动 FB: ucmd if env exists emmc_ack; then ; else setenv emmc_ack 0; fi; FB: ucmd setenv emmc_cmd mmc partconf ${emmc_dev} ${emmc_ack} 1 0 FB: ucmd if test \u0026#34;${emmc_skip_fb}\u0026#34; != \u0026#34;yes\u0026#34;; then run emmc_cmd; fi # 加载内核、设备树、rootfs 到内存上 FB: ucmd setenv fastboot_buffer ${loadaddr} FB: download -f tools/Image FB: ucmd setenv fastboot_buffer ${fdt_addr} FB: download -f tools/imx8mm-evk.dtb FB: ucmd setenv fastboot_buffer ${initrd_addr} FB: download -f tools/fsl-image-mfgtool-initramfs-imx_mfgtools.cpio.gz.u-boot #FB: ucmd setenv bootargs console=${console},${baudrate} earlycon=${earlycon},${baudrate} FB: acmd ${kboot} ${loadaddr} ${initrd_addr} ${fdt_addr} # get mmc dev number from kernel command line # Wait for emmc FBK: ucmd while [ ! -e /dev/mmcblk*boot0 ]; do sleep 1; echo \u0026#34;wait for /dev/mmcblk*boot* appear\u0026#34;; done; # serach emmc device number, if your platform have more than two emmc chip, please echo dev number \u0026gt;/tmp/mmcdev FBK: ucmd dev=`ls /dev/mmcblk*boot*`; dev=($dev); dev=${dev[0]}; dev=${dev#/dev/mmcblk}; dev=${dev%boot*}; echo $dev \u0026gt; /tmp/mmcdev; # dd to clear the possible MBR FBK: ucmd mmc=`cat /tmp/mmcdev`; dd if=/dev/zero of=/dev/mmcblk${mmc} bs=512 count=1 # 新建分区 # 前面 10M 留给 BootLoader ，从 0xa00000Bytes 开始新建一个 500M 的 FAT 分区，从 600M 开始新建一个 ext3 分区 FBK: ucmd mmc=`cat /tmp/mmcdev`; PARTSTR=$\u0026#39;10M,500M,0c\\n600M,,83\\n\u0026#39;; echo \u0026#34;$PARTSTR\u0026#34; | sfdisk --force /dev/mmcblk${mmc} # 格式化 fat 分区并挂载 FBK: ucmd mmc=`cat /tmp/mmcdev`; while [ ! -e /dev/mmcblk${mmc}p1 ]; do sleep 1; done FBK: ucmd mmc=`cat /tmp/mmcdev`; mkfs.vfat /dev/mmcblk${mmc}p1 FBK: ucmd mmc=`cat /tmp/mmcdev`; mkdir -p /mnt/fat FBK: ucmd mmc=`cat /tmp/mmcdev`; mount -t vfat /dev/mmcblk${mmc}p1 /mnt/fat # 将内核、设备树复制到 fat 分区 FBK: ucp image/fat/Image t:/mnt/fat FBK: ucp image/fat/imx8mm-evk.dtb t:/mnt/fat FBK: ucp image/fat/tee.bin t:/tmp/fat FBK: ucmd umount /mnt/fat # 格式化 ext3 分区 FBK: ucmd mmc=`cat /tmp/mmcdev`; mkfs.ext3 -F -E nodiscard /dev/mmcblk${mmc}p2 FBK: ucmd mkdir -p /mnt/ext3 FBK: ucmd mmc=`cat /tmp/mmcdev`; mount /dev/mmcblk${mmc}p2 /mnt/ext3 FBK: acmd export EXTRACT_UNSAFE_SYMLINKS=1; tar -jx -C /mnt/ext3 FBK: ucp image/rootfs.tar.bz2 t:- FBK: Sync FBK: ucmd umount /mnt/ext3 FBK: DONE 4. u-boot mmc #u-boot 提供了读写 eMMC 的命令 mmc ，语法如下：\nu-boot=\u0026gt; mmc mmc - MMC sub system Usage: mmc info - display info of the current MMC device mmc read addr blk# cnt mmc write addr blk# cnt mmc erase blk# cnt mmc rescan mmc part - lists available partition on current mmc device mmc dev [dev] [part] - show or set current mmc device [partition] mmc list - lists available devices mmc hwpartition [args...] - does hardware partitioning arguments (sizes in 512-byte blocks): [user [enh start cnt] [wrrel {on|off}]] - sets user data area attributes [gp1|gp2|gp3|gp4 cnt [enh] [wrrel {on|off}]] - general purpose partition [check|set|complete] - mode, complete set partitioning completed WARNING: Partitioning is a write-once setting once it is set to complete. Power cycling is required to initialize partitions after set to complete. mmc bootbus dev boot_bus_width reset_boot_bus_width boot_mode - Set the BOOT_BUS_WIDTH field of the specified device mmc bootpart-resize \u0026lt;dev\u0026gt; \u0026lt;boot part size MB\u0026gt; \u0026lt;RPMB part size MB\u0026gt; - Change sizes of boot and RPMB partitions of specified device mmc partconf dev [boot_ack boot_partition partition_access] - Show or change the bits of the PARTITION_CONFIG field of the specified device mmc rst-function dev value - Change the RST_n_FUNCTION field of the specified device WARNING: This is a write-once field and 0 / 1 / 2 are the only valid values. mmc setdsr \u0026lt;value\u0026gt; - set DSR register value 5. Linux mmc #Linux 提供看开源的 eMMC 读写工具 mmc-utils 。语法如下：\nroot@imx8mmevk:~# mmc Usage: mmc extcsd read \u0026lt;device\u0026gt; Print extcsd data from \u0026lt;device\u0026gt;. mmc writeprotect boot get \u0026lt;device\u0026gt; Print the boot partitions write protect status for \u0026lt;device\u0026gt;. mmc writeprotect boot set \u0026lt;device\u0026gt; Set the boot partitions write protect status for \u0026lt;device\u0026gt;. This sets the eMMC boot partitions to be write-protected until the next boot. mmc writeprotect user set \u0026lt;type\u0026gt;\u0026lt;start block\u0026gt;\u0026lt;blocks\u0026gt;\u0026lt;device\u0026gt; Set the write protect configuration for the specified region of the user area for \u0026lt;device\u0026gt;. \u0026lt;type\u0026gt; must be \u0026#34;none|temp|pwron\u0026#34;. \u0026#34;none\u0026#34; - Clear temporary write protection. \u0026#34;temp\u0026#34; - Set temporary write protection. \u0026#34;pwron\u0026#34; - Set write protection until the next poweron. \u0026lt;start block\u0026gt; specifies the first block of the protected area. \u0026lt;blocks\u0026gt; specifies the size of the protected area in blocks. NOTE! The area must start and end on Write Protect Group boundries, Use the \u0026#34;writeprotect user get\u0026#34; command to get the Write Protect Group size. mmc writeprotect user get \u0026lt;device\u0026gt; Print the user areas write protect configuration for \u0026lt;device\u0026gt;. mmc disable 512B emulation \u0026lt;device\u0026gt; Set the eMMC data sector size to 4KB by disabling emulation on \u0026lt;device\u0026gt;. mmc gp create \u0026lt;-y|-n|-c\u0026gt; \u0026lt;length KiB\u0026gt; \u0026lt;partition\u0026gt; \u0026lt;enh_attr\u0026gt; \u0026lt;ext_attr\u0026gt; \u0026lt;device\u0026gt; Create general purpose partition for the \u0026lt;device\u0026gt;. Dry-run only unless -y or -c is passed. Use -c if more partitioning settings are still to come. NOTE! This is a one-time programmable (unreversible) change. To set enhanced attribute to general partition being created set \u0026lt;enh_attr\u0026gt; to 1 else set it to 0. To set extended attribute to general partition set \u0026lt;ext_attr\u0026gt; to 1,2 else set it to 0 mmc enh_area set \u0026lt;-y|-n|-c\u0026gt; \u0026lt;start KiB\u0026gt; \u0026lt;length KiB\u0026gt; \u0026lt;device\u0026gt; Enable the enhanced user area for the \u0026lt;device\u0026gt;. Dry-run only unless -y or -c is passed. Use -c if more partitioning settings are still to come. NOTE! This is a one-time programmable (unreversible) change. mmc write_reliability set \u0026lt;-y|-n|-c\u0026gt; \u0026lt;partition\u0026gt; \u0026lt;device\u0026gt; Enable write reliability per partition for the \u0026lt;device\u0026gt;. Dry-run only unless -y or -c is passed. Use -c if more partitioning settings are still to come. NOTE! This is a one-time programmable (unreversible) change. mmc status get \u0026lt;device\u0026gt; Print the response to STATUS_SEND (CMD13). mmc bootpart enable \u0026lt;boot_partition\u0026gt; \u0026lt;send_ack\u0026gt; \u0026lt;device\u0026gt; Enable the boot partition for the \u0026lt;device\u0026gt;. Disable the boot partition for the \u0026lt;device\u0026gt; if \u0026lt;boot_partition\u0026gt; is set to 0. To receive acknowledgment of boot from the card set \u0026lt;send_ack\u0026gt; to 1, else set it to 0. mmc bootbus set \u0026lt;boot_mode\u0026gt; \u0026lt;reset_boot_bus_conditions\u0026gt; \u0026lt;boot_bus_width\u0026gt; \u0026lt;device\u0026gt; Set Boot Bus Conditions. \u0026lt;boot_mode\u0026gt; must be \u0026#34;single_backward|single_hs|dual\u0026#34; \u0026lt;reset_boot_bus_conditions\u0026gt; must be \u0026#34;x1|retain\u0026#34; \u0026lt;boot_bus_width\u0026gt; must be \u0026#34;x1|x4|x8\u0026#34; mmc bkops enable \u0026lt;device\u0026gt; Enable the eMMC BKOPS feature on \u0026lt;device\u0026gt;. NOTE! This is a one-time programmable (unreversible) change. mmc hwreset enable \u0026lt;device\u0026gt; Permanently enable the eMMC H/W Reset feature on \u0026lt;device\u0026gt;. NOTE! This is a one-time programmable (unreversible) change. mmc hwreset disable \u0026lt;device\u0026gt; Permanently disable the eMMC H/W Reset feature on \u0026lt;device\u0026gt;. NOTE! This is a one-time programmable (unreversible) change. mmc sanitize \u0026lt;device\u0026gt; Send Sanitize command to the \u0026lt;device\u0026gt;. This will delete the unmapped memory region of the device. mmc rpmb write-key \u0026lt;rpmb device\u0026gt; \u0026lt;key file\u0026gt; Program authentication key which is 32 bytes length and stored in the specified file. Also you can specify \u0026#39;-\u0026#39; instead of key file path to read the key from stdin. NOTE! This is a one-time programmable (unreversible) change. Example: $ echo -n AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH | \\ mmc rpmb write-key /dev/mmcblk0rpmb - mmc rpmb read-counter \u0026lt;rpmb device\u0026gt; Counter value for the \u0026lt;rpmb device\u0026gt; will be read to stdout. mmc rpmb read-block \u0026lt;rpmb device\u0026gt; \u0026lt;address\u0026gt; \u0026lt;blocks count\u0026gt; \u0026lt;output file\u0026gt; [key file] Blocks of 256 bytes will be read from \u0026lt;rpmb device\u0026gt; to output file or stdout if \u0026#39;-\u0026#39; is specified. If key is specified - read data will be verified. Instead of regular path you can specify \u0026#39;-\u0026#39; to read key from stdin. Example: $ echo -n AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH | \\ mmc rpmb read-block /dev/mmcblk0rpmb 0x02 2 /tmp/block - or read two blocks without verification $ mmc rpmb read-block /dev/mmcblk0rpmb 0x02 2 /tmp/block mmc rpmb write-block \u0026lt;rpmb device\u0026gt; \u0026lt;address\u0026gt; \u0026lt;256 byte data file\u0026gt; \u0026lt;key file\u0026gt; Block of 256 bytes will be written from data file to \u0026lt;rpmb device\u0026gt;. Also you can specify \u0026#39;-\u0026#39; instead of key file path or data file to read the data from stdin. Example: $ (awk \u0026#39;BEGIN {while (c++\u0026lt;256) printf \u0026#34;a\u0026#34;}\u0026#39; | \\ echo -n AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH) | \\ mmc rpmb write-block /dev/mmcblk0rpmb 0x02 - - mmc cache enable \u0026lt;device\u0026gt; Enable the eMMC cache feature on \u0026lt;device\u0026gt;. NOTE! The cache is an optional feature on devices \u0026gt;= eMMC4.5. mmc cache disable \u0026lt;device\u0026gt; Disable the eMMC cache feature on \u0026lt;device\u0026gt;. NOTE! The cache is an optional feature on devices \u0026gt;= eMMC4.5. mmc csd read \u0026lt;device path\u0026gt; Print CSD data from \u0026lt;device path\u0026gt;. The device path should specify the csd file directory. mmc cid read \u0026lt;device path\u0026gt; Print CID data from \u0026lt;device path\u0026gt;. The device path should specify the cid file directory. mmc scr read \u0026lt;device path\u0026gt; Print SCR data from \u0026lt;device path\u0026gt;. The device path should specify the scr file directory. mmc ffu \u0026lt;image name\u0026gt; \u0026lt;device\u0026gt; Run Field Firmware Update with \u0026lt;image name\u0026gt; on \u0026lt;device\u0026gt;. mmc help|--help|-h Show the help. mmc \u0026lt;cmd\u0026gt; --help Show detailed help for a command or subset of commands. 0.1 ","date":"2021 July 15","permalink":"/posts/2021/07/15/","section":"Posts","summary":"1. iMX8MM 的启动流程 # iMX8MM 系统启动的详细流程可以参考 IMX8MMRM.","title":"iMX8MM 从 eMMC 启动系统和烧写的笔记"},{"content":"在 VSCode 中安装 Waveform Render 插件：\n它可以解析 WaveJSON 语法的 json 文件，绘制一幅数字电路时序图。官网提供了一个完整教程：https://wavedrom.com/tutorial.html ，还有一个在线的编辑器：https://wavedrom.com/editor.html 。\n开始 #在 vscode 中新建一个名为 demo.json 的文件，内容如下：\n{ \u0026#34;signal\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;clk\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;p.......\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;01010101\u0026#34; } ] } 保存后用 Command+Shift+P 组合键打开命令面板，选择执行 Waveform Render:Draw ，就可以看到渲染后的时序图，也可以选择执行 Waveform Render:Toggle Live Preview ，实时查看渲染结果：\n这个例子展示了基本的 WaveJSON 语法：\nsignal 是必须的关键词，它用一个数组表示一幅时序图。 数组内每个元素描述一个信号。 每个元素至少要包含 name 和 wave 两个变量： name 定义了信号的名称。 wave 用来描述信号的样子。 wave 定义的字符串中，每个字符代表一个时钟周期（1bit），通过不同的字符来描述信号的样子：\n0 表示低电平，1 表示高电平。 p 表示上升沿开始的一个时钟周期。 . 表示与上一个时钟周期相同。 语法 #对于时钟信号， WaveJSON 支持的语法有：\np 表示上升沿开始的方波。 n 表示下降沿开始的方波。 l 表示低电平。 h 表示高电平。 如果用大写字母，会在起始边沿绘制一个箭头。 例如：\n{ \u0026#34;signal\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;pclk\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;p.......\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;nclk\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;n.......\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;clk0\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;lhlhlhlh\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;clk1\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;LHLHLHLH\u0026#34; } ] } 对于数据信号，除了 0 和 1 ，还支持其他语法：\nx 表示未知的无效状态。 = 表示有效数据，也可以写成 2~9 ，会用不同的颜色显示。 对于有效数据，可以用 data 变量加上文本标签。 例如：\n{ \u0026#34;signal\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;pclk\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;p.......\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;01010101\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;x234789x\u0026#34;, \u0026#34;data\u0026#34;: [\u0026#34;head\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;3\u0026#34;] } ] } 还可以用 | 符号表示一段空白，例如：\n{ \u0026#34;signal\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;pclk\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;p...|...\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;1222|.==\u0026#34; } ] } period 和 phase 变量用于调整时序：\nperiod 的值应该是一个数字 n ，表示横向等比例放大或缩小。 phase 的值应该是一个数字 n ，表示横向的位置调整，单位是一个时钟周期： 如果是正数，表示向左移动 n 个时钟周期。 如果是负数，表示向右移动 n 个时钟周期。 例如：\n{ \u0026#34;signal\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;pclk\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;p.......\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;pclk\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;p...\u0026#34;, \u0026#34;period\u0026#34;: 2}, { \u0026#34;name\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;01010101\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;01010101\u0026#34;, \u0026#34;phase\u0026#34;: 0.5}, { \u0026#34;name\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;01010101\u0026#34;, \u0026#34;phase\u0026#34;: -1} ] } 多个信号可以用 ['group name', {...}, {...}, ...] 语法编成一组，而且支持嵌套，例如：\n{ \u0026#34;signal\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;clk\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;p..Pp..P\u0026#34; }, [ \u0026#34;Master\u0026#34;, [ \u0026#34;ctrl\u0026#34;, { \u0026#34;name\u0026#34;: \u0026#34;write\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;01.0....\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;read\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;0...1..0\u0026#34; } ], { \u0026#34;name\u0026#34;: \u0026#34;addr\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;x3.x4..x\u0026#34;, \u0026#34;data\u0026#34;: \u0026#34;A1 A2\u0026#34; } ], {}, [\u0026#34;Slave\u0026#34;, [\u0026#34;ctrl\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;ack\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;x01x0.1x\u0026#34; } ], { \u0026#34;name\u0026#34;: \u0026#34;rdata\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;x.....4x\u0026#34;, \u0026#34;data\u0026#34;: \u0026#34;Q2\u0026#34; } ] ] } 时序绘制完毕后，还可以对图片进行修饰。 \u0026quot;config\u0026quot;: { \u0026quot;hscale\u0026quot;: n } 表示将图片横向等比例放大 n 倍。\u0026quot;head\u0026quot;:{ } 和 \u0026quot;foot\u0026quot;:{ } 分别表示在时序图的上方和下方添加一些内容：\ntext 变量应该设置一个字符串，表示添加一行文本。 tick 变量应该设置一个整数，表示在时钟周期的起点显示序号，从 n 开始。 tock 变量应该设置一个整数，表示在时钟周期的中点显示序号，从 n 开始。 例如：\n{ \u0026#34;signal\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;pclk\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;p.......\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;wave\u0026#34;: \u0026#34;23232323\u0026#34; } ], \u0026#34;config\u0026#34;: { \u0026#34;hscale\u0026#34;: 2 }, \u0026#34;head\u0026#34;: { \u0026#34;text\u0026#34;: \u0026#34;WaveDrom example\u0026#34;, \u0026#34;tick\u0026#34;: 0 }, \u0026#34;foot\u0026#34;: { \u0026#34;text\u0026#34;: \u0026#34;TIME\u0026#34;, \u0026#34;tock\u0026#34;: 0 } } ","date":"2021 July 3","permalink":"/posts/2021/07/03/","section":"Posts","summary":"在 VSCode 中安装 Waveform Render 插件：","title":"使用 VSCode 绘制数字电路时序图"},{"content":"以 NXP 的 iMX Yocto 4.9.88 系统版本为例，启动分为三个阶段：U-Boot ，内核，根文件系统，每个阶段都可以设置自己的显示画面。\nU-Boot 的启动画面 #u-boot 阶段的运行时很短，一般不用修改。待补充。\n内核的启动画面 #PPM 图片格式 #如果开启了 FrameBuffer ，Linux 内核启动时会在屏幕左上角显示企鹅图标，图标的数量等于 CPU 的核心数量。这个图标来自于内核源码的 driver/video/logo/ 目录下的 ppm 格式图片：\n$ ls drivers/video/logo/ clut_vga16.ppm logo_linux_mono.pbm logo_sun_clut224.ppm Kconfig logo_linux_vga16.ppm logo_superh_clut224.ppm logo_blackfin_clut224.ppm logo_m32r_clut224.ppm logo_superh_mono.pbm logo_blackfin_vga16.ppm logo_mac_clut224.ppm logo_superh_vga16.ppm logo.c logo_parisc_clut224.ppm Makefile logo_dec_clut224.ppm logo_sgi_clut224.ppm logo_linux_clut224.ppm logo_spe_clut224.ppm 这里的 ppm 格式是一种 ASCII 编码的图片文件格式，可以用文本编辑器打开，以 logo_linux_clut224.ppm 为例 ：\nP3 # Standard 224-color Linux logo 80 80 255 0 0 0 0 0 0 0 0 0 0 0 0 井号 # 开头的是注释，忽略注释后，前三行文本是文件头：\n第一行表示文件类型，P3 表示 ASCII 编码的 RGB 三色色显现图像 第二行表示图像的宽度和高度，单位是像素 第三行表示最大的像素值 文件头后面所有像素点的数据，每个像素点是由 RGB三个数据组成，RGB 中间用一个空格隔开，像素点之间由两个空格隔开，每一行用回车隔开。\n这样的文件不能供内核直接使用，需要转换成 C 语音的格式。编译内核时，执行的 drivers/video/logo/Makefile 文件会调用 scripts/pnmtologo 工具：\npnmtologo := scripts/pnmtologo # Create commands like \u0026#34;pnmtologo -t mono -n logo_mac_mono -o ...\u0026#34; quiet_cmd_logo = LOGO $@ cmd_logo = $(pnmtologo) \\ -t $(patsubst $*_%,%,$(notdir $(basename $\u0026lt;))) \\ -n $(notdir $(basename $\u0026lt;)) -o $@ $\u0026lt; scripts/pnmtologo 是用 scripts/pnmtologo.c 编译生成的二进制工具，执行的语法是：\n./pnmtologo [options] \u0026lt;filename\u0026gt; 可选项: -h : 显示帮助信息 -n \u0026lt;name\u0026gt; : 生成的 struct linux_logo 类型变量的名字 (default: linux_logo) -o \u0026lt;output\u0026gt; : 生成的 C 语音源文件的名字 -t \u0026lt;type\u0026gt; : 启动画面的类型 mono : monochrome black/white vga16 : 16 colors VGA text palette clut224 : 224 colors (default) gray256 : 256 levels grayscale \u0026lt;filename\u0026gt; 是要解析的 ppm 图片的文件名 它会把 driver/video/logo/ 目录下 .ppm 文件转换为同名的 .c 文件，例如，logo_linux_clut224.ppm 会转换为 logo_linux_clut224.c ，通过一个 struct linux_logo 变量保存图片的数据。\n显示启动画面的过程 #内核绘制 logo 是由 drivers/video/fbdev/core/fbmem.c 文件中的 fb_show_logo() 完成的：\nint fb_show_logo(struct fb_info *info, int rotate) { int y; y = fb_show_logo_line(info, rotate, fb_logo.logo, 0, num_online_cpus()); y = fb_show_extra_logos(info, y, rotate); return y; } 参数 info 传递的 FrameBuffer 的属性，rotate 则表示屏幕的旋转方向。这个函数又调用了 fb_show_logo_line() 函数，参数 num_online_cpus() 是一个宏，它返回了 CPU 的核心数量，参数 fb_logo.logo 是一个 struct linux_logo 指针，这个结构记录了 logo 图片的分辨率和像素数据，它是在 fb_prepare_logo() 函数中由 fb_find_logo() 赋值：\nint fb_prepare_logo(struct fb_info *info, int rotate) { ... /* Return if no suitable logo was found */ fb_logo.logo = fb_find_logo(depth); ... } 参数 depth 表示 FrameBuffer 的颜色深度，基本是由屏幕的素质决定，fb_find_logo() 函数定义在 drivers/video/logo/logo.c 中，它的作用是根据 depth 的值和内核配置决定用那个图片作为 logo ，如果颜色深度是 16 ，且内核配置了 CONFIG_LOGO_LINUX_CLUT224 选项，就用 logo_linux_clut224 作为 logo ：\nconst struct linux_logo * __ref fb_find_logo(int depth) { const struct linux_logo *logo = NULL; ... if (depth \u0026gt;= 8) { #ifdef CONFIG_LOGO_LINUX_CLUT224 /* Generic Linux logo */ logo = \u0026amp;logo_linux_clut224; #endif ... return logo; } 配置选项是在 menuconfig 中的 Device Drivers \u0026gt; Graphics support \u0026gt; Bootup logo 中设置的：\nlogo_linux_clut224 是一个 struct linux_logo 类型的变量，定义在 logo_linux_clut224.c 文件中，它是在编译时，由 drivers/video/logo/Makefile 文件调用 scripts/pnmtologo 工具，读取 drivers/video/logo/ 目录下的同名图片 logo_linux_clut224.ppm 解析后生成的。内容类似如下：\nstatic unsigned char logo_linux_clut224_data[] __initdata = { 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, ... ... }; static unsigned char logo_linux_clut224_clut[] __initdata = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xfe, 0xff, 0xff, 0xff, 0xfe, 0xff, ... ... } const struct linux_logo logo_linux_clut224 __initconst = { .type = LINUX_LOGO_CLUT224, .width = 800, .height = 590, .clutsize = 223, .clut = logo_linux_clut224_clut, .data = logo_linux_clut224_data }; 确定了 logo 用的图片后， fb_show_logo_line() 函数会改用 struct fb_image 结构保存要显示的图片：\nstatic int fb_show_logo_line(struct fb_info *info, int rotate, const struct linux_logo *logo, int y, unsigned int n) { struct fb_image image; ... image.depth = 8; //图片的颜色深度固定为 8 image.data = logo-\u0026gt;data; //图片的数据 image.dx = 0; //绘制图片的起始横坐标，屏幕的左上角为 0 image.dy = y; //绘制图片的起始纵坐标，也是 0 ，表示从左上角开始显示 image.width = logo-\u0026gt;width; //图片的横向分辨率 image.height = logo-\u0026gt;height; //图片的纵向分辨率 ... fb_do_show_logo(info, \u0026amp;image, rotate, n); } 最后调用 fb_do_show_logo() 函数横向的绘制 n 个 image 。如果屏幕是正向的，图片会按如下方式绘制：\nstatic void fb_do_show_logo(struct fb_info *info, struct fb_image *image, int rotate, unsigned int num) { ... if (rotate == FB_ROTATE_UR) { for (x = 0; x \u0026lt; num \u0026amp;\u0026amp; image-\u0026gt;dx + image-\u0026gt;width \u0026lt;= info-\u0026gt;var.xres; x++) { info-\u0026gt;fbops-\u0026gt;fb_imageblit(info, image); image-\u0026gt;dx += image-\u0026gt;width + 8; } } ... } 更换启动画面 #根据 logo 的显示原理，我们可以按如下步骤更换内核的启动画面。\n首先准备一张小于等于屏幕分辨率的 png 格式图片，命名为 logo.png ，执行如下命令将其转换为 ppm 格式：\n~$ pngtopnm logo.png \u0026gt; logo_linux_clut.pnm ~$ pnmquant 224 logo_linux_clut.pnm \u0026gt; logo_linux_clut224.pnm ~$ pnmtoplainpnm logo_linux_clut224.pnm \u0026gt; logo_linux_clut224.ppm 将生成的 logo_linux_clut224.ppm 覆盖到内核源码的 drivers/video/logo/ 目录下。\n如果 CPU 是多核，且 logo 图片跟屏幕分辨率相同，想要全屏显示，就修改 drivers/video/fbdev/core/fbmem.c 文件中的 fb_show_logo() 函数，将绘制 logo 的数量设为 1 ：\n@@ -665,7 +665,7 @@ int fb_show_logo(struct fb_info *info, int rotate) int y; y = fb_show_logo_line(info, rotate, fb_logo.logo, 0, - num_online_cpus()); + 1); y = fb_show_extra_logos(info, y, rotate); return y; 默认情况下，图片会贴着屏幕的左上角 \u0026lt;0,0\u0026gt; 显示。如果需要居中显示，可以在 drivers/video/fbdev/core/fbmem.c 文件的 fb_show_logo_line() 函数中修改图片显示的起始坐标：\n-image.dx=0; -image.dy=y; +image.dx = (info-\u0026gt;var.xres / 2) - (image.width / 2); +image.dy = (info-\u0026gt;var.yres / 2) - (image.height / 2); 查看内核的 git log 发现，在 5.0 之后的版本，通过 commit:3d8b19 添加了让 logo 居中显示的配置选项，但是很快又通过 commit/890d14 将这个功能转移到了命令行的选项 fbcon=logo-pos:\u0026lt;location\u0026gt; 中。\n动态修改启动画面 #上面的方法中，启动画面的数据必须编译到内核中，每次修改启动画面都要重新编译内核，不太方便。eMMC 中有一个用于放置内核和设备树文件的 FAT 分区，我们可以利用这个分区和 u-boot 的 load 命令，实现动态修改启动画面的功能，大致原理是：\n将 ppm 格式的 logo 图片转换成二进制格式的 ppmlogo.bin 文件，放到 FAT 分区中。 u-boot 启动时，读取 ppmlogo.bin 文件，并写入内核的保留内存中。 kernel 启动时，从保留内存的特定位置读取 ppmlogo.bin 的数据，用这个数据初始化 linux_logo 变量。 首先写一个名为 ppmtobin 的程序，可以借用 script/pnmtologo.c 进行修改。它的作用是把一个 ppm 格式的 logo 图片转换成内核能够直接读取的二进制格式文件 ppmlogo.bin ，把这个文件放到 eMMC 的 FAT 分区，该文件的存储布局与 struct linux_logo 相同：\n* --------------------------------------------- * | 0 1 2 3 (byte) * --------------------------------------------- * 0| logo type * --------------------------------------------- * 4| logo width(w) * --------------------------------------------- * 8| logo height(h) * --------------------------------------------- * 12| logo clutsize * --------------------------------------------- * 16| * ...| logo data * ...| (size = w*h) * --------------------------------------------- * w*h+16| * ...| logo clut * ...| (size = clutsize*3) * --------------------------------------------- 下一步就是 u-boot 中操作。先确认一下板卡的内存信息，可以在 u-boot 中执行 bdinfo 命令：\n=\u0026gt; bdinfo arch_number = 0x00000F8C boot_params = 0x10000100 DRAM bank = 0x00000000 -\u0026gt; start = 0x10000000 # 内存起始地址 -\u0026gt; size = 0x40000000 # 内存大小 1GB ，我们可以把 logo 文件加载到 4f000000 地址后面的内存里 baudrate = 115200 bps TLB addr = 0x4FFF0000 relocaddr = 0x4FF40000 reloc off = 0x38740000 irq_sp = 0x4EF318C0 sp start = 0x4EF318B0 FB base = 0x4EF46580 Early malloc usage: 114 / 400 然后确认分区和文件，明确 ppplog.bin 文件的路径：\n=\u0026gt; mmc part Partition Map for MMC device 2 -- Partition Type: DOS Part Start Sector Num Sectors UUID Type 1 20480 1024000 bcd6138c-01 0c 2 1228800 6324224 bcd6138c-02 83 =\u0026gt; fatls mmc 2:1 7679712 zimage 52298 imx6dl-sabresd.dtb 472688 ppmlogo.bin 51391 imx6q-sabresd.dtb 先试试手动加载，将 ppmlogo.bin 文件加载 4f00000 的地址上：\n=\u0026gt; load mmc 2:1 4f000000 ppmlogo.bin reading ppmlogo.bin 472688 bytes read in 29 ms (15.5 MiB/s) 加载成功后可以读一下这段内存的值，看一下写入的值是否正确：\n=\u0026gt; md.l 4f000000 4 4f000000: 00000003 00000320 0000024e 000000df .... ...N....... 手动加载成功后，就可以新建一个环境变量，保存加载 logo 文件的操作：\n=\u0026gt; env set load_logo load mmc 2:1 4f000000 ppmlogo.bin =\u0026gt; env save 手动执行一次，确保命令可以正常执行：\n=\u0026gt; run load_logo reading ppmlogo.bin 472688 bytes read in 29 ms (15.5 MiB/s) 最后，编辑 bootcmd 环境变量，添加 run load_logo; ，让 u-boot 启动时自动执行 load_logo ：\n=\u0026gt; env edit bootcmd edit: run findfdt;run findtee;mmc dev ${mmcdev}; run load_logo; if mmc rescan; then if run loadbootscript; then run bootscript; else if run loadimage; then run mmcboot; else run netboot; fi; fi; else run netboot; fi =\u0026gt; env save 保存后重启，可以看到加载 ppmlogo.bin 时，u-boot 打印的如下信息：\nreading ppmlogo.bin 472688 bytes read in 28 ms (16.1 MiB/s) 手动修改 u-boot 没有问题后，可以在 u-boot 源码中修改 bootcmd 的值，使 u-boot 启动时自动加载 logo 图片。例如修改 imx6q 的配置文件 `include/configs/mx6sabre_common.h：\n#define CONFIG_EXTRA_ENV_SETTINGS \\ CONFIG_MFG_ENV_SETTINGS \\ TEE_ENV \\ \u0026#34;epdc_waveform=epdc_splash.bin\\0\u0026#34; \\ \u0026#34;script=boot.scr\\0\u0026#34; \\ \u0026#34;image=zImage\\0\u0026#34; \\ + \u0026#34;load_logo=load mmc 2:1 4f000000 ppmlogo.bin\u0026#34; ... ... #define CONFIG_BOOTCOMMAND \\ \u0026#34;run findfdt;\u0026#34; \\ \u0026#34;run findtee;\u0026#34; \\ \u0026#34;mmc dev ${mmcdev};\u0026#34; \\ + \u0026#34;run load_logo\u0026#34; \\ \u0026#34;if mmc rescan; then \u0026#34; \\ \u0026#34;if run loadbootscript; then \u0026#34; \\ \u0026#34;run bootscript; \u0026#34; \\ \u0026#34;else \u0026#34; \\ \u0026#34;if run loadimage; then \u0026#34; \\ \u0026#34;run mmcboot; \u0026#34; \\ \u0026#34;else run netboot; \u0026#34; \\ \u0026#34;fi; \u0026#34; \\ \u0026#34;fi; \u0026#34; \\ \u0026#34;else run netboot; fi\u0026#34; #endif 最后就是修改内核。我们需要在设备树的 /reserved-memory 中添加一个字节点，申请一段保留内存，将地址 0x4f000000 开始的 3MB 内存留給 u-boot 存放的 ppmlogo.bin ，避免内核启动后将这段内存覆盖：\nreserved-memory { linux-logo { compatible = \u0026#34;cs-logo\u0026#34;; reusable; reg = \u0026lt;0x4f000000 0x300000\u0026gt;; } } 然后修改 drivers/video/logo/logo.c 文件中的 fb_find_logo() 函数，读取 0x4f000000 内存中的数据，并结构化为 struct linux_logo 格式：\ndiff --git a/drivers/video/logo/logo.c b/drivers/video/logo/logo.c index b6bc4a0..d304272 100644 --- a/drivers/video/logo/logo.c +++ b/drivers/video/logo/logo.c @@ -28,6 +28,8 @@ MODULE_PARM_DESC(nologo, \u0026#34;Disables startup logo\u0026#34;); static bool logos_freed; +struct linux_logo cs_logo; //存放内存中读取的 logo 数据，一定要全局变量 + static int __init fb_logo_late_init(void) { logos_freed = true; @@ -43,6 +45,7 @@ late_initcall(fb_logo_late_init); const struct linux_logo * __ref fb_find_logo(int depth) { const struct linux_logo *logo = NULL; + char *logo_addr = NULL; if (nologo || logos_freed) return NULL; @@ -76,7 +79,17 @@ const struct linux_logo * __ref fb_find_logo(int depth) if (depth \u0026gt;= 8) { #ifdef CONFIG_LOGO_LINUX_CLUT224 /* Generic Linux logo */ - logo = \u0026amp;logo_linux_clut224; + logo_addr = phys_to_virt((phys_addr_t)(0x4f000000)); // 将物理地址转换为虚拟地址 + memcpy(\u0026amp;cs_logo.type, logo_addr, 4); + memcpy(\u0026amp;cs_logo.width, logo_addr+4, 4); + memcpy(\u0026amp;cs_logo.height, logo_addr+8, 4); + memcpy(\u0026amp;cs_logo.clutsize,logo_addr+12, 4); + printk(\u0026#34;load cs_logo head: %d,%d,%d,%d \\n\u0026#34;, cs_logo.type, cs_logo.width, cs_logo.height, cs_logo.clutsize); + + cs_logo.data = logo_addr+16; + cs_logo.clut = logo_addr+16+cs_logo.width*cs_logo.height; + logo = \u0026amp;cs_logo; + #endif #ifdef CONFIG_LOGO_BLACKFIN_CLUT224 修改完毕，下面是 ppmtobin 的程序的源码：\n/* * ppmtobin.c * compile: gcc -Wall ppmtobin.c -o ppmtobin * Author: LiShaocheng * * Convert a logo in ASCII PNM format to binary file, format is * --------------------------------------------- * | 0 1 2 3 * --------------------------------------------- * 0| logo type * --------------------------------------------- * 4| logo width(w) * --------------------------------------------- * 8| logo height(h) * --------------------------------------------- * 12| logo clutsize * --------------------------------------------- * 16| * ...| logo data * ...| (size = w*h) * --------------------------------------------- * w*h+16| * ...| logo clut * ...| (size = clutsize*3) * --------------------------------------------- */ #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; struct bin_header { int type; /* one of LINUX_LOGO_* */ unsigned int width; unsigned int height; unsigned int clutsize; /* LINUX_LOGO_CLUT224 only */ }; static const char *appname; static const char *filename; static const char *outputname; static FILE *out; #define MAX_LINUX_LOGO_COLORS 224 struct color { unsigned char red; unsigned char green; unsigned char blue; }; static unsigned int logo_width; static unsigned int logo_height; static struct color **logo_data; static struct color logo_clut[MAX_LINUX_LOGO_COLORS]; static unsigned int logo_clutsize; static int is_plain_pbm = 0; static void die(const char *fmt, ...) __attribute__((noreturn)) __attribute((format(printf, 1, 2))); static void usage(void) __attribute((noreturn)); // read data from PNG file static unsigned int get_number(FILE *fp) { int c, val; /* Skip leading whitespace */ do { c = fgetc(fp); if (c == EOF) die(\u0026#34;%s: end of file\\n\u0026#34;, filename); if (c == \u0026#39;#\u0026#39;) { /* Ignore comments \u0026#39;till end of line */ do { c = fgetc(fp); if (c == EOF) die(\u0026#34;%s: end of file\\n\u0026#34;, filename); } while (c != \u0026#39;\\n\u0026#39;); } } while (isspace(c)); /* Parse decimal number */ val = 0; while (isdigit(c)) { val = 10 * val + c - \u0026#39;0\u0026#39;; /* some PBM are \u0026#39;broken\u0026#39;; GiMP for example exports a PBM without space * between the digits. This is Ok cause we know a PBM can only have a \u0026#39;1\u0026#39; * or a \u0026#39;0\u0026#39; for the digit. */ if (is_plain_pbm) break; c = fgetc(fp); if (c == EOF) die(\u0026#34;%s: end of file\\n\u0026#34;, filename); } return val; } static unsigned int get_number255(FILE *fp, unsigned int maxval) { unsigned int val = get_number(fp); return (255 * val + maxval / 2) / maxval; } static void read_image(void) { FILE *fp; unsigned int i, j; int magic; unsigned int maxval; /* open image file */ fp = fopen(filename, \u0026#34;r\u0026#34;); if (!fp) die(\u0026#34;Cannot open file %s: %s\\n\u0026#34;, filename, strerror(errno)); /* check file type and read file header */ magic = fgetc(fp); if (magic != \u0026#39;P\u0026#39;) die(\u0026#34;%s is not a PNM file\\n\u0026#34;, filename); magic = fgetc(fp); switch (magic) { case \u0026#39;1\u0026#39;: case \u0026#39;2\u0026#39;: /* Plain PBM/PGM */ die(\u0026#34;%s: Plain PBM/PGM is not supported\\n\u0026#34; \u0026#34;Use pnmnoraw(1) to convert it to ASCII PNM\\n\u0026#34;, filename); case \u0026#39;3\u0026#39;: /* Plain PPM */ break; case \u0026#39;4\u0026#39;: case \u0026#39;5\u0026#39;: case \u0026#39;6\u0026#39;: /* Binary PBM/PGM/PPM */ die(\u0026#34;%s: Binary PNM is not supported\\n\u0026#34; \u0026#34;Use pnmnoraw(1) to convert it to ASCII PNM\\n\u0026#34;, filename); default: die(\u0026#34;%s is not a PNM file\\n\u0026#34;, filename); } logo_width = get_number(fp); logo_height = get_number(fp); /* allocate image data */ logo_data = (struct color **)malloc(logo_height * sizeof(struct color *)); if (!logo_data) die(\u0026#34;%s\\n\u0026#34;, strerror(errno)); for (i = 0; i \u0026lt; logo_height; i++) { logo_data[i] = malloc(logo_width * sizeof(struct color)); if (!logo_data[i]) die(\u0026#34;%s\\n\u0026#34;, strerror(errno)); } /* read Plain PPM data */ maxval = get_number(fp); for (i = 0; i \u0026lt; logo_height; i++) for (j = 0; j \u0026lt; logo_width; j++) { logo_data[i][j].red = get_number255(fp, maxval); logo_data[i][j].green = get_number255(fp, maxval); logo_data[i][j].blue = get_number255(fp, maxval); } /* close file */ fclose(fp); } static inline int is_equal(struct color c1, struct color c2) { return c1.red == c2.red \u0026amp;\u0026amp; c1.green == c2.green \u0026amp;\u0026amp; c1.blue == c2.blue; } static void write_logo_clut224(void) { unsigned int i, j, k; int len = 0; int write_hex_cnt = 0; struct bin_header header; unsigned char bin_data[logo_width*logo_height]; unsigned char bin_clut[MAX_LINUX_LOGO_COLORS*3]; /* validate image */ for (i = 0; i \u0026lt; logo_height; i++) for (j = 0; j \u0026lt; logo_width; j++) { for (k = 0; k \u0026lt; logo_clutsize; k++) if (is_equal(logo_data[i][j], logo_clut[k])) break; if (k == logo_clutsize) { if (logo_clutsize == MAX_LINUX_LOGO_COLORS) die(\u0026#34;Image has more than %d colors\\n\u0026#34; \u0026#34;Use ppmquant(1) to reduce the number of colors\\n\u0026#34;, MAX_LINUX_LOGO_COLORS); logo_clut[logo_clutsize++] = logo_data[i][j]; } } /* open bin file */ if (outputname) { printf(\u0026#34;Creat %s file\\n\u0026#34;, outputname); out = fopen(outputname, \u0026#34;wb\u0026#34;); if (!out) die(\u0026#34;Cannot create file %s: %s\\n\u0026#34;, outputname, strerror(errno)); } else { printf(\u0026#34;Creat ppmlogo.bin file\\n\u0026#34;); out = fopen(\u0026#34;ppmlogo.bin\u0026#34;, \u0026#34;wb\u0026#34;); if (!out) die(\u0026#34;Cannot create file %s: %s\\n\u0026#34;, outputname, strerror(errno)); } /* write logo header to bin file*/ header.type = 3; header.width = logo_width; header.height = logo_height; header.clutsize = logo_clutsize; printf(\u0026#34;logo_width is %d \\n\u0026#34;, logo_width); printf(\u0026#34;logo_height is %d \\n\u0026#34;, logo_height); printf(\u0026#34;logo_clutsize is %d \\n\u0026#34;, logo_clutsize); len = fwrite(\u0026amp;header, 1, sizeof(header), out); printf(\u0026#34;write logo header len is %d bytes\\n\\n\u0026#34;, len); /* write logo data to bin file*/ for (i = 0; i \u0026lt; logo_height; i++) for (j = 0; j \u0026lt; logo_width; j++) { for (k = 0; k \u0026lt; logo_clutsize; k++) if (is_equal(logo_data[i][j], logo_clut[k])) break; bin_data[write_hex_cnt++] = k + 32; } printf(\u0026#34;bin data len is %d bytes\\n\u0026#34;, write_hex_cnt); len = fwrite(\u0026amp;bin_data, 1, sizeof(bin_data), out); printf(\u0026#34;write bin data len is %d bytes\\n\\n\u0026#34;, len); /* write logo clut to bin file*/ write_hex_cnt = 0; for (i = 0; i \u0026lt; logo_clutsize; i++) { bin_clut[write_hex_cnt++] = logo_clut[i].red; bin_clut[write_hex_cnt++] = logo_clut[i].green; bin_clut[write_hex_cnt++] = logo_clut[i].blue; } printf(\u0026#34;bin clut len is %d bytes\\n\u0026#34;, write_hex_cnt); len = fwrite(\u0026amp;bin_clut, 1, sizeof(bin_clut), out); printf(\u0026#34;write bin clut len is %d bytes\\n\u0026#34;, len); fclose(out); } static void die(const char *fmt, ...) { va_list ap; va_start(ap, fmt); vfprintf(stderr, fmt, ap); va_end(ap); exit(1); } static void usage(void) { die(\u0026#34;Convert a logo in ASCII PNM format to binary file\\n\u0026#34; \u0026#34;Usage: %s [options] \u0026lt;filename\u0026gt;\\n\u0026#34; \u0026#34;\\n\u0026#34; \u0026#34;Valid options:\\n\u0026#34; \u0026#34; -h : display this usage information\\n\u0026#34; \u0026#34; -o \u0026lt;output\u0026gt; : output to file \u0026lt;output\u0026gt; instead of default ppmlogo.bin\\n\u0026#34; \u0026#34;\\n\u0026#34;, appname); } int main(int argc, char *argv[]) { int opt; appname = argv[0]; opterr = 0; while (1) { opt = getopt(argc, argv, \u0026#34;ho:\u0026#34;); if (opt == -1) break; switch (opt) { case \u0026#39;h\u0026#39;: usage(); break; case \u0026#39;o\u0026#39;: outputname = optarg; break; default: usage(); break; } } if (optind != argc - 1) usage(); filename = argv[optind]; read_image(); write_logo_clut224(); exit(0); } 一些问题 #如果你的屏幕分辨率是 800x600 ，而你准备了一张 800x600 的图片，替换后会发现启动画面没有显示，查看内核信息会提示：\nfbcon_init: disable boot-logo (boot-logo bigger than screen). 这条信息来自 drivers/video/console/fbcon.c 文件的 fbcon_prepare_logo() 函数：\nif (logo_lines \u0026gt; vc-\u0026gt;vc_bottom) { logo_shown = FBCON_LOGO_CANSHOW; printk(KERN_INFO \u0026#34;fbcon_init: disable boot-logo (boot-logo bigger than screen).\\n\u0026#34;); } logo_lines 的值来自：\nlogo_lines = DIV_ROUND_UP(logo_height, vc-\u0026gt;vc_font.height); logo_height 表示图片的高度，就是 600 ，vc-\u0026gt;vc_font.height 的默认值是 16 ，DIV_ROUND_UP 的定义是：\n#define DIV_ROUND_UP __KERNEL_DIV_ROUND_UP#define __KERNEL_DIV_ROUND_UP(n, d) (((n) + (d) - 1) / (d)) 计算后得到的 logo_lines 就是 38 。打印 vc-\u0026gt;vc_bottom 的值发现是 37 ，所有需要把图片的纵向分辨率调小到 592 ，这样计算出的 logo_lines 就是 37 。\n关于保留内存 #参考内核文档 reserved-memory.txt 。\n可以在设备树的 /reserved-memory 节点下面新建子节点，用于描述特定的内存区域，Linux 会将这部分内存排除在正常使用之外。 /reserved-memory 节点的定义如下：\nreserved-memory { #address-cells = \u0026lt;1\u0026gt;; # 标准定义，用于设置子节点的 reg 属性的书写格式 #size-cells = \u0026lt;1\u0026gt;; # 标准定义，用于设置子节点的 reg 属性的书写格式 ranges; # 标准定义，空属性 #子节点 } 在下面的子节点中，可以使用 reg 属性来指定保留内存的范围，或者用 size 属性请求动态分配一段特定大小的内存，如果两个都存在，则 reg 优先，size 会被忽略。按照推荐的做法，节点名称应该反映节点的目的，如果是静态分配，应该附加上单位地址 @\u0026lt;address\u0026gt; 。\n可用的属性如下：\n静态分配 reg - 标准定义，必须设置。语法是 \u0026lt;address offset\u0026gt; ，例如 reg = \u0026lt;0x10000000 0x40000000\u0026gt;; 表示从 0x10000000 开始，分配 1GB 内存。 动态分配 size - 基于父类的 #size-cells 的长度，要保留的内存的字节数，必须设置。 alignment - 基于父类的#size-cells的长度，用于对齐分配的地址边界，可选设置。 alloc-ranges - 设置一个地址和长度，请求在这个特定区域内分配保留内存，可选设置。 可选的附加属性：\ncompatible - 可以包含以下字符串。\nshared-dma-pool 。这表示一个内存区域，旨在作为一组设备的DMA缓冲区的共享池使用。如果有必要，它可以被操作系统用来实例化必要的池管理子系统。\n厂商特定的字符串，形式为 \u0026lt;vendor\u0026gt;,[\u0026lt;device\u0026gt;-]\u0026lt;usage\u0026gt; 。\nno-map - 空属性，表示操作系统不得创建该区域的虚拟映射作为其系统内存标准映射的一部分，也不允许在使用该区域的设备驱动程序控制之外的任何情况下对其进行投机访问。\nreusable - 空属性，操作系统可以使用该区域的内存，但有一个限制，即拥有该区域的设备驱动程序需要能够将其收回。通常情况下，这意味着操作系统可以使用该区域来存储易失性或缓存的数据，这些数据可以通过其他方式重新生成或迁移到其他地方。\nno-map 和 reusable 两个属性不能共存，因为它们的逻辑是矛盾的。\nLinux 还有特定的实现：\n如果 \u0026ldquo;linux,cma-default \u0026ldquo;属性存在，那么 Linux 将使用该区域作为连续内存分配器的默认池。\n如果 \u0026ldquo;linux,dma-default \u0026ldquo;属性存在，那么 Linux 将使用该区域作为一致 DMA 分配器的默认池。\n其他设备节点可以通过 memory-region 属性引用已定义的保留内存：\nmemory-region - 它的值应该是保留内存子节点的名称 memory-region-names - 保留内存子节点的名称的列表。 下面是一个例子，定义了三个保留内存：\n一个是所有设备驱动的默认区域（名为linux,cma@72000000，大小为64MB）。 一个专门用于帧缓冲设备（命名为framebuffer@78000000，8MB）。 一个用于多媒体处理（名为multimedia-memory@77000000，64MB）。 / { #address-cells = \u0026lt;1\u0026gt;; #size-cells = \u0026lt;1\u0026gt;; memory { reg = \u0026lt;0x40000000 0x40000000\u0026gt;; }; reserved-memory { #address-cells = \u0026lt;1\u0026gt;; #size-cells = \u0026lt;1\u0026gt;; ranges; /* global autoconfigured region for contiguous allocations */ linux,cma { compatible = \u0026#34;shared-dma-pool\u0026#34;; reusable; size = \u0026lt;0x4000000\u0026gt;; alignment = \u0026lt;0x2000\u0026gt;; linux,cma-default; }; display_reserved: framebuffer@78000000 { reg = \u0026lt;0x78000000 0x800000\u0026gt;; }; multimedia_reserved: multimedia@77000000 { compatible = \u0026#34;acme,multimedia-memory\u0026#34;; reg = \u0026lt;0x77000000 0x4000000\u0026gt;; }; }; /* ... */ fb0: video@12300000 { memory-region = \u0026lt;\u0026amp;display_reserved\u0026gt;; /* ... */ }; scaler: scaler@12500000 { memory-region = \u0026lt;\u0026amp;multimedia_reserved\u0026gt;; /* ... */ }; codec: codec@12600000 { memory-region = \u0026lt;\u0026amp;multimedia_reserved\u0026gt;; /* ... */ }; }; 用户空间的启动画面 #用户空间的启动画面是用 psplash 实现的，它的原理就是使用 FrameBuffer 的 API 在屏幕上绘制图片。源码可以用 git 下载：\ngit://git.yoctoproject.org/psplash 源文件比较简单，比较重要的有：\nmake-image-header.sh ，它的作用是把 png 格式的图片转换为 C 语言头文件，这样就可以把图片编译到可执行的二进制文件中。 psplash.c ，main 函数所在的源文件，可以在这里查看绘制启动画面的流程。 psplash-config.h ，基本的配置宏定义。 psplash-colors.h ，颜色相关的配置宏定义。 psplash-poky-img.h ，包含图片数据的头文件。 psplash-fb.c ，定义了 framebuffer 绘图函数。 psplash-config.h 头文件定义了显示配置：\n/* 设置启动画面中文本信息，默认是空的。如果不用，最好注释掉，否则会在启动画面中显示一行背景色 */ #define PSPLASH_STARTUP_MSG \u0026#34;\u0026#34; /* 一个布尔值，用于指示图片的显示位置，如果图片的分辨率等于屏幕分辨率，最好设为 1 ，如果图片的分辨率小于屏幕分辨率 ，可以设置为 0 ，然后用后面的参数调整显示效果*/ #define PSPLASH_IMG_FULLSCREEN 0 /* 设置分屏显示的分子 */ #define PSPLASH_IMG_SPLIT_NUMERATOR 5 /* 设置分屏显示的分母 */ #define PSPLASH_IMG_SPLIT_DENOMINATOR 6 psplash-colors.h 头文件定义了画面元素的颜色：\n/* 设置背景颜色，RGB */ #define PSPLASH_BACKGROUND_COLOR 0xec,0xec,0xe1 /* 设置文字的颜色，RGB */ #define PSPLASH_TEXT_COLOR 0x6d,0x6d,0x70 /* 设置进度条的颜色，RGB */ #define PSPLASH_BAR_COLOR 0x6d,0x6d,0x70 /* 设置进度条的背景颜色，RGB */ #define PSPLASH_BAR_BACKGROUND_COLOR 0xec,0xec,0xe1 psplash-poky-img.h 文件用 make-image-header.sh 脚本生成的，根据图片的属性定义了一些宏：\n/* 图片的横向分辨率 */ #define POKY_IMG_WIDTH (800) /* 图片的纵向分辨率 */ #define POKY_IMG_HEIGHT (600) /* 一个像素的数据大小，单位是字节 */ #define POKY_IMG_BYTES_PER_PIXEL (3) /* 3:RGB, 4:RGBA */ /* 一行像素占用的数据大小，就是 POKY_IMG_WIDTH*POKY_IMG_BYTES_PER_PIXEL ，单位是字节 */ #define POKY_IMG_ROWSTRIDE (2400) /* 一张图片的像素数据 */ #define POKY_IMG_RLE_PIXEL_DATA ((uint8*) \u0026#34;\u0026#34; psplash.c 中的 main 函数绘制了启动画面，基本流程如下：\n初始化 framebuffer 调用 psplash_fb_draw_rect 函数，将屏幕上的每个像素部设为 PSPLASH_BACKGROUND_COLOR 颜色 调用 psplash_fb_draw_image 函数，将 POKY_IMG_RLE_PIXEL_DATA 的所有数据绘制到屏幕上： 横向是居中显示。 如果 PSPLASH_IMG_FULLSCREEN 为 1 ，横向也是居中显示。 如果 PSPLASH_IMG_FULLSCREEN 为 0 ，纵向占用屏幕的 PSPLASH_IMG_SPLIT_NUMERATOR/PSPLASH_IMG_SPLIT_DENOMINATOR 部分 调用 psplash_fb_draw_image 函数，绘制进度条。 调用 psplash_draw_progress 函数，绘制进度条的动画。 如果定义了 PSPLASH_STARTUP_MSG ，调用 psplash_draw_msg 函数，在进度条上方显示文本信息。 如果要更换启动画面，首先要准备一张 png 格式的图片，重命名为 psplash-poky.png ，分辨率应该小于等于屏幕的分辨率。然后使用 make-image-header.sh 脚本将图片转换为 C 语音的格式：\n./make-image-header.sh psplash-poky.png POKY 这个脚本使用 gdk-pixbuf-csource 工具进行转换，需要安装 gdk-pixbuf-csource ：sudo apt install libgdk-pixbuf2.0-dev\n处理完毕会生成 psplash-poky-img.h 头文件，直接编译，生成的 psplash 二进制文件就包含了启动画面，在系统启动时执行就可以显示。iMX Yocto 把这个文件名改成了 psplash-default ，安装在 /usr/bin 目录下，通过 psplash-start.service 服务启动。\n","date":"2021 May 7","permalink":"/posts/2021/05/07/","section":"Posts","summary":"以 NXP 的 iMX Yocto 4.","title":"如何修改 ARM Linux 系统的启动画面"},{"content":"SPI 通信协议 #SPI 的全称是 Serial Peripheral Interface，是一个带时钟同步的全双工串行链接，使用主/从结构，用于连接微控制器和传感器、存储器和外设。常见的连接结构如下：\n通信时需要四个信号：\nSCLK，Serial Clock，时钟信号，SPI 的时钟频率通常可以达到 10MHz，实际情况还依赖从机能够支持的时钟频率。 MISO，Master In Slave Out，从机向主机发出的数据。 MOSI，Master Out Slave In，主机向从机发出的数据。 SS，Slave Select，从机选择，也叫做片选信号。一条 SPI 总线可以连接多个从设备，SCLK、MISO 和 MOSI 是共用的，每个从机需要一个独立的片选信号，当从机的 SS 信号拉低时，表示从机被选中，才开始接收总线上的信号。 在一个SPI时钟周期内，收发是同时进行的：\n主机通过 MOSI 线发送 1bit 数据，从机通过该线读取这 1bit 数据； 从机通过 MISO 线发送 1bit 数据，主机通过该线读取这 1bit 数据。 这个过程是 SPI 设备内的移位寄存器实现的，当寄存器中的内容全部移出时，相当于完成了两个寄存器内容的交换，如下图所示。\n下面是一个典型的主机模型的通信时序，描述了主机的 0xD2 的数据被移出，从 MISO 信号移入了 0x66 ：\nSCLK 、MOSI 和 SS 信号由主机产生，MISO 是从机发出的信号，主机从这个信号读取从机的数据。通信开始前，SCLK 为低电平，当 SS 拉低后，从机被选中，通信开始，MOSI 和 MISO 信号在 SCLK 的上升沿发生变化，MISO 信号在 SCLK 的下降沿被采样锁存，通信结束后，SS 信号拉高，SCLK 信号重回低电平，一次通信发出的 bit 数为一个 word ，也叫字长。这只是一种情况，在 SCLK 下降沿和上升沿所做的事情由 CPOL 和 CPHA 的值决定，可以在 SPI 设备内的寄存器配置：\nCPOL，时钟极性，是指 SS 处于高电平，通信空闲时，SCLK 的电平。CPOL=0 时， SCLK 在空闲状态时为低电平，CPOL=1 时，则相反。 CPHA，时钟相位，是指通信过程中，数据被采样锁存的时刻。当 CPHA=0 时，MOSI 或 MISO 信号会在 SCLK 的“奇数边沿”被采样，当 CPHA=1 时，信号在 SCLK 的“偶数边沿”采样。 两个配置选项，就会组成四种模式，时序如下图所示：\n我们需要注意的是，主机和从机必须在相同的模式下才能正常通信。\nSPI userspace api #Linux 的 SPI 驱动生成的 spi 设备文件格式 /dev/spidevB.C ，并提供了功能有限的 API ，可以用 open() 和 close() 函数打开和关闭设备，用 read() 和 write() 函数读写数据，用 ioctl() 发送请求。需要的头文件：\n#include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;linux/types.h\u0026gt; #include \u0026lt;linux/spi/spidev.h\u0026gt; 首先需要打开设备文件，调用 open() 和 close() 是标准操作，没有特殊之处，例如 open(\u0026quot;/dev/spidev0.0\u0026quot;, O_RDWR) 。然后调用 ioctl() 进行设置，常用的请求有：\nSPI_IOC_RD_MODE 和 SPI_IOC_WR_MODE 。用于查询（RD）和设置（WR）单字节 SPI 通信的工作模式，包括时钟极性和时钟相位等特性，需要传递一个字符指针，每个位表示一种特性，可用的宏定义在内核源码的 include/uapi/linux/spi/spi.h 文件中，常用的有： SPI_MODE_0 , 表示 CPOL=0，CPHA=0 。 SPI_MODE_1 , 表示 CPOL=0，CPHA=1 。 SPI_MODE_2 , 表示 CPOL=1，CPHA=0 。 SPI_MODE_3 , 表示 CPOL=1，CPHA=1 。 SPI_CS_HIGH , 表示片选信号高电平有效。 SPI_LSB_FIRST, 表示按照 LSB 发送，默认是 MSB 发送。 SPI_IOC_RD_MODE32 和 SPI_IOC_WR_MODE32 。用于查询（RD）和设置（WR）完整的 SPI 通信的工作模式，不再局限于单字节传输。需要传递一个 uint32 指针，可用的选项与 SPI_IOC_WR_MODE 相同。 SPI_IOC_RD_LSB_FIRST 和 SPI_IOC_WR_LSB_FIRST 。用于查询（RD）和设置（WR）SPI 的发送顺序，需要传递一个字符指针，0 表示 MSB ，其他值表示 LSB 。 SPI_IOC_RD_BITS_PER_WORD 和 SPI_IOC_WR_BITS_PER_WORD 。用于查询（RD）和设置（WR）SPI 通信的字长，即一次通信发送的 bit 数，需要传递一个字符指针， 0 表示 8bits 。 SPI_IOC_RD_MAX_SPEED_HZ 和 SPI_IOC_WR_MAX_SPEED_HZ 。用于查询（RD）和设置（WR）SPI 的最大传输速率（比特率），单位是 Hz，需要传递一个 uint32 型的指针。 配置完毕后就是可以读写，标准的 read() 和 write() 函数显然只能实现半双工，在这些函数调用之间，片选会被停用，要实现全双工需要调用 ioctl() 函数的 SPI_IOC_MESSAGE(n) 请求，n 用于指定传输的次数，读写的数据需要用 struct spi_ioc_transfer 型的指针传递：\n#include \u0026lt;linux/spi/spidev.h\u0026gt; struct spi_ioc_transfer { __u64\ttx_buf; // 发送缓冲区的指针，里面的数据会发出去，如果为空，会发出 0 __u64\trx_buf; // 接收缓冲区的指针，接收的数据会放在这里，可以为空 __u32\tlen; // 一次传输的数据长度，单位是字节 __u32\tspeed_hz; // 临时改变 SPI 的速率 __u16\tdelay_usecs; // 如果非零，表示两次传输直接的间隔，单位是微秒 __u8\tbits_per_word; // 临时改变字长 __u8\tcs_change; // 如果非零，下次传输前会取消片选 __u8\ttx_nbits; __u8\trx_nbits; __u8\tword_delay_usecs; __u8\tpad; } 下面是一个例程，它的作用是向指定的 SPI 设备发送数据，并读回从设备发来的数据。\n/* Copyright (C), SBS Science \u0026amp; Technology Co., Ltd. Author: LiShaocheng */ #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;linux/types.h\u0026gt; #include \u0026lt;linux/spi/spidev.h\u0026gt; #define BUF_MAX_SIZE\t0x100 static unsigned char mode; static unsigned char bits_per_word = 8; static unsigned int speed = 100000; char *buffer; void help_info(const char *appname) { printf(\u0026#34;\\n\u0026#34; \u0026#34;*******************************************************\\n\u0026#34; \u0026#34;*********** Read/Write SPI device test **********\\n\u0026#34; \u0026#34;*******************************************************\\n\u0026#34; \u0026#34;* *\\n\u0026#34; \u0026#34; Options : %s \\n\u0026#34; \u0026#34; [-D spi_dev] [-s speed] \\n\u0026#34; \u0026#34; [-b bits_per_word] \\n\u0026#34; \u0026#34; [-H] [-O] [-C] \u0026lt;value\u0026gt; \\n\u0026#34; \u0026#34;* *\\n\u0026#34; \u0026#34;* \u0026lt;spi_dev\u0026gt; - SPI device name , /dev/spidev0.0 *\\n\u0026#34; \u0026#34;* \u0026lt;speed\u0026gt; - Max transfer speed，Hz *\\n\u0026#34; \u0026#34;* \u0026lt;bits_per_word\u0026gt; - bits per word *\\n\u0026#34; \u0026#34;* -H - Phase 1 operation of clock *\\n\u0026#34; \u0026#34;* -O - Active low polarity of clock *\\n\u0026#34; \u0026#34;* -C - Active high for chip select *\\n\u0026#34; \u0026#34;* \u0026lt;value\u0026gt; - Actual values to be sent *\\n\u0026#34; \u0026#34;*******************************************************\\n\u0026#34; \u0026#34;\\n\u0026#34;, appname); } void numToHexStr(unsigned char _hexNum, unsigned char* _hexStr) { unsigned char tmp; if(NULL == _hexStr) return; //低4bit tmp = (_hexNum \u0026gt;\u0026gt; 4) \u0026amp; 0x0f; if(tmp \u0026lt;= 9) *_hexStr = tmp+\u0026#39;0\u0026#39;; else *_hexStr = tmp-0x0a + \u0026#39;A\u0026#39;; _hexStr++; //高4bit tmp = _hexNum \u0026amp; 0x0f; if(tmp \u0026lt;= 9) *_hexStr = tmp+\u0026#39;0\u0026#39;; else *_hexStr = tmp-0x0a + \u0026#39;A\u0026#39;; } //将字符串转为16进制形式，以查看不可见字符 \u0026#34;01\u0026#34; ==\u0026gt; \u0026#34;3031\u0026#34; int toHexStr(const unsigned char * _str, unsigned char *_hexStr) { int i; int len; unsigned char* resultPtr; if(NULL == _str || NULL == _hexStr) return -1; len = strlen(_str); resultPtr = _hexStr; for(i=0; i\u0026lt;len; i++) { numToHexStr(_str[i], resultPtr); resultPtr += 2; } return strlen(_hexStr); } //判断是否是十六进制的基数 int isHexNum(unsigned char _hexNum) { if(\u0026#39;0\u0026#39;\u0026lt;=_hexNum \u0026amp;\u0026amp; _hexNum\u0026lt;=\u0026#39;9\u0026#39;) return 1; else if(\u0026#39;A\u0026#39;\u0026lt;=_hexNum \u0026amp;\u0026amp; _hexNum\u0026lt;=\u0026#39;F\u0026#39;) return 2; else if(\u0026#39;a\u0026#39;\u0026lt;=_hexNum \u0026amp;\u0026amp; _hexNum\u0026lt;=\u0026#39;f\u0026#39;) return 3; return -1; } //十六进制的字符转数字 unsigned char charToHexNum(unsigned char hexChar) { unsigned char tmp; if(1\u0026gt;isHexNum(hexChar)) return 0xFF; if(hexChar\u0026lt;=\u0026#39;9\u0026#39;) tmp = hexChar-\u0026#39;0\u0026#39;; else if(hexChar\u0026lt;=\u0026#39;F\u0026#39;) tmp = hexChar-\u0026#39;7\u0026#39;; else tmp = hexChar-\u0026#39;W\u0026#39;; return tmp; } static int transfer(int fd, char *tbuf, char *rbuf, int bytes) { int ret; struct spi_ioc_transfer tr = { .tx_buf = (unsigned long)tbuf, .rx_buf = (unsigned long)rbuf, .len = bytes, }; ret = ioctl(fd, SPI_IOC_MESSAGE(1), \u0026amp;tr); if (ret == 1) printf(\u0026#34;can\u0026#39;t send spi message\u0026#34;); return ret; } int spidev_data_rw(char *dev, int len, char *buffer) { char *rbuf; int res = 0; int fd = -1; int i = 0; fd = open(dev, O_RDWR); if (fd \u0026lt; 0) { printf(\u0026#34;Error:cannot open device \u0026#34; \u0026#34;(Maybe not present in your board?)\\n\u0026#34;); return -1; } res = ioctl(fd, SPI_IOC_WR_MODE, \u0026amp;mode); if (res == -1) { printf(\u0026#34;can\u0026#39;t set spi mode\u0026#34;); goto exit; } res = ioctl(fd, SPI_IOC_RD_MODE, \u0026amp;mode); if (res == -1) { printf(\u0026#34;can\u0026#39;t set spi mode\u0026#34;); goto exit; } /* * bits per word */ res = ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, \u0026amp;bits_per_word); if (res == -1) { printf(\u0026#34;can\u0026#39;t set bits per word\u0026#34;); goto exit; } res = ioctl(fd, SPI_IOC_RD_BITS_PER_WORD, \u0026amp;bits_per_word); if (res == -1) { printf(\u0026#34;can\u0026#39;t get bits per word\u0026#34;); goto exit; } /* * max speed hz */ res = ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, \u0026amp;speed); if (res == -1) { printf(\u0026#34;can\u0026#39;t set max speed hz\u0026#34;); goto exit; } res = ioctl(fd, SPI_IOC_RD_MAX_SPEED_HZ, \u0026amp;speed); if (res == -1) { printf(\u0026#34;can\u0026#39;t get max speed hz\u0026#34;); goto exit; } printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;spi mode: %d\\n\u0026#34;, mode); printf(\u0026#34;bits per word: %d\\n\u0026#34;, bits_per_word); printf(\u0026#34;max speed: %d Hz (%d KHz)\\n\\n\u0026#34;, speed, speed/1000); rbuf = malloc(len); memset(rbuf, 0, len); res = transfer(fd, buffer, rbuf, len); if (res \u0026lt; 0) { printf(\u0026#34;Failed transferring data: %d\\n\u0026#34;, errno); free(rbuf); close(fd); return -1; } for(i=0; i\u0026lt;len; i++) { printf(\u0026#34;Data recived buffer[%d] = 0x%02x\\n\u0026#34;, i, rbuf[i]); } free(rbuf); exit: close(fd); return 0; } int main(int argc, char **argv) { char *spi_dev; int bytes, len; int res; int i; unsigned char tmp[4]; if (argc \u0026lt;= 1) { help_info(argv[0]); return 1; } mode = 0; for(i = 1; i \u0026lt; argc; i++) { if(!strcmp(argv[i], \u0026#34;-D\u0026#34;)) { i++; spi_dev = argv[i]; } else if(!strcmp(argv[i], \u0026#34;-s\u0026#34;)) { i++; speed = atoi(argv[i]); } else if(!strcmp(argv[i], \u0026#34;-b\u0026#34;)) { i++; bits_per_word = atoi(argv[i]); } else if(!strcmp(argv[i], \u0026#34;-H\u0026#34;)) mode |= SPI_CPHA; else if(!strcmp(argv[i], \u0026#34;-O\u0026#34;)) mode |= SPI_CPOL; else if(!strcmp(argv[i], \u0026#34;-C\u0026#34;)) mode |= SPI_CS_HIGH; else if((i != (argc - 1))) { printf(\u0026#34;invalid parameter\\n\u0026#34;); help_info(argv[0]); return -1; } } // 获得最后一个参数的长度，单位是 byte ，并将数据全部放入 buffer bytes = strlen((char *)argv[argc - 1]); if (bytes \u0026lt; 1) { printf(\u0026#34;invalid parameter for buffer size\\n\u0026#34;); help_info(argv[0]); return -1; } buffer = malloc(BUF_MAX_SIZE); memset(buffer, 0, BUF_MAX_SIZE); strcpy(buffer, (char *)argv[argc-1]); // 将字符转换为十六进制数字 for(i=0; i\u0026lt;bytes/2; i++) { tmp[0] = charToHexNum(buffer[i*2]); tmp[0] = tmp[0]\u0026lt;\u0026lt;4; tmp[1] = charToHexNum(buffer[i*2+1]); buffer[i] = tmp[0] + tmp[1]; printf(\u0026#34;Data send buffer[%d] = 0x%02x\\n\u0026#34;, i, buffer[i]); } len = i; printf(\u0026#34;Data send buffer len = 0x%x\\n\u0026#34;, len); res = spidev_data_rw(spi_dev, len, buffer); free(buffer); return res; } ","date":"2021 April 10","permalink":"/posts/2021/04/10/","section":"Posts","summary":"SPI 通信协议 #SPI 的全称是 Serial Peripheral Interface，是一个带时钟同步的全双工串行链接，使用主/从结构，用于连接微控制器和传感器、存储器和外设。常见的连接结构如下：","title":"Linux 系统的 SPI 设备编程"},{"content":"以 NXP 的 Yocto Linux 4.9.88 为例。\nSystemd 管理系统资源的基本单元是 Unit ，分为 12 种：\nService unit：系统服务 Target unit：多个 Unit 构成的一个组 Device Unit：硬件设备 Mount Unit：文件系统的挂载点 Automount Unit：自动挂载点 Path Unit：文件或路径 Scope Unit：不是由 Systemd 启动的外部进程 Slice Unit：进程组 Snapshot Unit：Systemd 快照，可以切回某个快照 Socket Unit：进程间通信的 socket Swap Unit：swap 文件 Timer Unit：定时器 我们可以使用 systemd-analyze 命令来分析系统启动的过程：\n# 查看启动耗时 $ systemd-analyze # 查看每个服务的启动耗时 $ systemd-analyze blame # 显示瀑布状的启动过程流 $ systemd-analyze critical-chain # 显示指定服务的启动流 $ systemd-analyze critical-chain atd.service # 将系统启动流程输出为 svg 格式，可以通过浏览器查看 systemd-analyze plot \u0026gt; ./systemd.svg Systemd 使用 Target 替换了 init 启动模式的 runlevel 概念。常用的分析命令：\n# 查看当前系统的所有 Target $ systemctl list-unit-files --type=target # 查看一个 Target 包含的所有 Unit $ systemctl list-dependencies multi-user.target # 查看启动时的默认 Target $ systemctl get-default # 设置启动时的默认 Target $ systemctl set-default multi-user.target # 切换 Target 时，默认不关闭前一个 Target 启动的进程，systemctl isolate 命令可以改变这种行为，它会关闭前一个 Target 里面所有不属于后一个 Target 的进程 $ systemctl isolate multi-user.target 常用的两个 Target 是：\nmulti-user.target , 多用户文本界面 graphical.target , 图形界面，在 multi-user.target 的基础上，增加了图形界面的相关单元。 系统登录 #虚拟控制台（tty1\u0026hellip;）的登录是 getty@.service 服务维护的，最终调用的是 agetty ：\nExecStart=-/sbin/agetty -o \u0026#39;-p -- \\\\u\u0026#39; --noclear %I $TERM 启动服务时通过 @ 符号向 agetty 传递一个参数，例如执行 getty@tty1.service ，启动的进程就是：\n/sbin/agetty -o -p -- \\u --noclear tty1 linux 串口控制台的登录是 serial-getty@.service 服务维护的，最终调用的也是 agetty ：\nExecStart=-/sbin/agetty -8 -L %I 115200 $TERM 这里传递的参数应该是串口设备文件，例如 serial-getty@ttymxc0.service 。\nagetty 有很多参数，\u0026ndash;noclear 表示清除控制台显示的启动信息：\n-J, --noclear Do not clear the screen before prompting for the login name. By default the screen is cleared. -a 用于自动登录：\n-a, --autologin username Automatically log in the specified user without asking for a username or password. Using this option causes an -f username option and argument to be added to the /bin/login command line. See --login-options, which can be used to modify this option\u0026#39;s behavior. Note that --autologin may affect the way in which getty initializes the serial line, because on auto-login agetty does not read from the line and it has no opportunity optimize the line setting. 要系统启动时在串口控制台自动登录 root 用户，可以做如下操作：\n新建 /etc/systemd/system/serial-getty@ttymxc0.service.d/ 目录。 在上面新建的目录中添加 autologing.conf 文件。 在 autologing.conf 文件中添加如下内容： [Service] ExecStart= ExecStart=-/sbin/agetty -a root -8 -L %I 115200 $TERM 这里利用的是 systemd 的附加配置片段功能，这个功能可以修改、重置或者追加配置选项。先创建名为 /etc/systemd/system/\u0026lt;Unit\u0026gt;.d/ 的目录，然后放入 *.conf 文件，其中可以添加或重置选项参数，这里设置的参数优先级高于原来的 Unit 配置文件。用 systemctl 命令会更简单：\n$ systemctl edit unit 这将会在编辑器中打开文件 /etc/systemd/system/[unit].d/override.conf，编辑完成之后自动加载。\n基于 X11 的 Qt 应用自启动 #系统中启动 Qt 的服务是 xserver-nodm ，是通过 Yocto 的 xserver-nodm-init_3.0.bb 安装的。启动后调用了如下脚本：\nxserver-nodm.service /etc/xserver-nodm/Xserver - /etc/default/xserver-nodm 初始化一些环境变量 exec xinit /etc/X11/Xsession -- $XSERVER $DISPLAY $ARGS $* xinit /etc/X11/Xsession -- /usr/bin/Xorg :0 -br -pn 最终干活的是 xinit ，这是 X Window 系统的启动器，它的功能是启动一个 X Server ，同时启动一个 X Client ，基本语法是：\nxinit [ [ client ] options ] [ -- [ server ] [ display ] options ] 在这里它执行了 /etc/X11/Xsession 脚本，Xsession 会按字母顺序执行 /etc/X11/Xsession.d 下面的脚本，在脚本内启动 Qt 应用，默认安装时会有很多：\n$ ls /etc/X11/Xsession.d/ 13xdgbasedirs.sh 30xinput_calibrate.sh 70settings-daemon.sh 80matchboxkeyboard.sh 89xdgautostart.sh 90XWindowManager.sh 我们可以修改这里的脚本，来启动自己的 Qt 应用。例如，我们只想启动 /home/root/ 下的 basiclayouts ，可以将 /etc/X11/Xsession.d/ 下的文件全部删掉，然后新建一个 10qtapp.sh ，内容如下：\nexec /home/root/basiclayouts 重启系统，basiclayouts 就会自动启动。\n文本界面的程序自启动 #默认情况下，系统启动的是图形目标：\n$ systemctl get-default graphical.target 如不不需要图形界面，可以切换到多用户文本目标：\n$ systemctl set-default multi-user.target Removed /etc/systemd/system/default.target. Created symlink /etc/systemd/system/default.target → /lib/systemd/system/multi-user.target. systemd 通过 rc-local.service 调用 /etc/rc.local 。需要开机时实现的程序，可以添加到 rc.local 文件中。\n","date":"2021 March 6","permalink":"/posts/2021/03/06/","section":"Posts","summary":"以 NXP 的 Yocto Linux 4.","title":"Systemd 中实现自动登录和程序自启动"},{"content":"1. 概述 #NXP 为官方评估板 i.MX6ULL EVK 提供了完整的 Yocto 项目源码和文档 ，板卡的外观和接口如图：\n特性：\n参考板是 iMX6ULL EVK ：https://www.nxp.com/design/development-boards/i-mx-evaluation-and-development-boards/evaluation-kit-for-the-i-mx-6ull-and-6ulz-applications-processor:MCIMX6ULL-EVK 芯片是 NXP 的 iMX6ULL : https://www.nxp.com/products/processors-and-microcontrollers/arm-processors/i-mx-applications-processors/i-mx-6-processors:IMX6X_SERIES 软件使用最新的 Linux 5.4.47_2.2.0 : https://www.nxp.com/design/software/embedded-software/i-mx-software/embedded-linux-for-i-mx-applications-processors:IMXLINUX 2. 构建系统 #我们先为这个板卡编译一个可以运行的系统。\n2.1. 准备宿主机 #使用 Ubuntu 20.04 （至少要用 18.04 ，低版本系统会遇到很多问题），安装必要的开发包：\n$ sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib \\ build-essential chrpath socat cpio python python3 python3-pip python3-pexpect \\ xz-utils debianutils iputils-ping python3-git python3-jinja2 libegl1-mesa libsdl1.2-dev \\ pylint3 xterm 安装 repo :\n$ sudo curl https://storage.googleapis.com/git-repo-downloads/repo \u0026gt; /usr/bin/repo $ sudo chmod +x /usr/bin/repo 需要设置 git 账户：\n$ git config --global user.name \u0026#34;Your Name\u0026#34; $ git config --global user.email \u0026#34;Your Email\u0026#34; 新建一个工程目录，然后开始拉取源码：\n$ mkdir imx-yocto-bsp-5.4.47 $ cd imx-yocto-bsp-5.4.47 $ repo init -u https://source.codeaurora.org/external/imx/imx-manifest -b imx-linux-zeus -m imx-5.4.47-2.2.0.xml $ repo sync 拉取过程需要连接 google 和 github 的服务器，所以必须翻墙。有些远程仓库使用 git:// 下载很慢，可以修改 .repo/manifests/imx-5.4.47-2.2.0.xml 文件中的 URL ，替换成 https:// 加快下载速度。中途如果卡住，可以结束进程后重新执行 repo sync 。也可以在 repo sync 命令中添加 -j4 选项，开启四线程下载，加快下载速度。\n拉取成功后，会提示 repo sync has finished successfully. ，所有源码会放在 imx-yocto-bsp-5.4.47/sources 目录下:\n~/imx-yocto-bsp-5.4.47$ ls -l total 12 lrwxrwxrwx 1 sbs sbs 19 Nov 20 05:55 README -\u0026gt; sources/base/README lrwxrwxrwx 1 sbs sbs 23 Nov 20 05:55 README-IMXBSP -\u0026gt; sources/meta-imx/README drwxrwxr-x 3 sbs sbs 4096 Nov 20 07:08 downloads lrwxrwxrwx 1 sbs sbs 43 Nov 20 05:55 imx-setup-release.sh -\u0026gt; sources/meta-imx/tools/imx-setup-release.sh lrwxrwxrwx 1 sbs sbs 30 Nov 20 05:55 setup-environment -\u0026gt; sources/base/setup-environment drwxrwxr-x 16 sbs sbs 4096 Nov 20 05:55 sources 2.2. 配置 #NXP 提供了一个脚本 imx-setup-release.sh，它简化了 i.MX 机器的设置。语法：\n[MACHINE=\u0026lt;machine\u0026gt;] [DISTRO=fsl-imx-\u0026lt;backend\u0026gt;] source ./imx-setup-release.sh -b \u0026lt;build folder\u0026gt; MACHINE 表示目标机的硬件名称，当前版本支持的硬件可以在 meta-imx/README 文件中查看，实际上是指向了 meta-imx/meta-bsp/conf/machine 目录下的相应配置文件。对于 i.MX 6ULL EVK 开发板，要设为 imx6ull14x14evk 。 DISTRO 是发行版的名称，需要设置为 meta-imx/meta-sdk/conf/distro 目录下存在的配置文件（不用带后缀），这个配置文件设置了该发行版包含哪些软件。当前版本支持发行版有： fsl-imx-fb.conf，支持 framebuff 图像界面的系统 fsl-imx-wayland.conf，支持 wayland 协议的系统 fsl-imx-x11.conf，支持 x11 协议的系统 fsl-imx-xwayland.conf，同时支持 x11 和 wayland 的系统 build folder 用于指定编译目录，每个发行版都应该有独立的编译目录，编译过程中产生的所有文件都会输出到这个目录下。 在 imx-yocto-bsp-5.4.47 目录下执行：\nMACHINE=imx6ull14x14evk DISTRO=fsl-imx-fb source ./imx-setup-release.sh -b imx6ullevk-fb 根据提示接受 EULA 协议，执行成功后，会自动进入 imx-yocto-bsp-5.4.47/imx6ullevk-fb 目录，所有的配置文件都位于 conf 目录下：\nbblayers.conf 包含了本发行版所需的所有 layer ，编译时，会到这些 layer 下找相应的 recipe 。 local.conf 包含了一些编译设置选项，比如指定了硬盘平台的 MACHINE 变量。 2.3. 编译 #官方提供了多种编译目标，可以根据需要选择，或者在此基础上修改：\n这里编译一个基础版本：\n$ bitbake core-image-base 网络良好的情况下，大约需要 5 小时。下载的软件包源码都位于 imx-yocto-bsp-5.4.47/downloads 目录下。如果出现类似如下的错误，通常是网络连接的问题，确保可以访问 www.example.com 后即可正常编译：\nFetcher failure for URL: \u0026#39;https://www.example.com/\u0026#39;. URL https://www.example.com/ doesn\u0026#39;t work. 2.4. 烧写 #编译成功后，输出的文件位于 tmp/deploy/images/imx6ull14x14evk 目录下，用于 SD/MMC/eMMC 的镜像压缩文件是 core-image-base-imx6ull14x14evk.wic.bz2，它包含了 U-boot ，设备树，内核和根文件系统，可以用如下命令直接写入 SD 卡：\n$ bunzip2 -dk -f \u0026lt;image_name\u0026gt;.wic.bz2 $ sudo dd if=\u0026lt;image name\u0026gt;.wic of=/dev/sd\u0026lt;partition\u0026gt; bs=1M conv=fsync 默认的 .wic 镜像上的 rootfs 被限制在 4GB 以下，但重新分区和重新加载 rootfs 可以将其增加到卡的大小。默认情况下，该版本对SD卡上的镜像使用以下布局。内核映像和 DTB 移动到使用 FAT 分区，在 SD 卡上没有固定的原始地址。如果需要固定的原始地址，用户必须改变 U-Boot 的启动环境。\n为了灵活使用，也有可以单独烧写的组件：\nu-boot-imx6ull14x14evk.imx，U-boot 文件 imx6ull-14x14-evk-emmc-imx6ull14x14evk.dtb ，设备树文件 zImage-imx6ull14x14evk.bin， 内核文件 core-image-base-imx6ull14x14evk.tar.bz2 ，根文件系统压缩文件。 上面这些文件通常是一个软链接，每次编译后都会指向最新编译生成的实际文件。关于单独烧写的详细信息可以参考 i.MX Linux® User\u0026rsquo;s Guide (IMXLUG) 中的 \u0026ldquo;4.3 Preparing an SD/MMC card to boot\u0026rdquo; 。如果要烧写到板载的 eMMC ，通常是用 UUU 工具，通过 USB-OTG 接口烧写。\n2.5. 安装 # 将 TF卡安装到 CPU 板的 MicroSD 插槽（J301） 用 USB 线缆（Micro-B 转标准-A）连接开发板的调试 USB 口（J1901 ）和电脑的 USB 口，在电脑的设备管理器上可以看到串口设备（需要安装驱动）： 在电脑上打开一个串口终端，比如 putty ，按如下配置： 波特率： 115200 数据位： 8 停止位： 1 奇偶校验：无 流控制：无 将 CPU 板的启动模式选择开关（SW602）设为 D1:ON、 D2:OFF ，启动设备选择开关（SW601）设为 D1:OFF、 D2:OFF、 D3:ON、 D4:OFF ，表示从 TF 卡启动： 连接电源，将电源开关（SW2001）滑至 ON ，系统即开始启动，在串口终端软件上可以看到启动过程。 启动完毕后会看到登录提示符，用户名是 root ，无密码。 3. 使用 UUU #Universal Update Utility（UUU）是 MFGTools 的最新演进版(也叫做 MFGTools v3)，可以在 Win10 64bit 和 Ubuntu 16.14 64bit 以上版本的主机上运行，是NXP官方开发的镜像烧写工具，我们主要是用它通过 USB-OTG 接口将各种系统镜像组件烧写到板载的 eMMC 。可以在 https://github.com/NXPmicro/mfgtools/releases 下载软件和文档，当前版本是 1.4.43 。\n3.1. 准备 #需要将板上的 SD 卡取出，换成 eMMC ，然后将启动模式改为串行下载器（SW602:D1:OFF,D2:ON)。使用 USB-OTG 数据线将板载的 OTG 接口连接到电脑。 在电脑端打开 PowerShell 环境，进入 uuu 程序的目录，执行 uuu.exe -lsusb ，会列出识别到的 USB Device ：\nPS D:\\NXP_iMX6\\UUU\u0026gt; .\\uuu.exe -lsusb uuu (Universal Update Utility) for nxp imx chips -- libuuu_1.4.43-0-ga9c099a Connected Known USB Devices Path Chip Pro Vid Pid BcdVersion ================================================== 1:4 MX6ULL SDP: 0x15A2 0x0080 0x0001 可以将调试串口也连接到电脑，会有信息打印输出。\n3.2. 烧写 BootLoader #以烧写 u-boot 为例，将 u-boot 镜像文件放在 uuu 程序的目录下，然后执行 uuu.exe -b emmc \u0026lt;bootloader\u0026gt; ，立即开始烧写，烧写成功显示如下：\nPS D:\\NXP_iMX6\\UUU\u0026gt; .\\uuu.exe -b emmc .\\u-boot-sd-optee-2020.04-r0.imx uuu (Universal Update Utility) for nxp imx chips -- libuuu_1.4.43-0-ga9c099a Success 1 Failure 0 1:6 7/ 7 [Done ] FB: Done 在电脑的串口终端也可以调试串口打印的详细烧写过程：\nU-Boot 2020.04-5.4.47-2.2.0+gffc3fbe7e5 (Nov 23 2020 - 03:48:29 +0000) CPU: i.MX6ULL rev1.1 900 MHz (running at 396 MHz) CPU: Commercial temperature grade (0C to 95C) at 43C Reset cause: POR Model: i.MX6 ULL 14x14 EVK Board Board: MX6ULL 14x14 EVK DRAM: 512 MiB MMC: FSL_SDHC: 0, FSL_SDHC: 1 Loading Environment from MMC... *** Warning - bad CRC, using default environment [*]-Video Link 0 (480 x 272) [0] lcdif@21c8000, video In: serial Out: serial Err: serial switch to partitions #0, OK mmc1(part 0) is current device flash target is MMC:1 Net: Warning: ethernet@20b4000 using MAC address from ROM eth1: ethernet@20b4000 [PRIME]Get shared mii bus on ethernet@2188000 Warning: ethernet@2188000 using MAC address from ROM, eth0: ethernet@2188000 Fastboot: Normal Boot from USB for mfgtools *** Warning - Use default environment for mfgtools, using default environment Run bootcmd_mfg: run mfgtool_args;if iminfo ${initrd_addr}; then if test ${tee} = yes; then bootm ${tee_addr} ${initrd_addr} ${fdt_addr}; else bootz ${loadaddr} ${initrd_addr} ${fdt_addr}; fi; else echo \u0026#34;Run fastboot ...\u0026#34;; fastboot 0; fi; Hit any key to stop autoboot: 0 ## Checking Image at 86800000 ... Unknown image format! Run fastboot ... switch to partitions #0, OK mmc1(part 0) is current device Starting download of 543744 bytes .... downloading of 543744 bytes finished writing to partition \u0026#39;bootloader\u0026#39; Initializing \u0026#39;bootloader\u0026#39; switch to partitions #1, OK mmc1(part 1) is current device Writing \u0026#39;bootloader\u0026#39; MMC write: dev # 1, block # 2, count 1062 ... 1062 blocks written: OK Writing \u0026#39;bootloader\u0026#39; DONE! 烧写完毕后，将启动模式设为 eMMC 启动（SW602:D1:ON,D2:OFF; SW601:D1:OFF,D2:ON,D3:ON,D4:OFF），然后按下复位键，主板复位，在串口终端可以看到 u-boot 的启动信息：\nU-Boot 2020.04-5.4.47-2.2.0+gffc3fbe7e5 (Nov 23 2020 - 03:48:29 +0000) CPU: i.MX6ULL rev1.1 900 MHz (running at 396 MHz) CPU: Commercial temperature grade (0C to 95C) at 47C Reset cause: POR Model: i.MX6 ULL 14x14 EVK Board Board: MX6ULL 14x14 EVK DRAM: 512 MiB MMC: FSL_SDHC: 0, FSL_SDHC: 1 Loading Environment from MMC... *** Warning - bad CRC, using default environment [*]-Video Link 0 (480 x 272) [0] lcdif@21c8000, video In: serial Out: serial Err: serial switch to partitions #0, OK mmc1(part 0) is current device flash target is MMC:1 Net: Warning: ethernet@20b4000 using MAC address from ROM eth1: ethernet@20b4000 [PRIME]Get shared mii bus on ethernet@2188000 Warning: ethernet@2188000 using MAC address from ROM, eth0: ethernet@2188000 Fastboot: Normal Normal Boot Hit any key to stop autoboot: 0 =\u0026gt; 3.3. 烧写系统镜像 #烧写系统镜像的语法是 uuu.exe -b emmc_all \u0026lt;bootloader\u0026gt; \u0026lt;rootfs.wic.bz2\u0026gt; ,例如：\nPS D:\\NXP_iMX6\\UUU\u0026gt; .\\uuu.exe -b emmc_all .\\u-boot-sd-optee-2020.04-r0.imx .\\core-image-base-imx6ull14x14evk-20201123024550.rootfs.wic.bz2 uuu (Universal Update Utility) for nxp imx chips -- libuuu_1.4.43-0-ga9c099a Success 1 Failure 0 1:6 8/ 8 [Done ] FB: done 烧写完毕后，将启动模式设为 eMMC 启动（SW602:D1:ON,D2:OFF; SW601:D1:OFF,D2:ON,D3:ON,D4:OFF），然后按下复位键，主板复位，在串口终端可以看到系统启动信息。\nU-Boot 2020.04-5.4.47-2.2.0+gffc3fbe7e5 (Nov 23 2020 - 03:48:29 +0000) CPU: i.MX6ULL rev1.1 900 MHz (running at 396 MHz) CPU: Commercial temperature grade (0C to 95C) at 43C Reset cause: POR Model: i.MX6 ULL 14x14 EVK Board Board: MX6ULL 14x14 EVK DRAM: 512 MiB MMC: FSL_SDHC: 0, FSL_SDHC: 1 Loading Environment from MMC... *** Warning - bad CRC, using default environment [*]-Video Link 0 (480 x 272) [0] lcdif@21c8000, video In: serial Out: serial Err: serial switch to partitions #0, OK mmc1(part 0) is current device flash target is MMC:1 Net: Warning: ethernet@20b4000 using MAC address from ROM eth1: ethernet@20b4000 [PRIME]Get shared mii bus on ethernet@2188000 Warning: ethernet@2188000 using MAC address from ROM, eth0: ethernet@2188000 Fastboot: Normal Boot from USB for mfgtools *** Warning - Use default environment for mfgtools, using default environment Run bootcmd_mfg: run mfgtool_args;if iminfo ${initrd_addr}; then if test ${tee} = yes; then bootm ${tee_addr} ${initrd_addr} ${fdt_addr}; else bootz ${loadaddr} ${initrd_addr} ${fdt_addr}; fi; else echo \u0026#34;Run fastboot ...\u0026#34;; fastboot 0; fi; Hit any key to stop autoboot: 0 ...... NXP i.MX Release Distro 5.4-zeus imx6ull14x14evk ttymxc0 imx6ull14x14evk login: 4. 使用 U-boot #内核和文件系统还可以使用 u-boot 下载。\n5. Yocto系统开发 #Yocto系统开发的学习过程可以参考 https://www.yoctoproject.org/docs/what-i-wish-id-known/ 。\n前面是使用官方提供的配置编译出系统镜像，通常我们需要根据实际情况定制自己的系统。在 Yocto 工程中，工作开始之前，都应该初始化编译环境，语法是：source setup-environment \u0026lt;build dir\u0026gt; 。\n5.1. OpenEmbedded #Yocto 是一个开源合作项目，它帮助开发人员创建基于 Linux 的定制系统，使用 OpenEmbedded 开发模型构建。\n几个概念：\nLayers ，中文可以叫做层。Layer 被用来分类不同的任务单元。某些任务单元有共同的特性，可以放在一个 Layer 下，方便模块化组织元数据，也方便日后修改。例如要定制一套支持特定硬件的系统，可以把与低层相关的单元放在一个 layer 中，这叫做 Board Support Package(BSP) Layer 。 Configuration ，中文叫做配置。Configuration 文件的后缀是 .conf ，它会在很多地方出现，定义了多种变量，包括硬件架构选项、编译器选项、通用配置选项、用户配置选项。主 Configuration 文件是 bitbake.conf ，以 Yocto 为例，位于 ./poky/meta/conf/bitbake.conf ，其他都在源码树的 conf 目录下。 Classes ，中文叫做类。Class 文件的后缀是 .bbclass ，它的内容是元数据文件之间的共享信息。BitBake 源码树都源自一个叫做 base.bbclass 的文件，在 Yocto 中位于 ./poky/meta/classes/base.bbclass ，它会被所有的 recipe 和 class 文件自动包含。它包含了标准任务的基本定义，例如获取、解压、配置、编译、安装、打包，有些定义只是框架，内容是空的。 Recipe ，中文叫做菜单或者配方。Recipe 文件是最基本的元数据文件，每个任务单元对应一个 Recipe 文件，后缀是 .bb ，这种文件为 BitBake 提供的信息包括软件包的基本信息（作者、版本、License等）、依赖关系、源码的位置和获取方法、补丁、配置和编译方法、如何打包和安装。 Append ，中文叫做追加。Append 文件的后缀是 .bbappend ，用于扩展或者覆盖 recipe 文件的信息。BitBake 希望每一个 append 文件都有一个相对应的 recipe 文件，两个文件使用同样的文件名，只是后缀不同，例如 formfactor_0.0.bb 和 formfactor_0.0.bbappend 。命名 append 文件时，可以用百分号（%）来通配 recipe 文件名。例如，一个名为 busybox_1.21.%.bbappend 的 apend 文件可以对应任何名为 busybox_1.21.x.bb 的 recipe 文件进行扩展和覆盖，文件名中的 x 可以为任何字符串，比如 busybox_1.21.1.bb、busybox_1.21.2.bb … 通常用百分号来通配版本号。 OpenEmbedded 的工作流如下：\n参考：https://www.yoctoproject.org/docs/3.1.2/overview-manual/overview-manual.html\n5.2. 目录结构 #通常情况下，我们会使用一个硬件原厂发布的 BPS 源码编译系统镜像，BSP 源码包含了 Yocto 项目的参考发行版 poky 包，还有原厂加入的扩展包，当完成了第一次系统构建后，工程目录下的文件结构大致如下：\nimx-yocto-bsp-5.4.47 ├── downloads # bitbake 下载的软件包都放在这里 ├── imx6ullevk-fb # 工作目录，编译过程产生的所有文件都在这里，我们自己添加的源码也应该放在这里。 ├── imx-setup-release.sh # 配置脚本 ├── README ├── README-IMXBSP ├── setup-environment # 用于初始化编译环境的脚本 └── sources # 原厂官方提供的 BSP 源码，通常不要直接修改这个目录下的文件。 ├── base # 原厂添加的包 ├── meta-browser ├── meta-freescale ├── meta-freescale-3rdparty ├── meta-freescale-distro ├── meta-imx ├── meta-openembedded ├── meta-python2 ├── meta-qt5 ├── meta-rust ├── meta-timesys └── poky # Yocto 项目的主仓库 下载的软件包都放在 downloads 目录下，并生成一个后缀为 .done 的空文件，表示指定的包已经下载完毕。如果使用 bitbake 下载某个包失败，也可以手动下载，然后放到 downloads 路径下，并新建一个 .done 文件，这样 bitbake 工作时就会任务 fetch 任务已经完成。\npoky 是 yocto 项目的参考发行版，官方文档都是基于这个包讲解的，单独使用这个包可以构建一个运行在 QEMU 虚拟机上的系统。它包含了构建系统所需的核心包，比如 Linux 内核的 recipe 。\nmeta-openembedded 提供很多扩展包。meta-imx 和 meta-freescale* 都是 NXP 官方提供的，针对硬件的扩展。\n我们需要在此基础上添加或者修改一些包，完成自己的特定需求。这时，建议在工作目录下新建一个 layer ，在 layer 中包含自己的 append (.bbappend) 文件和 recipe(.bb)文件，来完成相应的工作，尽量不要修改 sources 目录下的文件。\n源码目录结构的详细信息可以查看 https://www.yoctoproject.org/docs/3.0.4/ref-manual/ref-manual.html#ref-structure 。\n5.3. Bitbake #Bitbake 手册：https://www.yoctoproject.org/docs/3.1.2/bitbake-user-manual/bitbake-user-manual.html\nOpenEmbedded 构建系统时使用的生产工具是 BitBake ，是用 Python 写的一个程序，现在有很多嵌入式系统都是在使用，比如Yocto 、WindRiver Linux 等。它是一个多任务引擎，可以并行执行 shell 和 Python 任务，每个任务单元根据预定义的元数据来管理源码、配置、编译、打包，并最终将每个任务生成的文件集合成为系统镜像。例如要从源码构建一个 Linux 系统，需要搭建一个生产环境，然后依次生成 Grub、Kernel、各种库文件、各种可执行文件，然后集合到一个文件系统里。如果你玩过 LFS ，就会了解这个过程的复杂性。BitBake 存在的意义就是提供了一个高效的工具，将这个过程标准化、流程化。BitBake 与 GNU Make 的关系就像 GNU Make 之于 GCC ，运作方式也类似 GNU Make ，又有很多不同：\nBitBake 根据预先定义的元数据执行任务，这些元数据定义了执行任务所需的变量，执行任务的过程，以及任务之间的依赖关系，它们存储在 recipe(.bb)、append(.bbappend)、configuration(.conf)、include(.inc) 和 class(.bbclass) 文件中。 BitBake 包含一个抓取器，用于从不同的位置获取源码，例如本地文件、源码控制器(git)、网站等。 每一个任务单元的结构通过 recipe 文件描述，描述的信息有依赖关系、源码位置、版本信息、校验和、说明等等。 BitBake 包含了一个 C/S 的抽象概念，可以通过命令行或者 XML-RPC 使用，拥有多种用户接口。 执行 bitbake -s 命令可以列出当前项目中所有可构建的包和版本。构建一个包的最简单方法是执行 bitbake \u0026lt;package_name\u0026gt; ，Bitbake 会搜索这个包的 recipe 文件，找到后就解析 recipe 中的配置选项，然后依次执行如下任务（task）。\nFetch\u0026ndash;从远程或者本地获取源码 Extract\u0026ndash;将源码解压到指定的工作目录下，之后所有的构建工作都在这个工作目录下进行 Patch\u0026ndash;为错误修复和新功能应用补丁文件 Configure\u0026ndash;进行编译前的配置工作 Compile\u0026ndash;编译和链接 Install\u0026ndash;将文件复制到目标目录下 Package\u0026ndash;生成安装包 也可以通过 -c 参数执行单独的任务，例如只下载源码可以执行 bitbake \u0026lt;package_name\u0026gt; -c fetch 。所有任务可以在 https://www.yoctoproject.org/docs/3.0.4/ref-manual/ref-manual.html#ref-tasks 查询。常用的任务选项有：\nfetch ，下载源码 unpack ，解压源码 patch ， 打补丁 configure ，配置 compile ，编译 clean ，删除最终输出的文件 clearsstate ，删除编译过程产生的所有文件 cleanall ，删除所有文件，包括下载的源码包，编译过程的缓存文件和最终的输出文件。 此外，执行 listtasks 选项可以查看所有可用的任务，例如查看 linux-imx 的任务列表和描述：\nbitbake linux-imx -c listtasks 执行 bitbake -e \u0026lt;package\u0026gt; 可以解析特定包的配置选项。例如查找 Linux 内核的包名称和版本可以执行：\n~/imx-yocto-bsp-5.4.47/imx6ullevk-fb$ bitbake -s | grep linux binutils-crosssdk-x86_64-pokysdk-linux :2.32.0-r0 cryptodev-linux :1.10-r0 cryptodev-linux-native :1.10-r0 gcc-crosssdk-x86_64-pokysdk-linux :9.2.0-r0 go-crosssdk-x86_64-pokysdk-linux :1.12.9-r0 linux-atm :2.5.2-r0 linux-firmware 1:20190815-r0 linux-imx :5.4-r0 linux-imx-headers :5.4-r0 linux-imx-mfgtool :4.14.98-r0 很明显，linux-imx 就是当前项目的 Linux 内核，然后先定位 recipe 文件的位置：\n~/imx-yocto-bsp-5.4.47/imx6ullevk-fb$ bitbake -e linux-imx | grep ^FILE= FILE=\u0026#34;/home/sbs/imx-yocto-bsp-5.4.47/sources/meta-imx/meta-bsp/recipes-kernel/linux/linux-imx_5.4.bb\u0026#34; 有时候，我们还需要知道这个 recipe 依赖的 conf、bbclass 、bbappend 等文件，可以通过 BBINCLUDED 变量获得：\n~/imx-yocto-bsp-5.4.47/imx6ullevk-fb$ bitbake -e linux-imx | grep ^BBINCLOUD= 然后我们可以定位构建这个包时的工作目录：\n~/imx-yocto-bsp-5.4.47/imx6ullevk-fb$ bitbake -e linux-imx | grep ^WORKDIR= WORKDIR=\u0026#34;/home/sbs/imx-yocto-bsp-5.4.47/imx6ullevk-fb/tmp/work/imx6ull14x14evk-poky-linux-gnueabi/linux-imx/5.4-r0\u0026#34; 定义源码解压后的位置：\n~/imx-yocto-bsp-5.4.47/imx6ullevk-fb$ bitbake -e linux-imx | grep ^S= S=\u0026#34;/home/sbs/imx-yocto-bsp-5.4.47/imx6ullevk-fb/tmp/work/imx6ull14x14evk-poky-linux-gnueabi/linux-imx/5.4-r0/git\u0026#34; 定位源码的编译目录：\n~/imx-yocto-bsp-5.4.47/imx6ullevk-fb$ bitbake -e linux-imx | grep ^B= B=\u0026#34;/home/sbs/imx-yocto-bsp-5.4.47/imx6ullevk-fb/tmp/work/imx6ull14x14evk-poky-linux-gnueabi/linux-imx/5.4-r0/build\u0026#34; 工作目录下还有几个重要的文件夹：\nimage ，存放这要安装到目标系统的文件，而且是按照安装路径存放。 deploy ，存放 rpm ，deb 等格式的安装包 tmp ，存放了构建过程中执行的所有任务指令，已经执行过程的日志。 BitBake 执行任务的顺序由其任务调度器控制。${WORKDIR}/tmp/ 目录下，以 run_ 开头的文件记录了每个任务解析后的详细内容，以 log_ 开头的文件记录任务执行时的日志，log.task_order 文件按顺序记录了当前目标执行了哪些任务。\n关于 recipe 文件中其他选项的含义可以查看 https://www.yoctoproject.org/docs/3.0.4/ref-manual/ref-manual.html#ref-varlocality-recipes 。\n5.4. 新建 Layer #新建 layer 的过程可以手动完成，但是推荐使用 bitbake-layers 脚本的create-layer子命令来简化创建过程。基本的语法是 bitbake-layers create-layer \u0026lt;your_layer_name\u0026gt; ，这条命令会按默认的模式新建如下文件：\n一个名为 your_layer_name 的文件夹，注意，layer 的名称应该以 meta- 为前缀，且不要与已有的 layer 重名。\n一个配置文件 conf/layer.conf ，内容如下：\n# We have a conf and classes directory, add to BBPATH BBPATH .= \u0026#34;:${LAYERDIR}\u0026#34; # We have recipes-* directories, add to BBFILES BBFILES += \u0026#34;${LAYERDIR}/recipes-*/*/*.bb \\ ${LAYERDIR}/recipes-*/*/*.bbappend\u0026#34; BBFILE_COLLECTIONS += \u0026#34;mylayer\u0026#34; BBFILE_PATTERN_mylayer = \u0026#34;^${LAYERDIR}/\u0026#34; BBFILE_PRIORITY_mylayer = \u0026#34;6\u0026#34; LAYERDEPENDS_mylayer = \u0026#34;core\u0026#34; LAYERSERIES_COMPAT_mylayer = \u0026#34;warrior zeus\u0026#34; BBPATH：将 layer 的根目录添加到 BitBake 的搜索路径中。通过使用 BBPATH 变量，BitBake可以定位类文件（.bbclass）、配置文件以及包含在 include 和 require 语句中的文件。在这些情况下，BitBake 会使用第一个与 BBPATH 中找到的文件名相匹配的文件。这与 PATH 变量用于二进制文件的方式类似。因此，建议你在自定义层中使用唯一的类和配置文件名。 BBFILES: 定义 layer 中所有 recipes 的位置。 BBFILE_COLLECTIONS：定义了当前层中所有配方的位置。通过独特的标识符建立当前层，该标识符在整个OpenEmbedded构建系统中用于引用该层。在本例中，标识符 \u0026ldquo;yoctobsp\u0026rdquo; 是名为 \u0026ldquo;meta-yocto-bsp\u0026rdquo; 的容器层的表示。 BBFILE_PATTERN: 在解析过程中立即展开，提供层的目录。 BBFILE_PRIORITY: 建立了一个优先级，当 OpenEmbedded 构建发现不同层中的同名配方时，该层中的配方将被使用。 LAYERVERSION：为图层建立一个版本号，你可以在使用 LAYERDEPENDS 变量时使用这个版本号来指定这个图层的确切版本作为依赖关系。当使用 LAYERDEPENDS 变量时，你可以使用这个版本号来指定这个层的确切版本作为依赖关系。 LAYERDEPENDS: 列出这个图层所依赖的所有图层（如果有的话）。 LAYERSERIES_COMPAT: 列出当前版本兼容的 Yocto 项目版本。这个变量是表明你的图层是否是当前版本的好方法。 一个 recipes-example 子目录，其中包含了另一个名为 example 的子目录，其中包含了一个 example.bb 配方文件\n一个 COPYING.MIT ，这是该层的许可证声明。脚本假设你想对图层本身的内容使用 MIT 许可证，这对大多数图层来说是典型的。\n一个 README 文件，这是一个描述新图层内容的文件。\n我们新建一个名为 meta-mylayer 的层：\n$ bitbake-layers create-layer meta-mylayer 新建完毕后，需要根据 layer 的类型，添加内容。如果该层添加了对机器的支持，则在该层的conf/machine/文件中添加机器配置。如果该层增加了发行版策略，就把发行版配置添加到该层内的conf/distro/ 文件中。如果图层引入了新的配方，把你需要的配方放在图层内的 recipes-* 子目录中。\n要想 bitbake 编译时找到这个新建的 layer ，还需要把它添加到 conf/bblayers.conf 文件的 BBLAYERS 变量中，例如：\nBBLAYERS += \u0026#34;${BSPDIR}/imx6ullevk-fb/meta-mylayer\u0026#34; 这一步也可以使用脚本完成：\n$ bitbake-layers add-layer meta-mylayer BitBake按照 BBLAYERS 变量的设置，自上而下地解析每个 conf/layer.conf 文件。在处理每个 conf/layer.conf 文件的过程中，BitBake会将特定层中包含的配方、类和配置添加到源目录中。\n有些工作可能已经有前人做过了，我们可以在 OpenEmbedded Metadata Index 下查找特定功能 layer ，拿来直接用。\n5.5. 自定义系统镜像 #自定义系统镜像主要是修改构建系统的源码，定制输出到目标镜像的文件，有很多种方式，比如修改 con/local.conf 文件，这里的修改是全局性的，会所有的镜像生效，不利于项目的工程化管理，最好的方式依然是在自定义的 layer 中添加对源码的修改。例如，要定制 fsl-image-machine-test 生成的镜像，就可以新建一个 image-machine-test.bbappend 文件进行修改。\n5.5.1. 添加或删除包 #定制系统时,经常要添加一个包到目标镜像中，或者从目标镜像里删除一个已有的包。Yocto 构建系统镜像时，主要是通过 IMAGE_INSTALL 和 IMAGE_IMAGE_FEATURES 两个变量来确定目标镜像要安装那些包，以构建 fsl-image-machine-test 系统镜像为例：\n$ bitbake -e fsl-image-machine-test | grep ^IMAGE_INSTALL= IMAGE_INSTALL=\u0026#34; packagegroup-core-boot packagegroup-base-extended packagegroup-fsl-gstreamer1.0 packagegroup-fsl-gstreamer1.0-full packagegroup-fsl-tools-gpu packagegroup-fsl-tools-gpu-external packagegroup-fsl-tools-testapps packagegroup-fsl-tools-benchmark packagegroup-fsl-optee-imx\u0026#34; $ bitbake -e fsl-image-machine-test | grep ^IMAGE_FEATURES IMAGE_FEATURES=\u0026#34;debug-tweaks package-management tools-profile tools-testapps\u0026#34; IMAGE_FEATURES_REPLACES_ssh-server-openssh=\u0026#34;ssh-server-dropbear\u0026#34; IMAGE_INSTALL 设置了安装到目标镜像的包和包组，包组就是一些相关的包的集合，它们都是通过 .bb 文件定义的。如果要向目标镜像添加包，可以用 _append 语法（参考 Bitbake user manual）向 IMAGE_INSTALL 变量中追加内容，例如：\nIMAGE_INSTALL_append = \u0026#34; vim\u0026#34; 也可以用 _remove 语法从 IMAGE_INSTALL 变量中删除已有的内容，例如：\nIMAGE_INSTALL_remove = \u0026#34;packagegroup-fsl-tools-testapps\u0026#34; IMAGE_FEATURES 设置了目标镜像的特性，不止是包和包组，这些特性来自于 IMAGE_FEATURES 的定义，假设 :\nFEATURE_PACKAGES_widget = \u0026#34;package1 package2\u0026#34; 那么，如果 IMAGE_FEATURES 中包含了 widget ，就包含了 package1 和 package2 。例如：\n$ bitbake -e fsl-image-machine-test | grep ^FEATURE_PACKAGES FEATURE_PACKAGES_eclipse-debug=\u0026#34;packagegroup-core-eclipse-debug\u0026#34; FEATURE_PACKAGES_hwcodecs=\u0026#34;\u0026#34; FEATURE_PACKAGES_nfs-client=\u0026#34;packagegroup-core-nfs-client\u0026#34; FEATURE_PACKAGES_nfs-server=\u0026#34;packagegroup-core-nfs-server\u0026#34; FEATURE_PACKAGES_package-management=\u0026#34;dpkg apt\u0026#34; FEATURE_PACKAGES_splash=\u0026#34;psplash\u0026#34; FEATURE_PACKAGES_ssh-server-dropbear=\u0026#34;packagegroup-core-ssh-dropbear\u0026#34; FEATURE_PACKAGES_ssh-server-openssh=\u0026#34;packagegroup-core-ssh-openssh\u0026#34; FEATURE_PACKAGES_tools-debug=\u0026#34;packagegroup-core-tools-debug\u0026#34; FEATURE_PACKAGES_tools-profile=\u0026#34;packagegroup-core-tools-profile\u0026#34; FEATURE_PACKAGES_tools-sdk=\u0026#34;packagegroup-core-sdk packagegroup-core-standalone-sdk-target\u0026#34; FEATURE_PACKAGES_tools-testapps=\u0026#34;packagegroup-core-tools-testapps\u0026#34; FEATURE_PACKAGES_x11=\u0026#34;packagegroup-core-x11\u0026#34; FEATURE_PACKAGES_x11-base=\u0026#34;packagegroup-core-x11-base\u0026#34; FEATURE_PACKAGES_x11-sato=\u0026#34;packagegroup-core-x11-sato\u0026#34; IMAGE_FEATURES 中定义的 tools-testapps 就表示 packagegroup-core-tools-testapps ，可以在源码目录中直接搜索这个包组的 .bb 文件：\n$ find ./ -name \u0026#34;packagegroup-core-tools-testapps*\u0026#34; ./poky/meta/recipes-core/packagegroups/packagegroup-core-tools-testapps.bb ./meta-imx/meta-sdk/recipes-fsl/packagegroup/packagegroup-core-tools-testapps.bbappend 我们也可以用 _append 和 _remove 语法修改 IMAGE_FEATURES 变量的内容，Yocto 提供的可选项可以参考 Feature Image 。\n如果我们想删除的包没有显示在 IMAGE_INSTALL 和 IMAGE_IMAGE_FEATURES 的定义里，通常是被封装到了包组里面，这时，可以用 PACKAGE_EXCLUDE 变量设置：\nPACKAGE_EXCLUDE = \u0026#34;package_name package_name package_name ...\u0026#34; 这些列出的包都不会被安装到目标镜像中。这里可能会出现一个问题，如果其他一些包依赖于这里列出的包（即在 RDEPENDS 变量中列出），构建时会报错，必须接触相应的依赖关系。以删除 connman 为例：\nPACKAGE_EXCLUDE = \u0026#34;connman\u0026#34; 构建时会出现如下错误：\n$ bitbake fsl-image-machine-test ... Some packages could not be installed. This may mean that you have requested an impossible situation or if you are using the unstable distribution that some required packages have not yet been created or been moved out of Incoming. The following information may help to resolve the situation: The following packages have unmet dependencies: packagegroup-core-tools-testapps : Depends: connman-client but it is not going to be installed Depends: connman-tools but it is not going to be installed E: Unable to correct problems, you have held broken packages. ... packagegroup-core-tools-testapps 包组里的 connman-client 和 connman-tools 都依赖于 connman ，在 packagegroup-core-tools-testapps.bb 文件中可以看到：\nRDEPENDS_${PN} = \u0026#34;\\ blktool \\ ${KEXECTOOLS} \\ alsa-utils-amixer \\ alsa-utils-aplay \\ ltp \\ connman-tools \\ connman-tests \\ connman-client \\ ${@bb.utils.contains(\u0026#39;DISTRO_FEATURES\u0026#39;, \u0026#39;x11\u0026#39;, \u0026#34;${X11TOOLS}\u0026#34;, \u0026#34;\u0026#34;, d)} \\ ${@bb.utils.contains(\u0026#39;DISTRO_FEATURES\u0026#39;, \u0026#39;x11 opengl\u0026#39;, \u0026#34;${X11GLTOOLS}\u0026#34;, \u0026#34;\u0026#34;, d)} \\ ${@bb.utils.contains(\u0026#39;DISTRO_FEATURES\u0026#39;, \u0026#39;3g\u0026#39;, \u0026#34;${3GTOOLS}\u0026#34;, \u0026#34;\u0026#34;, d)} \\ \u0026#34; 可以新建一个 packagegroup-core-tools-testapps.bbappend 文件，使用 _remove 语法将其删除：\nRDEPENDS_${PN}_remove = \u0026#34;connman-tools connman-tests connman-client\u0026#34; 修改完毕后，可以使用 bitbake 的 -g 选项生成目标的依赖关系：\nbitbake -g fsl-image-machine-test 它会在当前目录下生成两个文件，pn-buildlist 列出了生成目标所依赖的所有包，我们可以在这里快速的检查删减和增加的操作是否成功，task-depends.dot 记录了所有任务的依赖关系，可以用 Graphviz 打开，进行图形化的阅览。\n5.5.2. 自定义 recipe #我们也可以新建一个系统镜像的 recipe ，添加自己需要的特性。例如，在 meta-freescale-distro/recipes-fsl/images 目录下新建一个 fsl-image-custom.bb 文件，然后添加如下内容：\nLICENSE = \u0026#34;MIT\u0026#34; # 声明许可证 inherit core-image # 继承 core-image 类 IMAGE_INSTALL_append = \u0026#34; package-name\u0026#34; # 添加的包 5.5.3. 自定义包组 #包组（packagegroup）就是按特定需求把几个包组合成一个变量，以 packagegroup- 为前缀，在类似 meta*/recipes*/packagegroups/packagegroup*.bb的文件中定义。以 poky/meta/recipes-core/packagegroups/packagegroup-base.bb 文件为例，文件内通过 PACKAGES 变量列出了要产生的包组，然后再用 RDEPENDS 和 RRECOMMENDS 项设置每个包组所包含的软件包。\n下面是一个简单的例子，我们自定义一个名为 packagegroup-custom.bb 的 recipe 文件：\nDESCRIPTION = \u0026#34;My Custom Package Groups\u0026#34; inherit packagegroup PACKAGES = \u0026#34;\\ ${PN}-apps \\ ${PN}-tools \\ \u0026#34; RDEPENDS_${PN}-apps = \u0026#34;\\ dropbear \\ portmap \\ psplash\u0026#34; RDEPENDS_${PN}-tools = \u0026#34;\\ oprofile \\ oprofileui-server \\ lttng-tools\u0026#34; RRECOMMENDS_${PN}-tools = \u0026#34;\\ kernel-module-oprofile\u0026#34; ${PN} 是替代文件名（packagegroup-custom）的变量，所以，这里是定义了两个包组：packagegroup-custom-apps 和 packagegroup-custom-tools ，然后用 RDEPENDS_${PN}-* 设置了每个包组依赖的软件包。如果只想定义一般包组，可以不用 PACKAGES 变量，​${PN} 即是包组的名称，用 RDEPENDS_${PN} 设置包组依赖的软件包。\n5.5.4. 自定义 hostname #Linux 系统在 /etc/hostname 文件中定义了 hostname ，默认情况下，Yocto 是在 base-files_*.bb 文件中定义 hostname 的：\n# By default the hostname is the machine name. If the hostname is unset then a # /etc/hostname file isn\u0026#39;t written, suitable for environments with dynamic # hostnames. # # The hostname can be changed outside of this recipe by using # hostname_pn-base-files = \u0026#34;my-host-name\u0026#34;. hostname = \u0026#34;${MACHINE}\u0026#34; 默认值是 ${MACHINE} 定义在 conf/local.conf 文件中。有两种方法重写定义 hostname 的值。你可以新增一个 base-files_*.bbappend 文件，在其中添加：\nhostname=\u0026#34;myhostname\u0026#34; 或者在 conf/local.conf 中添加：\nhostname_pn-base-files = \u0026#34;myhostname\u0026#34; 5.5.5. 自定义 /etc/issue 和 /etc/issue.net #Linux 系统在用户登录时会显示欢迎信息，通常是一些关于系统版本的说明，这些信息定义在 /etc/issue 和 /etc/issue.net 两个文件中。在 Yocto 中，这两个文件的内容也是在 base-files_*.bb 文件中定义的：\n​``` BASEFILESISSUEINSTALL ?= \u0026#34;do_install_basefilesissue\u0026#34; ...... DISTRO_VERSION[vardepsexclude] += \u0026#34;DATE\u0026#34; do_install_basefilesissue () { install -m 644 ${WORKDIR}/issue* ${D}${sysconfdir} if [ -n \u0026#34;${DISTRO_NAME}\u0026#34; ]; then printf \u0026#34;${DISTRO_NAME} \u0026#34; \u0026gt;\u0026gt; ${D}${sysconfdir}/issue printf \u0026#34;${DISTRO_NAME} \u0026#34; \u0026gt;\u0026gt; ${D}${sysconfdir}/issue.net if [ -n \u0026#34;${DISTRO_VERSION}\u0026#34; ]; then distro_version_nodate=\u0026#34;${@d.getVar(\u0026#39;DISTRO_VERSION\u0026#39;).replace(\u0026#39;snapshot-${DATE}\u0026#39;,\u0026#39;snapshot\u0026#39;).replace(\u0026#39;${DATE}\u0026#39;,\u0026#39;\u0026#39;)}\u0026#34; printf \u0026#34;%s \u0026#34; $distro_version_nodate \u0026gt;\u0026gt; ${D}${sysconfdir}/issue printf \u0026#34;%s \u0026#34; $distro_version_nodate \u0026gt;\u0026gt; ${D}${sysconfdir}/issue.net fi printf \u0026#34;\\\\\\n \\\\\\l\\n\u0026#34; \u0026gt;\u0026gt; ${D}${sysconfdir}/issue echo \u0026gt;\u0026gt; ${D}${sysconfdir}/issue echo \u0026#34;%h\u0026#34; \u0026gt;\u0026gt; ${D}${sysconfdir}/issue.net echo \u0026gt;\u0026gt; ${D}${sysconfdir}/issue.net fi } do_install_basefilesissue[vardepsexclude] += \u0026#34;DATE\u0026#34; 欢迎信息是通过 do_install_basefilesissue() 函数添加到文件的，主要是记录了发行版的名称 ${DISTRO_NAME} 和版本号 ${DISTRO_VERSION} ，这两个变量的值可以直接查询：\n$ bitbake -e base-files | grep -E \u0026#34;^DISTRO_NAME=|^DISTRO_VERSION=\u0026#34; DISTRO_NAME=\u0026#34;NXP i.MX Release Distro\u0026#34; DISTRO_VERSION=\u0026#34;5.4-zeus\u0026#34; 我们可以新增一个 base-files_*.bbappend 文件，禁用 do_install_basefilesissue() 函数，然后添加自己的函数，例如：\nFILESEXTRAPATHS_prepend := \u0026#34;${THISDIR}/${PN}:\u0026#34; SRC_URI_prepend = \u0026#34; file://issue \\ file://issue.net \u0026#34; BASEFILESISSUEINSTALL = \u0026#34;do_install_basefilesissuecustom\u0026#34; do_install_basefilesissuecustom () { install -m 644 ${WORKDIR}/issue* ${D}${sysconfdir} } 5.5.6. 修改 rootfs 分区的大小 #我们的系统镜像文件使用 .wic 格式定义 SD/MMC 存储介质上的分区， .wic 是用 OpenEmbedded Kickstart(.wks) 生成的，支持 RAW 和 FileSystem两种分区方式，关于 .wks 的详细信息可以查看 kickstart-docs 。\n可以执行 bitbake -e core-image-base 导出当前镜像的所有元数据，在 _WKS_TEMPLATE 字段可以看到启动镜像在存储介质上的布局：\n# $_WKS_TEMPLATE # set image_types_wic.bbclass:112 [__anon_115__home_sbs_imx_yocto_bsp_5_4_47_sources_poky_meta_classes_image_types_wic_bbclass] # \u0026#34;# short-description: Create SD card image with a boot partition # # long-description: # # Create an image that can be written onto a SD card using dd for use # # with i.MX SoC family # # It uses u-boot # # # # The disk layout used is: # # - --------- -------------- -------------- # # | | u-boot | boot | rootfs | # # - --------- -------------- -------------- # # ^ ^ ^ ^ # # | | | | # # 0 1kiB 4MiB 16MiB + rootfs + IMAGE_EXTRA_SPACE (default 10MiB) # # # part u-boot --source rawcopy --sourceparams=\u0026#34;file=${UBOOT_BINARY}\u0026#34; --ondisk mmcblk --no-table --align 1 # part /boot --source bootimg-partition --ondisk mmcblk --fstype=vfat --label boot --active --align 4096 --size 16 # part / --source rootfs --ondisk mmcblk --fstype=ext4 --label root --align 4096 # # bootloader --ptable msdos # \u0026#34; _WKS_TEMPLATE=\u0026#34;# short-description: Create SD card image with a boot partition \\ 可见，U-boot 占了前面的 4MB ，boot 是一个 FAT 格式的分区，存放了设备树和内核文件，rootfs 是 ext4 分区，在宿主机的编译环境下也会保留一份根文件系统的拷贝，位于 IMAGE_ROOTFS 变量指定的路径：\n# $IMAGE_ROOTFS [2 operations] # set /home/sbs/imx-yocto-bsp-5.4.47/sources/poky/meta/conf/bitbake.conf:451 # \u0026#34;${WORKDIR}/rootfs\u0026#34; # set /home/sbs/imx-yocto-bsp-5.4.47/sources/poky/meta/conf/documentation.conf:219 # [doc] \u0026#34;The location of the root filesystem while it is under construction (i.e. during do_rootfs).\u0026#34; # pre-expansion value: # \u0026#34;${WORKDIR}/rootfs\u0026#34; IMAGE_ROOTFS=\u0026#34;/home/sbs/imx-yocto-bsp-5.4.47/imx6ullevk-fb/tmp/work/imx6ull14x14evk-poky-linux-gnueabi/core-image-base/1.0-r0/rootfs\u0026#34; rootfs 之后的存储空间都可能成为未使用的空间而被浪费，我们可以修改 rootfs 分区的大小，使其占满整个 SD/MMC 的存储空间。\nrootfs 分区的大小是由一套算法决定的,可以表示如下：\nif (image-du * overhead) \u0026lt; rootfs-size: internal-rootfs-size = rootfs-size + xspace else: internal-rootfs-size = (image-du * overhead) + xspace where: image-du = Returned value of the du command on the image. overhead = IMAGE_OVERHEAD_FACTOR rootfs-size = IMAGE_ROOTFS_SIZE xspace = IMAGE_ROOTFS_EXTRA_SPACE internal-rootfs-size = Initial root filesystem size before any modifications. 该算法涉及三个变量：\n初始磁盘空间 IMAGE_ROOTFS_SIZE 开销系数 IMAGE_OVERHEAD_FACTOR 额外可用空间 IMAGE_ROOTFS_EXTRA_SPACE 构建系统首先运行 du 命令来确定 rootfs 目录树的磁盘使用量（image-du）。如果 IMAGE_ROOTFS_SIZE 当前值大于磁盘使用量（image-du）乘以开销系数（IMAGE_OVERHEAD_FACTOR），则只增加额外的空间（IMAGE_ROOTFS_EXTRA_SPACE）。如果 IMAGE_ROOTFS_SIZE 小于磁盘使用量乘以开销系数，则在添加额外空间之前，先将磁盘使用量乘以开销系数。\nIMAGE_ROOTFS_SIZE 变量必须设置一个默认值，单位是 KBytes ，这个默认值通常很低，因为它只是初始化，并在每次生成镜像时根据实际大小需求进行更新。以 core-image-base 镜像为例，默认值是 65536 KBytes ：\n# $IMAGE_ROOTFS_SIZE [2 operations] # set /home/sbs/imx-yocto-bsp-5.4.47/sources/poky/meta/conf/documentation.conf:221 # [doc] \u0026#34;Defines the size in Kbytes for the generated image.\u0026#34; # set /home/sbs/imx-yocto-bsp-5.4.47/sources/poky/meta/conf/bitbake.conf:783 # [_defaultval] \u0026#34;65536\u0026#34; # pre-expansion value: # \u0026#34;65536\u0026#34; IMAGE_ROOTFS_SIZE=\u0026#34;65536\u0026#34; 开销系数的默认值是 1.3 ，也就是在 rootfs 中预留 30% 的空间给用户安装软件，额外空间默认为 0 ：\n# $IMAGE_OVERHEAD_FACTOR [2 operations] # set? /home/sbs/imx-yocto-bsp-5.4.47/sources/poky/meta/conf/bitbake.conf:460 # \u0026#34;1.3\u0026#34; # set /home/sbs/imx-yocto-bsp-5.4.47/sources/poky/meta/conf/documentation.conf:216 # [doc] \u0026#34;Defines a multiplier that the build system applies to the initial image size for cases when the multiplier times the returned disk usage value for the image is greater than the sum of IMAGE_ROOTFS_SIZE and IMAGE_ROOTFS_EXTRA_SPACE.\u0026#34; # pre-expansion value: # \u0026#34;1.3\u0026#34; IMAGE_OVERHEAD_FACTOR=\u0026#34;1.3\u0026#34; # # $IMAGE_ROOTFS_EXTRA_SPACE [2 operations] # set? /home/sbs/imx-yocto-bsp-5.4.47/sources/poky/meta/conf/bitbake.conf:465 # \u0026#34;0\u0026#34; # set /home/sbs/imx-yocto-bsp-5.4.47/sources/poky/meta/conf/documentation.conf:220 # [doc] \u0026#34;Defines additional free disk space created in the image in Kbytes. By default, this variable is set to \u0026#39;0\u0026#39;.\u0026#34; # pre-expansion value: # \u0026#34;0\u0026#34; IMAGE_ROOTFS_EXTRA_SPACE=\u0026#34;0\u0026#34; 所以，扩大 rootfs 分区大小有多种方法。\n修改开销系数，比如在 conf/local.conf 中添加：IMAGE_OVERHEAD_FACTOR = \u0026ldquo;1.5\u0026rdquo; ，使 rootfs 分区有 50% 的空闲存储空间。 增加额外空间，比如在 conf/local.conf 文件中添加：IMAGE_ROOTFS_EXTRA_SPACE = \u0026ldquo;1048576\u0026rdquo; ，使 rootfs 直接多出 1GB 的空间。需要注意的是，这可能是 IMAGE_OVERHEAD_FACTOR 系数之后的额外空间。 直接设置 IMAGE_ROOTFS_SIZE ，使它足够大，可以占满存储介质的空间。 5.6. 添加新的 recipe #recipe（.bb文件）是 Yocto 项目环境中的基本组件。由 OpenEmbedded 构建系统构建的每个软件包都需要一个 recipe 来定义。我们可以从头开始手写 recipe ，或者参考别的 recipe 进行修改，例如在 http://layers.openembedded.org/layerindex/branch/master/layers/ 中有很多社区维护的recipe ，可以查找符合需求的拿来用。此外，OpenEmbedded 和 Yocto 分别提供了了 devtool 和 recipetool 两种工具来新建 recipe 。Recipe 文件的语法也可以参考 https://www.yoctoproject.org/docs/1.8/bitbake-user-manual/bitbake-user-manual.html 。下面是手写一个 recipe 的基本流程：\n5.6.1. 新建文件 #以移植 UCI 为例，因为 bitbake 是通过 conf/layer.conf 文件中定义的 BBFILES 变量来搜索 recipe 的，这个变量定义了搜索路径：\nBBFILES += \u0026#34;${LAYERDIR}/recipes-*/*/*.bb \\ ${LAYERDIR}/recipes-*/*/*.bbappend\u0026#34; 所以我们依次建立如下路径和文件：\nmeta-mylayer/recipes-example/uci meta-mylayer/recipes-example/uci/uci_git.bb recipe 文件的命名规范是 \u0026lt;packagename\u0026gt;_\u0026lt;version\u0026gt;-\u0026lt;revision\u0026gt;.bb :\npackagename 就是包的名字，名字中间不应该有下划线，可以用短横线，bitbake 会将其赋值给变量 PN version 是软件包的版本号，bitbake 会将其赋值给变量 PV revision 是修订版本号，bitbake 会将其赋值给变量 PR 例如 linux-imx_5.4.bb 。传统的开源软件都是以源码压缩包的形式，压缩包的文件名里就带有版本号，这样的命名就可以方便把版本号传递到 recipe 文件内部。对于 git 或者 svn 等形式发布的软件，可以直接用 git 或 svn 替代版本号的位置，例如 uci_git.bb 。向文件填入一些基本信息：\nSUMMARY = \u0026#34;UCI\u0026#34; DESCRIPTION = \u0026#34;OpenWrt Unified Configuration Interface\u0026#34; LICENSE = \u0026#34;GPLv2\u0026#34; SUMMARY 是对这个 recipe 的概述，不能超过 72 个字符。 DESCRIPTION 是对这个 recipe 的详细描述 LICENSE 是这个软件包的开源许可证 此时，recipe 文件已经可以被正确解析，查看一些基本的变量：\n$ bitbake -e uci | grep -E \u0026#34;^PN=|^PV=|^PR=\u0026#34; PN=\u0026#34;uci\u0026#34; PR=\u0026#34;r0\u0026#34; PV=\u0026#34;git\u0026#34; 下面开始编辑这个文件。\n5.6.2. 获取源码 #获取源码的过程是由 do_fetch 任务来完成，主要是通过 SRC_URI 变量控制，它可以指定源码的位置，获取源码的协议，源码的版本等。源码通常来源于三种途径：\n上游发布的源码压缩包，通常是 ftp 、http 等协议的下载地址。 通过版本控制服务器发布的源码，通常是 git 、svn 等协议下载地址。 本地源码树，源码文件就放在 recipe 文件的同层路径下，通常是用户自己开发的软件。 必须在 recipe 中定义 SRC_URI ，尽量不要使用硬编码，而要多用系统体用的变量，比如 poky/meta/recipes-connectivity/iw/iw_5.3.bb 中的定义：\nSRC_URI = \u0026#34;http://www.kernel.org/pub/software/network/iw/${BP}.tar.gz \\ BP 的含义就是 ${BPN}-${PV} ，BPN 是 PN 的另一个版本，它会去掉 PN 的一些特殊前后缀（比如lib32- 、-native等）。\n如果是通过 git 克隆的源码，还需要手动设置 SRCREV 和 PV 。SRCREV 是 git 仓库的 commit hash 值，bitbake 根据这个值调用 git 命令检出我们需要的版本。PV 的默认值就是 git ，最好手动设置一个具有版本意义的值，比如 /meta-openembedded/meta-oe/recipes-devtools/libubox/libubox_git.bb 中的定义：\nPV = \u0026#34;1.0.1+git${SRCPV}\u0026#34; 1.0.1+git 是自定义的字段，SRCPV 的值是 bitbake 自动生成的，主要使用了 SRCREV 的前十个字符。对于 git 协议，还可以设置其他参数来精确匹配想要的版本，例如：\nbranch，要克隆的分支，如果未设置，默认为 \u0026ldquo;master\u0026rdquo;。 tag，指定用于检出的标签，有些软件是用 tag 来标记版本的。 参数之间用分号隔开，例如：\nSRC_URI = \u0026#34;git://git.oe.handhelds.org/git/vip.git;tag=version-1\u0026#34; 对于远程下载的源码压缩包，bitbake 会尝试计算文件的校验和，然后与 recpie 中设置的 SRC_URI[md5sum] 和 SRC_URI[sha256sum] 进行对比，确保没有篡改或损坏，如果检验和不一致，会报错。还是以 poky/meta/recipes-connectivity/iw/iw_5.3.bb 中的定义为例：\nSRC_URI = \u0026#34;http://www.kernel.org/pub/software/network/iw/${BP}.tar.gz \\ file://0001-iw-version.sh-don-t-use-git-describe-for-versioning.patch \\ file://separate-objdir.patch \\ \u0026#34; SRC_URI[md5sum] = \u0026#34;6d4d1c0ee34f3a7bda0e6aafcd7aaf31\u0026#34; SRC_URI[sha256sum] = \u0026#34;175abbfce86348c0b70e778c13a94c0bfc9abc7a506d2bd608261583aeedf64a\u0026#34; 如果使用了本地的源码，源码文件要放在 recipe 文件旁边名为 ${BP}、${BPN} 或者 files 的文件夹中，然后用 file:// 协议指定相对路径，bitbake 会依次从 ${BP}、${BPN} 和 files 文件夹中按相对路径进行搜索。\n源码获取成功后，do_unpack 任务会把源码释放到 ${S} 变量指向的路径。S 的默认值是 ${ WORKDIR}/${ BPN}-${ PV} ，如果下载的是源码压缩包，并且压缩包的内部结构符合顶层子目录 ${BPN}-${PV} 的约定，那就不需要设置 S 。然而，压缩包不符合这个约定，或者是从 git 等版本管理服务器克隆的源码，就要手动设置 S ，比如 git 会将源码克隆到 ${WORKDIR}/git 路径下，就要在 recipe 中设置这个值。下面是获取和释放源码的示意图：\n我们需要在 uci_git.bb 中添加：\nSRC_URI = \u0026#34;git://git.openwrt.org/project/uci.git\u0026#34; SRCREV = \u0026#34;52bbc99f69ea6f67b6fe264f424dac91bde5016c\u0026#34; PV = \u0026#34;1.0.0+git${SRCPV}\u0026#34; S = \u0026#34;${WORKDIR}/git\u0026#34; 然后执行 unpack 任务，验证 recipe 是否正确：\nbitbake uci -c unpack 源码会释放到 tmp/work/cortexa7t2hf-neon-poky-linux-gnueabi/uci/1.0.0+gitAUTOINC+52bbc99f69-r0/git 路径下。\n5.6.3. 打补丁 #有时需要在获取源码后对其打补丁。SRC_URI 中提到的任何文件，如果其名称以 .patc 或 .diff结尾，或者是这些后缀的压缩版本(例如：diff.gz)，都会被视为补丁。do_patch 任务会自动应用这些补丁。\n构建系统应该能够使用\u0026quot;-p1 \u0026ldquo;选项来应用补丁 (即路径中的一个目录级别将被移除)。如果你的补丁需要剥离更多的目录级别，请使用补丁的 SRC_URI 条目中的 \u0026ldquo;striplevel\u0026rdquo; 选项指定级别数。另外，如果您的补丁需要应用在补丁文件中没有指定的特定子目录中，请使用条目中的 \u0026ldquo;patchdir \u0026ldquo;选项。\n如同在 SRC_URI 中使用 file:// 引用的本地文件一样，应该把补丁文件放在 recipe 文件旁边名为 ${BP}、${BPN} 或者 files 的文件夹中。\n5.6.4. 设置 License #应该在 recipe 中用 LICENSE 和 LIC_FILES_CHKSUM 设置版权许可证和许可证文件的校验和。\n软件通常会在源码包的某个文件中声明自己的许可证类型，比如 COPYING, LICENSE 和 README 等，查到许可证类型就可以设置 LICENSE ，对于标准许可证，使用 poky/meta/files/common-licenses/ 中的文件名，或者 meta/conf/licenses.conf 中定义的 SPDXLICENSEMAP 标志名即可，也可以使用自定义的许可证名称。然后用许可证文件的 md5 校验值设置 LIC_FILES_CHKSUM 。如果源码包里没有许可证文件，也可以用任意文件替代。或者用系统内的 License ，例如:\nLICENSE = \u0026#34;MIT\u0026#34; LIC_FILES_CHKSUM = \u0026#34;file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4f302\u0026#34; 我们需要在 uci_git.bb 中添加：\nLICENSE = \u0026#34;GPLv2\u0026#34; LIC_FILES_CHKSUM = \u0026#34;file://CMakeLists.txt;md5=5c39cc16168ed9d0e1603468508a6e2b\u0026#34; 5.6.5. 确定依赖关系 #大多数软件包都有一个它们所需要的其他软件包的简短列表，这就是所谓的依赖关系。这些依赖关系可分为两大类：构建时依赖关系，这是软件构建时需要的；运行时依赖关系，这是软件运行时需要安装在目标机上的。\n在 recipe 文件中，可以使用 DEPENDS 变量设置构建时的依赖关系，DEPENDS中指定的项目应该是其他 recipe 的名称。以 meta-openembedded/meta-oe/recipes-devtools/libubox/libubox_git.bb 为例：\nDEPENDS = \u0026#34;json-c\u0026#34; 另一个考虑因素是，configure 脚本可能会自动检查可选的依赖关系，并在发现这些依赖关系时启用相应的功能。这意味着，为了保证确定性，应该把这些依赖关系也显式地指定出来，或者明确地告诉 configure 脚本禁用这些功能。\n与构建时的依赖关系类似，可以 RDEPENDS 变量设置运行时的依赖关系，这些依赖关系是为了让包正确运行而必须安装的其他包。因为 RDEPENDS 变量适用于正在构建的包，所以你应该总是以带有包名的形式来使用这个变量（记住，一个 recipe 可以构建多个包）。例如，假设你正在构建一个依赖于perl包的开发包。在这种情况下，你会使用下面的RDEPENDS语句。\nRDEPENDS_${PN}-dev += \u0026#34;perl\u0026#34; uci 的编译和运行都依赖 libubox ，我们需要在 uci_git.bb 中添加：\nDEPENDS = \u0026#34;libubox\u0026#34; 5.6.6. 配置 #大部分软件在编译之前都需要进行配置，通常有如下三种情况：\nAutotools：如果源文件中有configure.ac文件，那么软件是使用 Autotools 构建的，recipe 文件里需要继承 autotools 类（inherit autotools），而且不必包含 do_configure 任务。但是，可能还是要做一些调整，可以设置 EXTRA_OECONF 或 PACKAGECONFIG_CONFARGS 来传递所需的配置选项。 CMake: 如果源文件中有一个 CMakeLists.txt 文件，那么你的软件是用 CMake 构建的，recipe文件需要继承 cmake 类（inherit cmake），而且不必包含do_configure任务。你可以通过设置 EXTRA_OECMAKE 来进行一些调整。 其他：其他情况就需要在你的 recipe 中提供一个do_configure任务。 uci 编译时默认需要 lua5.1 ，但是我们的系统没有安装 lua5.1 ，源码包中的 CMakeLists.txt 提供了 BUILD_LUA 选项，默认是 ON ，我们把这个特性关闭，执行 cmake 时就不会寻找 lua5.1 了：\ninherit cmake EXTRA_OECMAKE = \u0026#34;-DBUILD_LUA=OFF\u0026#34; 一旦配置成功，最好检查一下 log.do_configure 文件，以确保适当的选项已经启用。\n5.6.7. 编译 #配置成功后，系统会自动调用 do_compile 任务进行编译，如果没有报错，就不用做任何事情。如果编译步骤失败，需要分析失败原因，可能的原因有：\n并行构建失败。这些故障表现为间歇性错误，或报告说找不到应由构建过程其他部分创建的文件或目录。详细信息和解决方法可以参考 https://docs.yoctoproject.org/3.0.4/dev-manual/dev-manual.html#debugging-parallel-make-races 主机路径错误。当为目标机交叉编译时，使用了来自主机系统的不正确的头文件、库或其他文件时，就会发生该故障。要解决这个问题，请检查log.do_compile文件，以确定正在使用的路径，然后添加配置选项、应用补丁等。 错误的头文件和库文件。如果因为没有在 DEPENDS 中声明而缺少构建时的依赖关系，或者因为依赖关系存在，但构建过程用来查找文件的路径不正确，配置步骤没有检测到它，编译过程可能会失败。对于这两种失败的情况，编译过程都会报告无法找到文件。在这些情况下，需要回过头来向配置过程添加额外的选项。 5.6.8. 安装 #安装过程中，系统调用 do_install 任务生成的文件和目录结构复制到目标设备上的镜像位置。会将 ${S}、${B} 和 ${WORKDIR} 目录中的文件复制到 ${D} 目录中，以创建目标系统中的结构。对于使用 autotools 和 cmake 构建的软件包，系统会调用它们的 instal 指令执行安装任务，如果能够满足要求，就不用修改。其他情况则需要修改或者手写 do_install 任务。我们可以在 recipe 文件中定义一个 do_install 函数，然后添加安装指令。\n如果你的源码包有 Makefile 文件，并支持 make install 操作，需要在 do_install 中调用 oe_runmake install 指令执行安装操作，例如：\ndo_install () { oe_runmake install DESTDIR=${D} SBINDIR=${sbindir} MANDIR=${mandir} INCLUDEDIR=${includedir} } 如果要手动安装，必须先在 do_install 函数中使用 install -d 来创建 ${D} 下的目录。一旦这些目录存在，就可以使用 install 来手动安装文件到这些目录中。以 meta-openembedded/meta-networking/recipes-connectivity/mosquitto/mosquitto_1.6.7.bb 为例：\ndo_install() { oe_runmake \u0026#39;DESTDIR=${D}\u0026#39; install install -d ${D}${systemd_unitdir}/system/ install -m 0644 ${S}/service/systemd/mosquitto.service.notify ${D}${systemd_unitdir}/system/mosquitto.service install -d ${D}${sysconfdir}/mosquitto install -m 0644 ${D}${sysconfdir}/mosquitto/mosquitto.conf.example \\ ${D}${sysconfdir}/mosquitto/mosquitto.conf install -d ${D}${sysconfdir}/init.d/ install -m 0755 ${WORKDIR}/mosquitto.init ${D}${sysconfdir}/init.d/mosquitto sed -i -e \u0026#39;s,@SBINDIR@,${sbindir},g\u0026#39; \\ -e \u0026#39;s,@BASE_SBINDIR@,${base_sbindir},g\u0026#39; \\ -e \u0026#39;s,@LOCALSTATEDIR@,${localstatedir},g\u0026#39; \\ -e \u0026#39;s,@SYSCONFDIR@,${sysconfdir},g\u0026#39; \\ ${D}${sysconfdir}/init.d/mosquitto } 5.6.9. 使能系统服务 #如果希望软件安装后随系统开机启动，通常需要使能 SysVinit 或 Systemd 。\n对于 SysVinit服务，recipe 需要继承 update-rc.d 类，并设置INITSCRIPT_PACKAGES、INITSCRIPT_NAME和INITSCRIPT_PARAMS变量。详情参考 https://www.yoctoproject.org/docs/3.0.4/ref-manual/ref-manual.html#ref-classes-update-rc.d 。\n对于 Systemd 服务，首先要确保 DISTRO_FEATURES 中已经加入了 \u0026ldquo;systemd\u0026rdquo;，然后 recipe 需要继承 systemd 类。详情参考 https://www.yoctoproject.org/docs/3.0.4/ref-manual/ref-manual.html#ref-classes-systemd 。\n5.6.10. 打包 #如果使用了 cmake ，这一步也是自动的，否则需要写一个 do_package 函数。\n5.6.11 实例 #下面是一个简单实例，目录结构如下：\ntest-app |---files |---helloworld.c |---CMakeLists.txt |---test-app_0.1.bb 源码编译使用了 cmake ，CMakeLists.txt 的内容：\ncmake_minimum_required(VERSION 3.1) project(test-app) add_executable(helloworld helloworld.c) install(TARGETS helloworld DESTINATION bin) 所以 recipe 文件非常简单：\nSUMMARY = \u0026#34;test app\u0026#34; DESCRIPTION = \u0026#34;interface test application\u0026#34; LICENSE = \u0026#34;MIT\u0026#34; LIC_FILES_CHKSUM = \u0026#34;file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4f302\u0026#34; inherit cmake S = \u0026#34;${WORKDIR}\u0026#34; SRC_URI = \u0026#34;file://helloworld.c \\ file://CMakeLists.txt \u0026#34; 这里源码文件只有两个，比较简单，如果源码很多，一个个的添加到 SRC_URI 非常麻烦，可以选择将源码打包成一个压缩包，例如 helloworld.tar.gz ，还是放在 files 目录下，然后直接添加：\nSRC_URI = \u0026#34;file://helloworld.tar.gz;md5=0374ade698e0bcf8509ecda2f7b4f404\u0026#34; 这样虽然方便，但是压缩包无法用 git 进行版本控制，所以，最好是在服务器上建立 git 仓库，然后通过 git 协议添加到 SRC_URI 。\n5.7. 使用 .bbappend 文件 #将元数据追加到另一个 recipe 的 recipe 称为 BitBake append 文件。一个 BitBake append文件使用 .bbappend 后缀，而相应的配方中的 Metadata 被附加到的配方使用 .bb 文件类型后缀。\n你可以在你的图层中使用 .bbappend 文件对另一个图层的配方内容进行添加或更改，而不必将另一个图层的配方复制到你的图层中。您的 .bbappend 文件位于您的图层中，而您要附加元数据的主.bb配方文件则位于另一个图层中。\n能够将信息追加到现有的配方中，不仅避免了重复，而且还能自动将不同层的配方更改应用到您的层中。如果你是复制配方，你将不得不在发生变化时手动合并。\n当你创建一个追加文件时，你必须使用与对应的配方文件相同的根名。例如，追加文件 someapp_3.1.2.bbappend 必须应用到 someapp_3.1.2.bb。这意味着原始配方和追加文件的名称是针对版本号的。如果重命名相应的配方以更新到较新的版本，你也必须重命名并可能更新相应的.bbappend。在构建过程中，如果 BitBake 检测到一个 .bbappend 文件，而该文件没有对应的配方与名称相匹配，则会在启动时显示一个错误。请参阅 BB_DANGLINGAPPENDS_WARNONLY 变量，了解如何处理这个错误。\n以 formfactor_0.0.bb 为例，位于meta/recipes-bsp/formfactor ：\nSUMMARY = \u0026#34;Device formfactor information\u0026#34; SECTION = \u0026#34;base\u0026#34; LICENSE = \u0026#34;MIT\u0026#34; LIC_FILES_CHKSUM = \u0026#34;file://${COREBASE}/meta/COPYING.MIT;md5=3da9cfbcb788c80a0384361b4de20420\u0026#34; PR = \u0026#34;r45\u0026#34; SRC_URI = \u0026#34;file://config file://machconfig\u0026#34; S = \u0026#34;${WORKDIR}\u0026#34; PACKAGE_ARCH = \u0026#34;${MACHINE_ARCH}\u0026#34; INHIBIT_DEFAULT_DEPS = \u0026#34;1\u0026#34; do_install() { # Install file only if it has contents install -d ${D}${sysconfdir}/formfactor/ install -m 0644 ${S}/config ${D}${sysconfdir}/formfactor/ if [ -s \u0026#34;${S}/machconfig\u0026#34; ]; then install -m 0644 ${S}/machconfig ${D}${sysconfdir}/formfactor/ fi } 在 recipe 中，注意 SRC_URI 变量，它告诉 OpenEmbedded 构建系统在构建过程中在哪里找到文件。下面是 append 文件，名为 formfactor_0.0.bbappend ，来自meta-raspberrypi/recipes-bsp/formfactor :\nFILESEXTRAPATHS_prepend := \u0026#34;${THISDIR}/${PN}:\u0026#34; 默认情况下，构建系统使用 FILESPATH 变量来定位文件。这个 append 文件通过设置 FILESEXTRAPATHS 变量来扩展这些位置。在 .bbappend 文件中设置这个变量是将目录添加到构建系统用来查找文件的搜索路径中的最可靠和最推荐的方法。\n本例中的语句将目录扩展为包括 ${THISDIR}/${PN}，它的解析结果是在 append 文件所在的同一目录下的一个名为 formfactor 的目录（即 meta-raspberrypi/recipes-bsp/formfactor ）。这意味着你必须设置好支持的目录结构，它将包含你将从层中包含的任何文件或补丁。\n使用立即扩展赋值运算符 := 是很重要的，因为它引用了 thisdir 。尾部的冒号字符很重要，因为它确保列表中的项目保持冒号分隔。\n注意，BitBake 会自动定义 THISDIR 变量，你不应该自己设置这个变量。使用\u0026rdquo;_prepend \u0026ldquo;作为 FILESEXTRAPATHS 的一部分，可以确保你的路径会在最终列表中的其他路径之前被搜索到。另外，并不是所有的追加文件都会添加额外的文件。很多 append 文件只是为了添加构建选项而存在（例如systemd）。对于这些情况，你的 append 文件甚至不会使用 FILESEXTRAPATHS 语句。\n6. Yocto 内核开发 #参考：Linux Kernel Development Manual。进行开发工作之前，都要初始化开发环境：\nsource setup-environment imx6ullevk-fb/ 新建一个 layer ，用于开发，记得把它添加到 conf/bblayers.conf 例如：\nbitbake-layers create-layer meta-mylayer bitbake-layers add-layer meta-mylayer 然后在 meta-mylayer 下新建一个 recipes-kernel 文件夹，用于存放内核开发相关的 append 和 recipe 。\n6.1. 修改内核源码 #对内核源码的修改是通过 append 文件，使用补丁文件的形式添加修改内容。\n首先需要新建 append文件 。内核的 recipe 文件是 linux-imx_5.4.bb ，所以要新建如下目录和文件：\nmeta-mylayer/recipes-kernel/linux/ meta-mylayer/recipes-kernel/linux/linux-imx/ meta-mylayer/recipes-kernel/linux/linux-imx_5.4.bbappend 在 .bbappend 文件中添加\nFILESEXTRAPATHS_prepend := \u0026#34;${THISDIR}/${PN}:\u0026#34; 构建时，${THISDIR}/${PN} 会被替换为 meta-mylayer/recipes-kernel/linux/linux-imx ，构建系统会到该路径下搜索补丁文件。\n然后需要获取或者制作补丁。以修改 calibrate.c 文件添加内核打印信息为例，先进入内核源码目录 /tmp/work/imx6ull14x14evk-poky-linux-gnueabi/linux-imx/5.4-r0/git ，编辑 init/calibrate.c 文件的 calibrate_delay() 函数，添加如下 printk 函数：\nvoid calibrate_delay(void) { unsigned long lpj; static bool printed; int this_cpu = smp_processor_id(); printk(\u0026#34;*************************************\\n\u0026#34;); printk(\u0026#34;* *\\n\u0026#34;); printk(\u0026#34;* HELLO YOCTO KERNEL *\\n\u0026#34;); printk(\u0026#34;* *\\n\u0026#34;); printk(\u0026#34;*************************************\\n\u0026#34;); if (per_cpu(cpu_loops_per_jiffy, this_cpu)) { ... 使用 git 命令提交变更并生成补丁：\n$ git add init/calibrate.c $ git commit -m \u0026#34;calibrate.c - Added some printk statements\u0026#34; $ git format-patch -1 0001-calibrate.c-Added-some-printk-statements.patch 把生成的补丁文件放到 meta-mylayer/recipes-kernel/linux/linux-imx/ 路径下，并在 .bbappend 文件中添加：\nSRC_URI_append = \u0026#34; file://0001-calibrate.c-Added-some-printk-statements.patch\u0026#34; 执行如下命令，先清空内核编译目录，然后重新打补丁：\n$ bitbake linux-imx -c clean $ bitbake linux-imx -c patch 然后查看打过补丁的源码，确认补丁已经生效，即可执行编译：\n$ bitbake linux-imx 6.2. 修改内核配置 #源码准备完毕后，bitbake 会继续执行配置工作，如果要修改配置，需要手动执行 menuconfig ：\n$ bitbake linux-imx -c menuconfig 这一步就是执行内核编译时的 make menuconfig 操作，会打开一个交互界面，在这里修改配置：\n这里的配置来自于编译目录下的 .config 文件，如果是第一次编译，这个文件就是内核源码的 arch/arm/conifg 目录的某个 defconfig 文件的拷贝，具体是哪个文件，通常是在 recipe 文件的 do_config 任务中有说明。\n在 menuconfig 中修改完毕后，保存并推出。在编译目录 tmp/work/imx6ull14x14evk-poky-linux-gnueabi/linux-imx/5.4-r0/build/ 下面会生成更新后的 .config 文件，原有的 .config 被重命名为 .config.old 。然后调用 diffconfig 选项生成一个配置片段：\nbitbake linux-imx -c diffconfig 这一步就是对比 .config 和 .config.old 的区别，确定修改的内容，生成一个补丁文件，称之为配置片段，生成的文件位于内核构建目录下的 fragment.cfg 。我们可以把这个文件复制到 meta-mylayer/recipes-kernel/linux/linux-imx/ 目录下，然后在 linux-imx_5.4.bbappend 文件中添加：\nSRC_URI += \u0026#34;file://fragment.cfg\u0026#34; 最好为 fragment.cfg 更改一个有意义的文件名，因为通常会使用多个配置片段来添加不同类型的修改内容。\n在编译前，可以调用 kernel_configcheck 选项检查内核配置是否正确：\nbitbake linux-imx -c kernel_configcheck 在某些旧版本里，内核的 recipe 存在 bug，无法合并配置片段，可以参考如下方法解决。\nLinux 内核源码的 /scripts/kconfig/merge_config.sh 脚本提供了合并配置片段的功能，语法：\n$ ./merge_config.sh -h Usage: ./merge_config.sh [OPTIONS] [CONFIG [...]] -h display this help text -m only merge the fragments, do not execute the make command -n use allnoconfig instead of alldefconfig -r list redundant entries when merging fragments -y make builtin have precedence over modules -O dir to put generated output files. Consider setting $KCONFIG_CONFIG instead. Used prefix: \u0026#39;CONFIG_\u0026#39;. You can redefine it with $CONFIG_ environment variable. 我们可以在 linux-imx 的 .bbappend 文件中添加一个任务，让它在编译前利用 merge_config.sh 脚本合并配置片段：\ndo_merge_fragment() { if [ -f ${WORKDIR}/fragment.cfg ]; then ${S}/scripts/kconfig/merge_config.sh -m ${B}/.config ${WORKDIR}/fragment.cfg mv .config ${B}/.config fi } addtask merge_fragment before do_compile after do_configure 6.3. 编译外部驱动 #对于来自内核源码树之外的驱动，可以通过新建 recipe 的方式进行编译。以 sources/poky/meta-skeleton/recipes-kernel/hello-mod/hello-mod_0.1.bb 为例：\nSUMMARY = \u0026#34;Example of how to build an external Linux kernel module\u0026#34; LICENSE = \u0026#34;GPLv2\u0026#34; LIC_FILES_CHKSUM = \u0026#34;file://COPYING;md5=12f884d2ae1ff87c09e5b7ccc2c4ca7e\u0026#34; inherit module SRC_URI = \u0026#34;file://Makefile \\ file://hello.c \\ file://COPYING \\ \u0026#34; S = \u0026#34;${WORKDIR}\u0026#34; RPROVIDES_${PN} += \u0026#34;kernel-module-hello\u0026#34; 可以把这个文件复制到 meta-mylayer/recipes-kernel/ 下的相应文件夹里，更改一个有意义的名字，在此基础上进行修改。\n7. Yocto 应用开发 #Yocto 的应用开发有两种方式，一种是在 yocto 项目内新建 recipe ，另一种是导出 SDK ，然后使用 SDK 独立开发应用软件，第二种更方便一点。\n7.1. 安装 SDK #执行如下命令，生成扩展 SDK 安装脚本：\n~/imx-yocto-bsp-5.4.47/imx6ullevk-fb$ bitbake imx-image-multimedia -c populate_sdk 生成的脚本位于 tmp/deploy/sdk 目录下，执行这个脚本即可安装：\n~/imx-yocto-bsp-5.4.47/imx6ullevk-fb$ cd tmp/deploy/sdk/ ~/imx-yocto-bsp-5.4.47/imx6ullevk-fb/tmp/deploy/sdk$ ./fsl-imx-fb-glibc-x86_64-imx-image-multimedia-cortexa7t2hf-neon-imx6ull14x14evk-toolchain-5.4-zeus.sh 默认安装在 /opt 目录下。也可以把这个脚本复制到其他主机中执行。参考：Using the Standard SDK\n","date":"2020 December 12","permalink":"/posts/2020/12/12/","section":"Posts","summary":"1. 概述 #NXP 为官方评估板 i.","title":"在 i.MX 6ULL 上学习 Yocto"},{"content":"# 1. 安装 #Docker 的安装比较简单，访问 \u0026lt;www.docker.com\u0026gt; ，按照指引安装相应系统的版本即可。安装完毕后，我们先拉取 Redis 的镜像：\n$ docker pull redis 这个命令默认是拉取 Redis 官方的 Docker 镜像最新版，也可以在后面指定具体的版本：\n$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE docker101tutorial latest 8e9d20f8bd52 38 hours ago 27.3MB nginx alpine 6f715d38cfe0 2 weeks ago 22.1MB nginx latest 4bb46517cac3 2 weeks ago 133MB python alpine 44fceb565b2a 2 weeks ago 42.7MB redis latest 1319b1eaa0b7 3 weeks ago 104MB node 12-alpine 18f4bc975732 4 weeks ago 89.3MB 然后启动这个进行容器:\n$ docker run -itd --name redis -p 6379:6379 redis $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f0b825b877b8 redis \u0026#34;docker-entrypoint.s…\u0026#34; 1 hours ago Up Up 9 seconds 0.0.0.0:6379-\u0026gt;6379/tcp redis 最后，进入容器，使用 redis-cli 命令连接 Redis ：\n$ docker exec -it redis redis-cli 127.0.0.1:6379\u0026gt; ping PONG 127.0.0.1:6379\u0026gt; exit ","date":"2020 September 1","permalink":"/posts/2020/09/01/","section":"Posts","summary":"# 1.","title":"使用 Docker 学习 Redis"},{"content":"1. 工作原理 #epoll 是 Linux 独有的 I/O 多路复用机制，核心概念就是 epoll 实例，它是一个内核里的数据结构，从用户角度来看它可以简单的看做包含了两个队列：\ninterest list（或者叫epoll set），用户注册的感兴趣的描述符集合。 ready list，就绪的描述符集合，当有 I/O 就绪时，内核会自动将就绪的描述符加到 ready list 中。 在用户端的工作流程就是：\n向 interest list 注册感兴趣的文件描述符的 I/O 事件。 等待已注册的文件描述符就绪。 处理所有已经就绪的文件描述符。 2. 使用方法 #使用 epoll 时，需要包括头文件：\n#include \u0026lt;sys/epoll.h\u0026gt; 2.1 新建一个 epoll 实例 #int epoll_create(int size); epoll_create() 函数会新建一个 epoll 实例，然后返回一个文件描述符，作为 epoll 操作的句柄。从 Linux 2.6.8 开始， 参数 size 可以忽略，但是必须大于 0 。当不在需要这个描述符时，应该调用 close() 函数将其关闭。\n调用失败时，会返回一个负数。\n2.2 操作 epoll 实例 #int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 这是操作 epoll 实例的接口函数，用于添加、删除和修改 interest list 中监控的文件描述符。如果调用成功，会返回 0 ，如果失败，会返回一个负数，并设置 errno 。参数的含义：\n第一个参数 epfd 就是 epoll_create() 函数返回的文件描述符。 第二个参数表示操作类型，可选： EPOLL_CTL_ADD，将 fd 添加到 epfd 的 interest list 中。 EPOLL_CTL_MOD，从 interest list 中删除 fd 。 EPOLL_CTL_DEL，修改 fd 的监视事件。 第三个参数是需要监听的文件描述符。 第四个参数是需要监听的事件。 监视的事件通过 struct epoll_event 结构体设置：\ntypedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; 结构成员 data 由内核负责修改，当监视的文件描述符准备就绪时返回。结构成员 event 用于设置监视的事件类型，是一个枚举的集合，可以用 | 来增加多种事件类型，枚举如下：\nEPOLLIN 表示关联的 fd 可以进行读操作了。 EPOLLOUT 表示关联的 fd 可以进行写操作了。 EPOLLRDHUP(since Linux 2.6.17) 表示套接字关闭了连接，或者关闭了正写一半的连接。 EPOLLPRI 表示关联的 fd 有紧急优先事件可以进行读操作了。 EPOLLERR 表示关联的fd发生了错误，epoll_wait() 会一直等待这个事件，所以一般没必要设置这个属性。 EPOLLHUP 表示关联的fd挂起了，epoll_wait() 会一直等待这个事件，所以一般没必要设置这个属性。 EPOLLET 设置关联的fd为ET的工作方式，epoll 的默认工作方式是LT。 EPOLLONESHOT (since Linux 2.6.2) 设置关联的 fd 为 one-shot 的工作方式。表示只监听一次事件，如果要再次监听，需要把 socket 放入到 epoll 队列中。 2.3 等待 I/O 事件 #int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); epoll_wait() 用于等待监视的 I/O 事件就绪，也就是返回 ready list 中的文件描述符 。调用后，函数开始阻塞，直到：\n一个文件描述符触发了一个监视的事件。 被信号中断。 超时时间到。 已经就绪的文件描述符会写入 events 指向的缓存，这是一个数组，每个元素记录了一个就绪的文件描述符的信息。maxevents 用于告诉内核一次最多返回多少个已经就绪的文件描述符，这个值必须大于 0 ，但不要大于已经注册的文件描述符的个数。timeout 设置了等待超时，单位是毫秒，0 表示立即返回，如果设为 -1 ，表示永久等待。\n如果调用成功，返回值就是已经就绪的文件描述符的数量，如果返回值是 1，那 events 数字的长度也只有 。失败会返回一个负数。\n3. 例程 #参考 # 彻底理解 I/O 多路复用 epoll 的运行机制 epoll_create epoll_ctl ","date":"2020 August 30","permalink":"/posts/2020/08/30/","section":"Posts","summary":"1. 工作原理 #epoll 是 Linux 独有的 I/O 多路复用机制，核心概念就是 epoll 实例，它是一个内核里的数据结构，从用户角度来看它可以简单的看做包含了两个队列：","title":"epoll 学习笔记"},{"content":"uthash 是一个 C 语言的哈希表函数库，支持哈希表的各种操作，包括添加，删除，查找，排序等。你可以在 github 上下载到它的源码：\n源码：https://github.com/troydhanson/uthash 文档：https://troydhanson.github.io/uthash/userguide.html 这个函数库在使用时只需要包含 uthash.h 头文件即可，没有二进制的库文件。\n1. 数据结构 #uthash 的哈希表是由多个结构体组成的双向链表实现的，一个结构体就是一个键值对，例如：\n#include \u0026#34;uthash.h\u0026#34; struct my_struct { int id; /* key */ char name[10]; UT_hash_handle hh; /* makes this structure hashable */ }; id 就是键（key），名称和数据类型没有限制； name 就是值（value），也可以是任何数据类型； hh 是内部使用的 hash 处理句柄，UT_hash_handle 字段必须存在于你的结构中。它用于内部记录，使哈希表正常工作，它不需要初始化。可以被命名为任何标识符； 哈希句柄在 32 位系统中每个元素消耗约 32 个字节，在 64 位系统中每个元素消耗 56 个字节。其他的开销成本\u0026ndash;桶和表\u0026ndash;相比之下可以忽略不计。你可以使用 HASH_OVERHEAD 来获取哈希表的开销大小，单位是字节。\n2. 基本操作 #完整的例子可以在源码下的 tests/exapmle.c 文件中找到，可以执行 make example 进行编译。\n2.1 声明 #定义一个结构体类型的空指针，即声明了一个哈希表：\nstruct my_struct *users = NULL; 此时的哈希表示空的，我们需要先表中添加数据元素，在整个生命周期中，这个指针都指向链表的头结点。\n2.2 添加 #首先需要初始化一个数据元素，也就是定义一个 struct my_struct 变量，并分配空间，然后调用 HASH_ADD （这里我们使用方便的宏 HASH_ADD_INT，它为 int 类型的 key 提供了简化的用法）方法，将其添加到哈希表中：\nvoid add_user(int user_id, char *name) { struct my_struct *s; s = malloc(sizeof(struct my_struct)); s-\u0026gt;id = user_id; strcpy(s-\u0026gt;name, name); HASH_ADD_INT( users, id, s ); /* id: name of key field */ } HASH_ADD_INT 的第一个参数是哈希表的指针，第二个参数是结构体中 key 的变量名，最后一个参数是需要加入哈希表的元素。一个元素添加到哈希表后，就不能修改它的 key 的值，必须从哈希表中删除后，才能修改。\n2.3 查询 #可以调用 HASH_FIND （这里我们使用方便的宏 HASH_ADD_INT，它为 int 类型的 key 提供了简化的用法）查询某个 key 的 value ：\nstruct my_struct *find_user(int user_id) { struct my_struct *s; HASH_FIND_INT( users, \u0026amp;user_id, s ); /* s: output pointer */ return s; } 第一个参数是哈希表的指针，第二个参数是 key 的值，第三参数是返回的结果，就是给定 key 的结构体指针，如果没找到，就返回 NULL 。\n通常在添加之前要查询一下 key 是否已经存在，避免发生冲突。\n2.4 删除 #要从哈希表中删除一个元素，必须先获取这个元素的指针（可以用 HASH_FIND），然后调用 HASH_DEL ：\nvoid delete_user(struct my_struct *user) { HASH_DEL(users, user); /* user: pointer to deletee */ free(user); /* optional; it\u0026#39;s up to you! */ } users 就是哈希表的指针，user 就是要删除的元素，删除后，uthash 不会自动释放 user 指向的内存，可以调用 free() 手动释放，可以继续其他工作，比如修改这个键值对。\n当删除的是哈希表的第一个元素时，users 的值是会改变的，它会继续指向新的头结点。\n如果要删除所有元素，可以调用 HASH_ITER 方法，这个宏可以扩展为一个简单的循环：\nvoid delete_all() { struct my_struct *current_user, *tmp; HASH_ITER(hh, users, current_user, tmp) { HASH_DEL(users,current_user); /* delete; users advances to next */ free(current_user); /* optional- if you want to free */ } } 如果清空哈希表时，并不想释放所有元素的空间，可以直接调用：\nHASH_CLEAR(hh, users); 之后，users 就会变为空指针。\n2.5 统计 #获取哈希表中元素总数时，可以调用 HASH_COUNT ：\nunsigned int num_users; num_users = HASH_COUNT(users); printf(\u0026#34;there are %u users\\n\u0026#34;, num_users); 如果哈希表是空的，会返回 0 。\n","date":"2020 August 29","permalink":"/posts/2020/08/29/","section":"Posts","summary":"uthash 是一个 C 语言的哈希表函数库，支持哈希表的各种操作，包括添加，删除，查找，排序等。你可以在 github 上下载到它的源码：","title":"uthash 学习笔记"},{"content":"编译安装 #首先要安装一些依赖的软件：\napt-get install pkg-config apt-get install lua5.1 apt-get install liblua5.1-dev apt-get install cmake apt-get install libjson-c-dev 然后要编译安装 libubox ：\ngit clone https://git.openwrt.org/project/libubox.git cd libubox cmake . make make install ulog #头文件 ulog.h 提供了打印日志的方法。使用时，先调用 ulog_open() 函数初始化一些 ulog 需要的变量：\nvoid ulog_open(int channels, int facility, const char *ident); channels 用于设置日志消息的输出目标，取值：\nULOG_KMSG，内核日志，输出到了 /dev/kmsg 文件。 ULOG_SYSLOG，系统日志，调用了 vsyslog() 产生系统日志。 ULOG_STDIO，标准输出，输出到了 stderr 。 facility 用于设置记录日志的程序的类型，只有当 channels 的值为 ULOG_SYSLOG 时，这个参数有效。取值与 openlog() 的第三个参数一致，它们是定义在 \u0026lt;syslog.h\u0026gt; 中的宏：\n/* facility codes */ #define LOG_KERN (0\u0026lt;\u0026lt;3) /* kernel messages */ #define LOG_USER (1\u0026lt;\u0026lt;3) /* random user-level messages */ #define LOG_MAIL (2\u0026lt;\u0026lt;3) /* mail system */ #define LOG_DAEMON (3\u0026lt;\u0026lt;3) /* system daemons */ #define LOG_AUTH (4\u0026lt;\u0026lt;3) /* security/authorization messages */ #define LOG_SYSLOG (5\u0026lt;\u0026lt;3) /* messages generated internally by syslogd */ #define LOG_LPR (6\u0026lt;\u0026lt;3) /* line printer subsystem */ #define LOG_NEWS (7\u0026lt;\u0026lt;3) /* network news subsystem */ #define LOG_UUCP (8\u0026lt;\u0026lt;3) /* UUCP subsystem */ #define LOG_CRON (9\u0026lt;\u0026lt;3) /* clock daemon */ #define LOG_AUTHPRIV (10\u0026lt;\u0026lt;3) /* security/authorization messages (private) */ #define LOG_FTP (11\u0026lt;\u0026lt;3) /* ftp daemon */ ident 用于设置日志消息的标识，当 channels 的值为 ULOG_STDIO 时，这个参数无效。可以设置为程序名的字符串，如果为空，它会从 /proc/self/status 文件读取当前进程的名称作为默认值。\n初始化完毕后，就可以调用 ulog 打印一条日志：\nvoid ulog(int priority, const char *fmt, ...) priority 表示这条日志的类型，当 channels 的值为 ULOG_STDIO 时，这个参数无效。取值与 syslog() 的第一个参数一致，它们是定义在 \u0026lt;syslog.h\u0026gt; 中的宏：\n#define LOG_EMERG 0 /* system is unusable */ #define LOG_ALERT 1 /* action must be taken immediately */ #define LOG_CRIT 2 /* critical conditions */ #define LOG_ERR 3 /* error conditions */ #define LOG_WARNING 4 /* warning conditions */ #define LOG_NOTICE 5 /* normal but significant condition */ #define LOG_INFO 6 /* informational */ #define LOG_DEBUG 7 /* debug-level messages */ 为了调用方便，ulog 提供了不同类型的宏定义：\n#define ULOG_INFO(fmt, ...) ulog(LOG_INFO, fmt, ## __VA_ARGS__) #define ULOG_NOTE(fmt, ...) ulog(LOG_NOTICE, fmt, ## __VA_ARGS__) #define ULOG_WARN(fmt, ...) ulog(LOG_WARNING, fmt, ## __VA_ARGS__) #define ULOG_ERR(fmt, ...) ulog(LOG_ERR, fmt, ## __VA_ARGS__) 程序结束时，应该调用 ulog_close() 关闭日志，对于 ULOG_SYSLOG 来说，它会调用 closelog() 函数完成任务。\nulog 还提供了一个函数来控制程序打印日志的级别：\nvoid ulog_threshold(int threshold); threshold 可选的值与 ulog() 的 priority 参数一致，默认值是 LOG_DEBUG 。设置后，再调动 ulog() 时，如果 priority 的数值大于 threshold ，就不会打印任何消息。我们可以在开发调试阶段设置为 LOG_DEBUG ，调试结束发布程序时再设为 LOG_INFO ，调试信息就直接关闭了。\n下面是一个例程：\n// main.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; #include \u0026lt;libubox/ulog.h\u0026gt; int main() { ulog_open(ULOG_SYSLOG, LOG_USER, NULL); ULOG_INFO(\u0026#34;hello ulog\u0026#34;); ulog_close(); } 编译后执行：\n~$ gcc -Wall main.c -o main -lubox ~$ ./main 然后，在系统日志中可以查看到这条消息：\nJul 02 10:58:06 ubuntu main[25733]: hello ulog utils #utils.h 类似一个工具库，提供很多使用的方法。\nbase64 #utils 提供了 base64 的编解码方法。\n编码函数是 b64_encode() ：\nint b64_encode(const void *_src, size_t srclength, void *dest, size_t targsize) 参数 _src 是指向源数据的指针，srclength 是源数据的长度，单位是字节。dest 指向编码后的字符串存放位置，targsize 是 dest 的空间大小，单位是字节。targsize 应该不小于 (((srclength) + 2) / 3) * 4 + 1 ，除法取整，最后要加字符串结束符 '\\0' ，所以要加 1 。如果调用成功，返回值是编码后的字符串长度，失败则返回 -1 。例如：\nb64_encode(\u0026#34;food\u0026#34;, 4, buf, 9); 解码函数是 b64_decode() ：\nint b64_decode(const void *_src, void *dest, size_t targsize); 参数的含义与编码函数一致，不需要设置源数据的长度，函数以 _src 字符串中的 '\\0' 字符为结束符。如果调用成功，返回值是编码后的字符串长度，失败则返回 -1 。\nutil.h 文件提供了计算编解码后字符串长度的宏：\n#define B64_ENCODE_LEN(_len)\t((((_len) + 2) / 3) * 4 + 1) #define B64_DECODE_LEN(_len)\t(((_len) / 4) * 3 + 1) list #ubox 用 list.h 提供了一种侵入式链表结构，结点中不含任何数据 ：\nstruct list_head { struct list_head *next; // 下一个元素 struct list_head *prev; // 上一个元素 }; 可以用一个宏初始化链表：\n#define LIST_HEAD_INIT(name) { \u0026amp;(name), \u0026amp;(name) } 它定义了链表的 head ，next 和 prev 都指向本身，调用方法：\nstruct list_head test_list = LIST_HEAD_INIT(test_list); ubox 的 list 还是一个双向循环链表：\n在链表 head 的头部插入 new 结点，实际上是在 head 与 first 之间插入 new 结点：\nstatic inline void list_add(struct list_head *_new, struct list_head *head); 在链表 head 的末尾追加 new 结点，实际上是在 head 与 last 之间插入 new 结点 ：\nstatic inline void list_add_tail(struct list_head *_new, struct list_head *head); 将 entry 结点从原有的列表中删除：\nstatic inline void list_del(struct list_head *entry); 将 list 结点移动列表头部，就是 head 与 first 之间：\nstatic inline void list_move(struct list_head *list, struct list_head *head); 将 list 结点移动到列表末尾，就是 head 与 last 之间：\nstatic inline void list_move_tail(struct list_head *entry, struct list_head *head); 判断一个链表是否为空，它会判断 head 结点的 next 指针是否指向本身。：\nstatic inline bool list_empty(const struct list_head *head); 判断 list 结点是否是 head 链表的头结点：\nstatic inline bool list_is_first(const struct list_head *list, const struct list_head *head); 判断 list 结点是否是 head 链表的尾结点：\nstatic inline bool list_is_last(const struct list_head *list, const struct list_head *head); 对于侵入式链表，通常的使用方法是将 list 结点嵌入到特定的数据结构中，例如：\nstruct item { const char *data; struct list_head list; }; usock #usock.h 提供便于新建 socket 的方法，是对 Linux socket API 的封装：\nint usock(int type, const char *host, const char *service); 如果调用成功，就返回一个 socket 文件描述符，失败返回 -1。\n参数 type 用于设置 socket 类型，可选的值是下面这些宏定义的组合：\n#define USOCK_IPV6ONLY 0x2000 // IPv4 地址域的套接字 #define USOCK_IPV4ONLY 0x4000 // IPv6 地址域的套接字 #define USOCK_UNIX 0x8000 // UNIX 域的套接字 #define USOCK_TCP 0 // 字节流 #define USOCK_UDP 1 // 报文 #define USOCK_SERVER 0x0100 #define USOCK_NOCLOEXEC 0x0200 #define USOCK_NONBLOCK 0x0400 // 非阻塞 #define USOCK_NUMERIC 0x0800 host 是本机地址，如果是网络 socket，这里应该是一个 IP 地址或者域名，如果是 UNIX socket ，这里应该是 socket 文件的路径。\nservice 是本机端口，也可以是协议名称的字符串，例如 http 和 ftp 等。对于 UNIX socket ，这个参数无效。\n对于非阻塞的 socket ，usock 提供了一个等待描述符就绪的方法：\nint usock_wait_ready(int fd, int msecs); fd 是要等待的 socket 描述符，msecs 是等待超时，单位是微秒。这个方法是对 poll() 函数的封装。\nconst char *usock_port(int port); usock_port() 函数可以把数字表示的端口号转换为一个字符串。\n","date":"2020 July 16","permalink":"/posts/2020/07/16/","section":"Posts","summary":"编译安装 #首先要安装一些依赖的软件：","title":"libubox 学习笔记"},{"content":"本教程提供了一个渐进式的指导，参考的是官方教程 CMake Tutorial ，然后加入学习过程的笔记。涵盖了使用 CMake 构建一个工程时经常遇到的问题 。通过一个示例项目，展示各种功能是如何一起工作的，这对理解 CMake 非常有用。\n1. 最简单的工程 #最简单工程是从源码文件直接编译生成一个可执行的问题，最简单的解决方案只需要在 CMakeLists.txt 文件中添加三行。\n新建一个工程目录，在目录下新建一个源文件 Tutorial.c ：\n#include \u0026lt;stdio.h\u0026gt; int main (int argc, char *argv[]) { printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } 新建一个 CMakeLists.txt ：\ncmake_minimum_required(VERSION 3.1) project(Tutorial) add_executable(Tutorial Tutorial.c) CMakeLists.txt 是 cmake 生成 Makefile 所依赖的描述性文件，文件内容由一行一行的命令组成，命令不区分大小写。\ncmake_minimum_required 表示该项目对 CMake 的最低版本要求。 project 用于设置项目名称。 add_executable 添加了一个生成的可执行文件，和依赖的源码。 这样的话，执行 cmake . 生成 Makefile ，再执行 make 开始编译，就可以使用 Tutorial.c 生成的可执行文件 Tutorial 。\ncmake 执行过程中会生成大量的缓存文件，又没有提供类似 cmake clean 的命令来清除生成的文件，有一个简单的方法可以解决这个问题。在工程目录下新建一个名为 build 的子目录，进入这个子目录中执行 cmake .. ，这样生成的文件都会输出到 build 子目录中，方便清理。\n添加一个版本号 #一个软件工程通常需要版本号，可以直接写在源码里，但是 CMake 提供了更便捷的方法。可以在 project() 命令中添加版本号，例如：\nproject(Tutorial VERSION 1.0) 其实，还可以在该命令中添加项目的描述等，它的语法是：\nproject(\u0026lt;PROJECT-NAME\u0026gt; [VERSION \u0026lt;major\u0026gt;[.\u0026lt;minor\u0026gt;[.\u0026lt;patch\u0026gt;[.\u0026lt;tweak\u0026gt;]]]] [DESCRIPTION \u0026lt;project-description-string\u0026gt;] [HOMEPAGE_URL \u0026lt;url-string\u0026gt;] [LANGUAGES \u0026lt;language-name\u0026gt;...]) 这样添加的版本号，被 cmake 存放在特定的变量中：\n\u0026lt;PROJECT-NAME\u0026gt;_VERSION ，存放完整的版本号 。 \u0026lt;PROJECT-NAME\u0026gt;_VERSION_MAJOR ，存放 major 。 \u0026lt;PROJECT-NAME\u0026gt;_VERSION_MINOR ，存放 minor 。 \u0026lt;PROJECT-NAME\u0026gt;_VERSION_PATCH ， 存放 patch 。 \u0026lt;PROJECT-NAME\u0026gt;_VERSION_TWEAK ，存放 tweak 。 \u0026lt;PROJECT-NAME\u0026gt;表示工程的名称，这里的值为 Tutorial ，所以 Tutorial_VERSION_MAJOR 的值就是 1 ， Tutorial_VERSION_MINOR 的值就是 0 。我们需要新建一个名为 TutorialConfig.h.in 的文件传递这些变量：\n#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@ #define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@ 然后，在 CMakeLists.txt 中添加一条命令：\nconfigure_file(TutorialConfig.h.in TutorialConfig.h) cmake 执行这条命令的时候，会读取 TutorialConfig.h.in 文件，并将其中的变量替换成真实的值，然后在执行目录下生成头文件 TutorialConfig.h ：\n#define Tutorial_VERSION_MAJOR 1 #define Tutorial_VERSION_MINOR 0 下一步，我们需要在源码文件 Tutorial.c 中导入头文件，然后使用头文件里定义的宏打印版本号：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026#34;TutorialConfig.h\u0026#34; # 导入头文件 int main (int argc, char *argv[]) { printf(\u0026#34;Hello World!\\n\u0026#34;); printf(\u0026#34;MAJOR Version is %d\\n\u0026#34;, Tutorial_VERSION_MAJOR); # 引用版本号的宏定义 printf(\u0026#34;MINOR Version is %d\\n\u0026#34;, Tutorial_VERSION_MINOR); return 0; } 如果你是在源码目录下执行 cmake ，这样修改就可以了。如果是在 build 目录下执行 cmake ，生成的 TutorialConfig.h 文件位于 build 目录下，源文件中的 #include \u0026quot;TutorialConfig.h\u0026quot; 语句会找不到头文件，这时，需要将 build 目录页加入到头文件的检索路径中，可以在 CMakeLists.txt 的末尾加一行：\ntarget_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34;) target_include_directories() 的语法是：\ntarget_include_directories(\u0026lt;target\u0026gt; [SYSTEM] [BEFORE] \u0026lt;INTERFACE|PUBLIC|PRIVATE\u0026gt; [items1...] [\u0026lt;INTERFACE|PUBLIC|PRIVATE\u0026gt; [items2...] ...]) 它的作用是向目标文件添加头文件检索路径。当编译 target 目标文件时，去指定的 iters* 路径下检索头文件。target 的值必须是通过 add_executable() 或 add_library() 命令添加的目标文件名称。\nPROJECT_BINARY_DIR 是指 cmake 提供的一个变量，表示目标文件输出的路径，通常就是执行 cmake 命令时的路径。还有一个变量 PROJECT_SOURCE_DIR ，表示源码的路径。它们的值都是由 project() 命令自动设置的。在 cmake 中，应用变量的语法是 ${variable-name} 。\n测试 #修改完毕后，CMakeLists.txt 的完整内容是：\ncmake_minimum_required(VERSION 3.1) project(Tutorial VERSION 1.0) configure_file(TutorialConfig.h.in TutorialConfig.h) add_executable(Tutorial Tutorial.c) target_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34;) 然后，我们在 build 子目录下依次执行 cmake .. 和 make （或者 cmake --build .） ，生成的文件如下：\n~$ ls CMakeCache.txt Tutorial inc CMakeFiles TutorialConfig.h Makefile cmake_install.cmake ~$ ./Tutorial Hello World! MAJOR Version is 1 MINOR Version is 0 2. 添加一个库 #下面我们在工程中添加一个用于数学计算的链接库，把库的源码放在 MathFunctions 子目录中，工程结构如下：\n~$ tree . ├── CMakeLists.txt ├── MathFunctions │ ├── MathFunctions.h │ └── mysqrt.c ├── Tutorial.c └── TutorialConfig.h.in 头文件 MathFunctions.h 中声明了一个计算平方根的函数 mysqrt() ：\ndouble mysqrt(double x); 它定义在 mysqrt.c 文件中：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026#34;MathFunctions.h\u0026#34; // a hack square root calculation using simple operations double mysqrt(double x) { if (x \u0026lt;= 0) { return 0; } double result = x; // do ten iterations for (int i = 0; i \u0026lt; 10; ++i) { if (result \u0026lt;= 0) { result = 0.1; } double delta = x - (result * result); result = result + 0.5 * delta / result; printf(\u0026#34;Computing sqrt of %f to be %f .\\n\u0026#34;, x, result); } return result; } 然后，我们在 Tutorial.c 文件中调用这个函数计算一个数的平方根：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026#34;TutorialConfig.h\u0026#34; #include \u0026#34;MathFunctions/MathFunctions.h\u0026#34; int main (int argc, char *argv[]) { double input = 4; printf(\u0026#34;Hello World!\\n\u0026#34;); printf(\u0026#34;Version %d.%d\\n\u0026#34;, Tutorial_VERSION_MAJOR, Tutorial_VERSION_MINOR); double output = mysqrt(input); printf(\u0026#34;The square root of %f is %f .\\n\u0026#34;, input, output); return 0; } 编译的时候，我们希望将 mysqrt.c 生成一个共享库，再连接到 Tutorial 目标中。所以，需要对 CMake 的描述文件做如下修改：\n在 MathFunctions 子目录下新建一个 CMakeLists.txt ，内容是 add_library(MathFunctions mysqrt.c) ，表示将 mysqrt.c 编译为库文件。 在顶层目录的 CMakeLists.txt 文件中如下内容： add_subdirectory(MathFunctions) ，表示向 CMake 工程添加一个子目录，执行时会调用子目录中的 CMakeLists.txt 。 target_link_libraries(Tutorial PUBLIC MathFunctions) ，表示目标文件 Tutorial 要链接 MathFunctions 。 因为 Tutorial.c 文件中导入了 MathFunctions 子目录下的头文件，所以，要用 target_include_directories() 命令将这个子目录也加入头文件检索路径。 完整的顶层目录 CMakeLists.txt 文件内容如下：\ncmake_minimum_required(VERSION 3.1) project(Tutorial VERSION 1.0) add_subdirectory(MathFunctions) configure_file(TutorialConfig.h.in TutorialConfig.h) add_executable(Tutorial Tutorial.c) target_link_libraries(Tutorial PUBLIC MathFunctions) target_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34; ) 然后，在 build 目录下依次执行 cmake .. 和 cmake --build . ，编译生成可执行文件 Tutorial ，执行：\n~$ ./Tutorial Hello World! Version 1.0 Computing sqrt of 4.000000 to be 2.500000 . Computing sqrt of 4.000000 to be 2.050000 . Computing sqrt of 4.000000 to be 2.000610 . Computing sqrt of 4.000000 to be 2.000000 . Computing sqrt of 4.000000 to be 2.000000 . Computing sqrt of 4.000000 to be 2.000000 . Computing sqrt of 4.000000 to be 2.000000 . Computing sqrt of 4.000000 to be 2.000000 . Computing sqrt of 4.000000 to be 2.000000 . Computing sqrt of 4.000000 to be 2.000000 . The square root of 4.000000 is 2.000000 . 提供可选项 #上一步添加的 MathFunctions 库可以做成一个可选的模块，这是大型工程里的常见做法。\n首先需要用 option() 命令设置一个选项：\noption(USE_MYMATH, \u0026#34;Use tutorial provided math implementation\u0026#34;, ON) 这样就设置了一个名为 USE_MYMATH 的选项，初始值是 ON 。option() 的作用是新建一个用户可以选择的选项，语法很简单：\noption(\u0026lt;variable\u0026gt; \u0026#34;\u0026lt;help_text\u0026gt;\u0026#34; [value]) 三个参数依次是选项的变量名，选项的描述，选项的初始值。选项的值只有两个：ON 和 OFF ，如果没有设置初始值，默认就是 OFF 。\n然后可以通过这个选项，把模块相关的语句包裹在一个选择语句中：\noption(USE_MYMATH \u0026#34;Use tutorial provided math implementation\u0026#34; ON) if(USE_MYMATH) add_subdirectory(MathFunctions) list(APPEND EXTRA_LIBS MathFunctions) list(APPEND EXTRA_INCLUDES \u0026#34;${PROJECT_SOURCE_DIR}/MathFunctions\u0026#34;) endif() target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS}) target_include_directories(Tutorial PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; \u0026#34;${EXTRA_INCLUDES}\u0026#34; ) list() 命令用于操作列表，APPEND 可以将一个元素追加到一个列表的尾部。后面通过新建的列表调用模块，这样的话，只有 USE_MYMATH 的值为 ON 时，才会将模块包含在编译过程中。\n源码中的修改比较简单，只需修改 Tutorial.c 文件，通过宏定义将模块相关的语句做成可选项：\n#ifdef USE_MYMATH #include \u0026#34;MathFunctions/MathFunctions.h\u0026#34; #endif #ifdef USE_MYMATH double output = mysqrt(input); printf(\u0026#34;The square root of %f is %f .\\n\u0026#34;, input, output); #endif 这个宏定义的值也需要通过 TutorialConfig.h.in 文件传递给源码：\n#cmakedefine USE_MYMATH 执行到 configure_file() 命令的时候，如果 USE_MYMATH 的值是 ON ，这条语句会被替换为 #define USE_MYMATH ；如果 USE_MYMATH 的值是 OFF ，这条语句会被替换为一行注释 /* #undef USE_MYMATH */ 。\n设置库文件的使用要求 #构建 C 语言的工程时，应该清晰的规划模块之间的关系，在编译时，先编译出子模块的目标文件，再由这些目标文件链接起来生成上一层的目标文件，层层递进，最终编译出可执行文件。目标文件包括 add_executable() 和 add_library() 命令生成的可执行文件和库。目标文件的依赖关系是通过两条命令控制的：\ntarget_include_directories() ，向目标文件添加编译时的头文件检索目录。 target_link_libraries() ，向目标文件添加编译时依赖的库。 这两条命令需要一个控制传递属性的参数，可选三种关键字：\nPRIVATE ，私有。库文件提供的方法只供目标文件使用，不会暴露给更上层目标文件。即生产者需要，消费者不需要。 INTERFACE ，接口。库文件提供的方法会暴露给上层文件使用，本目标文件只用到了库文件提供的一些数据结构和声明等。即生产者不需要，消费者需要。 PUBLIC ，公开。库文件提供的方法可以供所有目标文件使用。即生产者和消费者都需要。 以上一节的工程为例，目录结果是：\n. ├── build ├── CMakeLists.txt ├── MathFunctions # 生成 libMathFunctions.a │ ├── CMakeLists.txt │ ├── MathFunctions.h │ └── mysqrt.c ├── Tutorial.c └── TutorialConfig.h.in 目标 MathFunctions 需要的头文件 MathFunctions.h 中的声明，并将方法暴露给上一层的 Tutorial.c 使用。所以，目标 MathFunctions 对头文件 MathFunctions.h 的使用要求就是 INTERFACE ，目标 Tutrial 对目标 MathFunctions 的使用要求是 PRIVATE 。\n那么，可以在 MathFunctions/CMakeLists.txt 中添加一行：\ntarget_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR} ) 然后就可以把顶层 CMakeLists.txt 中包含头文件的部分删除，并将库文件的使用要求改为私有：\nif(USE_MYMATH) add_subdirectory(MathFunctions) list(APPEND EXTRA_LIBS MathFunctions) endif() target_link_libraries(Tutorial PRIVATE ${EXTRA_LIBS}) target_include_directories(Tutorial PRIVATE \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; ) 3. 安装和测试 #这个工程只需要把可执行文件安装到指定的目录，所以，在顶层 CMakeLists.txt 目录下添加一行：\ninstall(TARGETS Tutorial DESTINATION bin) 这样，在执行 make install 时，就会把 Tutorial 文件安装到 /usr/local/bin/ 目录下，默认的前缀是 /usr/local/ ，如果要换别的目录，可以写上绝对路径。\n","date":"2020 June 29","permalink":"/posts/2020/06/29/","section":"Posts","summary":"本教程提供了一个渐进式的指导，参考的是官方教程 CMake Tutorial ，然后加入学习过程的笔记。涵盖了使用 CMake 构建一个工程时经常遇到的问题 。通过一个示例项目，展示各种功能是如何一起工作的，这对理解 CMake 非常有用。","title":"CMake 学习笔记"},{"content":"tcpdump 是一个帮助用户捕获、筛选和解析 TCP/IP 协议数据包的命令行工具。\n1. 基本用法 #下面展示了 tcpdump 的常用的选项：\n:~$ tcpdump -nn -s0 -v -i en0 port 80 -i ：指定需要监听的网卡，可以是物理网卡，也可以是虚拟网卡。途径该网卡的数据包都会被捕获，然后用过滤器的规则进行筛选。如果没有指定，默认会监听本机的所有网卡。 port ：这是一个过滤器规则，表示只显示使用该端口收发的数据。 -nn ：默认情况下，tcpdump 会将 ip 和端口号解析为字符串的形式，例如 80 端口会显示为 http 。可以用 -n 表示不解析主机名，-nn 表示不解析主机名和端口号，这样可以加快速度，也方便查看。 -s0 ：设置要捕获的数据包的大小，s0 表示不限制大小。 -v ：表示粗略显示数据包的内容，-vv 可以增加显示数据包的细节。 1.1 显示控制 #使用 -A 选项可以将数据包的内容以 ASCII 字符形式显示，方便阅读，另一个选项 -X 可以让数据包的内容同时以 16 进制和 ASCII 字符形式显示，例如：\n:~$ tcpdump -nn -s0 -v -i en0 port 80 -X tcpdump: listening on en0, link-type EN10MB (Ethernet), capture size 262144 bytes 08:51:01.902291 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 40) 192.168.50.102.53936 \u0026gt; 120.92.84.16.80: Flags [F.], cksum 0xefc2 (correct), seq 710116020, ack 2044458673, win 4096, length 0 0x0000: 4500 0028 0000 4000 4006 7b55 c0a8 3266 E..(..@.@.{U..2f 0x0010: 785c 5410 d2b0 0050 2a53 82b4 79db f6b1 x\\T....P*S..y... 0x0020: 5011 1000 efc2 0000 P....... 1.2 组合规则 #多种过滤器规则可以用标准逻辑进行组合。\nand 或者 \u0026amp;\u0026amp; 表示 与 or 或者 || 表示或 not 或者 ! 表示非 1.3 写入文件 #用 -w [filename] 选项可以将筛选解析后的数据以 pcap 格式写入文件，这种格式可以用 wireshark 打开显示，方便查看。例如：\n:~$ tcpdump -nn -s0 -v -i en0 port 80 -w test.pcap 1.4 行缓存模式 #如果想实时将抓取到的数据通过管道传递给其他工具来处理，需要使用 -l 选项来开启行缓存模式（或使用 -c 选项来开启数据包缓存模式）。它可以将标准输出立即发送给其他命令，其他命令会立即响应。例如：\n:~$ tcpdump -l | tee dat 2. 过滤器 #2.1 筛选 IP #筛选目的 IP 或者源 IP 为特定值的数据包：\n:~$ tcpdump -i en0 host 192.168.1.1 也可用 src 筛选源 IP 为特定值的数据包，用 dst 筛选目的 IP 为特定在的数据包：\n:~$ tcpdump -i en0 dst 192.168.1.1 2.2 筛选端口 #使用 port 选项可以筛选通过特定端口收发的数据包，例如：\n:~$ tcpdump -i en0 port 80 也可以筛选特定范围内的端口：\n:~$ tcpdump -i en0 portrange 21-23 2.2 筛选协议 #使用 proto 选项可以筛选特定协议的数据包，例如只显示 upd 数据包：\n:~$ tcpdump -i en0 proto udp 关键字 proto 可以省略，直接写协议名称，支持的协议有 icmp, igmp, igrp, pim, ah, esp, carp, vrrp, udp和 tcp 。\n","date":"2020 April 12","permalink":"/posts/2020/04/12/","section":"Posts","summary":"tcpdump 是一个帮助用户捕获、筛选和解析 TCP/IP 协议数据包的命令行工具。","title":"tcpdump 使用笔记"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings #The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 #H2 #H3 #H4 #H5 #H6 #Paragraph #Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes #The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution # Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution # Don\u0026rsquo;t communicate by sharing memory, share memory by communicating. — Rob Pike1\nTables #Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Code Blocks #Code block with backticks\nhtml \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types #Ordered List\nFirst item Second item Third item Unordered List\nList item Another item And another item ","date":"2020 January 15","permalink":"/posts/2020/01/15/","section":"Posts","summary":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.","title":"Markdown Syntax Guide"},{"content":"iproute2 是一个 Linux 网络管理工具包，提供了 ip 、tc 、ss 等组件，集成了原有的 ifconfg 、arp 、route 、netstat 等多种命令的功能，并新增了很多特性。\n1. ip 命令 #ip 命令的语法是：\nip [OPTIONS] OBJECT {COMMAND|help} 其中：\nOBJECT 表示操作对象，可选的值有 { link | addr | addrlabel | route | rule | neigh | ntable | tunnel | maddr | mroute | mrule | monitor | xfrm | token } ，常用的对象包括： link：网络设备 addr：设备上的协议（IP或IPv6）地址 addrlabel：协议地址选择的标签配置 route：路由表条目 rule：路由策略数据库中的规则 neigh: ARP 表 OPTIONS 表示选项，可选的值有 { -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] | -h[uman-readable] | -iec | -f[amily] { inet | inet6 | ipx | dnet | link } | -o[neline] | -t[imestamp] | -b[atch] [filename] | -rc[vbuf] [size] } 常用的选项包括： -V，-Version：显示指令版本信息 -s，-stats，statistics：输出详细信息 -h，-human，-human-readable：输出人类可读的统计信息和后缀 -o，-oneline：将每条记录输出到一行，用 \\ 字符替换换行符 1.1 配置网卡 #调用 ip addr 可以查看所有网卡的信息和配置，也可以在后追加网卡的接口名称，单独查看特定网卡，以 enp1s0 为例：\nroot@localhost:~# ip addr show enp1s0 3: enp1s0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 00:1d:f3:52:b7:94 brd ff:ff:ff:ff:ff:ff inet 192.168.5.242/24 brd 192.168.5.255 scope global enp1s0 valid_lft forever preferred_lft forever inet6 fe80::21d:f3ff:fe52:b794/64 scope link valid_lft forever preferred_lft forever 每个字段的含义：\n\u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; : BROADCAST表示该接口支持广播；MULTICAST表示该接口支持多播；UP表示该网络接口已启用；LOWER_UP表示网络电缆已插入，设备已连接至网络。 mtu 1500：最大传输单元（链路层最大一次传输的上层数据大小，也就是一个 IP 包的最大值）为 1500 字节。 qdisc mq：用于数据包排队 。 state UP：网络接口已启用，如果接口没有启用，会显示 DOWN 。 qlen 1000：传输队列长度。 link/ether 00:1d:f3:52:b7:94 : 网卡的 MAC 地址。 brd ff:ff:ff:ff:ff:ff : 广播 MAC 地址。 inet 192.168.5.242/24 : 网卡的 IPv4 地址。 brd 192.168.5.255 : 广播 IPv4 地址。 scope global：全局有效，如果显示为 link 表示仅对此设备有效。 enp1s0 : 如果前面有 dynamic 字符，表示这个网卡的 IP 是动态获取的。 valid_lft forever : IP 的有效期是永久，如果是动态获取的 IP ，会显示剩余的有效时间。 preferred_lft forever : 首选 IP 的地址的有效期。 为网卡添加或者删除一个 IP 地址：\nip addr add/del 192.168.0.123/24 dev enp1s0 启动或者禁用一个网卡：\nip link set enp1s0 up/down 设置网卡的其他特性也可以用 ip link set 语法。例如：\narp on/off : 改变网卡的 NOARP 标识，设为 off 表示禁用该网卡的 ARP 协议。网卡处于 UP 状态时不能执行这个操作。 multicast on/off : 改变网卡的 MULTICAST 标识，设为 off 表示禁用该网卡的组播。 dynamic on/off : 改变网卡的 DYNAMIC 标识，设为 off 表示禁止该网卡动态获取 IP。 mtu NUMBER : 设置该网卡的最大传输单元。 查看网卡的流量统计：\nroot@localhost:~# ip -s -s link ls enp1s0 3: enp1s0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000 link/ether 00:1d:f3:52:b7:94 brd ff:ff:ff:ff:ff:ff RX: bytes packets errors dropped overrun mcast 42861012 137710 0 0 0 151 RX errors: length crc frame fifo missed 0 0 0 0 0 TX: bytes packets errors dropped carrier collsns 520406 6159 0 0 0 0 TX errors: aborted fifo window heartbeat transns 0 0 0 0 2 1.2 配置路由表 #显示系统的路由表：\nroot@localhost:~# ip route show default via 10.76.141.9 dev enp0s29u1u4c2 proto static metric 100 10.76.141.8/29 dev enp0s29u1u4c2 proto kernel scope link src 10.76.141.12 metric 100 192.168.5.0/24 dev enp1s0 proto kernel scope link src 192.168.5.242 metric 100 192.168.99.0/24 dev wlp3s0 proto kernel scope link src 192.168.99.1 metric 600 default 一行表示缺省路由。\nvia 10.76.141.9 表示网关，也就是吓一跳的 IP 。\n普通路由的第一个字段表示目标网段。\ndev enp1s0 表示出口网卡。\nmetric 100 表示优先级，数字小的优先。\n添加一条到主机的静态路由：\nip route add 192.0.2.1 via 192.168.145.2 dev enp1s0 add 表示添加，如果要删除可以用 del 命令 192.0.2.1 表示目标主机的 IP via 192.168.145.2 表示吓一跳地址 dev enp1s0 表示出口的网卡设备 如果要添加到网络的静态路由，将目标地址设为一个网段即可：\nip route add 192.0.2.1/24 via 192.168.145.2 dev enp1s0 如果要添加一条默认路由，将目标地址设为 default 即可：\nip route add default via 192.168.145.2 dev enp1s0 1.3 配置 ARP #查看系统的 ARP 缓存：\nroot@localhost:~# ip neigh show 192.168.5.252 dev enp1s0 lladdr 8c:a6:df:0c:7a:0a REACHABLE 192.168.5.36 dev enp1s0 lladdr 98:ee:cb:a9:c1:98 STALE 192.168.5.50 dev enp1s0 lladdr f8:7b:20:ee:d2:47 STALE 192.168.5.64 dev enp1s0 lladdr 74:27:ea:6f:08:35 STALE 10.76.141.9 dev enp0s29u1u4c2 lladdr 4c:54:99:45:e5:d5 REACHABLE fe80::4e54:99ff:fe45:e5d5 dev enp0s29u1u4c2 lladdr 4c:54:99:45:e5:d5 router REACHABLE 每一行都是一条 ARP ，以第一行为例：\n192.168.5.252 表示设备的 IP 。 dev enp1s0 表示发现此设备的网卡。 lladdr 8c:a6:df:0c:7a:0a 表示此设备的 MAC 地址。 REACHABLE 表示这条 ARP 条目的状态： REACHABLE 表示条目有效，设备在线。 STALE 表示条目有效，但是设备未必在线。 FAILED 表示条目无效，设备不在线。 PERMANENT 表示此条目永久有效，直到管理员将其删除，通常是手动添加的静态 ARP 绑定。 添加一条静态 ARP ：\nip neight add dev enp1s0 add 192.168.5.50 lladdr f8:7b:20:ee:d2:47 nud permanent 如果 ARP 表中已经存在了这样的 ARP 映射，执行 add 命令会报错，可以用 replace 将其替换，其他参数不变：\nip neight relpace dev enp1s0 add 192.168.5.50 lladdr f8:7b:20:ee:d2:47 nud permanent 删除一条 ARP 时不用这么多参数，只需指定接口和 IP 即可：\nip neight delete dev enp1s0 add 192.168.5.50 清空当前 ARP 表：\nip neight flush dev enp1s0 2. ss 命令 #ss 是查看 socket 连接信息的工具。常用的参数有：\n-a ，显示所有 socket 连接的信息。 -4 ，只显示 IPv4 的 socket 。 -6 ，只显示 IPv6 的 socket 。 -t ，只显示 TCP 协议的 socket 。 -u ，只显示 UCP 协议的 socket 。 -x ，只显示 Unix 域的 socket 。 -l ，显示处于 LISTEN 状态的 socket 。 -o ，显示定时器信息。 -p ， -e ， 参考： # http://www.policyrouting.org/iproute2.doc.html\nhttps://linux.cn/article-3144-1.html\n","date":"2020 January 8","permalink":"/posts/2020/01/08/","section":"Posts","summary":"iproute2 是一个 Linux 网络管理工具包，提供了 ip 、tc 、ss 等组件，集成了原有的 ifconfg 、arp 、route 、netstat 等多种命令的功能，并新增了很多特性。","title":"iproute2 学习笔记"},{"content":"UCI 和 ubus 都是 Openwrt 项目提供的软件，UCI 提供了统一的配置文件格式和读写工具，ubus 提供了基于 Unix Socket 的进程间通信框架。两个软件都可以方便的移植到其他 Linux 系统，以 Ubuntu20.04 为例，首先要安装一些依赖的软件：\napt-get install pkg-config apt-get install lua5.1 apt-get install liblua5.1-dev apt-get install cmake apt-get install libjson-c-dev 然后要编译安装 libubox ：\ngit clone https://git.openwrt.org/project/libubox.git cd libubox cmake . make make install 编译时可能出现找不到头文件的错误：\n/root/libubox/lua/uloop.c:21:17: fatal error: lua.h: No such file or directory 这是路径问题，因为 lua 的头文件在 /usr/include/lua5.1 目录下，所有修改 uloop.c 文件，为 lua.h 等头文件前面加上 lua5.1/ 路径：\n#include \u0026lt;lua5.1/lua.h\u0026gt; #include \u0026lt;lua5.1/lualib.h\u0026gt; #include \u0026lt;lua5.1/lauxlib.h\u0026gt; 1. UCI #官方文档：https://openwrt.org/docs/guide-user/base-system/uci\n编译安装 uci ：\ngit clone https://git.openwrt.org/project/uci.git cd uci cmake . make make install # 默认都安装在 /usr/local 路径下 安装完成后执行一次 sudo ldconfig -v ，否则可能找不到刚安装的共享库。\nUCI 的全称叫做统一配置接口（Unified Configuration Interface），它的作用为各种不同的服务单元提供统一的配置文件格式和编程方法。配置文件是纯文本文件，只支持 ASCII 字符，UCI 提供了 shell 命令，C 语言和 Lua 语言编程接口，不推荐手动编辑配置文件，避免出现语法错误。\n1.1 配置文件语法 #UCI 的配置文件默认都放在 /etc/config 路径下，也可以自定义。配置文件的语法是 config -\u0026gt; section -\u0026gt; option 这样的层级关系，一个配置文件就是一个 config，由多个 section 段组成的，每个 section 内包含了一组选项和值，以井号 # 开头的行是注释，语法如下：\nconfig \u0026lt;type\u0026gt; [\u0026#34;name\u0026#34;] # section option \u0026lt;name\u0026gt; \u0026#34;\u0026lt;value\u0026gt;\u0026#34; # option 以 openwrt 系统的 /etc/confg/network 文件为例，系统的网络配置程序在启动时会读取并解析这个配置文件，然后根据文件内的选项来设置网卡参数：\nconfig interface \u0026#39;lan\u0026#39; option ifname \u0026#39;eth0\u0026#39; option proto \u0026#39;static\u0026#39; option netmask \u0026#39;255.255.255.0\u0026#39; option ipaddr \u0026#39;192.168.1.1\u0026#39; config interface \u0026#39;wan\u0026#39; option ifname \u0026#39;eth1\u0026#39; option proto \u0026#39;dhcp\u0026#39; 这里包含了两个 section , 每个 section 必须以 config 关键字开头，后面两个元素分别是 section 的 type 和 name ，由用户自定义，name 必须用引号包裹，如果没有定义 name，UCI 会自动分配一个 ID 作为它的 name ，这叫做匿名 section 。\n每个 section 下包含了若干选项，以行为单位，必须以 option 关键字开头，后面两个元素分别是 option 的 name 和 vlaue ，由用户自定义，value 必须用引号包裹，不能为空，否则解析时会报错。\n要获取 wan 口网卡的名称，可以用 network.wan.ifname 定位：\n$ uci get network.wan.ifname eth1 1.2 shell 命令 #UCI 提供了 uci 命令读写配置文件，语法可以直接用 uci -h 获得，常用的命令：\nbatch ，进入一个交互环境，可以连续执行多条 uci 命令，用 exit 命令退出。 export [\u0026lt;config\u0026gt;] ，以 uci 配置文件的语法显示 config 的内容。 import [\u0026lt;config\u0026gt;] ，导入配置文件。 changes [\u0026lt;config\u0026gt;] ，显示已修改未保存的内容。 commit [\u0026lt;config\u0026gt;] ，将修改内容提交保存到配置文件。 add \u0026lt;config\u0026gt; \u0026lt;section-type\u0026gt; ，添加一个匿名 section 。 add_list \u0026lt;config\u0026gt;.\u0026lt;section\u0026gt;.\u0026lt;option\u0026gt;=\u0026lt;string\u0026gt; ，添加 list 。 del_list \u0026lt;config\u0026gt;.\u0026lt;section\u0026gt;.\u0026lt;option\u0026gt;=\u0026lt;string\u0026gt; ，删除 list 。 show [\u0026lt;config\u0026gt;[.\u0026lt;section\u0026gt;[.\u0026lt;option\u0026gt;]]] ，以编程可读的语法显示 config，section 或者 option 的内容 get \u0026lt;config\u0026gt;.\u0026lt;section\u0026gt;[.\u0026lt;option\u0026gt;] ，获取 section 的 type ，或者 option 的 value 。 set \u0026lt;config\u0026gt;.\u0026lt;section\u0026gt;[.\u0026lt;option\u0026gt;]=\u0026lt;value\u0026gt; ，设置 section 的 type ，或者 option 的 value delete \u0026lt;config\u0026gt;[.\u0026lt;section\u0026gt;[[.\u0026lt;option\u0026gt;][=\u0026lt;id\u0026gt;]]] ，删除一个 section，option 或者 option 的 type rename \u0026lt;config\u0026gt;.\u0026lt;section\u0026gt;[.\u0026lt;option\u0026gt;]=\u0026lt;name\u0026gt; ，重命名 section 或者 option 。 revert \u0026lt;config\u0026gt;[.\u0026lt;section\u0026gt;[.\u0026lt;option\u0026gt;]] ，恢复未保存的修改内容 reorder \u0026lt;config\u0026gt;.\u0026lt;section\u0026gt;=\u0026lt;position\u0026gt; 新建一个 /etc/config/system 文件，然后做一次配置测试：\n# 添加一个匿名 section $ sudo uci add system system cfg01e48a # 设置一个选项 hostname 为 openwrt $ sudo uci set system.@system[0].hostname=\u0026#34;openwrt\u0026#34; # 查看已修改未保存的内容 $ sudo uci changes system system.cfg01e48a=\u0026#39;system\u0026#39; system.cfg01e48a.hostname=\u0026#39;openwrt\u0026#39; # 将修改内容提交保存到配置文件 $ sudo uci commit system # 获取一个选项的值 $ uci get system.@system[0].hostname openwrt # 查看文件内容 $ cat /etc/config/system config system option hostname \u0026#39;openwrt\u0026#39; uci 默认先将修改内容保存在 /tmp/.uci/ 目录下的临时文件中，使用 commit 命令后，才会将修改内容合并到 /etc/confg/ 下的文件。还没有 commit 的内容，可以用 revert 命令恢复，原理就是删除临时文件。\n将匿名 section 重命名 ：\n$ uci rename system.@system[0]=info $ uci changes system.cfg01e48a=\u0026#39;info\u0026#39; $ uci show system.info=system system.info.hostname=\u0026#39;openwrt\u0026#39; $ uci commit $ cat /etc/config/system config system \u0026#39;info\u0026#39; option hostname \u0026#39;openwrt\u0026#39; UCI 还支持一种特别的选项 list ，通常用于记录一组常量。以设置 ntp 服务器为例：\n$ sudo uci add system timeserver cfg02096b $ sudo uci rename system.@timeserver[0]=ntp $ sudo uci add_list system.ntp.server=\u0026#39;0.de.pool.ntp.org\u0026#39; $ sudo uci add_list system.ntp.server=\u0026#39;1.de.pool.ntp.org\u0026#39; $ sudo uci add_list system.ntp.server=\u0026#39;2.de.pool.ntp.org\u0026#39; $ sudo uci export system package system config system \u0026#39;info\u0026#39; option hostname \u0026#39;openwrt\u0026#39; config timeserver \u0026#39;ntp\u0026#39; list server \u0026#39;0.de.pool.ntp.org\u0026#39; list server \u0026#39;1.de.pool.ntp.org\u0026#39; list server \u0026#39;2.de.pool.ntp.org\u0026#39; $ sudo uci commit 同名的 list 可以一次读取：\n$ uci get system.ntp.server 0.de.pool.ntp.org 1.de.pool.ntp.org 2.de.pool.ntp.org 1.3 C 编程接口 #使用 C 语言解析 UCI 非常复杂，不推荐。下面是一个简单的例子，可以读取一个选项的值：\n// uci-example.c #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;uci.h\u0026gt; int main(int argc, char **argv) { struct uci_context *ctx; struct uci_ptr ptr; char *opt = strdup(\u0026#34;system.@system[0].hostname\u0026#34;); // 申请一个 uci_context ctx = uci_alloc_context(); // 获取并打印选项的值 if(UCI_OK != uci_lookup_ptr(ctx, \u0026amp;ptr, opt, true)) { uci_perror(ctx, \u0026#34;uci_lookup_ptr():\u0026#34;); } else { printf(\u0026#34;%s\\n\u0026#34;, ptr.o-\u0026gt;v.string); } // 释放指针 uci_free_context(ctx); free(opt); return 0; } 要包含 uci.h 头文件，关键的数据结构和 API 都定义在这个文件中。\n首先要调用 uci_alloc_context() 函数申请一个 struct uci_context 类型的指针，该结构存储了使用 UCI 过程中的各种状态数据，其他方法都要通过这个指针获得上下文数据。使用完毕用 uci_free_context() 函数释放。\nuci_lookup_ptr() 函数的作用是解析 opt 传入的 uci 元素定位字符串，查找配置文件，将该元素下的树形结构保存到一个 struct uci_ptr 结构变量中，原型如下：\nint uci_lookup_ptr(struct uci_context *ctx, struct uci_ptr *ptr, char *str, bool extended); 最后一个参数用于使能 UCI 扩展语法，设为 true 才可以解析 @system[0] 这种匿名 section 。函数调用成功会返回 UCI_OK ，调用失败会返回错误代码，可以用 uci_perror() 打印最新的错误代码对应的错误信息，原型如下：\nvoid uci_perror(struct uci_context *ctx, const char *str); 第二个参数用于设置错误信息的前缀，可以设为空。\n编译执行：\n$ gcc -Wall uci-example.c -o uci-example -luci $ ./uci-example openwrt 1.4 Lua 编程接口 #使用 lua 编程更为简便，只需导入 uci 包，就可以调用 uci 的 lua 语言 API ，下面是一个简单的例子：\n#!/usr/bin/lua -- uci-example.lua require(\u0026#34;uci\u0026#34;) print(\u0026#34;Hello World!\u0026#34;) -- 新建一个 uci 操作实例 ctx = uci.cursor() -- 获取一个选项的值 hostname = ctx:get(\u0026#34;system\u0026#34;,\u0026#34;@system[0]\u0026#34;,\u0026#34;hostname\u0026#34;) print(hostname) 保存后执行：\n$ chmod +x uci-example.lua $ ./uci-example.lua Hello World! openwrt 更多的 API 可以参考官方文档：https://openwrt.org/docs/techref/uci 。\n2. ubus #ubus 是基于 unix socket 的进程间通信框架，包含守护进程、命令行工具和链接库，守护进程 ubusd 作为 socket server ，用户可用 lua 或者 C 语言的 API 实现 socket client ，client 和 server 之间用 json 格式进行通信，client 端的消息处理抽象处理对象（object）和方法（method）。ubus 通过对 socket 的封装，简化了进程间通信的步骤，只需按照固定模式调用 ubus 提供的API即可。有两种常见的应用场景：\n服务器-客户端的形式，进程 A 注册一系列服务，进程 B 调用这些服务 订阅-通知的形式，进程 A 提供订阅服务，其他进程可用订阅或者退订这些服务，进程 A 可用向所有订阅者发布消息 编译安装 ubus\ngit clone https://git.openwrt.org/project/ubus.git cd ubus cmake . make make install 默认安装在 /usr/local 目录下，主要有四种文件：\nubusd ，守护进程 ubus ，命令行工具 libubus.h 等，一些头文件 libubus.so 等，一些链接库 ","date":"2019 December 24","permalink":"/posts/2019/12/24/","section":"Posts","summary":"UCI 和 ubus 都是 Openwrt 项目提供的软件，UCI 提供了统一的配置文件格式和读写工具，ubus 提供了基于 Unix Socket 的进程间通信框架。两个软件都可以方便的移植到其他 Linux 系统，以 Ubuntu20.","title":"UCI 和 ubus 学习笔记"},{"content":"1. 套接字 #套接字（Socket）是一种操作系统提供的进程间通信机制，可以用于不同主机间的进程通信，最早由 UNIX 提出，现在广泛用于各种操作系统，同时也特指这种机制下的通信端点。根据通信地址的不同种类，Socket 可以分为三类：\nINET ，这是 IPv4 地址域的套接字，用于 IPv4 网络间的通信。 INET6 ，这是 IPv6 地址域的套接字，用于 IPv6 网络间的通信。 UNIX ，这是 UNIX 域的套接字，用于主机内的进程间通信。 套接字常用的报文类型有两种：\nSOCK_DGRAM，固定长度，无连接不可靠的报文传递，两个对等进程之间通信时不需要建立逻辑连接，直接向对方的套接字发送报文即可。在 INET 套接字中，这种报文使用的默认协议是 UDP 。 SOCK_STREAM，有序的，可靠的，双向的，面向连接的字节流，两个对等进程在正式通信之前，要先建立逻辑连接。在 INET 套接字中，这种报文使用的默认协议是 TCP 。 Python 提供了 socket 模块用于底层 socket 通信，模块提供了一个同名的类，以及其他读写 socket 的方法。\n2. 获得主机信息 #获取本机的名字和 IP ：\n$ python3 Python 3.7.4 (default, Jul 9 2019, 18:13:23) [Clang 10.0.1 (clang-1001.0.46.4)] on darwin Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; import socket \u0026gt;\u0026gt;\u0026gt; socket.gethostname() \u0026#39;lscMBP.local\u0026#39; \u0026gt;\u0026gt;\u0026gt; socket.gethostbyname(\u0026#39;lscMBP.local\u0026#39;) \u0026#39;127.0.0.1\u0026#39; \u0026gt;\u0026gt;\u0026gt; socket.gethostbyname(\u0026#39;localhost\u0026#39;) \u0026#39;127.0.0.1\u0026#39; 也可以通过域名获得远程主机的 IP ：\n\u0026gt;\u0026gt;\u0026gt; socket.gethostbyname(\u0026#39;www.baidu.com\u0026#39;) \u0026#39;14.215.177.38\u0026#39; 以上方法返回的 IP 地址都是 str 类型，socket 模块提供格式转换的方法，可以把字符串转换为 32 位的整型：\n\u0026gt;\u0026gt;\u0026gt; addr = socket.gethostbyname(\u0026#39;localhost\u0026#39;) \u0026gt;\u0026gt;\u0026gt; addr \u0026#39;127.0.0.1\u0026#39; \u0026gt;\u0026gt;\u0026gt; socket.inet_aton(addr) b\u0026#39;\\x7f\\x00\\x00\\x01\u0026#39; 也可以把 32 位整型 IP 地址转换为字符串：\n\u0026gt;\u0026gt;\u0026gt; socket.inet_ntoa(b\u0026#39;\\xc0\\xa8\\x00\\x01\u0026#39;) \u0026#39;192.168.0.1\u0026#39; 3. UDP socket #socket 编程的第一步，通常是先新建一个 socket 对象，作为通信端点自身的抽象，最基本的方法是：\nsocket.socket(family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None) 参数 family 用于设置域，常用的值是：\nAF_INET : IPv4 域 AF_UNIX : UNIX 域 参数 type 用于设置报文的类型，常用的值是：\nSOCK_STREAM : 有序的，可靠的，双向的，面向连接的字节流 SOCK_DGRAM : 固定长度的，无连接的，不可靠的数据报 参数 proto 用于设置协议类型，0 表示默认，对于 SOCK_STREAM 类型，默认的协议就是 TCP ，对于 SOCK_DGRAM 类型，默认的协议就是 UDP 。\n新建 socket 后，可以调用 socket.bind() 方法为 socket 对象绑定一个本机的 IP 和端口，表示用该端口收发数据：\nsocket.bind(address) 对于 AF_INET , address 应该是一个元组 (host, port) ，host 是一个表示 IPv4 或者域名的字符串，host 是表示端口号的数字。 对于 AF_UNIX ，address 应该是一个表示 sock 文件绝对路径的字符串 如果没有调用 socket.bind() 绑定端口，系统会为 socket 随机分配可用的端口。所以，接收方必须绑定端口，发送方通常可用等待系统分配，下面是一个简单的例子。\n接收方绑定了 UDP:20000 端口，循环接收数据，并打印发送方的地址：\n#!/usr/bin/env python3 import socket with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s : s.bind((\u0026#39;127.0.0.1\u0026#39;, 20000)) while True : data, addr = s.recvfrom(1024) print(\u0026#39;Received\u0026#39;, repr(data), \u0026#39;from\u0026#39;, repr(addr)) 发送方向指定的地址发送一个字符串：\n#!/usr/bin/env python3 import socket with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s : s.sendto(b\u0026#39;Hello world\u0026#39;, (\u0026#39;127.0.0.1\u0026#39;, 20000)) 对于 UDP ，新建 socket 后，不需要建立连接，可用直接向对方的 IP 和端口发送数据。通常用 socket.redvfrom() 和 socket.sendto() 函数收发 UDP 数据。\n4. TCP socket #TCP 有如下几个特点：\n面向连接，发送数据前必须建立连接，确认接收方存在 有序传送，数据按发送者写入的顺序被读取 可靠，网络传输中丢失的数据包会被检测到并重新发送 TCP socket 编程的 API 调用次序如下：\n服务器端的 socket 绑定本机 IP 和端口后，调用 socket.listen() 方法表示愿意接受连接请求：\nsocket.listen([backlog]) 参数 backlog 可选，如果没有设置，系统会提供一个默认值，表示该进程允许进去请求队列的的连接数量的最大值，如果队列满了，会拒绝多余的连接请求。所以，backlog 的值应该基于服务器期望负载和处理的连接数量进行设置。\n之后，套接字可以调用 socket.accept() 方法获得连接请求，并建立连接：\nsocket.accept() 默认情况下这个方法会阻塞，收到客户端的请求后会返回一个元组 (conn, address) ，其中，conn 是客户端的 socket ，用于向客户端收发数据，address 是客户端 socket 绑定的地址。\n客户端可以调用 socket.connect() 方法向服务器端发起连接：\nsocket.connect(address) 参数 address 是表示服务器端地址的元组 (host, port) ，调用失败会抛出一个 OSError 异常。连接成功后，可以调用 socket.send() 和 socket.recv() 收发数据，下面是一个简单的例子。\n服务器端：\n#!/usr/bin/env python3 import socket host = \u0026#34;127.0.0.1\u0026#34; port = 20000 with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s : s.bind((host, port)) s.listen() conn, addr = s.accept() with conn : print(\u0026#34;Connected by\u0026#34;, addr) while True : data = conn.recv(1024) #阻塞，直到对方 socket 关闭 if not data : print(\u0026#34;Received finish\u0026#34;) break print(\u0026#34;Received : \u0026#34;, repr(data)) conn.sendall(data) print(\u0026#34;Reply !\u0026#34;) 客户端：\n#!/usr/bin/env python3 import socket host = \u0026#34;127.0.0.1\u0026#34; port = 20000 with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s : try : s.connect((host, port)) s.sendall(b\u0026#39;Hello world\u0026#39;) data = s.recv(1024) # 阻塞，直到对方 socket 关闭 except OSError as err : print(err) else : print(\u0026#34;Received : \u0026#34;, repr(data)) 5. UNIX socket #UNIX 域套接字用于同一台主机内的进程间通信，也提供 STREAM 和 DGRAM 两种报文类型，但 UNIX 域套接字的 DGRAM 是可靠的，不会丢失也不会传递出错。编程方法与 INET 域类似，只是 UNIX socket 需要绑定的地址是主机上的 socket 类型文件，下面是一个 STREAM 类型的例子。\n服务器端：\n#!/usr/bin/env python3 import socket import os SOCK = \u0026#34;./server.sock\u0026#34; if os.path.exists(SOCK): os.remove(SOCK) with socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) as s : s.bind(SOCK) s.listen() conn, _ = s.accept() with conn : print(\u0026#34;Connected by\u0026#34;, SOCK) while True : data = conn.recv(1024) if not data : print(\u0026#34;Received finish\u0026#34;) break print(\u0026#34;Received :\u0026#34;, repr(data)) conn.sendall(data) print(\u0026#34;Reply !\u0026#34;) os.remove(SOCK) 客户端：\n#!/usr/bin/env python3 import socket SOCK = \u0026#34;./server.sock\u0026#34; with socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) as s : try : s.connect(SOCK) s.sendall(b\u0026#39;Hello world\u0026#39;) data = s.recv(1024) except OSError as err : print(err) else : print(\u0026#34;Received : \u0026#34;, repr(data)) 6. bytes 对象 #socket 只能收发 bytes 类型的数据，这是 Python 内建的一个数据类型，是用于表示字节序列的对象，bytes 对象提供的很多方法仅在处理 ASCII 兼容数据时有效，且与字符串对象密切相关。bytes 类的定义：\nclass bytes([source[, encoding[, errors]]]) 如果 source 是一个整数，会返回一个长度为 source ，内容全为 0 的初始化字节序列。 如果 source 是一个字符串，会按照 encoding 指定的编码将字符串转换为字节序列。 \u0026gt;\u0026gt;\u0026gt; b=bytes(10) \u0026gt;\u0026gt;\u0026gt; b b\u0026#39;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#39; \u0026gt;\u0026gt;\u0026gt; a=\u0026#34;hello\u0026#34; \u0026gt;\u0026gt;\u0026gt; b=bytes(a,\u0026#39;ascii\u0026#39;) \u0026gt;\u0026gt;\u0026gt; b b\u0026#39;hello\u0026#39; 更简便的方法是在一个字符串前面加上字符 b ，表示这是一个 bytes 类型的字符串：\n\u0026gt;\u0026gt;\u0026gt; a=b\u0026#39;hello\u0026#39; \u0026gt;\u0026gt;\u0026gt; type(a) \u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; str 类型的字符串可以调用 encode() 方法转换为 bytes 类型：\n\u0026gt;\u0026gt;\u0026gt; a=\u0026#39;hello\u0026#39; \u0026gt;\u0026gt;\u0026gt; a.encode() b\u0026#39;hello\u0026#39; bytes 类型的字符串可以调用 decode() 方法转换为 str 类型：\n\u0026gt;\u0026gt;\u0026gt; a=b\u0026#39;hello\u0026#39; \u0026gt;\u0026gt;\u0026gt; a.decode() \u0026#39;hello\u0026#39; bytes 类提供了 hex() 方法，可以返回实例的十六进制数字的字符串对象：\n\u0026gt;\u0026gt;\u0026gt; a=b\u0026#39;hello\u0026#39; \u0026gt;\u0026gt;\u0026gt; a.hex() \u0026#39;68656c6c6f\u0026#39; \u0026gt;\u0026gt;\u0026gt; type(a.hex()) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; 除了显式 ASCII 字符，也可以直接定义一串十六进制序列，这样，非 ASCII 字符也可以使用 bytes ：\n\u0026gt;\u0026gt;\u0026gt; a=b\u0026#39;\\x68\\x65\\x6c\u0026#39; \u0026gt;\u0026gt;\u0026gt; a b\u0026#39;hel\u0026#39; \u0026gt;\u0026gt;\u0026gt; a=b\u0026#39;\\x01\\x02\u0026#39; \u0026gt;\u0026gt;\u0026gt; a b\u0026#39;\\x01\\x02\u0026#39; \u0026gt;\u0026gt;\u0026gt; a.hex() \u0026#39;0102\u0026#39; 因为 bytes 是以字节为单位的序列，可以用下标索引读取每个字节：\n\u0026gt;\u0026gt;\u0026gt; a=b\u0026#39;hello\u0026#39; \u0026gt;\u0026gt;\u0026gt; a.hex() \u0026#39;68656c6c6f\u0026#39; \u0026gt;\u0026gt;\u0026gt; a[0] 104 \u0026gt;\u0026gt;\u0026gt; a[0:2] b\u0026#39;he\u0026#39; 也可以用 list() 方法把 bytes 转换为元组，或者用元组定义 bytes ：\n\u0026gt;\u0026gt;\u0026gt; a=b\u0026#39;hello\u0026#39; \u0026gt;\u0026gt;\u0026gt; list(a) [104, 101, 108, 108, 111] \u0026gt;\u0026gt;\u0026gt; b=bytes([104, 101, 108, 108, 111]) \u0026gt;\u0026gt;\u0026gt; b b\u0026#39;hello\u0026#39; 利用这个特性，我们可以处理非 ASCII 编码的数据，例如把一个 32 位无符号整数变成长度为 4 的 bytes ：\n\u0026gt;\u0026gt;\u0026gt; n = 0x12345678 \u0026gt;\u0026gt;\u0026gt; n 305419896 \u0026gt;\u0026gt;\u0026gt; b1 = (n\u0026amp;0xff000000) \u0026gt;\u0026gt; 24 \u0026gt;\u0026gt;\u0026gt; b2 = (n\u0026amp;0xff0000) \u0026gt;\u0026gt; 16 \u0026gt;\u0026gt;\u0026gt; b3 = (n\u0026amp;0xff00) \u0026gt;\u0026gt; 8 \u0026gt;\u0026gt;\u0026gt; b4 = (n\u0026amp;0xff) \u0026gt;\u0026gt;\u0026gt; bs = bytes([b1, b2, b3, b4]) \u0026gt;\u0026gt;\u0026gt; bs b\u0026#39;\\x124Vx\u0026#39; \u0026gt;\u0026gt;\u0026gt; bs.hex() \u0026#39;12345678\u0026#39; 7. Struct 模块 #非 ASCII 编码的数据转换为 bytes 对象比较麻烦，python 提供了 struct 模块来解决二进制数据类型与 bytes 之间的转换。struct.pack() 函数可以把任意数据类型转换为 bytes ：\nstruct.pack(format, v1, v2, ...) 第一个参数是处理指令，后面的参数是要处理的数据，返回一个 bytes 对象，例如把一个 32 位无符号整数变成长度为 4 的 bytes ：\n\u0026gt;\u0026gt;\u0026gt; import struct \u0026gt;\u0026gt;\u0026gt; struct.pack(\u0026#39;\u0026gt;I\u0026#39;,0x12345678) b\u0026#39;\\x124Vx\u0026#39; \u0026gt;I 中的 \u0026gt; 表示字节序是大端，也就是网络序，I 表示一个 4 字节的无符号整数，后面的数据要和处理指令一致。处理指令的第一个字符总要定义字节序、大小和对齐方式，可选如下字符：\n字符 字节序 大小 对齐方式 @ 原生 原生 原生 = 原生 标准 无 \u0026lt; 小端 标准 无 \u0026gt; 大端 标准 无 ! 网络序（大端） 标准 无 如果没有设置，默认使用 @ 。 字节序分为大端和小端，原生 表示与本地的主机系统保持一致。 大小是指不同类型所占的字节数，原生 表示与本机使用的 C 编译器保持一致，标准 是指 struct 模块内置的标准大小，参考下面的格式字符表。 字节对齐方式与 C 语言相同。 字节序是指数据存储方式，Intel 处理和 Linux 系统都是小端，也就是低位数据存放在高位地址上，而 TCP/IP 协议使用的网络序是大端，低位数据存放在低位地址上。例如：\n\u0026gt;\u0026gt;\u0026gt; a=0x01020304 \u0026gt;\u0026gt;\u0026gt; struct.pack(\u0026#34;I\u0026#34;, a) b\u0026#39;\\x04\\x03\\x02\\x01\u0026#39; \u0026gt;\u0026gt;\u0026gt; struct.pack(\u0026#34;!I\u0026#34;, a) b\u0026#39;\\x01\\x02\\x03\\x04\u0026#39; struct 模块的本质是把 C 语言的数据类型转换为 Python 的数据类型，常用的类型转换如下表所示：\n字符 C 类型 Python 类型 大小 备注 c char bytes of length 1 1 b signed char integer 1 B unsigned char integer 1 ? _Bool bool 1 h short integer 2 H unsigned short integer 2 i int integer 4 I unsigned int integer 4 l long integer 4 L unsigned long integer 4 q long long integer 8 Q unsigned long long integer 8 f float float 4 d double float 8 s char[] bytes 在字符前可以加一个数字，表示有连续多个这样的数据，例如 4I 等同于 IIII 。对于 s 字符，默认只会去 bytes 数据的第一个字节，如果前面加一个数字，表示取 bytes 数去的前面几个字节。\nstruct.unpack() 函数可以把 bytes 类型转换为其他数据类型，例如把一个 6 字节的 bytes 转换为一个 4 字节的无符号整数和一个 2 字节的无符号整数：\n\u0026gt;\u0026gt;\u0026gt; struct.unpack(\u0026#39;\u0026gt;IH\u0026#39;, b\u0026#39;\\xf0\\xf0\\xf0\\xf0\\x08\\x08\u0026#39;) (4042322160, 2056) 举例填充一个数据帧，由两个单字节整数，一个四字节整数和四个字符组成：\n\u0026gt;\u0026gt;\u0026gt; buff = struct.pack(\u0026#39;2BI4s\u0026#39;, 0x01, 0x02, 0x12345678, b\u0026#39;will\u0026#39;) \u0026gt;\u0026gt;\u0026gt; print(buff) b\u0026#39;\\x01\\x02\\x00\\x00xV4\\x12will\u0026#39; \u0026gt;\u0026gt;\u0026gt; a = struct.unpack(\u0026#39;2BI4s\u0026#39;,buff) \u0026gt;\u0026gt;\u0026gt; print(a) (1, 2, 305419896, b\u0026#39;will\u0026#39;) \u0026gt;\u0026gt;\u0026gt; struct.calcsize(\u0026#39;2BI4s\u0026#39;) 12 struct.calcsize() 函数用于计算数据格式所占的字节数，为了与 I 型数据字节对齐，两个 B 型数据都填充了一个字节，所以实际占用了 12 个字节。\n上面处理的数据帧中，每个位置的长度都是固定的，而现实中的很多协议都有不定长的字段，处理这种数据时，需要把字段长度也一起打包，后面才方便解包。例如打包一个长度不定的字符串：\n\u0026gt;\u0026gt;\u0026gt; s = b\u0026#39;hello\u0026#39; \u0026gt;\u0026gt;\u0026gt; data = struct.pack(\u0026#34;I%ds\u0026#34; % len(s), len(s), s) \u0026gt;\u0026gt;\u0026gt; data b\u0026#39;\\x05\\x00\\x00\\x00hello\u0026#39; 解包的时候先获取字符串长度，然后在读取字符串：\n\u0026gt;\u0026gt;\u0026gt; int_size = struct.calcsize(\u0026#34;I\u0026#34;) \u0026gt;\u0026gt;\u0026gt; (i,)=struct.unpack(\u0026#34;I\u0026#34;, data[:int_size]) \u0026gt;\u0026gt;\u0026gt; i 5 \u0026gt;\u0026gt;\u0026gt; data_content = struct.unpack(\u0026#34;I%ds\u0026#34; % i, data) \u0026gt;\u0026gt;\u0026gt; data_content (5, b\u0026#39;hello\u0026#39;) 8. 非阻塞和超时 #sokcet 对象有三种模式：阻塞、非阻塞和超时：\n阻塞，会一直等待，直到操作成功，或者返回错误。 非阻塞，无论操作是否成功，都会立即返回，等待时间为 0 。 超时，会等待一段时间，之后会返回一个超时错误。 默认情况下，新建的 socket 对象总是阻塞的，accept() 、connect() 和 recv() 等方法都会受到阻塞的影响。可以调用如下函数设为非阻塞：\nsocket.setblocking(flag) flag 设为 Ture 表示阻塞。 flag 设为 False 表示非阻塞。 非阻塞模式下，默认的等待时间是 0 ，可以设置等待时间，这样就会变为超时模式，设置方法是：\nsocket.settimeout(value) 参数 value 应该设置一个浮点数，时间单位是秒。\n通过 socket.accept() 方法返回的 socket 对象是什么模式，取决于多种因素，最好设置一次。\n9. 并发 #实现 Socket 服务器并发的为了同时接收并处理更多的客户端连接，方法有很多，比如多线程，接收到一个客户端连接后就新建一个线程去处理，主线程继续等待新的连接。以 Unix Socket 为例：\n#!/usr/bin/env python3 import threading import socket import os def handle(conn): print(threading.current_thread().name) with conn : while True : data = conn.recv(1024) if not data : print(\u0026#34;Received finish\u0026#34;) break print(\u0026#34;Received :\u0026#34;, repr(data)) conn.sendall(data) print(\u0026#34;Reply !\u0026#34;) return SOCK = \u0026#34;./server.sock\u0026#34; if os.path.exists(SOCK): os.remove(SOCK) with socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) as s : s.bind(SOCK) s.listen() while True : conn, _ = s.accept() t = threading.Thread(target=handle, args=(conn, )) t.start() os.remove(SOCK) 参考 # socket 文档 Python并行编程 ","date":"2019 November 26","permalink":"/posts/2019/11/26/","section":"Posts","summary":"1. 套接字 #套接字（Socket）是一种操作系统提供的进程间通信机制，可以用于不同主机间的进程通信，最早由 UNIX 提出，现在广泛用于各种操作系统，同时也特指这种机制下的通信端点。根据通信地址的不同种类，Socket 可以分为三类：","title":"Python Socket 编程笔记"},{"content":"以 Ubuntu 16.04 为例，如果只想获得当前内核版本的源码可以用 apt-get ，如果想获取当前系统的所有内核源码建议用 git 。\n1. apt-get #通常是用 apt-get source 下载：\napt-get source linux-image-$(uname -r) 源码会直接下载到当前目录，并自动解压，所以建议在 /usr/src/ 目录下执行：\nroot@ubuntu:/usr/src# ls linux-4.4.0 linux_4.4.0-161.189.dsc linux-headers-4.4.0-142 linux_4.4.0-161.189.diff.gz linux_4.4.0.orig.tar.gz linux-headers-4.4.0-142-generic linux_4.4.0.orig.tar.gz 是标准内核源码 linux_4.4.0-161.189.diff.gz 是 Ubuntu kernel 的补丁 linux_4.4.0-161.189.dsc 是 Debian Source Control 文档，用于描述源码版本的相关信息 linux-4.4.0 是前两个文件解压打补丁后的源码目录 这样自动下载的小版本号通常是最新的，如果想精确匹配当前的内核版本，可以在 https://launchpad.net/ubuntu/+source/linux/ 搜索所需的版本，也是这样的三个文件，下载后需要手动解压打补丁：\ntar xfvz \u0026lt;filname\u0026gt;.orig.tar.gz gunzip \u0026lt;filename\u0026gt;.diff.gz cd ./\u0026lt;filename\u0026gt; patch -p1 -i \u0026lt;file name\u0026gt;.diff 此外，用 apt-cache search linux-source 和 apt-get install linux-source 也可以搜索并下载当前内核版本的源码，并自动解压到 /usr/src/ 目录下。\nroot@ubuntu:/usr/src$ ls linux-headers-4.4.0-116 linux-headers-4.4.0-116-generic linux-source-4.4.0 linux-source-4.4.0.tar.gz root@ubuntu:/usr/src$ ls linux-source-4.4.0/ debian debian.master linux-source-4.4.0.tar.gz 其中 debian 和 debian.master 目录下存放的是 ubuntu 发行版中针对内核修改的配置、补丁、说明和一些工具，在 /usr/src/ 目录下执行如下命令解压，所有源码就解压在 linux-source-4.4.0 目录下，：\n/usr/src$ tar xvf linux-source-4.4.0.tar.gz 2. git #Ubuntu 使用的内核源码都是用 git 维护的，每个版本的源代码都保存在 kernel.ubuntu.com上的 git 存储库中。可以下载你需要的版本：\ngit clone git://kernel.ubuntu.com/ubuntu/ubuntu-\u0026lt;release codename\u0026gt;.git 例如下载 16.04 LTS Xenial Xerus 的源码：\ngit clone git://kernel.ubuntu.com/ubuntu/ubuntu-xenial.git 这个版本库包含了当前内核源码的所有 commit ，可以检出所需的具体版本。\n3. 编译 #编译内核前，需要安装一些依赖，并复制一份系统自带的配置文件：\nroot@ubuntu:~# apt-get install libncurses5-dev bc libssl-dev root@ubuntu:~# cp -rf /boot/config-4.4.0-116-generic /usr/src/linux-source-4.4.0/.config 如果只是想修改个别模块，必须先复制当前安装的模块的符号表\nroot@ubuntu:/usr/src/linux-4.4# cp -rf /lib/modules/4.4.0-142-generic/build/Module.symvers ./Module.symvers 然后执行 make M=\u0026lt;module dir\u0026gt; 命令编译。\n参考 # Build Your Own Kernel Kernel Git Guide ","date":"2019 September 20","permalink":"/posts/2019/09/20/","section":"Posts","summary":"以 Ubuntu 16.","title":"Ubuntu 下获取和编译内核源码的方法"},{"content":"keepalived 是一个用 C 语言编写的免费开源软件，它实现了 VRRP协议，同时提供了强大的负载均衡 (LVS) 功能。我们可以用他的 VRRP 功能实现路由器或者服务器等网络设备的双机热备。简单的说，两台路由器，一台作为主机，一台作为备机，两台路由器有自己的独立 IP ，同时共享一个虚拟 IP ，主机正常是，这个虚拟 IP 指向主机，当主机出现故障时，虚拟 IP 指向备机，实现了路由器的无缝自动切换。网络拓扑如下图所示：\n虚拟 IP 的实现方式有很多种，比较可靠的方法是为一个网卡定义多个 IP ，端口名用冒号隔开一个数字，用 ifconfig 命令实现，例如：\nifconfig eth0:0 192.168.6.100 netmask 255.255.255.0 up 用点隔开一个数字的端口名属于 VLAN 网卡，例如 eth0.100 ，具有不同的特性和应用。\n安装 #keepalived 官网在 https://www.keepalived.org/ ，可以编译源码进行安装。在 ubuntu 系统下，直接用 apt 安装：\napt-get install keepalived 配置 #keepalived 只有一个配置文件 keepalived.conf，通常位于 /etc/keepalived/ 目录下，keepalived 还提供了很多配置文件的实例，安装在 /usr/share/doc/keepalived/sample/ 目录下。对于双机热备，最简单的配置如下：\n主机 ：\nvrrp_instance VI_1 { # 定义一个 VRRP 实例，VI_1 表示这个实例的名称，同一组 VRRP 路由器的实例名称必须一致 state MASTER # 定义本机的初始状态，MASTER 表示主机，BACKUP 表示备机 interface enp3s0 # 指定 VRRP 运行的网卡 virtual_router_id 51 # 定义 VRRP 路由器的 ID ，取值 1~255 ，同一组 VRRP 路由器的 ID 必须一致，这个 ID 会用于虚拟路由器的 MAC 地址 priority 100 # 定义本机的优先级，取值 1~254 ，数字越大，优先级越高，MASTER 应该比 BACKUP 高 50 以上。 virtual_ipaddress { # 定义虚拟 IP 192.168.1.3/24 } } 备机：\nvrrp_instance VI_1 { state BACKUP interface enp3s0 virtual_router_id 51 priority 40 virtual_ipaddress { 192.168.1.3/24 } } 配置完成后，执行 systemctl start keepalived 命令启动 keepalived 服务。\n验证 #主机正常的情况下，可以看到主机的 VRRP 实例处于 MASTER 状态：\n# systemctl status keepalived.service ● keepalived.service - Keepalive Daemon (LVS and VRRP) Loaded: loaded (/lib/systemd/system/keepalived.service; enabled; vendor preset: enabled) Active: active (running) since Sat 2019-08-24 16:22:33 CST; 9min ago Process: 2311 ExecStart=/usr/sbin/keepalived $DAEMON_ARGS (code=exited, status=0/SUCCESS) Main PID: 2315 (keepalived) Tasks: 3 Memory: 1.2M CPU: 195ms CGroup: /system.slice/keepalived.service ├─2315 /usr/sbin/keepalived ├─2316 /usr/sbin/keepalived └─2319 /usr/sbin/keepalived Aug 24 16:22:33 ubuntu Keepalived_vrrp[2319]: Using LinkWatch kernel netlink reflector... Aug 24 16:22:33 ubuntu Keepalived_healthcheckers[2316]: Registering Kernel netlink reflector Aug 24 16:22:33 ubuntu Keepalived_healthcheckers[2316]: Registering Kernel netlink command channel Aug 24 16:22:33 ubuntu Keepalived_healthcheckers[2316]: Opening file \u0026#39;/etc/keepalived/keepalived.conf\u0026#39;. Aug 24 16:22:33 ubuntu Keepalived_healthcheckers[2316]: Using LinkWatch kernel netlink reflector... Aug 24 16:25:27 ubuntu Keepalived_vrrp[2319]: VRRP_Instance(VI_1) Entering MASTER STATE 以及虚拟 IP 指向主机的网卡：\nroot@ubuntu:~# ip addr 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: enp3s0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:1d:f3:52:99:10 brd ff:ff:ff:ff:ff:ff inet 192.168.1.1/24 brd 192.168.1.255 scope global enp3s0 valid_lft forever preferred_lft forever inet 192.168.1.3/24 scope global secondary enp3s0 valid_lft forever preferred_lft forever inet6 fe80::21d:f3ff:fe52:9910/64 scope link valid_lft forever preferred_lft forever 如果把主机关闭，则备机的 VRRP 实例状态会变为 MASTER ，虚拟 IP 也会指向备机的网卡：\n# systemctl status keepalived.service ● keepalived.service - Keepalive Daemon (LVS and VRRP) Loaded: loaded (/lib/systemd/system/keepalived.service; enabled; vendor preset: enabled) Active: active (running) since Sat 2019-08-24 16:22:33 CST; 9min ago Process: 2311 ExecStart=/usr/sbin/keepalived $DAEMON_ARGS (code=exited, status=0/SUCCESS) Main PID: 2315 (keepalived) Tasks: 3 Memory: 1.2M CPU: 195ms CGroup: /system.slice/keepalived.service ├─2315 /usr/sbin/keepalived ├─2316 /usr/sbin/keepalived └─2319 /usr/sbin/keepalived Aug 24 16:22:33 ubuntu Keepalived_vrrp[2319]: Using LinkWatch kernel netlink reflector... Aug 24 16:22:33 ubuntu Keepalived_healthcheckers[2316]: Registering Kernel netlink reflector Aug 24 16:22:33 ubuntu Keepalived_healthcheckers[2316]: Registering Kernel netlink command channel Aug 24 16:22:33 ubuntu Keepalived_healthcheckers[2316]: Opening file \u0026#39;/etc/keepalived/keepalived.conf\u0026#39;. Aug 24 16:22:33 ubuntu Keepalived_healthcheckers[2316]: Using LinkWatch kernel netlink reflector... Aug 24 16:22:34 ubuntu Keepalived_vrrp[2319]: VRRP_Instance(VI_1) Entering BACKUP STATE Aug 24 16:25:26 ubuntu Keepalived_vrrp[2319]: VRRP_Instance(VI_1) Transition to MASTER STATE Aug 24 16:25:27 ubuntu Keepalived_vrrp[2319]: VRRP_Instance(VI_1) Entering MASTER STATE 参考 # 虚拟路由冗余协议(VRRP) CentOS 7 配置 Keepalived 实现双机热备 虚拟 IP 技术 Linux-eth0 eth0:1 和eth0.1关系、ifconfig以及虚拟IP实现介绍 ","date":"2019 August 24","permalink":"/posts/2019/08/24/","section":"Posts","summary":"keepalived 是一个用 C 语言编写的免费开源软件，它实现了 VRRP协议，同时提供了强大的负载均衡 (LVS) 功能。我们可以用他的 VRRP 功能实现路由器或者服务器等网络设备的双机热备。简单的说，两台路由器，一台作为主机，一台作为备机，两台路由器有自己的独立 IP ，同时共享一个虚拟 IP ，主机正常是，这个虚拟 IP 指向主机，当主机出现故障时，虚拟 IP 指向备机，实现了路由器的无缝自动切换。网络拓扑如下图所示：","title":"使用 keepalived 实现双机热备"},{"content":"aes 加密需要一个字符串作为密钥，自己写一个，或者用完成的工具生成一随机的，假设密钥为 passphrase ，加密一个文件 file：\nopenssl enc -aes-128-cbc -in file -out file.enc -k passphrase 也可以把密钥存放在一个文本文件，然后用 -kfile 选项指定：\nopenssl enc -aes-128-cbc -in file -out file.enc -kfile passphrase.txt ","date":"2019 August 18","permalink":"/posts/2019/08/18/","section":"Posts","summary":"aes 加密需要一个字符串作为密钥，自己写一个，或者用完成的工具生成一随机的，假设密钥为 passphrase ，加密一个文件 file：","title":"使用 openssl 进行 AES 加密"},{"content":"有时我们需要连接不同局域网的两台主机，使其可以互相访问，比如用家里的电脑登录办公室电脑的某个服务。我们可以使用 OpenVPN 实现这个功能，它的原理是在两台电脑上安装 OpenVPN 客户端，同时连接公网上的 OpenVPN 服务器，OpenVPN 会将这两台电脑组成一个虚拟局域网，它们就可以像局域网内一样互相访问了。搭建 VPN 前的网络拓扑如下：\n家里的电脑是 Windows7 系统，办公室的电脑安装了 Ubuntu16.04 ，公网上的 VPS 安装了 Ubuntu16.04 。如果全部都是 Windows 系统，配置起来会更方便一点，Linux 下的文本操作略显繁琐，好在 SoftEther 提供了可以远程管理的 GUI 工具。\n1. 在 VPS 上安装 SoftEther #SoftEther 这套软件其实是一个完整的夸平台 VPN 解决方案，在单一软件内集成了 OpenVPN 、L2TP 、IPsec 等 VPN 协议，我们可以用它在 VPS 上搭建一个 OpenVPN 的服务器，非常方便。\n首先在 SoftEther 下载中心 下载 X64-Linux 平台的 SoftEther VPN Server，我下载的版本是 softether-vpnserver-v4.29-9680-rtm-2019.02.28-linux-x64-64bit.tar.gz ，将其解压到 VPS 的用户根目录下，得到一个名为 vpnserver 的文件夹，在这个文件夹下执行 ./.install.sh ，根据提示依次输入三次数字 1 并按回车即可完成编译安装，所有的可执行文件还是在这个路径下，先执行 sudo ./vpnserver start 让服务器在后台运行，然后执行 ./vpncmd 开始初始化配置，按如下输入：\nubuntu@VM-231-137-ubuntu:~/vpnserver$ sudo ./vpnserver start The SoftEther VPN Server service has been started. ubuntu@VM-231-137-ubuntu:~/vpnserver$ ./vpncmd vpncmd command - SoftEther VPN Command Line Management Utility SoftEther VPN Command Line Management Utility (vpncmd command) Version 4.29 Build 9680 (English) Compiled 2019/02/28 19:22:54 by yagi at pc33 Copyright (c) SoftEther VPN Project. All Rights Reserved. By using vpncmd program, the following can be achieved. 1. Management of VPN Server or VPN Bridge 2. Management of VPN Client 3. Use of VPN Tools (certificate creation and Network Traffic Speed Test Tool) Select 1, 2 or 3: [在这里输入 1 ，表示管理 VPN 服务器] Specify the host name or IP address of the computer that the destination VPN Server or VPN Bridge is operating on. By specifying according to the format ‘host name:port number’, you can also specify the port number. (When the port number is unspecified, 443 is used.) If nothing is input and the Enter key is pressed, the connection will be made to the port number 8888 of localhost (this computer). Hostname of IP Address of Destination:[这里敲回车键，按默认配置使用 443 端口] If connecting to the server by Virtual Hub Admin Mode, please input the Virtual Hub name. If connecting by server admin mode, please press Enter without inputting anything. Specify Virtual Hub Name: [这里敲回车键] Connection has been established with VPN Server “localhost” (port 443).You have administrator privileges for the entire VPN Server. VPN Server\u0026gt;[输入 ServerPasswordSet ，表示设置一个密码] ServerPasswordSet command - Set VPN Server Administrator PasswordPlease enter the password. To cancel press the Ctrl+D key. Password: [输入你的密码] Confirm input: [再次输入你的密码] 之后的配置可以用 Windows 下的远程管理工具进行。\n首先在 SoftEther 下载中心 下载 X64-Windows 平台的 SoftEther VPN Server ，把它安装在家里的笔记本上，安装时选择 SoftEther VPN Server 管理工具（仅限管理工具） ，我们只是用它来连接并配置 VPS 上的 VPN 服务器：\n安装完成后启动 SoftEther VPN Server 管理器 ，在连接设置界面中点击 新设置 按钮，在弹出的对话框中按如下设置，新建一个指向 VPS 的连接：\n新建成功后，在连接设置界面双击这个设置，开始连接 VPS ，连接成功后会弹出一个管理对话框，这里会出现一个默认的虚拟 HUB ，先将其删除，然后点击 创建虚拟 HUB 按钮，按如下设置，然后点击 确定 ，就可以新建一个虚拟 HUB ，其中名字和密码都可以自定义：\n回到管理界面，双击刚才新建的这个虚拟 HUB ，进入这个 HUB 的管理界面：\n点击 管理用户 ，为这个 HUB 新建一个用户，按如下设置：\n回到这个 HUB 的管理界面，点击 虚拟 NAT 和 虚拟 DHCP 服务器 ，在弹出的对话框中点击 启动 SecureNAT ，如果想修改配置，可以点击 SecureNAT 配置 。至此，VPN 服务器配置都结束了，我们需要导出相应的客户端配置，供后面的客户端使用。在管理界面的右下角点击 OpenVPN/MS-SSTP 设置 按钮，在弹出的对话框中按如下设置：\n然后点击 为 OpenVPN Client 生成配置样本文件 就可以导出一个保护配置文件的压缩包，压缩包里会有两个配置文件，我们使用 L3 用于远程访问的这个：\n注意，VPS 上使用了默认的 TCP:443 和 UDP:1194 端口，要记得在 VPS 的防火墙上打开这两个端口，否则会造成客户端连接失败。\n2. 在家里电脑上安装 OpenVPN 客户端 #在 OpenVPN 下载中心 下载 Win7 版的安装包，一路 Next 安装成功后启动 OpenVPN GUI ，首次启动会提示没有配置文件，这时需要在状态栏的 OpenVPN 图标上点击右键，选择 导入配置文件... :\n导入上一步得到的 vm-231-137-ubunt_openvpn_remote_access_l3.ovpn 配置文件，然后点击 连接 ，按提示输入 OpenVPN 服务器中设置的用户名和密码：\n点击 确定 后开始连接，连接成功后会获得虚拟局域网为本机分配的 IP ：\n3. 在办公室电脑上安装 OpenVPN 客户端 #在 Ubuntu 上用 sudo apt-get install openvpn 命令安装 OpenVPN ，然后把配置文件 vm-231-137-ubunt_openvpn_remote_access_l3.ovpn 复制到 /etc/openvpn/ 路径下，并改名为 client.conf ，然后执行 systemctl start openvpn@client 启动连接：\nroot@ubuntu:~# systemctl start openvpn@client Enter Auth Username: **** Enter Auth Password: *********** root@ubuntu:~# systemctl status openvpn@client ● openvpn@client.service - OpenVPN connection to client Loaded: loaded (/lib/systemd/system/openvpn@.service; disabled; vendor preset: enabled) Active: active (running) since Wed 2019-07-03 10:12:01 CST; 11s ago Docs: man:openvpn(8) https://community.openvpn.net/openvpn/wiki/Openvpn23ManPage https://community.openvpn.net/openvpn/wiki/HOWTO Process: 2409 ExecStart=/usr/sbin/openvpn --daemon ovpn-%i --status /run/openvpn/%i.status 10 --cd /etc/openvp Main PID: 2429 (openvpn) CGroup: /system.slice/system-openvpn.slice/openvpn@client.service └─2429 /usr/sbin/openvpn --daemon ovpn-client --status /run/openvpn/client.status 10 --cd /etc/openvp Jul 03 10:12:04 ubuntu ovpn-client[2429]: ROUTE_GATEWAY 10.231.222.129/255.255.255.248 IFACE=enp0s29u1u3u1c2 HWA Jul 03 10:12:04 ubuntu ovpn-client[2429]: TUN/TAP device tun0 opened Jul 03 10:12:04 ubuntu ovpn-client[2429]: TUN/TAP TX queue length set to 100 Jul 03 10:12:04 ubuntu ovpn-client[2429]: do_ifconfig, tt-\u0026gt;ipv6=0, tt-\u0026gt;did_ifconfig_ipv6_setup=0 Jul 03 10:12:04 ubuntu ovpn-client[2429]: /sbin/ip link set dev tun0 up mtu 1500 Jul 03 10:12:04 ubuntu ovpn-client[2429]: /sbin/ip addr add dev tun0 local 192.168.30.13 peer 192.168.30.14 Jul 03 10:12:04 ubuntu ovpn-client[2429]: /sbin/ip route add 118.89.16.2/32 via 10.231.222.129 Jul 03 10:12:04 ubuntu ovpn-client[2429]: /sbin/ip route add 0.0.0.0/1 via 192.168.30.14 Jul 03 10:12:04 ubuntu ovpn-client[2429]: /sbin/ip route add 128.0.0.0/1 via 192.168.30.14 Jul 03 10:12:04 ubuntu ovpn-client[2429]: Initialization Sequence Completed root@ubuntu:~# ps -ef | grep openvpn root 2429 1 0 10:12 ? 00:00:00 /usr/sbin/openvpn --daemon ovpn-client --status /run/openvpn/client.status 10 --cd /etc/openvpn --script-security 2 --config /etc/openvpn/client.conf --writepid /run/openvpn/client.pid root 2503 1858 0 10:12 pts/0 00:00:00 grep --color=auto openvpn 连接成功后会出现 tun0 网络接口，并获得一个 IP ：\nroot@ubuntu:~# ifconfig tun0 tun0 Link encap:UNSPEC HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00 inet addr:192.168.30.13 P-t-P:192.168.30.14 Mask:255.255.255.255 UP POINTOPOINT RUNNING NOARP MULTICAST MTU:1500 Metric:1 RX packets:6 errors:0 dropped:0 overruns:0 frame:0 TX packets:6 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:100 RX bytes:396 (396.0 B) TX bytes:396 (396.0 B) root@ubuntu:~# cat /run/openvpn/client.status OpenVPN STATISTICS Updated,Wed Jul 3 10:12:52 2019 TUN/TAP read bytes,594 TUN/TAP write bytes,594 TCP/UDP read bytes,4196 TCP/UDP write bytes,2725 Auth read bytes,850 END 4. 测试 #连接成功后的网络拓扑如下：\n客户端通过 VPN 隧道连接到了服务器的虚拟 HUB 上，共同组成了一个 192.168.30.0/24 的局域网，客户端直接可以想局域网内一样相互访问，在家里电脑上 ping 办公室内的电脑：\n5. 配置签名证书 #上面建立的 VPN 服务器支持的是密码验证，如果要使用签名证书认证，需要用 OpenVPN 搭建服务器，因为 SoftEther 对签名证书认证支持不够完善。签名证书由服务器端签发，需要制作三个证书： CA 证书、服务器端证书和客户端证书。\n5.1. 生成证书 #先在服务器端使用 sudo apt-get install openvpn easy-rsa 命令安装 OpenVPN 和证书制作工具 easy-rsa 。然后把 /usr/share/easy-rsa/ 文件夹及其内容复制到 /etc/openvpn/ 路径下，然后编辑其中的 vars 文件，这个文件是 easy-rsa 的配置文件，包含了生成证书和密钥时使用的选项，可以使用默认值，或者根据实际情况修改如下选项：\n# These are the default values for fields # which will be placed in the certificate. # Don\u0026#39;t leave any of these fields blank. export KEY_COUNTRY=\u0026#34;CN\u0026#34; #国家 export KEY_PROVINCE=\u0026#34;GD\u0026#34; #省份 export KEY_CITY=\u0026#34;Shenzhen\u0026#34; #城市 export KEY_ORG=\u0026#34;Fort-Funston\u0026#34; #组织/公司 export KEY_EMAIL=\u0026#34;me@myhost.mydomain\u0026#34; #Email export KEY_OU=\u0026#34;MyOrganizationalUnit\u0026#34; #部门名称 # X509 Subject Field export KEY_NAME=\u0026#34;EasyRSA\u0026#34; #密钥的名称 然后使这项选项生效，并初始化，需要先切换到 root 用户：\nubuntu@VM-231-137-ubuntu:~$ sudo su root@VM-231-137-ubuntu:~# cd /etc/openvpn/easy-rsa root@VM-231-137-ubuntu:/etc/openvpn/easy-rsa# source vars NOTE: If you run ./clean-all, I will be doing a rm -rf on /etc/openvpn/easy-rsa/keys root@VM-231-137-ubuntu:/etc/openvpn/easy-rsa# ./clean-all 执行 ./build-ca 新建 CA 证书，一路回车即可，生成的证书和密钥在 keys 文件夹下，把证书复制到 /etc/openvpn/ 目录下：\nroot@VM-231-137-ubuntu:/etc/openvpn/easy-rsa# ls keys/ ca.crt ca.key index.txt serial root@VM-231-137-ubuntu:/etc/openvpn/easy-rsa# cp -rf keys/ca.crt /etc/openvpn/ 执行 ./build-key-server EasyRSA 新建服务器端证书，其中 EasyRSA 是 vars 文件中设置的 KEY_NAME 的值，再执行 ./build-dh 生成密钥交换所需的 Diffe-Hellman 文件，一路回车后，生成的证书和密钥等都在 keys 文件夹下，把他们复制到 /etc/openvpn/ 目录下：\nroot@VM-231-137-ubuntu:/etc/openvpn/easy-rsa# ll keys/ total 60 drwx------ 2 root root 4096 Jul 3 17:51 ./ drwxr-xr-x 3 root root 4096 Jul 3 17:43 ../ -rw-r--r-- 1 root root 5702 Jul 3 17:45 01.pem -rw-r--r-- 1 root root 5702 Jul 3 17:45 EasyRSA.crt -rw-r--r-- 1 root root 1094 Jul 3 17:45 EasyRSA.csr -rw------- 1 root root 1704 Jul 3 17:45 EasyRSA.key -rw-r--r-- 1 root root 1801 Jul 3 17:27 ca.crt -rw------- 1 root root 1704 Jul 3 17:27 ca.key -rw-r--r-- 1 root root 424 Jul 3 17:51 dh2048.pem -rw-r--r-- 1 root root 146 Jul 3 17:45 index.txt -rw-r--r-- 1 root root 21 Jul 3 17:45 index.txt.attr -rw-r--r-- 1 root root 0 Jul 3 17:23 index.txt.old -rw-r--r-- 1 root root 3 Jul 3 17:45 serial -rw-r--r-- 1 root root 3 Jul 3 17:23 serial.old root@VM-231-137-ubuntu:/etc/openvpn/easy-rsa# cp -rf keys/EasyRSA.crt /etc/openvpn/ root@VM-231-137-ubuntu:/etc/openvpn/easy-rsa# cp -rf keys/EasyRSA.key /etc/openvpn/ root@VM-231-137-ubuntu:/etc/openvpn/easy-rsa# cp -rf keys/dh2048.pem /etc/openvpn/ 执行 ./build-key client 新建客户端证书，client 是证书名称，可以自定义，生成的客户端证书和密钥等都在 keys 文件夹下：\nroot@VM-231-137-ubuntu:/etc/openvpn/easy-rsa# ll keys/ total 92 drwx------ 2 root root 4096 Jul 3 17:57 ./ drwxr-xr-x 3 root root 4096 Jul 3 17:43 ../ -rw-r--r-- 1 root root 5702 Jul 3 17:45 01.pem -rw-r--r-- 1 root root 5578 Jul 3 17:57 02.pem -rw-r--r-- 1 root root 5702 Jul 3 17:45 EasyRSA.crt -rw-r--r-- 1 root root 1094 Jul 3 17:45 EasyRSA.csr -rw------- 1 root root 1704 Jul 3 17:45 EasyRSA.key -rw-r--r-- 1 root root 1801 Jul 3 17:27 ca.crt -rw------- 1 root root 1704 Jul 3 17:27 ca.key -rw-r--r-- 1 root root 5578 Jul 3 17:57 client.crt -rw-r--r-- 1 root root 1094 Jul 3 17:57 client.csr -rw------- 1 root root 1704 Jul 3 17:57 client.key -rw-r--r-- 1 root root 424 Jul 3 17:51 dh2048.pem -rw-r--r-- 1 root root 291 Jul 3 17:57 index.txt -rw-r--r-- 1 root root 21 Jul 3 17:57 index.txt.attr -rw-r--r-- 1 root root 21 Jul 3 17:45 index.txt.attr.old -rw-r--r-- 1 root root 146 Jul 3 17:45 index.txt.old -rw-r--r-- 1 root root 3 Jul 3 17:57 serial -rw-r--r-- 1 root root 3 Jul 3 17:45 serial.old 5.2. 服务器端配置 #服务器端可以复制 OpenVPN 自带的配置文件模板，得到 server.conf ，然后进行修改：\nroot@VM-231-137-ubuntu:~# cp -rf /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz /etc/openvpn/ root@VM-231-137-ubuntu:~# cd /etc/openvpn/ root@VM-231-137-ubuntu:/etc/openvpn# gzip -d server.conf.gz 注意如下几个选项：\nport 1194 # 监听的端口，使用默认的 1194 就行 proto udp # 使用的传输层协议，默认使用 UDP dev tun # 这里设置了虚拟网卡的类型，tun 表示网络层设备，它操作 IP 数据包，tap 表示以太网设备，它操作链路层的以太网数据帧。 ca ca.crt # 指定 CA 证书 cert EasyRSA.crt # 指定服务器端证书 key EasyRSA.key # 指定服务器端密钥 dh dh2048.pem # 指定 Diffe-Hellman 文件 server 10.8.0.0 255.255.255.0 # 设置虚拟局域网的网段，10.8.0.1 会留给服务器自用 client-to-client # 允许客户端之间相互可见，否则多个客户端只能看到服务器，而看不到彼此 duplicate-cn # 这个选项允许多个客户端使用相同的证书和密钥进行连接，并分配不同的 IP 保存后切回普通用户，然后启动 OpenVPN 服务器：\nroot@VM-231-137-ubuntu:~# exit exit ubuntu@VM-231-137-ubuntu:~$ cd ubuntu@VM-231-137-ubuntu:~$ systemctl start openvpn@server ubuntu@VM-231-137-ubuntu:~$ systemctl status openvpn@server * openvpn@server.service - OpenVPN connection to server Loaded: loaded (/lib/systemd/system/openvpn@.service; disabled; vendor preset: enabled Active: active (running) since Thu 2019-07-04 09:05:45 CST; 2s ago Docs: man:openvpn(8) https://community.openvpn.net/openvpn/wiki/Openvpn23ManPage https://community.openvpn.net/openvpn/wiki/HOWTO Process: 20430 ExecStart=/usr/sbin/openvpn --daemon ovpn-%i --status /run/openvpn/%i.st Main PID: 20439 (openvpn) CGroup: /system.slice/system-openvpn.slice/openvpn@server.service `-20439 /usr/sbin/openvpn --daemon ovpn-server --status /run/openvpn/server.st Jul 04 09:05:45 VM-231-137-ubuntu ovpn-server[20439]: do_ifconfig, tt-\u0026gt;ipv6=0, tt-\u0026gt;did_if Jul 04 09:05:45 VM-231-137-ubuntu ovpn-server[20439]: /sbin/ip link set dev tun0 up mtu 1 Jul 04 09:05:45 VM-231-137-ubuntu ovpn-server[20439]: /sbin/ip addr add dev tun0 local 10 Jul 04 09:05:45 VM-231-137-ubuntu ovpn-server[20439]: /sbin/ip route add 10.8.0.0/24 via Jul 04 09:05:45 VM-231-137-ubuntu ovpn-server[20439]: UDPv4 link local (bound): [undef] Jul 04 09:05:45 VM-231-137-ubuntu ovpn-server[20439]: UDPv4 link remote: [undef] Jul 04 09:05:45 VM-231-137-ubuntu ovpn-server[20439]: MULTI: multi_init called, r=256 v=2 Jul 04 09:05:45 VM-231-137-ubuntu ovpn-server[20439]: IFCONFIG POOL: base=10.8.0.4 size=6 Jul 04 09:05:45 VM-231-137-ubuntu ovpn-server[20439]: IFCONFIG POOL LIST Jul 04 09:05:45 VM-231-137-ubuntu ovpn-server[20439]: Initialization Sequence Completed ubuntu@VM-231-137-ubuntu:~$ ifconfig tun0 tun0 Link encap:UNSPEC HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00 inet addr:10.8.0.1 P-t-P:10.8.0.2 Mask:255.255.255.255 UP POINTOPOINT RUNNING NOARP MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:100 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) 5.3. 客户端配置 #客户端的认证需要三个文件：ca.crt 、client.crt 和 client.key ，它们都在服务器 /etc/openvpn/easy-rsa/keys/ 目录下已经生成了，客户端的配置文件也可用 OpenVPN 提供的模板 /usr/share/doc/openvpn/examples/sample-config-files/client.conf 进行修改。\n以 Ubuntu 系统为例，把以上四个文件复制到客户端的 /etc/openvpn/ 目录下，然后修改配置文件 /etc/openvpn/ ，注意如下几个选项。\ndev tun # 虚拟网卡类型，与服务器保持一致 proto udp # 传输层协议类型，与服务器保持一致 remote 118.89.16.2 1194 # 服务器的 IP 和端口 ca ca.crt # CA 证书的文件名，因为在同一目录下，所以不用加路径 cert client.crt # 客户端证书 key client.key # 客户端密钥 保存后启动 OpenVPN 客户端连接，这次就不用再输入用户名和密码了：\nroot@ubuntu:~# systemctl start openvpn@client root@ubuntu:~# ifconfig tun0 tun0 Link encap:UNSPEC HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00 inet addr:10.8.0.6 P-t-P:10.8.0.5 Mask:255.255.255.255 UP POINTOPOINT RUNNING NOARP MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:100 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) 如果是 Windows 客户端，配置文件的后缀要改成 .ovpn ，其他都是一样的。\n","date":"2019 July 2","permalink":"/posts/2019/07/02/","section":"Posts","summary":"有时我们需要连接不同局域网的两台主机，使其可以互相访问，比如用家里的电脑登录办公室电脑的某个服务。我们可以使用 OpenVPN 实现这个功能，它的原理是在两台电脑上安装 OpenVPN 客户端，同时连接公网上的 OpenVPN 服务器，OpenVPN 会将这两台电脑组成一个虚拟局域网，它们就可以像局域网内一样互相访问了。搭建 VPN 前的网络拓扑如下：","title":"使用 OpenVPN 实现远程访问"},{"content":"UDP 是面向非连接的，如果通讯双方都在局域网中，服务器端和客户端没有区别，如果是局域网内的主机与公网上的主机通讯，由于 NAT 地址转换协议的作用，必须由局域网内的主机主动向公网的主句发送数据，公网的主机作为服务器端，必须接收客户端的数据后，解析出源 IP 和端口，再反向发送，实现双向通讯。下面是一个简单的 Demo 。\n服务器端：\n// server.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define SERVER_PORT 6789 #define CPU_PORT 9009 #define BUFF_LEN 1024 int main(int argc, char* argv[]) { int server_fd, count; struct sockaddr_in ser_addr; struct sockaddr_in src_addr; socklen_t len; char buf[BUFF_LEN]; server_fd = socket(AF_INET, SOCK_DGRAM, 0); //IPV4,UDP memset(\u0026amp;ser_addr, 0, sizeof(ser_addr)); ser_addr.sin_family = AF_INET; ser_addr.sin_addr.s_addr = htonl(INADDR_ANY); // any ip ser_addr.sin_port = htons(SERVER_PORT); // server port bind(server_fd, (struct sockaddr*)\u0026amp;ser_addr, sizeof(ser_addr)); while(1) { // recv memset(buf, 0, BUFF_LEN); len = sizeof(src_addr); count = recvfrom(server_fd, buf, BUFF_LEN, 0, (struct sockaddr*)\u0026amp;src_addr, \u0026amp;len); //block if(count == -1) { printf(\u0026#34;recieve data fail!\\n\u0026#34;); return 0; } printf(\u0026#34;server recv from %s:%d : %s\\n\u0026#34;,inet_ntoa(src_addr.sin_addr),ntohs(src_addr.sin_port),buf); // send memset(buf, 0, BUFF_LEN); sprintf(buf, \u0026#34;Server have recieved %d bytes data!\u0026#34;, count); printf(\u0026#34;server send : %s\\n\\n\u0026#34;,buf); // send to src_addr sendto(server_fd, buf, BUFF_LEN, 0, (struct sockaddr*)\u0026amp;src_addr, len); } close(server_fd); return 0; } 客户端：\n// cpu.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define SERVER_IP \u0026#34;118.89.16.24\u0026#34; #define SERVER_PORT 6789 #define CPU_PORT 9009 #define BUFF_LEN 1024 int main(int argc, char* argv[]) { int cpu_fd; struct sockaddr_in ser_addr; struct sockaddr_in src_addr; struct sockaddr_in my_addr; socklen_t len; char buf[BUFF_LEN] = \u0026#34;cpu msg!\u0026#34;; cpu_fd = socket(AF_INET, SOCK_DGRAM, 0); //IPV4,UDP memset(\u0026amp;my_addr, 0, sizeof(my_addr)); my_addr.sin_family = AF_INET; my_addr.sin_addr.s_addr = htonl(INADDR_ANY); // any ip my_addr.sin_port = htons(CPU_PORT); // server port bind(cpu_fd, (struct sockaddr*)\u0026amp;my_addr, sizeof(my_addr)); memset(\u0026amp;ser_addr, 0, sizeof(ser_addr)); ser_addr.sin_family = AF_INET; ser_addr.sin_addr.s_addr = inet_addr(SERVER_IP); ser_addr.sin_port = htons(SERVER_PORT); len = sizeof(ser_addr); printf(\u0026#34;CPU send : %s\\n\u0026#34;,buf); sendto(cpu_fd, buf, BUFF_LEN, 0, (struct sockaddr*)\u0026amp;ser_addr, len); memset(buf, 0, BUFF_LEN); recvfrom(cpu_fd, buf, BUFF_LEN, 0, (struct sockaddr*)\u0026amp;src_addr, \u0026amp;len); //recv msg from server printf(\u0026#34;CPU recv from %s:%d : %s\\n\u0026#34;,inet_ntoa(src_addr.sin_addr),ntohs(src_addr.sin_port),buf); close(cpu_fd); return 0; } ","date":"2018 December 20","permalink":"/posts/2018/12/20/","section":"Posts","summary":"UDP 是面向非连接的，如果通讯双方都在局域网中，服务器端和客户端没有区别，如果是局域网内的主机与公网上的主机通讯，由于 NAT 地址转换协议的作用，必须由局域网内的主机主动向公网的主句发送数据，公网的主机作为服务器端，必须接收客户端的数据后，解析出源 IP 和端口，再反向发送，实现双向通讯。下面是一个简单的 Demo 。","title":"UDP socket 编程实践"},{"content":"关于 iptables 的原理，这里有一份教程写得深入浅出，浅显易懂：\niptables 详解 常用的命令可以参考参考 iptables 手册\n下面记录一些常见的 iptables 应用场景。\n1. IP 转发 #IP 转发也可以叫做路由转发，用于连接两个不同的网段，做软路由时经常用到，如下是一个应用场景的网络拓扑：\n中间的路由器上是 Linux 系统，有两张网卡，eth0 作为 LAN 口连接内网，wan 作为 WAN 口连接公网。要实现软路由功能，使内网的设备可以通过 WAN 口上网。首先需要开启内核的 IP 转发功能，可以用 sysctl 命令或者直接查看 /proc/sys/net/ipv4/ip_forward 文件获得当前系统的 ip_forward 是否开启：\n~# sysctl net.ipv4.ip_forward net.ipv4.ip_forward = 0 ~# cat /proc/sys/net/ipv4/ip_forward 0 Linux 系统默认是禁止 IP 转发的，所有返回 0 ，可以用 sysctl 命令或者直接向 /proc/sys/net/ipv4/ip_forward 文件写 1 来开启 IP 转发，如果要永久开启，可以在 /etc/sysctl.conf 文件中修改配置：\n~# cat /etc/sysctl.conf | grep ip_forward net.ipv4.ip_forward=1 然后在 iptables 中添加规则：\n# Default policy to drop all incoming packets iptables -P INPUT DROP iptables -P FORWARD DROP # Accept incoming packets from localhost and the LAN interface iptables -A INPUT -i lo -j ACCEPT iptables -A INPUT -i eth0 -j ACCEPT # Accept incoming packets from the WAN if the router initiated the connection iptables -A INPUT -i wan -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT # Forward LAN packets to the WAN iptables -A FORWARD -i eth0 -o wan -j ACCEPT # Forward WAN packets to the LAN if the LAN initiated the connection iptables -A FORWARD -i wan -o eth0 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT # NAT traffic going out the WAN interface iptables -t nat -A POSTROUTING -o wwan -j MASQUERADE 2. 端口映射 #端口映射就是将外网主机的一个端口映射到内网中某台主机的某个端口，当用户访问外网主机的这个端口时，实际上是由内网主机的相应端口通讯。如下是一个典型的应用场景：\n在这个网络拓扑里，右侧 192.168.2.101 的主机想要访问下方路由器连接的 192.168.1.101 主机的 HTTP 服务，该怎么办呢？\n方法是在下方路由器上做端口映射，将 192.168.1.101 的 80 端口映射到 192.168.2.103 的 80 端口上，这样直接访问 192.168.2.103:80 就可以与 192.168.1.101:80 通讯。 具体添加的规则是：\niptables -t nat -I PREROUTING -i eth2 -d 192.168.2.103 -p tcp --dport 80 -j DNAT --to-destination 192.168.1.101:80 iptables -t nat -I POSTROUTING -o eth1 -d 192.168.1.101 -p tcp --dport 80 -j SNAT --to-source 192.168.1.1 当 192.168.2.101 访问 192.168.2.103:80 时，第一条规则在入口处修改了数据包的目的地址，第二条规则在出口处修改了源地址，就将数据包转移到了 192.168.1.101:80 。\n3. 禁止 ping #禁止 ping 指的是禁止别的主机 ping 本机，可以添加如下规则：\niptables -t filter -I INPUT -p icmp -m icmp --icmp-type 8/0 -j REJECT # or iptables -t filter -I INPUT -p icmp -m icmp --icmp-type 8 -j REJECT # or iptables -t filter -I INPUT -p icmp -m icmp --icmp-type \u0026#34;echo-request\u0026#34; -j REJECT 发出的 ping 请求属于 type 8 类型的 ICMP 报文，这条规则表示 type 为 8 ，code 为 0 的 ICMP 包会被拒绝。\n","date":"2018 December 12","permalink":"/posts/2018/12/12/","section":"Posts","summary":"关于 iptables 的原理，这里有一份教程写得深入浅出，浅显易懂：","title":"iptables 学习笔记"},{"content":"查看当前系统时间：\n$ timedatectl status Local time: Thu 2018-09-20 09:42:53 CST Universal time: Thu 2018-09-20 01:42:53 UTC RTC time: Thu 2018-09-20 01:42:53 Time zone: Asia/Chongqing (CST, +0800) Network time on: yes NTP synchronized: yes RTC in local TZ: no RTC in local TZ: no 表示 RTC 时钟不是用本地时间，而是使用 UTC 时间，可以改成使用本地时间，但是并不推荐这么做：\n$ timedatectl set-local-rtc 1 $ timedatectl Local time: Thu 2018-09-20 03:57:58 CEST Universal time: Thu 2018-09-20 01:57:58 UTC RTC time: Thu 2018-09-20 03:57:59 Time zone: Europe/Paris (CEST, +0200) Network time on: yes NTP synchronized: yes RTC in local TZ: yes Warning: The system is configured to read the RTC time in the local time zone. This mode can not be fully supported. It will create various problems with time zone changes and daylight saving time adjustments. The RTC time is never updated, it relies on external facilities to maintain it. If at all possible, use RTC in UTC by calling \u0026#39;timedatectl set-local-rtc 0\u0026#39;. 列出所有可用的时区：\n$ timedatectl list-timezones 修改时区：\n$ timedatectl set-timezone \u0026#34;Europe/Paris\u0026#34; $ timedatectl Local time: Thu 2018-09-20 03:46:02 CEST Universal time: Thu 2018-09-20 01:46:02 UTC RTC time: Thu 2018-09-20 01:46:02 Time zone: Europe/Paris (CEST, +0200) Network time on: yes NTP synchronized: yes RTC in local TZ: no $ cat /etc/timezone Europe/Paris $ date Thu Sep 20 03:46:48 CEST 2018 设置时间和日期：\ntimedatectl set-time \u0026#39;16:10:40 2018-11-20\u0026#39; 关闭时间同步，实际是关闭 systemd-timesyncd.service 服务：\n$ timedatectl set-ntp 0 $ timedatectl Local time: Thu 2018-09-20 04:19:41 CEST Universal time: Thu 2018-09-20 02:19:41 UTC RTC time: Thu 2018-09-20 02:19:41 Time zone: Europe/Paris (CEST, +0200) Network time on: no NTP synchronized: yes RTC in local TZ: no $ systemctl status systemd-timesyncd.service ● systemd-timesyncd.service - Network Time Synchronization Loaded: loaded (/lib/systemd/system/systemd-timesyncd.service; disabled; vendor preset: enabled) Drop-In: /lib/systemd/system/systemd-timesyncd.service.d └─disable-with-time-daemon.conf Active: inactive (dead) Docs: man:systemd-timesyncd.service(8) Feb 11 17:28:02 ubuntu systemd-timesyncd[472]: System clock time unset or jumped backwards, restoring from recorded timestamp: Sep 19 11:36:39 ubuntu systemd[1]: Started Network Time Synchronization. Sep 20 03:19:45 ubuntu systemd-timesyncd[472]: Synchronized to time server 91.189.91.157:123 (ntp.ubuntu.com). Sep 20 04:19:37 ubuntu systemd[1]: Stopping Network Time Synchronization... Sep 20 04:19:37 ubuntu systemd[1]: Stopped Network Time Synchronization. Sep 20 04:20:27 ubuntu systemd[1]: Starting Network Time Synchronization... Sep 20 04:20:27 ubuntu systemd[1]: Started Network Time Synchronization. Sep 20 04:20:27 ubuntu systemd-timesyncd[1901]: Synchronized to time server 91.189.89.198:123 (ntp.ubuntu.com). Sep 20 04:20:51 ubuntu systemd[1]: Stopping Network Time Synchronization... Sep 20 04:20:51 ubuntu systemd[1]: Stopped Network Time Synchronization. systemd-timesyncd.service 调用的是 /lib/systemd/systemd-timesyncd 守护进程执行时间同步，配置文件是 /etc/systemd/timesyncd.conf ，有两个选项：\nNTP= ，主 NTP 服务器域名或者 IP 列表，多个地址之间用空格隔开。 FallbackNTP= ，备用 NTP 服务器域名或者 IP 列表，多个地址之间用空格隔开。 每次时间同步后都会更新 /var/lib/systemd/clock 文件：\n$ ll /var/lib/systemd/clock -rw-r--r-- 1 systemd-timesync systemd-timesync 0 Spe 25 14:09 /var/lib/systemd/clock 大约 20 分钟同步一次，这个时间间隔不可以设置。\n","date":"2018 September 24","permalink":"/posts/2018/09/24/","section":"Posts","summary":"查看当前系统时间：","title":"用 timedatectl 管理系统时间"},{"content":"dnf 是 Fedora 上的新一代软件包管理器，从 Fedora22 开始取代了原有的 yum 。拥有超级用户权限才可以使用 dnf 在系统上安装、更新和删除软件包。\n1. 配置 #dnf 的配置文件位于 /etc/dnf/dnf.conf ,文件里的配置信息按不同种类分为多个小节，其中必须的 [main] 小节包含了所有全局选项，还可能包含一些 [repository] 小节用于设置特定存储库的选项，但是建议在 /etc/yum.repos.d/ 目录中的 .repo 文件里定义某个存储库的选项，这些选项的值会覆盖 [main] 小节的同名选项。\n最简单的 /etc/dnf/dnf.conf 文件类似如下：\n[main] gpgcheck=1 installonly_limit=3 clean_requirements_on_remove=true 常用的选项和含义包括：\ngpgcheck=value ，value 可选两个值，0 表示禁止所有 GPG 签名检查，1 表示对所有安装的包进行 GPG 签名检查。 installonlypkgs=space separated list of packages ，这个选项中列出的软件包只安装不更新，多个软件包之间用空格分开。 installonly_limit=value ，value 是一个整数，表示 installonlypkgs 指令中列出的软件包可以同时安装的最大版本数。installonlypkgs 指令的默认值包括几个不同的内核包，因此，更改 installonly_limit 的值也会影响任何单个内核包的最大安装版本数。 /etc/dnf/dnf.conf 中列出的默认值为 installonly_limit = 3，建议不要降低此值，尤其是低于2。 keepcache=value ，value 可选两个值，0 表示成功安装后不保留标头和软件包的缓存，这是默认值。1 表示成功安装后保留缓存。 2. 使用 #2.1. 更新 #检测并安装所有软件包的更新：\ndnf upgrade 如果带有包的名字就可以单独更新某个包：\ndnf upgrade package_name 只检查可用的更新：\ndnf check-update 2.2. 查找 #在源里搜索所有名字里包含 term 的包：\ndnf search term 名字匹配时支持两种通配符，如果名字本身就包含这两个通配符，可以用反斜杠转义：\n* ，星号可以匹配任何字符多次 ？，问号可以匹配任何一个字符 列出所有已安装的和可安装的软件包：\ndnf list all 仅列出已安装的软件包\ndnf list installed 列出未安装但可用的软件包：\ndnf list available 也可以列出名字匹配的包：\ndnf list term 显示某个包的详细信息：\ndnf info package_name 2.3. 安装 #用 install 命令安装软件包，可以一次安装多个：\ndnf install package_name... 如果不知道某个软件包的名字，只知道它的某个二进制文件的安装路径，也可以只写该文件的路径，dnf 会自动搜索并安装，例如：\ndnf install /usr/sbin/named 删除某个包用 remove 命令：\ndnf remove package_name... 2.4. 历史 #dnf 的 history 命令可以让用户查看使用记录，包括安装、更新、删除等各种操作使用的命令和时间等详情，例如列出所有的历史操作记录：\ndnf history list 根据操作顺序的 ID 列出某个范围的历史记录：\ndnf history list start_id..end_id 撤销某一步操作：\ndnf history undo id 重做某一步操作：\ndnf history redo id 参考 #[DNF Command Reference](https://dnf.readthedocs.io/en/latest/command_ref.html\u003e\n","date":"2018 September 21","permalink":"/posts/2018/09/21/","section":"Posts","summary":"dnf 是 Fedora 上的新一代软件包管理器，从 Fedora22 开始取代了原有的 yum 。拥有超级用户权限才可以使用 dnf 在系统上安装、更新和删除软件包。","title":"包管理器 dnf 学习笔记"},{"content":"1.CPU 主频 #CPU 的主频是指 CPU 核心的时钟频率，它是 CPU 执行指令的最小时间单位。CPU 内部有时钟管理模块，通过外部振荡器（获取其他时钟电路）输入一个特定的频率（外频），经过内部的 PLL 电路（倍频器）锁定到一个很高的频率，再经过不同的分频，供给不同的模块和总线使用，供给 CPU 的就称为主频,就是通常所说的“主频 = 外频 x 倍频”。目前桌面 X86 CPU 的外频由主板供给，通常是 100MHz ，倍频通常是固定设置的。如果要超频，通常是在主板的 BIOS 中修改倍频因子，也有特殊情况可以增加外频。\nX86-Linux 体系有三种硬件时钟：\nReal Time Clock(RTC) ，实时时钟，通常位于 CMOS ，独立工作 Programmalbe Interval Timer(PIT) ，可编程的间隔定时器，通常由 8254 芯片实现 Time Stamp Counter(TSC) ，时间戳控制器，记录 CPU 时钟周期 Linux 内核在计算 CPU 主频时会用到 PIT 和 TSC 。以下是在 kernel 3.4 版本中分析。\n2.Programmalbe Interval Timer (PIT) #Programmalbe Interval Timer (PIT) 是现代计算机的重要组成部分，尤其是在多任务环境中。 PIT 是用 8253/8254 芯片实现的，由于历史原因，外接的晶振频率是 1.193182 MHz ，Linux 内核里的定义在 include/linux/timex.h 文件：\n/* The clock frequency of the i8253/i8254 PIT */ #define PIT_TICK_RATE 1193182ul 8253/8254 内置三个独立的 16 位减法计数器用于分频，每个计数器有一个输出用于特定的功能，示意图如下：\nChannel 0 ：PIT Channel 0 的输出连接在中断控制器上，因此它会产生 “IRQ 0”。通常在引导阶段，BIOS 将 Channel 0 设置为 65535 或 0（转换为65536），这将提供 18.2065Hz 的输出频率（每 54.9254ms 一次的中断）。 Channel 0 可能是最有用的 PIT 通道，因为它是唯一连接到 IRQ 的通道，可以用它产生定时中断。选择工作模式时，要注意 IRQ0 是由 Channel 0 输出电压的上升沿产生的。 Channel 1 ：PIT Channel 1 的输出曾被用于刷新 DRAM 或 RAM 。通常，RAM 中的每个位由一个电容器组成，该电容器保持代表该位状态的微小电荷，但是由于泄漏，这些电容器需要定期“刷新”，以便它们不会忘记自己的状态。在以后的机器上，DRAM 刷新是通过专用硬件完成的，不再使用 PIT 。在大规模集成电路中实现的现代计算机上，PIT Channel 1 不再可用。 Channel 2 ：PIT Channel 2 的输出连接在蜂鸣器上，因此输出的频率决定了蜂鸣器产生的声音的频率。这是唯一可以通过软件控制门信号的通道（通过I/O 端口 0x61 的 bit0），也可以用软件读取其输出。 PIT 的 8253/8254 芯片有四个寄存器，包括三个数据寄存器和一个模式控制寄存器，它们的地址和功能描述：\nI/O port Usage 0x40 Channel 0 data port (read/write) 0x41 Channel 1 data port (read/write) 0x42 Channel 2 data port (read/write) 0x43 Mode/Command register (write only, a read is ignored) 模式控制寄存器的格式：\n编程方式是先在模式控制寄存器中设置计数器、读写方式和工作模式，然后向相应的计数器中写入初始值。\n3.Time Stamp Counter (TSC) #时间戳控制器 Time Stamp Counter (TSC) 是 X86 CPU 里的一个 64 位寄存器，自 Pentium 开始引入，用于记录 CPU 复位后的周期数，CPU 内部时钟每产生一个时钟周期，该寄存器就加一，也就是 CPU 主频的节拍记录器。我们可以用单位时间内 TSC 记录的时钟周期个数来推算 CPU 的实际频率，比如一秒内 TSC 的值增长了 1000 ，那么主频就是 1KHz 。在单核 CPU 上，TSC 是一个简单高效的获取高精度 CPU 时序信息的方式，但是在多核 CPU 、休眠操作系统上，这个方式无法提供准确信息，依赖 TSC 会降低软件的可移植性。在 Windows 平台上，微软反对使用 TSC 进行高精度计时，在 POSIX 系统上，程序可以使用 clock_gettime() 函数读取 CLOCK_MONOTONIC 时钟的值来获得类似的功能。在 Linux 的内核上，可以用启动参数 notsc 禁用 TSC 。\nX86 CPU 提供了 RDTSC 指令来读取 TSC 的值，低 32 位存放在 EAX 寄存器，高 32 位存放在 EDX 寄存器:\n指令 操作码 说明 RDTSC 0F 31 将 TSC 的值读入 EDX:EAX 在内核源码的 arch/x86/include/asm/msr.h 文件中提供了读取方法：\n#ifdef CONFIG_X86_64 #define DECLARE_ARGS(val, low, high)\tunsigned low, high #define EAX_EDX_VAL(val, low, high)\t((low) | ((u64)(high) \u0026lt;\u0026lt; 32)) #define EAX_EDX_ARGS(val, low, high)\t\u0026#34;a\u0026#34; (low), \u0026#34;d\u0026#34; (high) #define EAX_EDX_RET(val, low, high)\t\u0026#34;=a\u0026#34; (low), \u0026#34;=d\u0026#34; (high) #else #define DECLARE_ARGS(val, low, high)\tunsigned long long val #define EAX_EDX_VAL(val, low, high)\t(val) #define EAX_EDX_ARGS(val, low, high)\t\u0026#34;A\u0026#34; (val) #define EAX_EDX_RET(val, low, high)\t\u0026#34;=A\u0026#34; (val) #endif static __always_inline unsigned long long __native_read_tsc(void) { DECLARE_ARGS(val, low, high); asm volatile(\u0026#34;rdtsc\u0026#34; : EAX_EDX_RET(val, low, high)); return EAX_EDX_VAL(val, low, high); } 我们可以在用户空间用 C 语言内联汇编实现同样的功能：\n#include \u0026lt;stdio.h\u0026gt; int main() { unsigned int low=0, high=0; asm volatile(\u0026#34;rdtsc\u0026#34; : \u0026#34;=a\u0026#34;(low), \u0026#34;=d\u0026#34;(high)); printf(\u0026#34;0x%x 0x%x\\n\u0026#34;,high,low); } 4.计算主频 #Linux 内核在初始化阶段用 TSC 来计算 CPU 主频。我们可以在 dmesg 中找到类似的信息：\n$ dmesg | grep -E \u0026#34;TSC|tsc\u0026#34; tsc: Fast TSC calibration using PIT tsc: Detected 3192.872 MHz processor TSC deadline timer enabled tsc: Refined TSC clocksource calibration: 3192.747 MHz Switched to clocksource tsc 前缀的 tsc 是模块的名称，有些内核可能没有这个，没有关系，我们从 Detected 3192.872 MHz processor 入手，这是在 arch/x86/kernel/tsc.c 文件的 tsc_init() 函数中打印的信息，属于内核的时钟子系统，它通过如下路径调用：\nstart_kernel() -\u0026gt; time_init() —\u0026gt; x86_late_time_init() -\u0026gt; tsc_init() 这个函数执行的是 TSC 模块的初始化工作，然后校准 TSC 频率，设置为 CPU 主频，判断 TSC 频率是否可靠，用 TSC 频率计算 lpj 等，我们先关注这一段：\nunsigned int __read_mostly cpu_khz; EXPORT_SYMBOL(cpu_khz); unsigned int __read_mostly tsc_khz; EXPORT_SYMBOL(tsc_khz); void __init tsc_init(void) { ... tsc_khz = x86_platform.calibrate_tsc(); cpu_khz = tsc_khz; if (!tsc_khz) { mark_tsc_unstable(\u0026#34;could not calculate TSC khz\u0026#34;); return; } printk(\u0026#34;Detected %lu.%03lu MHz processor.\\n\u0026#34;, (unsigned long)cpu_khz / 1000, (unsigned long)cpu_khz % 1000); ... } 其中的 x86_platform.calibrate_tsc() 调用的是 native_calibrate_tsc() 函数，它的功能是校准 tsc ，获取 tsc 频率。首先用 PIT 快速校准 TSC ，它的原理是用 PIT 记录一段时间，再测量这段时间内 TSC 的变换量，就可以计算出主频，通过 quick_pit_calibrate() 函数实现：\n/* 读取 PIT 的 MSB ，判断 MSB 是否等于参数 val */ static inline int pit_verify_msb(unsigned char val) { /* Ignore LSB */ inb(0x42); return inb(0x42) == val; } /* 这个函数通过一个 for 循环不断的读取和判断 PIT 和 TSC ，最终用 *tscp 返回 MSB==val 时的 TSC 的值，*deltap 返回是增量（ delta ：希腊字母第四个） */ static inline int pit_expect_msb(unsigned char val, u64 *tscp, unsigned long *deltap) { int count; u64 tsc = 0, prev_tsc = 0; for (count = 0; count \u0026lt; 50000; count++) { if (!pit_verify_msb(val)) // PIT 的 MSB 等于 val 时跳出循环 break; prev_tsc = tsc; tsc = get_cycles(); //读取 tsc 的值，最终是调用上一章提到的 __native_read_tsc() 函数 } *deltap = get_cycles() - prev_tsc; *tscp = tsc; return count \u0026gt; 5; } /* 这个宏确定的是迭代次数，也就是获取多少次 PIT 的 MSB 。 我们的目标是最大错误率为 500ppm（实际上真正的误差要小得多），但是耗时不能超过 50ms ， MAX_QUICK_PIT_MS * PIT_TICK_RATE / 1000 得到的是 50ms 内的时钟周期个数，也就是计数器减少的数值， 最后除以 256 是因为我们只取 MSB 。 */ #define MAX_QUICK_PIT_MS 50 #define MAX_QUICK_PIT_ITERATIONS (MAX_QUICK_PIT_MS * PIT_TICK_RATE / 1000 / 256) //=233 static unsigned long quick_pit_calibrate(void) { int i; u64 tsc, delta; unsigned long d1, d2; /* 关闭蜂鸣器 */ outb((inb(0x61) \u0026amp; ~0x02) | 0x01, 0x61); /* 计数器 2 , 读写方式是先低后高，工作模式是 0 , 二进制计数 当计数器工作模式设为 0 后，该计数器的输出信号立即变为低电平，且计数过程中一直保持低电平。在经初值寄存器赋初值后，开始计数，在每个 CLK 时钟下降沿，计数器进行减 1 计数，当计数减到 0 时，OUT 输出信号变为高电平，且一直保持到该计数器重新赋初值。该信号可以作为中断请求信号。 0 模式无自动装入计数初始值的功能，若要继续计数，则需要重新写入计数初始值。在计数期间，装入新的初始值，计数器会在初始值写入后重新开始计数。 */ outb(0xb0, 0x43); /* 从 0xffff 开始计数 */ outb(0xff, 0x42); outb(0xff, 0x42); /* 这里需要一个微小的延时，最简单的方法是第一次 PIT */ pit_verify_msb(0); /* 下面通过一个迭代过程测量出一段时间(50ms)内 TSC 的增长 每次循环，PIT 都会减少 256 , i 次循环就是 (I * 256 / PIT_TICK_RATE) 秒 delta 记录的是循环过程中 TSC 数值的增长 循环结束后，用这两个数值计算主频 */ if (pit_expect_msb(0xff, \u0026amp;tsc, \u0026amp;d1)) { for (i = 1; i \u0026lt;= MAX_QUICK_PIT_ITERATIONS; i++) { if (!pit_expect_msb(0xff-i, \u0026amp;delta, \u0026amp;d2)) break; delta -= tsc; if (d1+d2 \u0026gt;= delta \u0026gt;\u0026gt; 11) //确保误差小于 500ppm ，不理解 continue; if (!pit_verify_msb(0xfe - i)) //再次检测 PIT 的 MSB ，确保 PIT 的值已经是 0xfe-i break; goto success; } } printk(\u0026#34;Fast TSC calibration failed\\n\u0026#34;); return 0; success: /* kHz = ticks / time-in-seconds / 1000; kHz = (t2 - t1) / (I * 256 / PIT_TICK_RATE) / 1000 kHz = ((t2 - t1) * PIT_TICK_RATE) / (I * 256 * 1000) 主频通过 delta 返回 */ delta *= PIT_TICK_RATE; do_div(delta, i*256*1000); // do_div() 是内核的 64 位除法函数，结果保持在第一参数，返回余数 printk(\u0026#34;Fast TSC calibration using PIT\\n\u0026#34;); return delta; } 通常用 PIT 快速校准 TSC 都会成功，直接用返回值作为 tsc_khz ，并赋予 cpu_khz 作为主频。如果失败，会继续用一种复杂的方式计算 PIT 和 TSC 。\n5./proc/cpuinfo #在用户空间，我们是通过 /proc/cpuinfo 文件获得 CPU 主频的。proc 文件系统中的文件，必须在内核源码的某个位置创建并使用 file_operations 声明，cpuinfo 的声明位于 fs/proc/cpuinfo.c 文件：\nstatic const struct file_operations proc_cpuinfo_operations = { .open\t= cpuinfo_open, .read\t= seq_read, .llseek\t= seq_lseek, .release\t= seq_release, }; static int __init proc_cpuinfo_init(void) { proc_create(\u0026#34;cpuinfo\u0026#34;, 0, NULL, \u0026amp;proc_cpuinfo_operations); return 0; } 然后在 arch/x86/kernel/cpu/proc.c 文件中有很多 show_cpuinfo_*() 函数，比如 static int show_cpuinfo(struct seq_file *m, void *v) ，它们会调用 seq_printf() 函数把信息输出到 /proc/cpuinfo 文件中:\nstatic int show_cpuinfo(struct seq_file *m, void *v) { struct cpuinfo_x86 *c = v; unsigned int cpu; int i; cpu = c-\u0026gt;cpu_index; seq_printf(m, \u0026#34;processor\\t: %u\\n\u0026#34; \u0026#34;vendor_id\\t: %s\\n\u0026#34; \u0026#34;cpu family\\t: %d\\n\u0026#34; \u0026#34;model\\t\\t: %u\\n\u0026#34; \u0026#34;model name\\t: %s\\n\u0026#34;, cpu, c-\u0026gt;x86_vendor_id[0] ? c-\u0026gt;x86_vendor_id : \u0026#34;unknown\u0026#34;, c-\u0026gt;x86, c-\u0026gt;x86_model, c-\u0026gt;x86_model_id[0] ? c-\u0026gt;x86_model_id : \u0026#34;unknown\u0026#34;); ... } 可以看出大部分 CPU 信息都是通过 struct cpuinfo_x86 *c 结构获取的，这个结构的声明在 arch/x86/include/asm/processor.h 文件，在这个文件中搜索该结构的引用，会找到 extern void cpu_detect(struct cpuinfo_x86 *c); 等类似的函数，这些函数内通过 cpuid() 函数从硬件寄存器上读取信息，然后填充 struct cpuinfo_x86 *c 结构 ，这是一个内联函数 ：\nstatic inline void cpuid(unsigned int op, unsigned int *eax, unsigned int *ebx, unsigned int *ecx, unsigned int *edx) { *eax = op; *ecx = 0; __cpuid(eax, ebx, ecx, edx); } 函数内的 __cpuid() 是封装了 native_cpuid() 函数的宏定义，也在这个文件里定义：\nstatic inline void native_cpuid(unsigned int *eax, unsigned int *ebx, unsigned int *ecx, unsigned int *edx) { /* ecx is often an input as well as an output. */ asm volatile(\u0026#34;cpuid\u0026#34; : \u0026#34;=a\u0026#34; (*eax), \u0026#34;=b\u0026#34; (*ebx), \u0026#34;=c\u0026#34; (*ecx), \u0026#34;=d\u0026#34; (*edx) : \u0026#34;0\u0026#34; (*eax), \u0026#34;2\u0026#34; (*ecx) : \u0026#34;memory\u0026#34;); } 这里是通过汇编指令读取相应的寄存器，这些指令属于 CPUID ，是 X86 架构的处理器补充指令，用于发现处理器的详细信息，参考https://zh.wikipedia.org/wiki/CPUID。\n还有一些信息不是通过 CUPID 获取的，比如 CPU 主频（CPU frequency），在 arch/x86/kernel/cpu/proc.c 文件的 show_cpuinfo() 函数中可以看到：\nif (cpu_has(c, X86_FEATURE_TSC)) { unsigned int freq = cpufreq_quick_get(cpu); if (!freq) freq = cpu_khz; seq_printf(m, \u0026#34;cpu MHz\\t\\t: %u.%03u\\n\u0026#34;, freq / 1000, (freq % 1000)); } 它是先调用 cpufreq_quick_get() 函数返回一个值，这是 cpufrep 模块的一个函数，它的返回值与 sysfs 中 /sys/devices/system/cpu/cpu[n]/cpufreq/ 目录下的 scaling_cur_freq 完全一致，而且可以动态变化。如果调用失败，就把 cpu_khz 作为 CPU 主频。\nCPU 的主频是可以动态调节的。主频越高，功耗也越高，为了节省 CPU 的功耗和减少发热，我们可以根据当前 CPU 的负载情况，动态地提供刚好足够的主频给 CPU 。Linux 内核提供了一套框架来完成这个目标，这就是 cpufrep 子系统。\ncpufrep 子系统在用户空间提供了 sysfs 接口，都位于 /sys/devices/system/cpu 目录下：\n/sys/devices/system/cpu$ ls cpu0 cpu2 cpufreq kernel_max modalias online power probe uevent cpu1 cpu3 cpuidle microcode offline possible present release 6.BogoMIPS #在 /proc/cpuinfo 中可以看到一个参数 bogomips ，在 dmesg 中也可以看到类似的信息：\n[ 0.000001] Calibrating delay loop (skipped), value calculated using timer frequency.. 6385.48 BogoMIPS (lpj=12770964) 从字面意思也可以理解， BogoMIPS 就是伪百万次指令每秒，每秒钟可以执行几百万条指令，是一种衡量 CPU 速度的不科学方法。这条信息来自于内核 init/calibrate.c 文件的 calibrate_delay() 函数。\n参考 # CPU 频率 Programmable Interval Timer CPU frequency scaling ","date":"2018 August 7","permalink":"/posts/2018/08/07/","section":"Posts","summary":"1.CPU 主频 #CPU 的主频是指 CPU 核心的时钟频率，它是 CPU 执行指令的最小时间单位。CPU 内部有时钟管理模块，通过外部振荡器（获取其他时钟电路）输入一个特定的频率（外频），经过内部的 PLL 电路（倍频器）锁定到一个很高的频率，再经过不同的分频，供给不同的模块和总线使用，供给 CPU 的就称为主频,就是通常所说的“主频 = 外频 x 倍频”。目前桌面 X86 CPU 的外频由主板供给，通常是 100MHz ，倍频通常是固定设置的。如果要超频，通常是在主板的 BIOS 中修改倍频因子，也有特殊情况可以增加外频。","title":"Linux 系统如何获取 CPU 主频"},{"content":" 基于 Ubuntu 14.04 ，Linux Kernel 4.0 以上版本。\n1. printk() #printk() 是内核提供的函数，用于将内核空间的信息打印到用户空间缓冲区，打印的信息可以通过 demsg 命令查看，或者直接查看 /proc/kmsg 文件。缓冲区是一个环形队列的结构，消息太多时，旧的消息就会被逐渐覆盖，缓冲区大小是在 kernel/printk/printk.c 文件中的代码设置的：\n#define __LOG_BUF_LEN (1 \u0026lt;\u0026lt; CONFIG_LOG_BUF_SHIFT) static char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN); 缓冲区大小是 CONFIG_LOG_BUF_SHIFT*2 个字节，CONFIG_LOG_BUF_SHIFT 是在 init/Kconfig 文件中设置的，我们可以在 menuconfig 的相关路径中修改：\nGeneral setup -\u0026gt; Kernel log buffer size(16 =\u0026gt; 64KB, 17 =\u0026gt; 128kB) 还可以在加载内核时用启动参数 log_buf_len=n[KMG] 设置，其中的 n 必须是 2 的整数倍。\n在调用 printk() 函数时要设置消息级别，从 0 到 7 ，数值越小级别越高，相应的宏定义在 include/linux/kern_levels.h 文件中：\n#define KERN_EMERG KERN_SOH \u0026quot;0\u0026quot; /* system is unusable */ #define KERN_ALERT KERN_SOH \u0026quot;1\u0026quot; /* action must be taken immediately */ #define KERN_CRIT KERN_SOH \u0026quot;2\u0026quot; /* critical conditions */ #define KERN_ERR KERN_SOH \u0026quot;3\u0026quot; /* error conditions */ #define KERN_WARNING KERN_SOH \u0026quot;4\u0026quot; /* warning conditions */ #define KERN_NOTICE KERN_SOH \u0026quot;5\u0026quot; /* normal but significant condition */ #define KERN_INFO KERN_SOH \u0026quot;6\u0026quot; /* informational */ #define KERN_DEBUG KERN_SOH \u0026quot;7\u0026quot; /* debug-level messages */ #define KERN_DEFAULT KERN_SOH \u0026quot;d\u0026quot; /* the default kernel loglevel */ 内核中还有一个默认日志级别，只有数值小于这个级别的消息才会被打印到控制台上，大于或者等于这个数值的消息不会显示，它设置在 lib/Kconfig.debug 文件中，缺省情况下会设为 KERN_WARNING(4) ，我们可以在 menuconfig 的相关路径中设置：\nKernel hacking -\u0026gt; printk and dmesg options -\u0026gt; Default message log level(1-7) 也可以用内核启动参数 loglevel=n 设置，n 的取值是 0~7 。如果直接设置了启动参数 debug ，那么日志级别就是 KERN_DEBUG(7) ，所有调试信息都会显示在控制台上。还可以在系统启动后，在 /proc/sys/kernel/printk 文件中调整 printk() 函数的输出等级，该文件有四个数值，各自的含义：\n控制台的日志级别:当前的打印级别,优先级高于该值(值越小,优先级越高)的消息将被打印至控制台 默认的消息日志级别: 将用该优先级来打印没有优先级前缀的消息,也就是直接写 printk(\u0026quot;xxx\u0026quot;) 而不带打印级别的情况下,会使用该打印级别 最低的控制台日志级别: 控制台日志级别可被设置的最小值(一般是1) 默认的控制台日志级别: 控制台日志级别的默认值 修改方法：\nroot@sh-VirtualBox:/proc/sys/kernel# cat printk 4\t4\t1\t7 root@sh-VirtualBox:/proc/sys/kernel# echo 5 \u0026gt; printk root@sh-VirtualBox:/proc/sys/kernel# cat printk 5\t4\t1\t7 root@sh-VirtualBox:/proc/sys/kernel# echo \u0026quot;5 5\u0026quot; \u0026gt; printk root@sh-VirtualBox:/proc/sys/kernel# cat printk 5\t5\t1\t7 默认情况下，printk() 打印的消息是带时间戳的，可以在 menuconfig 的相应路径下关闭或者打开：\nKernel hacking -\u0026gt; printk and dmesg options -\u0026gt; Show timing information on printks 为了方便调用，内核提供很多封装了 printk() 函数的宏，在 /include/linux/printk.h 头文件中声明的 pr_xxx() ，例如：\n#define pr_fmt(fmt) fmt #define pr_err(fmt, ...) printk(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__) #define pr_warning(fmt, ...) printk(KERN_WARNING pr_fmt(fmt), ##__VA_ARGS__) #define pr_info(fmt, ...) printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__) 我们可用通过 pr_fmt(fmt) 添加一些自定义的消息格式，例如：\n#define pr_fmt(fmt) \u0026quot;[driver] watchdog:\u0026quot; fmt 这里要注意 pr_debug()，它与其他的宏不同，需要满足如下两个条件之一才会打印信息：\n在源文件、或者编译时定义了 DEBUG 宏，这个方式在开发内核模块时很有用 开启了 CONFIG_DYNAMIC_DEBUG ，也就是 menuconfig 中的 Kernel hacking -\u0026gt; printk and dmesg options 这里还有一个问题，内核启动后，需要一段时间才能准备好控制台，这段时间内的内核信息是无法通过控制台显示，内核为此提供了 early printk 机制，它会在内核启动后就注册一个 boot console ，让后将内核信息显示在这个控制台上。使能 early printk 的方法有两步：\n在 menuconfig 中打开 Early printk ：Kernel hacking -\u0026gt; Early printk 在启动参数中设置 earlyprintk=[vga|serial][,ttySn[,baudrate]][,keep] 如果用户空间的 printf() 和内核空间的 printk() 同时执行，二者的输出会互相干扰，内核为此提供了 /dev/ttyprintk 设备文件，可以将用户空间的信息打印到这个设备中，这样用户信息与内核信息就会顺序输出，输出的消息会自带 [U] 前缀。对于没有 /dev/ttyprintk 设备的系统，可以用 /dev/kmsg 代替，只是没有了 [U] 标识，需要用户自己添加前缀。\n2. SysRq 键 #标准键盘的右上角有一个 PrintScreen/SysRq 键，它的一个功能是截屏，另一个功能是当系统死机无法输入命令时，用这个按键获取内核信息。SysRq 键在确认内核运行、调查死机原因等情况时非常有效。关于它的详细情况可以参考内核的 Documentation/sysrq.txt 文件。\n要使用 SysRq 键，需要启动内核配置 CONFIG_MAGIC_SYSRQ ，在 menuconfig 中的路径是：\nKernel hacking -\u0026gt; Magic SysRq key 系统启动后，就可以在 /proc/sys/kernel/sysrq 文件中设置 SysRq 按键的功能，该文件的默认值是内核选项 CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE 设置的,必须是十六进制，在 menuconfig 的路径是：\nKernel hacking -\u0026gt; (0x01) Enable magic Sysrq key functions by default 注意，/proc/sys/kernel/sysrq 设置的各项功能，只对从键盘和串口控制台的输入有效，对于远程 ssh 等方式无效。直接向 /proc/sysrq-trigger 写入命令键则不受限制：echo [command key] \u0026gt; /proc/sysrq-trigger 。\n这个文件的值是位掩码，取值如下，括号内是命令键：\n0 ，禁用 sysrq 1 ，使能所有 sysrq 功能 2 = 0x2 ，允许控制控制台日志级别（0~9） 4 = 0x4 ，使能键盘控制 (kr) 8 = 0x8 ，使能显示进行等信息（lptwmcz） 16 = 0x10 ，使能 sync 命令（s） 32 = 0x20 ，使能只读状态下的重新挂在（u） 64 = 0x40 ，使能进程信号，例如 term, kill（ei） 128 = 0x80 ，使能重启和关机（b） 256 = 0x100 ，允许控制实时任务（q） 可以直接修改这个文件的值，比如使能 sync 和重新挂载：\n# echo 48 \u0026gt; /proc/sys/kernel/sysrq 也可以在 /etc/sysctl.d/10-magic-sysrq.conf 文件中修改 kernel.sysrq 选项（也可能在 /etc/sysctl.conf 文件中）。配置好功能后，通过组合键 Alt-SysRq-\u0026lt;command key\u0026gt; 就可以使用 SysRq 键的各项功能，功能键如下：\n'b' - Will immediately reboot the system without syncing or unmounting your disks. 'c'\t- Will perform a system crash by a NULL pointer dereference. A crashdump will be taken if configured. 'd'\t- Shows all locks that are held. 'e' - Send a SIGTERM to all processes, except for init. 'f'\t- Will call the oom killer to kill a memory hog process, but do not panic if nothing can be killed. 'g'\t- Used by kgdb (kernel debugger) 'h' - Will display help (actually any other key than those listed here will display help. but 'h' is easy to remember :-) 'i' - Send a SIGKILL to all processes, except for init. 'j' - Forcibly \u0026quot;Just thaw it\u0026quot; - filesystems frozen by the FIFREEZE ioctl. 'k' - Secure Access Key (SAK) Kills all programs on the current virtual console. NOTE: See important comments below in SAK section. 'l' - Shows a stack backtrace for all active CPUs. 'm' - Will dump current memory info to your console. 'n'\t- Used to make RT tasks nice-able 'o' - Will shut your system off (if configured and supported). 'p' - Will dump the current registers and flags to your console. 'q' - Will dump per CPU lists of all armed hrtimers (but NOT regular timer_list timers) and detailed information about all clockevent devices. 'r' - Turns off keyboard raw mode and sets it to XLATE. 's' - Will attempt to sync all mounted filesystems. 't' - Will dump a list of current tasks and their information to your console. 'u' - Will attempt to remount all mounted filesystems read-only. 'v'\t- Forcefully restores framebuffer console 'v'\t- Causes ETM buffer dump [ARM-specific] 'w'\t- Dumps tasks that are in uninterruptable (blocked) state. 'x'\t- Used by xmon interface on ppc/powerpc platforms. Show global PMU Registers on sparc64. Dump all TLB entries on MIPS. 'y'\t- Show global CPU Registers [SPARC-64 specific] 'z'\t- Dump the ftrace buffer '0'-'9' - Sets the console log level, controlling which kernel messages will be printed to your console. ('0', for example would make it so that only emergency messages like PANICs or OOPSes would make it to your console.) 如果系统疑似死机，可以一次执行 s-u-b 命令重启内核，如果不需要重启，可以执行 c 命令提取崩溃转储，获取内核信息（内核崩溃转储是指将系统内存的内容输出到文件）。还可以尝试用 i 命令向进程发送 SIGKILL 信号，使系统恢复。\n3. Kdump #Kdump 是内核提供的崩溃转储功能，工作原理是在系统内核崩溃时启动一个特殊的 dump-capture kernel 把系统内存里的数据保存到磁盘文件中，由内核机制和用户空间工具共同完成。Dump-capture kernel 可以是独立的，也可以和系统内核集成在一起（这需要硬件支持）。Kdump 的工作过程如下：\n系统内核启动的时候，要给 dump-capture kernel 预留一块内存空间； 内核启动完成后，用户空间的 kdump service 执行 kexec -p 命令把 dump-capture kernel 载入预留的内存里（/sys/kernel/kexec_crash_loaded 的值为 1 表示已经加载）； 如果系统发生 crash，生产内核会自动 reboot 进入 dump-capture kernel，dump-capture kernel 只使用自己的预留内存，确保其余的内存数据不会被改动，它的任务是把系统内存里的数据写入到 dump 文件，比如 /var/crash/vmcore，为了减小文件的大小，它会通过 makedumpfile(8) 命令对内存数据进行挑选和压缩； dump 文件写完之后，dump-capture kernel 自动 reboot 。 预留内存的方法是用内核启动参数 crashkernel=size[@offset] 实现的，某些内核支持 crashkernel=auto 自动分配大小，如果不支持，或者系统没有足够内存，就需要手动设置。通常 offset 可以设置为 16MB(0x1000000) ，size 根据系统内存的大小设置，而且要与 64MB 对齐：\n如果系统内存小于 512MB ，则不要保留内存 如果系统内存介于 512MB 到 2GB 之间，可以保留 64MB 内存 如果系统内存大于 2GB ，可以保留 128MB 内存 可能导致内核崩溃的事件包括：\nKernel Panic Non Maskable Interrupts (NMI) Machine Check Exceptions (MCE) Hardware failure Manual intervention 对于某些崩溃事件（例如 panic、NMI），内核会自动做出反应，并通过 kexec 触发崩溃转储，其他情况下需要手动捕获内存信息。\n在 Ubuntu 上首先要安装内核崩溃转储工具：\n$ sudo apt-get install linux-crashdump 如果是 Fedora 操作系统，通常是安装 crash 和 kexec-tools 软件包。\nlinux-crashdump 包安装了三个工具，分别是：crash，kexec-tools 和 makedumpfile。安装过程中会出现如下对话框，选择 Yes ，表示默认使能 kdump ：\n|------------------------| Configuring kdump-tools |------------------------| | | | | | If you choose this option, the kdump-tools mechanism will be enabled. A | | reboot is still required in order to enable the crashkernel kernel | | parameter. | | | | Should kdump-tools be enabled by default? | | | | \u0026lt;Yes\u0026gt; \u0026lt;No\u0026gt; | | | |---------------------------------------------------------------------------| 然后编辑 /etc/default/kdump-tools 文件，修改选项 USE_KDUMP=1 ，使能内核加载 kdump ，然后重启系统，内核自动激活 crashkernel= 启动参数 ，kdump-tools 默认启动，用 kdump-config show 命令和 /sys/kernel/kexec_crash_loaded 文件查看 kdump 的配置和状态，在 /proc/cmdline 文件中查看 crashkernel 的设置：\n$ kdump-config show DUMP_MODE: kdump USE_KDUMP: 1 KDUMP_SYSCTL: kernel.panic_on_oops=1 KDUMP_COREDIR: /var/crash crashkernel addr: 0x2d000000 current state: ready to kdump kexec command: /sbin/kexec -p --command-line=\u0026quot;BOOT_IMAGE=/boot/vmlinuz-4.4.0-31-generic root=UUID=2744d8e0-18c2-493f-b61c-d887647494a0 ro quiet splash vt.handoff=7 irqpoll maxcpus=1 nousb\u0026quot; --initrd=/boot/initrd.img-4.4.0-31-generic /boot/vmlinuz-4.4.0-31-generic $ cat /sys/kernel/kexec_crash_loaded 1 $ cat /proc/cmdline BOOT_IMAGE=/boot/vmlinuz-4.4.0-31-generic root=UUID=2744d8e0-18c2-493f-b61c-d887647494a0 ro quiet splash crashkernel=384M-:128M vt.handoff=7 系统启动后，可以通过向 /sys/kernel/kexec_crash_size 写入一个比原来小的数值来缩小甚至完全释放 crashkernel 。然后执行 sudo kdump-config load 加载 kdump ，也可以把 /etc/init.d/kdump-tool 服务设为默认启动，这样系统会自动加载。准备工作完成后，尝试提取崩溃转储，先确保 sysrq=1 ，然后手动触发一次崩溃：\n# echo c \u0026gt; /proc/sysrq-tirgger 稍等片刻，如果转储成功，内核会自动重启，并且在 /var/crash/ 目录下生成转储文件：\n$ ls -l /var/crash/* total 28 drwxr-sr-x 2 root whoopsie 4096 7月 6 11:45 201807061145 -rw-r----- 1 root whoopsie 18095 7月 6 11:45 linux-image-4.4.0-31-generic-201807061145.crash $ ls -l /var/crash/201807061145/ total 55300 -rw------- 1 root whoopsie 41223 7月 6 11:45 dmesg.201807061145 -rw------- 1 root whoopsie 56578589 7月 6 11:45 dump.201807061145 转储需要时间，如果手动关机重启会导致转储不完整，数据无法解读。\n如果是 RedHat 系统，生成的转储文件是 vmcore ，可以直接用 crash 命令分析。而 Ubuntu 提供了叫做 Apport 的工具，将系统内其他有用的信息一起打包生成了 linux-image-4.4.0-31-generic-201807061145.crash 文件，而以时间戳命名的文件夹 201807061145 包含了 dmesg 信息文件和 kdump 转储文件，对于某些版本，这两个文件也包含在 crash 文件中。对 crash 文件解压后可以得到几个与系统信息有关的纯文本文件：\n$ sudo apport-unpack /var/crash/linux-image-4.4.0-31-generic-201807061145.crash ~/201807061145.crash $ ls ~/201807061145.crash Architecture Date DistroRelease Package ProblemType Uname VmCoreDmesg 4. 崩溃测试 #内核有一个 lkdtm 模块，Linux Kernel Dump Test Module ，通过各种方式使内核崩溃，用于测试崩溃转储的功能。通常发行版的内核不会使能这个模块，需要启用内核 CONFIG_LKDTM 选项，在 menuconfig 的路径是：\nKernel hacking -\u0026gt; RunTime Testing -\u0026gt; Linux Kernel Dump Test Tool Module 最好编译成模块，然后加载模块时，通过模块参数指定崩溃位置和崩溃原因，即可造成所需的内核崩溃。\n5. crash 命令 #crash 是一个强大的交互式工具，基于 gdb ，用于分析内核映像，比如内核崩溃转储信息。有些系统中，安装 linux-crashdump 时会包含 crash ，如果没有，需要手动安装：\nsudo apt-get install crash 分析之前需要安装系带有 debug-info 的内核，叫做 kernel-debuginfo ，这是 redhat 的叫法， ubuntu 下叫 debug symbols，简称 dbgsym 。 ubuntu 默认安装时不会安装 dbgsym ，默认仓库上也没有 dbgsym 包。 dbgsym 包存在于独立的仓库上，官方仓库地址为 http://ddebs.ubuntu.com/ ，安装方法参考：https://oolap.com/2015-11-07-ubuntu-install-dbgsym 。kernel-debuginfo 的版本应该和系统运行的内核版本完全一致，如果是自行编译的内核，可能无法在官方仓库中找到对应版本的 kernel-debuginfo ，这时可以自行编译安装 kernel-debuginfo ，参考下一节。安装完成后，会在 /usr/lib/debug/boot/ 目录下生成带有调试信息的 vmlinux ，然后用 crash 工具分析 kdump 生成崩溃转储信息：\n$ sudo crash /usr/lib/debug/boot/vmlinux-4.4.0-31-generic /var/crash/201807061145/dump.201807061145 下面以一个 Fedora14(kernel 2.6.37) 下产生的转储文件 vmcore 为例说明 crash 的用法，crash 成功启动后先打印一段转储文件的分析报告，包括崩溃时间、崩溃类型、CPU、内存等，然后进入一个交互环境：\nKERNEL: /boot/vmlinux DUMPFILE: vmcore CPUS: 1 DATE: Fri Jul 27 13:59:13 2018 UPTIME: 00:05:23 LOAD AVERAGE: 0.01, 0.11, 0.07 TASKS: 56 NODENAME: localhost.localdomain RELEASE: 2.6.37.6 VERSION: #11 SMP Thu Jul 26 15:42:06 CST 2018 MACHINE: i686 (1500 Mhz) MEMORY: 1 GB PANIC: \u0026quot;[ 323.903003] Oops: 0002 [#1] SMP \u0026quot; (check log for details) PID: 4437 COMMAND: \u0026quot;bash\u0026quot; TASK: f6ec0c90 [THREAD_INFO: f6d2e000] CPU: 0 STATE: TASK_RUNNING (PANIC) crash \u0026gt; 可以看到引起崩溃的进程是 PID: 4437 , crash 提供了 ps 命令显示所有进程的状态，用 ps | grep 4437 可以筛选出引起崩溃的进程：\ncrash \u0026gt; ps | grep 4437 PID PPID CPU TASK ST %MEM VSZ RSS COMM 4437 4426 0 f6ec0c90 RU 0.2 8064 1780 bash bt 命令用于输出某个进程的内核栈的遍历，没有指定 PID 时默认输出引起崩溃的进程的内核栈信息：\ncrash\u0026gt; bt PID: 4437 TASK: f6ec0c90 CPU: 0 COMMAND: \u0026quot;bash\u0026quot; #0 [f6d2fdec] crash_kexec at c0466264 #1 [f6d2fe2c] __bad_area_nosemaphore at c04225b5 #2 [f6d2fe48] bad_area at c042260c #3 [f6d2fe60] do_page_fault at c079c8c9 #4 [f6d2fed8] error_code (via page_fault) at c079a685 EAX: 00000063 EBX: 00000063 ECX: ffffffd6 EDX: 00000000 EBP: f6d2ff18 DS: 007b ESI: c095dfe0 ES: 007b EDI: 00000004 GS: 00e0 CS: 0060 EIP: c061e0b9 ERR: ffffffff EFLAGS: 00010046 #5 [f6d2ff0c] sysrq_handle_crash at c061e0b9 #6 [f6d2ff1c] __handle_sysrq at c061e63d #7 [f6d2ff40] write_sysrq_trigger at c061e6e2 #8 [f6d2ff50] proc_reg_write at c0507c84 #9 [f6d2ff74] vfs_write at c04cdf4c #10 [f6d2ff90] sys_write at c04ce11d #11 [f6d2ffb0] ia32_sysenter_target at c0403298 EAX: 00000004 EBX: 00000001 ECX: b77f8000 EDX: 00000002 DS: 007b ESI: b77f8000 ES: 007b EDI: 00000002 SS: 007b ESP: bfc32fd0 EBP: bfc33008 GS: 0033 CS: 0073 EIP: b77fc424 ERR: 00000004 EFLAGS: 00000246 可以看到系统崩溃前最后一条调用是 #5 [f6d2ff0c] sysrq_handle_crash at c061e0b9 ，我们用 dis 命令看一下这个地址的反汇编结果：\ncrash\u0026gt; dis -l c061e0b9 /usr/src/linux-2.6.37/drivers/tty/sysrq.c: 134 0xc061e0b9 \u0026lt;sysrq_handle_crash+23\u0026gt;: movb $0x1,0x0 出错的代码位于 /usr/src/linux-2.6.37/drivers/tty/sysrq.c 文件的 134 行：\n129 static void sysrq_handle_crash(int key) 130 { 131 char *killer = NULL; 132 panic_on_oops = 1; /* force panic */ 133 wmb(); 134 *killer = 1; 135 } 这里为指针赋值 *killer = 1 ，而 131 行定义的是一个空指针，比如出错。\ncrash 还有很多命令：\nlog ：打印系统消息缓冲区，从而可能找到系统崩溃的线索。 sys ：显示系统概况。 kmem ：显示内存使用信息。 irq ：显示中断的信息。 mod ：显示模块信息。 runq ：显示处于运行队列的进程。 struct ：显示结构的定义、地址和数据。 6. kernel-debuginfo #kernel-debuginfo 是指带有 Debug information 的内核，就是在编译内核是指定 CONFIG_DEBUG_INFO 等相关选项，在 menuconfig 的路径是：\nKernel hacking -\u0026gt; Kernel debugging -\u0026gt; Compile the kernel with debug info 与 Kdump 分析相关的选项还有：\nkexec system call ：CONFIG_KEXEC=y sysfs file system support ： CONFIG_SYSFS=y Compile the kernel with debug info ： CONFIG_DEBUG_INFO=Y kernel crash dumps ： CONFIG_CRASH_DUMP=y /proc/vmcore support ： CONFIG_PROC_VMCORE=y 编译成功后，就会在源码目录下生成带有 debuginfo 的内核镜像 vmlinux ，kdump 、crash 等内核调试方法都会用到它。vmlinux 是一个包含 Linux kernel 的静态链接的可执行文件，ELF 格式。通常 /boot 目录下启动的内核是 vmlinuz ，它是 vmlinux 经过 gzip 和 objcopy 制作出来的压缩文件。vmlinuz 是一种统称，有两种具体的表现形式 zImage 和 bzImage 。bzimage 和 zImage 的区别在于本身的大小，以及加载到内存时的地址不同，zImage在 0～640KB，而bzImage 则在 1M 以上的位置。\n不同的程序查找这个内核的路径是不一样的，通常需要在如下路径建立这个内核的符号链接：\n/boot/vmlinux-`uname -r` /usr/lib/debug/lib/modules/`uname -r`/vmlinux /lib/modules/`uname -r`/vmlinux 有些程序还需要在 /lib/modules/ 目录下建立内核源码树和构建目录的符号链接：\n/lib/modules/`uname -r`/source /lib/modules/`uname -r`/build 7. NMI #NMI(non-maskable interrupt) 就是不可屏蔽的中断，当 x86 发生了无法恢复的硬件故障后，会触发这个中断通知操作系统，如果操作系统配置了 kdump，还会触发崩溃转储。根据 Intel 的软件开发者手册第三卷 6.7 的描述，NMI 的来源有两个：\n外部引脚 NMI pin，外部设备可以通过这个引脚触发 NMI ，有些服务器甚至提供了 NMI 触发按钮 处理器系统总线或者 APIC 串行总线产生的 NMI 消息（包括芯片错误、内存校验错误、总线数据损坏等） x86 在 IO 端口寄存器 0x70 的 bit7 提供了 NMI_Enable 位，可以如下代码使能、或者禁用 NMI ：\nvoid NMI_enable(void) { outb(0x70, inb(0x70)\u0026amp;0x7F); } void NMI_disable(void) { outb(0x70, inb(0x70)|0x80); } Linux 内核提供了名为 NMI watchdog 的机制，用于检测系统是否失去响应（也称为 lockup，包括 soft lockup 和 hard lockup），原理是周期性的产生 NMI ，由 NMI handler 响应中断并刷新 hrtimer 定时器，如果一段时间内没有刷新，就表示系统失去了相应，于是调用 panic，超时时间在内核配置里设置，默认是 5 秒。相关代码在内核的 kernel/watchdog.c 文件中。\nNMI watchdog 依赖 APIC ，所有要将 APIC 编译进内核，启动参数中也不要关闭 APIC 。传统的 x86 架构采用 8259A 芯片处理中断，现在的 x86 架构都引入了 APIC 。可以执行 cat /proc/interrupts ，如果输出结果中列出了 IO-APIC-* ，说明系统正在使用 APIC ，如果看到 XT-PIC ，说明系统正在使用 8259A 芯片。\nNMI watchdog 的开关是内核启动参数 nmi_watchdog=[panic,]N ，也可以在 /etc/sysctl.conf 、/etc/sysctl.d/* 等配置文件中添加内核参数 kernel.nmi_watchdog=[panic,]N 。其中 panic 可选，表示 NMI watchdog 超时时产生 panic ，进而可以触发 kdump 。N 可以取值 0~2 ，0 表示禁用 NMI watchdog ，如果要启用 NMI watchdog ，在具有 IO-ACPI 的系统中设为 1 ，在没有 IO-ACPI 的系统中设为 2 。设置成功后，可以看到如下内核信息：\n$ dmesg | grep NMI ACPI: LAPIC_NMI (acpi_id[0xff] high edge lint[0x1]) NMI watchdog: enabled on all CPUs, permanently consumes one hw-PMU counter. 然后可以看到 NMI 中断计数：\n$ cat /proc/interrupts | grep NMI NMI: 449 207 197 179 Non-maskable interrupts 因为 NMI 是硬件产生的，所以在虚拟机上测试很可能会失败，内核会报错误信息 : NMI watchdog: disable(cpu0): hardware events not enabled\n我们可以编写一个模块验证 NMI watchdog 能否正常工作，它的原理是在加载模块时禁用所有中断，这样 NMI handler 就不会响应，也不会刷新定时器，直到超时：\n#include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/interrupt.h\u0026gt; static int __init nmitest_init(void) { printk(\u0026quot;nmitest init\\n\u0026quot;); local_irq_disable(); while(1); return 0; } static void __exit nmitest_exit(void) { printk(\u0026quot;nmitest exit\\n\u0026quot;); } module_init(nmitest_init); module_exit(nmitest_exit); MODULE_LICENSE(\u0026quot;GPL\u0026quot;); 系统运行过程中要禁用 NMI watchdog ，可以将 /proc/sys/kernel/nmi_watchdog 设为 0 。\n8. Soft lockup 和 Hard lockup #","date":"2018 July 5","permalink":"/posts/2018/07/05/","section":"Posts","summary":"基于 Ubuntu 14.","title":"Linux 内核调试方法"},{"content":"0. 简介 #systemd 是 freedesktop 的项目，官网 https://www.freedesktop.org/wiki/Software/systemd/ ,项目源码在 github 上发布，可以在 https://github.com/systemd/systemd 查看所有版本更新、 Bug Fix 和版本对应的文档等。\nsystemd-networkd 是 systemd 默认提供的网络管理服务，可以完全管理以太网，对于无线网卡，还需要其他服务支持，比如管理 Wi-Fi 的 wpa_supplicant@.service ，管理 PPP 的 ppp@.service 。\n管理网卡前，应该确保各网卡的驱动都已经正常加载，systemd 的 systemd-modules-load.service 负责在系统启动时静态加载内核模块。它会从以下路径搜索可用的配置文件：\n/etc/modules-load.d/*.conf /run/modules-load.d/*.conf /usr/lib/modules-load.d/*.conf 配置文件的内容就是一个内核模块名称的列表，可以用井号 # 或者分号 ; 注释单个模块。\n1. 基本配置 #我的系统中，systemd 的版本是 216 ，有两个以太网卡和一个 Wi-Fi 网卡，先查看一下网卡列表，再查看 systemd-networkd.service 的状态：\n~# networkctl list IDX LINK TYPE OPERATIONAL SETUP 1 lo loopback carrier unmanaged 2 wlp1s0 wlan off unmanaged 3 enp0s20f6 ether routable configured 4 enp0s20f7 ether no-carrier configured 4 links listed. ~# systemctl status systemd-networkd a—? systemd-networkd.service - Network Service Loaded: loaded (/lib/systemd/system/systemd-networkd.service; enabled) Active: active (running) since Fri 2018-04-27 17:49:22 UTC; 24min ago Docs: man:systemd-networkd.service(8) Main PID: 260 (systemd-network) Status: \u0026quot;Processing requests...\u0026quot; CGroup: /system.slice/systemd-networkd.service a””a”€260 /lib/systemd/systemd-networkd Apr 27 17:49:21 quark systemd[1]: Starting Network Service... Apr 27 17:49:22 quark systemd-networkd[260]: lo : gained carrier Apr 27 17:49:22 quark systemd[1]: Started Network Service. Apr 27 17:49:22 quark systemd-networkd[260]: eth1 : renamed to enp0s20f7 Apr 27 17:49:22 quark systemd-networkd[260]: eth0 : renamed to enp0s20f6 Apr 27 17:49:23 quark systemd-networkd[260]: enp0s20f6 : gained carrier Apr 27 17:49:23 quark systemd-networkd[260]: enp0s20f7 : gained carrier Apr 27 17:49:25 quark systemd-networkd[260]: enp0s20f6 : lost carrier Apr 27 17:49:26 quark systemd-networkd[260]: enp0s20f7 : lost carrier sytemd-network.service 的配置文件可以位于 /usr/lib/systemd/network/ 或者 /etc/systemd/network/ 目录下，后者具有最高优先级。配置文件有三种类型：\n.network 文件，设置网卡的 IP 等各项属性 .netdev 文件，新建一个虚拟网卡 .link 文件，每当一个网卡出现时，udev 都会查找与它同名的 .link 文件 这几类文件都遵循下面的规则：\n各选项的值都支持星号 * 通配符 当 [Match] 段内的条件都匹配时，后面的配置项才会被激活 如果 [Match] 段为空，表示后面的配置项在任何情况下都可用 无论配置文件在哪个目录，都会统一安装字典顺序进行加载 同名文件可以相互替换 如果要给 enp0s20f6 配置一个静态 IP ，可以在 /etc/systemd/network/ 目录下新建一个 eth0.network 文件，内容如下：\n[Match] Name=enp0s20f6 # 匹配名为 enp0s20f6 的网卡 [Network] DHCP=none # 关闭 DHCP 客户端， Address=192.168.5.242/24 # 设置 IP 和子网掩码 Gateway=192.168.5.50 # 设置网关，这项设置会将该网卡添加到缺省路由 DNS=8.8.8.8 # 设置 DNS 如果要使用 DHCP 自动获取 IP ，也将 DHCP 设为如下值：\nv4 ，只接受 ipv4 的 IP v6 ，只接受 ipv6 的 IP both ，同时接受 ipv4 和 ipv6 格式的 IP 启动 DHCP 客户端后，Gateway 和 DNS 也会自动获取，有时我们不希望这样，可以在配置文件中添加一个 [DHCP] 段，做如下设置：\n[DHCP] UseDNS=false # 不使用 DHCP 分配的 DNS ，默认值是 true UseRoutes=false # 不会将本网卡设为缺省路由，默认值是 true 在这里会出现一个 Bug ，就是 UseRoutes 设置无效，高版本中已经解决，解决方案在 https://github.com/systemd/systemd/pull/3075 。\n2. Wi-Fi 配置 #Wi-Fi 连接还是使用 wpa_supplicant 程序，systemd 提供了 wpa_supplicant@.service 管理整个流程，然后再用 systemd-networkd.service 配置 IP 等。\nwpa_supplicant@.service 的内容：\n[Unit] Description=WPA supplicant daemon (interface-specific version) Requires=sys-subsystem-net-devices-%i.device After=sys-subsystem-net-devices-%i.device # NetworkManager users will probably want the dbus version instead. [Service] Type=simple ExecStart=/usr/sbin/wpa_supplicant -c/etc/wpa_supplicant/wpa_supplicant-%I.conf -i%I [Install] Alias=multi-user.target.wants/wpa_supplicant@%i.service 这是 service 模板，启动时在 @ 符号之后加入 Wi-Fi 网卡的名称使其实例实例化，这个名词还会关联到 wpa_supplicant 的配置文件，我们先在 /etc/ 下新建一个 wpa_supplicant 目录，然后新建一个 wpa_supplicant-wlp1s0.conf 文件，内容如下：\nctrl_interface=/var/run/wpa_supplicant ctrl_interface_group=wheel update_config=1 eapol_version=1 ap_scan=1 fast_reauth=1 用 wpa_passphrase 添加无线路由器配置：\n~# sudo wpa_passphrase [essid] [password] \u0026gt;\u0026gt; /etc/wpa_supplicant/wpa_supplicant-wlp1s0.conf 在 /etc/systemd/network/ 目录下添加配置文件 wireless.network ，内容如下：\n[Match] Name=wlp1s0 [Network] DHCP=yes 最后重启各项服务：\n~# systemctl restart systemd-networkd ~# systemctl restart wpa_supplicant@wlp1s0 ~# systemctl restart systemd-resolved 3. 3G/4G 配置 #依然使用 pppd 进行 3G/4G 拨号，systemd 提供了 ppp@.service 服务管理 pppd 。首先在 /etc/ppp/peers/ 下建好 ppp 拨号文件 me909s ，然后启动服务：\n~# systemctl start ppp@me909s 4. 关闭 IPv6 #向内核参数加入 ipv6.disable=1 可以完全关闭 IPv6 功能。此外，只加入 ipv6.disable_ipv6=1 内核参数可以保留 IPv6 功能，但不会向网卡分配 IPv6 地址，做法是：\n~# echo 1 \u0026gt; /proc/sys/net/ipv6/conf/enp0s20f6/disable_ipv6 5. ssh server #目前流行的启动 ssh server 的方式是调用 sshd.socket ：\n~# systemctl start sshd.socket 旧有的 sshd.service 模式会在后台保持一个 sshd 的守护进程，每当有 ssh 连接要建立时，就创建一个新进程，比较适合 SSH 下有大量流量的系统；\n新的 sshd.socket 方式也是在每次要建立新的ssh连接时生成一个守护进程的实例，不过监听端口则是交给了 systemd 来完成，意味着没有 ssh 连接的时候，也不会有 sshd 守护进程运行，大部分情况下，使用 sshd.socket 服务更为合适。这也与 MacOS 下的行为相一致，默认只监听端口，有连接时才创建进程。\n另外，通过使用 .socket 文件来管理需要监听端口的服务，可以直接通过 systemctl 来查看一些网络相关的信息，如监听的端口、目前已经接受的连接数、目前正连接的连接数等。\n参考 # How to use systemd-networkd to manage your wifi Systemd-network ","date":"2018 May 9","permalink":"/posts/2018/05/09/","section":"Posts","summary":"0. 简介 #systemd 是 freedesktop 的项目，官网 https://www.","title":"systemd 的网络管理"},{"content":"0. Quick Start #构建一个 yocto 系统镜像的基本流程如下：\n准备宿主机系统，安装必要的开发工具。 初始化构建环境，通常是利用 oe-init-build-env 脚本，默认会新建一个构建目录 build 。 编辑 build/conf/local.conf 文件，确认 MACHINE 变量，为 开始构建系统镜像，最终的镜像文件会生成在 build/tmp/deploy/images/ 目录下。 先在宿主机安装 Ubuntu Server 18.04 ，至少预留 50GB 硬盘空间，推荐 100GB ，然后安装如下软件包：\n$ sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat cpio python python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping libsdl1.2-dev xterm 用 git 克隆一份 yocto 源码：\n$ git clone git://git.yoctoproject.org/poky Cloning into 'poky'... remote: Counting objects: 367178, done. remote: Compressing objects: 100% (88161/88161), done. remote: Total 367178 (delta 272761), reused 366942 (delta 272525) Receiving objects: 100% (367178/367178), 133.26 MiB | 6.40 MiB/s, done. Resolving deltas: 100% (272761/272761), done. Checking connectivity... done. $ cd poky/ $ git status On branch master Your branch is up to date with 'origin/master'. nothing to commit, working tree clean $ git branch -a * master remotes/origin/1.1_M1 remotes/origin/1.1_M2 ... remotes/origin/1.6_M5 remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/bernard ... remotes/origin/rocko remotes/origin/rocko-next remotes/origin/sumo remotes/origin/sumo-next 克隆到本地的仓库处于 master 分支，在这里可以看到 yocto 的版本发行记录，我们应该检出当前的版本 2.4.2(Rocko) ：\n$ git checkout -b rocko origin/rocko Branch 'rocko' set up to track remote branch 'rocko' from 'origin'. Switched to a new branch 'rocko' $ git branch master * rocko 每个分支内又有很多 tags ，先查看当前的版本和 tag 信息:\n$ git describe rocko-18.0.2-105-g701cc0009f $ git show rocko-18.0.2 tag rocko-18.0.2 Tagger: Tracy Graydon \u0026lt;tracy.graydon@intel.com\u0026gt; Date: Mon Mar 12 14:51:03 2018 -0700 Tagging for yocto-2.4.2 ... ... commit 342fbd6a3e57021c8e28b124b3adb241936f3d9d (tag: yocto-2.4.2, tag: rocko-18.0.2) Author: Anuj Mittal \u0026lt;anuj.mittal@intel.com\u0026gt; Date: Tue Feb 20 08:33:45 2018 +0800 可以看到，当前版本已经是 tag rocko-18.0.2 之后的第 105 次 commit ，可以选择将版本回退到一个特定的 tag 。然后初始化编译环境：\n$ source oe-init-build-env build 以后所有编译生成的文件都位于 build 目录下，然后开始编译：\n$ bitbake core-image-sato 默认会构建出一个基于 qemu 的系统镜像。\n","date":"2018 April 27","permalink":"/posts/2018/04/27/","section":"Posts","summary":"0. Quick Start #构建一个 yocto 系统镜像的基本流程如下：","title":"Yocto 学习笔记"},{"content":"0. 简介 #libpcap 是用于捕获 TCP/IP 网络数据包的 C/C++ 库，支持 Linux 系统，Tcpdump 就是在其基础上开发的，通常用于网络嗅探、数据抓取、协议分析等，官网是 http://www.tcpdump.org ，主要的功能有：\n数据包捕获：捕获流经网卡的原始数据包 规则过滤：提供自带规则过滤功能，按需要选择过滤规则 流量采集与统计：采集网络中的流量信息 自定义数据包发送：构造任何格式的原始数据包 包捕获机制是在数据链路层增加一个旁路处理，并不干扰系统自身的网络协议栈的处理，对发送和接收的数据包通过 Linux 内核做过滤和缓冲处理，最后直接传递给上层应用程序。在 Linux 发行版上可以直接安装 libpcap 或者开发库 libpcap-devel ，也可以下载源码后编译安装。\n1. 编程 #调用 libpcap 库函数前要包含的头文件：\n#include \u0026lt;pcap/pcap.h\u0026gt; 调用 libpcap 库抓包的流程：\n查找网卡，目的是发现可用的网卡，实现的函数为 pcap_lookupdev() 。 获得网卡参数，这里是利用 pcap_lookupnet() 函数，获得指定网卡的 IP 地址和子网掩码。 打开网卡，利用第一步的返回值，决定使用哪个网卡，调用 pcap_open_live() 将其打开。 编译过滤策略，Lipcap 的重要功能就是提供数据包的过滤，实现的函数是 pcap_compile() 。 设置过滤器，调用 pcap_setfilter() 函数将编译好的过滤策略设置到相应网卡。 开始捕获数据包，有多种实现函数，具有不同的特性。 关闭网卡，释放资源。 如果是用源码包编译安装的话，在 tests 目录下有几个例程可以参考。\n1.1. 查找网卡 #char errbuf[PCAP_ERRBUF_SIZE]; int pcap_findalldevs(pcap_if_t **alldevsp, char *errbuf); void pcap_freealldevs(pcap_if_t *alldevs); pcap_freealldevs() 函数可以搜索当前系统中的网卡，并构造一个网卡设备链表。如果调用成功，函数返回 0 ，指针 alldevsp 会指向列表的第一个元素；否则返回 -1 ，指针为 NULL ，并在 errbuf 中存放错误信息，errbuf 至少应该是 PCAP_ERRBUF_SIZE 个字节长度的。链表中的每个元素都是 pcap_if_t 类型：\nstruct pcap_if { struct pcap_if *next; char *name; /* 网卡设备名称，可以调用 \u0026quot;pcap_open_live()\u0026quot; 打开*/ char *description; /* 网卡设备描述, 可以为 NULL */ struct pcap_addr *addresses; bpf_u_int32 flags; /* PCAP_IF_ interface flags */ }; typedef struct pcap_if pcap_if_t; addresses 是 struct pcap_addr 类型的指针，包含了 IP 、掩码等网卡信息：\nstruct pcap_addr { struct pcap_addr *next; struct sockaddr *addr; /* address */ struct sockaddr *netmask; /* netmask for that address */ struct sockaddr *broadaddr; /* broadcast address for that address */ struct sockaddr *dstaddr; /* P2P destination address for that address */ }; typedef struct pcap_addr pcap_addr_t; bpf_u_int32 flags 是设置网卡状态属性的变量，可选值有：\nPCAP_IF_LOOPBACK ，把网卡设为 loopback 接口 PCAP_IF_UP ，网卡状态设为 UP PCAP_IF_RUNNING ，网卡状态设为 running 使用完成后，调用如下函数释放设备链表：\nvoid pcap_freealldevs(pcap_if_t *alldevs); 下面是一个简单的例子：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;pcap/pcap.h\u0026gt; int main() { int ret = 0; int i = 0; char errbuf[PCAP_ERRBUF_SIZE] = \u0026quot;\\0\u0026quot;; pcap_if_t *devsp = NULL; pcap_if_t *temp = NULL; printf(\u0026quot;start libpcap\\n\u0026quot;); ret = pcap_findalldevs(\u0026amp;devsp, errbuf); if(ret==0 \u0026amp;\u0026amp; devsp) { for(temp=devsp;temp;temp=temp-\u0026gt;next) { printf(\u0026quot;%d : interface name %s\\n\u0026quot;,i++,temp-\u0026gt;name); } } else { printf(\u0026quot;pcap_findalldevs error : %s\\n\u0026quot;, errbuf); } return 0; } 编译：\n$ gcc -Wall test.c -o test -lpcap 执行：\n$ ./test start libpcap 0 : interface name eth0 1 : interface name any 2 : interface name lo 3 : interface name nflog 4 : interface name nfqueue 5 : interface name usbmon1 1.2. 打开网卡 #获得了网卡名称后，就可以调用相关函数把它打开：\npcap_t *pcap_open_live(const char *device, int snaplen, int promisc, int to_ms, char *errbuf); 该函数的作用获得指定网卡的操作句柄，并设置句柄的各种属性，后面的抓包函数都是直接操作这个句柄。各参数的含义：\ndevice 是网卡名称的字符串 snaplen 表示对每个数据包，从开头抓取多少个字节，任何一个协议的一个数据包长度都小于 65536 字节，我们可以用这个参数设置只抓取头部，而不关系具体内容 promise 设为 0 表示关闭混杂模式，1 表示打开，此时网卡也必须打开混杂模式，例如 ifconfig eth0 promisc to_ms 用于设置某些抓包函数的超时时间，单位是毫秒，0 表示一直等待 errbuf 用于存放错误信息 该函数调用成功时会返回一个 pcap_t 类型的指针，失败则返回 NULL 。使用完毕后，应该调用下面的函数将其关闭：\nvoid pcap_close(pcap_t * p); 如果想要知道某个网卡的类型，可以调用 pcap_datalink() ，它会返回网卡数据链路类型：\nint pcap_datalink(pcap_t *p); 它的返回值列表可以在 http://www.tcpdump.org/linktypes.html 查到，常见的有：\nLINKTYPE_ name value 描述 LINKTYPE_ETHERNET 1 IEEE 802.3 以太网 LINKTYPE_PPP 9 PPP, 描述在 RFC 1661 和 RFC 1662 LINKTYPE_IEEE802_11 105 IEEE 802.11 无线 1.3. 获取数据包 #libpcap 有多种获取数据包的方法，可以根据不同的应用场景进行选择。\nconst u_char *pcap_next(pcap_t *p, struct pcap_pkthdr *h); pcap_next() 在获取一个数据包后立即返回，并将数据包存放在返回值指向的内存中，这段内存可能随时被更改或者释放，所以，如果要对数据做进一步处理，最好先拷贝一份，调用失败会返回 NULL 。这种方式处理数据包的内容并不方便，所有我们通常只用这个方法统计数据量，参数 struct pcap_pkthdr *h 记录了数据包的其他信息：\nstruct pcap_pkthdr { struct timeval ts; /* 时间戳 */ bpf_u_int32 caplen; /* 本次捕获的数据长度 */ bpf_u_int32 len; /* 这个数据包的真实长度 */ }; 因为不能保证每次捕获的包是完整的，例如一个包长 1480，但是捕获到1000的时候，可能因为某些原因就中止了，所以caplen 是记录实际捕获的长度，也就是 1000，而 len 就是1480。\n另一个重要的方法是 pcap_loop() ：\nint pcap_loop(pcap_t * p, int cnt, pcap_handler callback, u_char * user); 该函数会连续捕获 cnt 个数据包后退出，如果 cnt \u0026lt; 0 ，会一直循环抓包，直到出现错误或者调用 pcap_breakloop() 。在低版本中，没有定义 cnt==0 时的情况，不同平台上的特性无法确定。函数正常退出时返回 0 ，出错返回 -1 ，如果是被 pcap_breakloop() 中断的会返回 -2 。每当收到足够的数据包时，pcap_loop() 会调用 callback 回调函数，并可以通过 u_char * user 向回调函数传递参数，我们可以在回调函数里处理收到的数据包：\ntypedef void (*pcap_handler)(u_char *user, const struct pcap_pkthdr *h, const u_char *bytes); 数据包就存放在指针参数 bytes 指向的内存里，长度可以通过第二个参数 struct pcap_pkthdr *h 获取。下面是一个简单的例子：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;pcap.h\u0026gt; void get_packet(u_char * arg, const struct pcap_pkthdr * pkthdr, const u_char * packet) { int * id = (int *)arg; printf(\u0026quot;id: %d\\n\u0026quot;, ++(*id)); printf(\u0026quot;Packet length: %d\\n\u0026quot;, pkthdr-\u0026gt;len); printf(\u0026quot;Number of bytes: %d\\n\u0026quot;, pkthdr-\u0026gt;caplen); printf(\u0026quot;Recieved time: %s\\n\u0026quot;, ctime((const time_t *)\u0026amp;pkthdr-\u0026gt;ts.tv_sec)); //print packet int i; for(i=0; i\u0026lt;pkthdr-\u0026gt;len; ++i) { printf(\u0026quot; %02x\u0026quot;, packet[i]); if( (i + 1) % 16 == 0 ) printf(\u0026quot;\\n\u0026quot;); } printf(\u0026quot;\\n\\n\u0026quot;); } int main() { char dev[10]=\u0026quot;eth0\u0026quot;; char errbuf[1024]; int id = 0; pcap_t* device=pcap_open_live(dev,65535,1,0,errbuf); if(!device){ printf(\u0026quot;couldn't open the net device: %s\\n\u0026quot;,errbuf); return 1; } //capture the packet pcap_loop(device,-1,get_packet,(u_char*)\u0026amp;id); return 0; } 另一个方法 pcap_dispatch() 与 pcap_loop() 非常相似，参数完全相同：\nint pcap_dispatch(pcap_t *p, int cnt, pcap_handler callback, u_char *user); 不同的是，这个函数有超时设定，超时时间由 pcap_open_live() 函数的第四个参数 to_ms 设置，如果超过 to_ms 毫秒还没有收到数据就会返回。正常情况下，这个函数的返回值是收到的数据包个数，没收到就返回 0 ，出错时返回 -1 ，如果是被 pcap_breakloop() 中断的会返回 -2 。有一点要注意，该函数返回后，如果还要继续抓包，可以直接调用 pcap_dispatch() 继续抓包，除非调用出错，否则不要关闭设备，频繁的打开关闭设备可能出现意想不到的错误。参数 cnt 表示的是最大值，即最多收到 cnt 个数据包就返回，因为一次只读取一个缓冲区内的数据包，可能会处理少于 cnt 的数据包，如果设为 -1 或者 0 ，表示捕获一个缓冲区内的所有数据包。\n这几个函数出错时，可以用 pcap_geterr() 获取错误信息：\nchar *pcap_geterr(pcap_t *p); 返回值是执行错误信息字符串的指针，最好拷贝一份再做处理。\n1.3. 过滤器 #libpcap 的过滤器是利用 BPF 来筛选网络数据包的，它是类 Unix 系统上数据链路层的一种原始接口，我们可以在过滤器中设置规则，获取想要的网络数据包，比如只获取 UDP 数据包，只获取特定地址的数据包等。过滤数据包需要完成三件事：\n构造过滤表达式，这是一个包含筛选规则的字符串 把过滤表达式编译到 BPF 应用过滤器 过滤表达式的语法比较简单，一个过滤表达式通常由一个 id （名字或数字）和多个修饰词组成，修饰词分为三种：\ntype ，用来说明 id 是什么类型，可选的 net 、host 和 port 分别表示网络、主机和端口，没有声明时默认是 host ，例如 net 192.168 , host 192.168.5.252 ， port 22 。 dir ，表示 id 的传输方向，可选 src 、dst 等，默认是 src or dst ，例如 dst port 22 表示目的端口是 22 。 proto ，限定匹配的协议，比如链路层协议 ether 、wlan ，网络层协议 ip ，传输层协议 tcp 、udp 等。 多个表达式可以用 and 、or 、not 连接，表示逻辑与、或、非。 下面是一些常用的表达式，更多细节可以查看 https://www.tcpdump.org/manpages/pcap-filter.7.html :\n#只接受源地址是 192.168.1.1 的数据包 src host 192.168.1.1 #只接受目的端口是 8000 的数据包 dst port 8000 #只接受 UDP 数据包 udp #不接受 TCP 数据包 not tcp #只接受 ip 的 ttl==5 的数据包（ip 首部第八个字节是 ttl） ip[8]==5 #接受来自 192.168.5.252 主机，且目的端口是 22 或者 23 的数据包 dst port 192.168.5.252 and (dst port 22 or dst port 23) 构造好过滤表达式后，就可以调用 pcap_compile() 函数进行编译：\nint pcap_compile(pcap_t *p, struct bpf_program *fp, const char *str, int optimize, bpf_u_int32 netmask); fp 是一个传出参数，用于保存编译后的 BPF ，str 就是过滤表达式，optimize 设为 1 表示对过滤表达式进行优化，netmask 设为 0 即可。编译成功返回 0 ，失败返回 -1 。\n注意， 在 libpcap 1.8.0 以及之后的版本中，pcap_compile() 可以用于多线程，旧版本中，该函数是线程不安全的，如果用于多线程，需要做互斥同步。\n编译成功后，调用 pcap_setfilter() 应用这个过滤器：\nint pcap_setfilter(pcap_t *p, struct bpf_program *fp); ","date":"2018 April 23","permalink":"/posts/2018/04/23/","section":"Posts","summary":"0. 简介 #libpcap 是用于捕获 TCP/IP 网络数据包的 C/C++ 库，支持 Linux 系统，Tcpdump 就是在其基础上开发的，通常用于网络嗅探、数据抓取、协议分析等，官网是 http://www.","title":"Libpcap 学习笔记"},{"content":"0. 开始 #Tkinter 是 Python 内置的 GUI 框架，安装后 Python 后即可使用：\nPython 3.6.2 (v3.6.2:5fd33b5926, Jul 16 2017, 20:11:06) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type \u0026quot;help\u0026quot;, \u0026quot;copyright\u0026quot;, \u0026quot;credits\u0026quot; or \u0026quot;license\u0026quot; for more information. \u0026gt;\u0026gt;\u0026gt; import tkinter as tk \u0026gt;\u0026gt;\u0026gt; tk._test() 运行结果：\n下面这个例子只包含一个 Quit 按钮:\nimport tkinter as tk window = tk.Tk() #定义一个顶层窗口 window.title('my window') #定义窗口的标题 window.geometry('200x100') #设置窗口的大小 quitbutton = tk.Button(window, text=\u0026quot;Quit\u0026quot;, command=window.quit) #在 window 上定义一个按钮，显示 Quit ，点击按钮执行 quit 方法 quitbutton.grid() #显示这个按钮 window.mainloop() #开始主循环 运行结果：\n1. 布局管理 #Tkinter 有多种布局管理系统，grid 是最常用的一种。以顶层窗口作为根控件形成一个控件树，一个父控件上可以包含很多子控件，例如顶层窗口上有按钮、输入框等，大体应该是如下的结构：\n新建一个控件分为两步：\nself.thing = tk.Constructor(parent, ...) self.thing.grid(...) 定义控件，Constructor 是一种控件的类， 比如 Button、Frame ，parent 表示该控件的父控件 将控件放到窗口上，所有的控件都有 grid 方法，负责通知布局管理器将这个组件放置到合适的位置 grid 布局将父控件的显示区域划分为网格，使用 grid 布局的过程就是为各个子控件指定行号和列号，左上角的坐标是 (0,0)，不需要为每个单元格指定大小，grid 布局会自动设置一个合适的大小。grid 方法的原型是 w.grid(option=value, ...) ，它将控件 w 注册到父控件的 grid 布局，并设置所处的单元格坐标，常用属性如下：\ncolumn ，列坐标，默认是 0 row ，行坐标，默认是新启一行 sticky ，控件填充单元格的方式，不设置该选项时默认是横竖居中，它有两种可选值，可以用加号组合： 紧贴单元格的某个角落：sticky=tk.NE (右上角) ， tk.SE (右下角) ， tk.SW (左下角) 或者 tk.NW (左上角) 紧贴单元格的某条边线：sticky=tk.N (上边居中) ， tk.E (右边居中) ， tk.S (底边居中) 或者 tk.W (左边居中) padx ，横向内边距 pady ，纵向内边距 也可以手动设置当前控件的单元格大小：\n设置第 N 列：w.columnconfigure(N, option=value, ...) 设置第 N 行：w.rowconfigure(N, option=value, ...) option 有三个属性可选：\nminsize ，行或者列的最小尺寸，单位是像素 pad ，行或者列占用的尺寸大小，单位是像素 weight ，设置行或者列占用的比例，使网格尺寸具有弹性， 例如：\nimport tkinter as tk window = tk.Tk() window.title('my window') window.geometry('200x100') window.columnconfigure(0, weight=1) #第一列占用 1/3 宽度 window.columnconfigure(1, weight=2) #第二列占用 2/3 宽度 window.rowconfigure(0, weight=1) #第一行占用全部高度 Abutton = tk.Button(window, text=\u0026quot;A\u0026quot;) Abutton.grid() Bbutton = tk.Button(window, text=\u0026quot;B\u0026quot;) Bbutton.grid(row=0,column=1,sticky=tk.W+tk.E) window.mainloop() 运行结果：\n还有一些常用的方法：\nw.grid_forget() ，隐藏一个控件 w.grid_propagate() ，控件的尺寸通常是由控件里的内容决定的，但是有时需要强制设置控件大小，这就要先设置 w.grid_propagate(0) ，然后设置尺寸 w.grid_info()，返回一个字典，包含了控件的属性名称和值 w.grid_size()，返回一个元组，包含两个元素，分别是行和列 w.grid_configure(option, \u0026hellip;) ，设置 grid 的属性，例如 w.grid_configure(padx=5,pady=5) 2. 一个完整的例子 #2.1. 设计 #这个例子是一个单窗口 GUI 应用，功能是将英尺转换为米，界面草图是这个样子：\n第一行有一个输入框，单位 feet 放在一个标签里，第二行中间是一个空白标签，用于放置转换后的结果，左右分别是文字说明，右下角是一个 \u0026lsquo;Calculate\u0026rsquo; 按钮，按下时获取输入框中的数值，转换成米后显示在中间的标签中。整个窗口是一个 3x3 的 grid 布局：\n三行所占高度应该是 1:1:1 ，三列所占的宽度应该是 2:1:1 ，输入框宽度 7 个字符。\n2.2. 编码 #新建一个目录，编辑源文件 mygui.py ，代码如下：\n#!~/py3-env/bin/python import tkinter as tk #新建一个根窗口，并设置窗口标题 window = tk.Tk() window.title('Feet to Meters') #按下按钮是调用的函数，获取输入框的值，转换成米制单位在写入标签 def calculate(*args): value = float(feet.get()) meters.set( (0.3048*value*10000.0 + 0.5) / 10000.0 ) #在窗口上绘制一个框架，并定义框架的内边距 mainframe = tk.Frame(window,padx=15,pady=25) #mainframe 会占满整个窗口 mainframe.grid(row=0,column=0,sticky=tk.N+tk.W+tk.E+tk.S) mainframe.rowconfigure(0,weight=1) mainframe.columnconfigure(0,weight=1) #输入框位于第一行第二列，左右占满，宽度是 7 个字符，内部文本右对齐，并且是程序启动后默认的焦点 feet=tk.StringVar() feet_entry = tk.Entry(mainframe,width=7,justify=tk.RIGHT,textvariable=feet) feet_entry.grid(row=0,column=1,sticky=tk.W+tk.E) feet_entry.focus() feet_label = tk.Label(mainframe,text=\u0026quot;Feet\u0026quot;,anchor=tk.W) feet_label.grid(row=0,column=2,sticky=tk.W) meters=tk.StringVar() tk.Label(mainframe,text=\u0026quot;is equivalent to\u0026quot;).grid(row=1,column=0,sticky=tk.E) tk.Label(mainframe,textvariable=meters).grid(row=1,column=1,sticky=tk.W+tk.E) tk.Label(mainframe,text=\u0026quot;Meters\u0026quot;).grid(row=1,column=2,sticky=tk.W+tk.W) #在右下角放置一个按钮，按下时执行 calculate 函数 tk.Button(mainframe,text=\u0026quot;Calculate\u0026quot;,command=calculate).grid(row=2,column=2,sticky=tk.W) #设置 mainframe 内每个控件的内边距为 5 for child in mainframe.winfo_children(): child.grid_configure(padx=5,pady=5) #按下回车键时也会执行转换 window.bind('\u0026lt;Return\u0026gt;', calculate) window.mainloop() 保存后运行，看一下效果：\n2.3. 打包 #测试成功后用 pyinstaller 将源码打包，这样在其他计算机上也可以运行，甚至不用安装 python ，但是有一点要注意，在 macOS 下用 pyinstaller 打包的程序只能运行于 macOS ，在 Windows 下用 pyinstaller 打包的程序只能运行于 Windows 。先安装 pyinstaller ：\n$ pip install pyinstaller $ python -m PyInstaller --version 3.3.1 这个版本在 macOS 上有个 Bug ，就是打包的 tkinter 程序在运行时会报如下的错误：\nImportError: dlopen(/var/folders/gk/q_9lv83d6999mzn5d3cjrry80000gn/T/_MEIlRBLqx/_tkinter.so, 2): Library not loaded: @loader_path/Tcl Referenced from: /var/folders/gk/q_9lv83d6999mzn5d3cjrry80000gn/T/_MEIlRBLqx/_tkinter.so Reason: image not found 需要安装下面提供的补丁修改 pyinstaller : https://github.com/pyinstaller/pyinstaller/pull/2969 。然后在源码目录下执行：\n$ pyinstaller -w -F mygui.py -F 表示将所有文件和库打包成一个文件，这样在没有安装 python 的计算机上也可以运行，-w 表示关闭终端，否则在运行生成的应用在打开时会运行一个终端。生成的应用程序在 dist 目录下，该目录下有两个文件，mygui 是调试版，mygui.app 是发行版，双击 mygui.app 即可运行：\n默认打包后的程序是不支持 Retina 屏幕的，所以在 macOS 上会显示模糊。需要先生成一个 spec 文件：\n$ pyi-makespec -w -F mygui.py 然后编辑生成的 mygui.spec ，添加 info_plist 并设置 'NSHighResolutionCapable': 'True' ：\napp = BUNDLE(exe, name='mygui.app', icon=None, bundle_identifier=None, info_plist={ 'NSHighResolutionCapable': 'True' } ) 保存后用这个配置文件执行打包任务：\n$ pyinstaller -w -F mygui.spec 这样生成的应用就支持 Retina 屏幕了。\n3. 常用控件 #每个控件都是一个类，调用控件的初始化函数就会新建一个实例。\n3.1. 按钮 #按钮的原型：\nw = tk.Button(parent, option=value, ...) bg or background\t，背景颜色 bd or borderwidth\t，边框宽度，默认是 2 anchor ，按钮上文字的对齐位置，例如 anchor=tk.NE 表示右上角对齐 text ，按钮上显示的文字 textvariable ，为该属性设置一个控制变量 StringVal 类的实例，以后修改这个变量就可以修改标签内显示的文本 command ，设置按钮按下时的行为，可以指向一个函数或者方法 width ，按钮的宽度，单位是字符个数，如果按钮显示的是图片，则单位是像素 padx ，按钮边框与文字之间的横向间距，就是内边距，单位是像素 pady ，按钮边框与文字之间的纵向间距，单位是像素 relief ，3D 样式，默认值是 relief=tk.RAISED，可选四个值：tk.GROOVE(边框突出)，tk.RIDGE(边框凹陷)，tk.SUNKEN(整体凹陷)，tk.RAISED(整体突出)，边框宽度由 borderwidth 决定 state ，按钮的状态，默认是 tk.NORMAL ，鼠标悬停时这个值是 tk.ACTIVE ，设为 tk.DISABLED 时按钮变灰并且失效 它有两个方法：\n.invoke() ，调用 command 指定的函数。 .flash() ，使按钮的颜色在按下和放开之间闪烁几次。 例程：\nimport tkinter as tk window = tk.Tk() window.title('my window') window.geometry('200x100') window.columnconfigure(0, weight=1) window.rowconfigure(0, weight=1) button = tk.Button(window, anchor=tk.CENTER, text='Quit', command=window.quit) button.grid() window.mainloop() 运行结果：\n3.2. 标签 #标签控件可以显示一行或者多行文本，或者一张图片。\nw = tk.Label(parent, option, ...) 常用属性；\nactivebackground ，鼠标经过时的背景颜色 activeforeground ，鼠标经过时的前景颜色 anchor ，文本或者图片的对齐位置，默认是 anchor=tk.CENTER bg or background ，背景颜色 bd or borderwidth\t，边框宽度，默认是 2 text ，显示是文本 textvariable ，为该属性设置一个控制变量 StringVal 类的实例，以后修改这个变量就可以修改标签内显示的文本 width ，宽度，单位是字符，如果没有设置，宽度随内容变化 padx ，按钮边框与文字之间的横向间距，就是内边距，单位是像素 pady ，按钮边框与文字之间的纵向间距，单位是像素 relief ，3D 样式，默认值是 relief=tk.FLAT，可选四个值：tk.GROOVE(边框突出)，tk.RIDGE(边框凹陷)，tk.SUNKEN(整体凹陷)，tk.RAISED(整体突出)，边框宽度由 borderwidth 决定 例程：\nimport tkinter as tk window = tk.Tk() window.title('my window') window.geometry('200x100') window.columnconfigure(0, weight=1) window.rowconfigure(0, weight=1) label = tk.Label(window, bg='#ff0000', text='Please',padx=5, pady=3) label.grid() window.mainloop() 运行结果：\n3.3. 输入框 #输入框可以显示和输入单行文本，文本中的字符编号从 0 开始，常量 tk.END 表示文本的结尾，tk.INSERT 表示当前光标所处的位置，原型：\nw = tk.Entry(parent, option, ...) 常用属性：\nbg or background\t，背景颜色 bd or borderwidth\t，边框宽度，默认是 0 width ，输入框能够容纳的字符数，默认是 20 show，默认情况下，输入的字符会直接显示，如果是密码，需要隐藏，可以要求输入的字符都显示为星号： show='*' justify ，输入框内文本的对齐方式，默认是左对齐 justify=tk.LEFT ，还可选 tk.CENTER 和 tk.RIGHT validate ，设置检查输入框内容的时机 validatecommand ，设置一个回调函数，负责检查输入框的内容 textvariable ，为该属性设置一个控制变量 StringVar 类的实例，就可以用 v.get() 方法取回输入框中内容，或者用 v.set(value) 设置，v 就是这个实例 state ，默认是 tk.NORMAL ，鼠标悬停时这个值是 tk.ACTIVE ，设为 tk.DISABLED 时输入框变灰，并无法输入。 常用方法：\n.delete(first, last=None) ，删除字符，从第 first 个字符到第 last 个字符之前。 .get() ，获取输入框中的文本，返回值是字符串。 .insert(index, s) ，在第 index 个字符前插入字符串 s 。 例程：\nimport tkinter as tk window = tk.Tk() window.title('my window') window.geometry('300x100') window.columnconfigure(0, weight=1) window.columnconfigure(1, weight=2) window.rowconfigure(0, weight=1) label1 = tk.Label(window,text=\u0026quot;Username:\u0026quot;, anchor=tk.E) label1.grid(row=0,column=0,sticky=tk.SE) user = tk.Entry(window, width=16, justify=tk.RIGHT) user.grid(row=0,column=1,sticky=tk.SW) label2 = tk.Label(window,text=\u0026quot;Password:\u0026quot;, anchor=tk.E) label2.grid(row=1,column=0,sticky=tk.NE) passwd = tk.Entry(window, width=16,show='*', justify=tk.RIGHT) passwd.grid(row=1,column=1,sticky=tk.NW) window.mainloop() 运行结果：\n有时我们需要检查输入的文本是否合法，这需要定义一个检测函数，并设置调用它的时间，具体步骤：\n定义一个回调函数，负责检查输入的内容，如果合法就返回 True ，否则返回 False 用 w.register(function) 方法将回掉函数封装为 Tcl ，它会返回一个字符串，用它设置 validatecommand 设置 validate ，声明调用回掉函数的时机，常用从选项有： \u0026lsquo;focus\u0026rsquo; ，输入框获得或者失去焦点时 \u0026lsquo;focusin\u0026rsquo; ，输入框获得焦点时 \u0026lsquo;focusout\u0026rsquo; ，输入框失去焦点时 \u0026lsquo;key\u0026rsquo; ，内容改变时 \u0026lsquo;all\u0026rsquo; ，以上任何情况发生时 \u0026rsquo;none\u0026rsquo; ，关闭内容检查，这是默认值 3.4. 框架 #框架是其他控件的容器，顶层窗口本质上就是一个框架，默认情况下，框架会紧紧的包裹它的控件，它的原型：\nw = Frame(parent, option, ...) 常用属性：\nbg or background\t，背景颜色 bd or borderwidth\t，边框宽度，默认是 0 width ，框架的宽度， w.grid_propagate(0) 时有效 height ，框架的高度，w.grid_propagate(0) 时有效 padx ，在框架与控件之间的横向间距，单位是像素 pady ，在框架与控件之间的纵向间距 relief ，3D 样式，默认情况下，框架是完全隐形的 relief=tk.FLAT，可选四个值：tk.GROOVE(边框突出)，tk.RIDGE(边框凹陷)，tk.SUNKEN(整体凹陷)，tk.RAISED(整体突出)，边框宽度由 borderwidth 决定 下面是一个例程：\nimport tkinter as tk window = tk.Tk() window.title('my window') window.geometry('200x100') window.columnconfigure(0, weight=1) window.rowconfigure(0, weight=1) frame = tk.Frame(window,height=50,width=100,relief=tk.GROOVE,bd=5) frame.grid_propagate(0) frame.grid() label = tk.Label(frame, text=\u0026quot;Label\u0026quot;) label.grid() window.mainloop() 运行结果：\n3.5. 标签框架 #LabelFrame 控件是带有标签的框架，原型：\nw = tk.LabelFrame(parent, option, ...) 常用属性：\nbg or background\t，背景颜色\nbd or borderwidth\t，边框宽度，默认是 2\nwidth ，框架的宽度， w.grid_propagate(0) 时有效\nheight ，框架的高度，w.grid_propagate(0) 时有效\nlabelwidget ，可以在标签中插入任何控件，代替原来的文本\ntext ，标签中的文字\nlabelanchor ，标签在框架上的位置，默认值是 \u0026rsquo;nw\u0026rsquo; ，可选值：\npadx=N ，在框架与控件之间，横向添加 N 个像素\npady=N ，在框架与控件之间，纵向添加 N 个像素\nrelief ，3D 样式，默认情况下，默认值是 tk.GROOVE，可选四个值：tk.GROOVE(边框突出)，tk.RIDGE(边框凹陷)，tk.SUNKEN(整体凹陷)，tk.RAISED(整体突出)，边框宽度由 borderwidth 决定\n例程：\nimport tkinter as tk window = tk.Tk() window.title('my window') window.minsize(width=300,height=150) window.columnconfigure(0, weight=1) window.rowconfigure(0, weight=1) login = tk.LabelFrame(window,text=\u0026quot;Login\u0026quot;,labelanchor='n',padx=10,pady=10) login.grid() label1 = tk.Label(login,text=\u0026quot;Username:\u0026quot;, anchor=tk.E) label1.grid(row=0,column=0,sticky=tk.SE) user = tk.Entry(login, width=16, justify=tk.RIGHT) user.grid(row=0,column=1,sticky=tk.SW) label2 = tk.Label(login,text=\u0026quot;Password:\u0026quot;, anchor=tk.E) label2.grid(row=1,column=0,sticky=tk.NE) passwd = tk.Entry(login, width=16,show='*', justify=tk.RIGHT) passwd.grid(row=1,column=1,sticky=tk.NW) window.mainloop() 运行结果：\n3.6. 菜单 #4. 顶层窗口 #Tk() 是由 root 新建的顶层窗口，如果要新建其他窗口，需要调用 .Toplevel() 方法：\nw = tk.Toplevel(option, ...) 4.1. 常用属性 # bg or background ，背景颜色 bd or borderwidth\t，边框宽度，默认是 0 menu ，为该属性传递一个 menu 控件的实例，会为窗口添加一个菜单栏，如果是 Windows 或者 Unix 系统，菜单栏会出现在串口的顶端，如果是 MacOS ，菜单栏会出现在屏幕顶端 4.2. 常用方法 # .maxsize(width=None, height=None) ，设置窗口的最大尺寸。 .minsize(width=None, height=None) ，设置窗口的最小尺寸。 .title(text=None) ，设置窗口标题。 .withdraw() ，隐藏窗口。 .geometry(newGeometry=None) ，设置窗口的尺寸，参数 newGeometry 是一个几何字符串。 5. 通用方法 #下面是每个控件都支持的方法。\nw.mainloop() ，主循环，处理各种事件，通常在所有静态控件新建完毕后调用， w.quit() ，结束主循环 .mainloop() ，程序退出 w.bind(sequence=None, func=None, add=None) ，将当前控件上发生的事件与某些函数绑定，sequence 是描述事件的字符串 w.bind_all(sequence=None, func=None, add=None)，将当前应用上所有控件发生的事件与某写函数绑定 w.bind_class(className, sequence=None, func=None, add=None) ，将某一类控件发生的事件与某些函数绑定，className 是控件类的名称，比如 \u0026lsquo;Button\u0026rsquo; w.winfo_screenheight() ，返回屏幕垂直方向的分辨率 w.winfo_screenwidth() ，返回屏幕水平方向的分辨率 w.winfo_children() ，返回一个包含所有子控件的列表，从低到高排序 w.configure(option=value, \u0026hellip;) ，设置一个或者多个属性 6. 标准属性 #6.1. 坐标 #Tkinter 的坐标系以左上角为原点，横轴是 x ：\nTkinter 还定义了一些常量，用于控制相对位置，比如标签内文字的对齐方向等，下面是这些常量的示意图：\n6.2. 单位 #许多控件的长度、宽度、或者其他尺寸的单位可以是像素、字符，也可以用其他单位描述，只需在数字的后面跟上单位即可：\n单位 描述 c 厘米 i 英寸 m 毫米 p 打印机的点 6.3. 颜色 #Tkinter 中的颜色可以用 RGB 字符串表示：\n字符串 描述 #rgb 每种颜色占四位 #rrggbb 每种颜色占八位 #rrrgggbbb 每种颜色占十二位 比如 \u0026lsquo;#FFF\u0026rsquo; 是白色，\u0026rsquo;#000000\u0026rsquo; 是黑色，\u0026rsquo;#FF0000\u0026rsquo; 是红色。还可以使用已经定义的标准颜色名称，比如 \u0026lsquo;white\u0026rsquo; ， \u0026lsquo;black\u0026rsquo; ， \u0026lsquo;red\u0026rsquo; ， \u0026lsquo;green\u0026rsquo; ， \u0026lsquo;blue\u0026rsquo; ， \u0026lsquo;cyan\u0026rsquo; ， \u0026lsquo;yellow\u0026rsquo; 和 \u0026lsquo;magenta\u0026rsquo; 。\n6.4. 几何字符串 #几何字符串是描述顶层窗口大小和位置的标准方法，通常的格式是 'wxh±x±y'，由三个部分组成：\nw 和 h 分别表示宽和高，单位是像素，用 x 连接，这个部分是必须的 如果后面跟着 +x ，表示窗口的左边框距离屏幕左边框 x 个像素，如果是 -x ，表示窗口的左边框超出屏幕左边框 x 个像素 如果后面还正常 +y ，表示窗口的上边框距离屏幕上边框 y 个像素，如果是 -y ，表示窗口的上边框超出屏幕上边框 y 个像素 7. 控制变量 #Tkinter 的控制变量是一种特定的对象，它的行为类似 Python 的普通变量，就是值的容器。它的特殊之处是可以由一组控件共享，如果某个控制变量 c 调用 c.set() 方法改变了自己的值，那么所有使用 c 的控件都会自动更新。控制变量的作用是保存控件上的某些值。控制变量有三种：\nv = tk.DoubleVar() # Holds a float; default value 0.0 v = tk.IntVar() # Holds an int; default value 0 v = tk.StringVar() # Holds a string; default value '' 控制变量有两个方法：\n.get() ，返回变量的值 .set(value) ，设置变量的值 用到控制变量的控件包括：\n控件 属性 类型 Button textvariable StringVar Entry textvariable StringVar Label textvariable StringVar Checkbutton variable IntVar Menubutton textvariable StringVar 8. 焦点：引导键盘输入 #某个控件被设为焦点（focus），意味着键盘输入会直接作用于这个控件。Tkinter 可以设置某个控件为默认焦点，也可以设置各种控件的焦点顺序，也就是用 Tab 键切换时的顺序。\n9. 事件：对刺激做出反应 #前面我们都在描述怎么绘制图形界面，下面我们讨论如今将控件与后台功能联系起来，让用户的操作得到实际的反馈。\n事件（event）就是应用程序上发生的事情，比如键盘输入、鼠标单击或者双击，应用程序应该对此作出反应。很多控件都有一些内置的行为，比如按钮按下时会调用 command 指向的函数。Tkinker 允许为一个或者多个事件定义相应的处理方法，有三中绑定级别：\n单独绑定，为一个控件上可能发生的某些事件绑定一个方法：w.bind(sequence=None, func=None, add=None) ，比如在 canvas 控件里为 PageUp 按键绑定一个翻页功能的方法。 分类绑定，为所用同类控件上可能发生的某些事件绑定一个方法：w.bind_class(className, sequence=None, func=None, add=None) ，比如双击鼠标时所有的按钮同时按下。 应用绑定，为应用上所有控件可能发生的某些事件绑定一个犯法：w.bind_all(sequence=None, func=None, add=None) 。 Tkinter 用事件序列字符串（sequence） 的方式描述事件，一个字符串可以描述一个或者多个事件，字符串遵循如下格式：\n\u0026lt;[modifier-]...type[-detail]\u0026gt; 字符串由尖括号 \u0026lt;\u0026gt; 包围 type 是必选项，指事件类型，例如按键，鼠标等 modifier 是可选项，可以连续设置多个，与 type 组成混合体来描述组合键，例如按下 shift 的时候单击鼠标 detail 是可选项，描述具体是哪个键盘按键、哪个鼠标按键。 下面是三个例子：\nsequence 描述 Button-1 按下鼠标左键 KeyPress-H 按下键盘上的 H 键 Control-Shift-KeyPress-H 按下 control-shift-H 组合键 9.1. type #常用的事件类型：\nName Type 描述 Activate 36 控件被激活，这个事件是由控件的 state 属性变化引起的 Button 4 按下鼠标，具体哪个键被按下由 detail 决定，按了几次由 modifier 决定 ButtonRelease 5 松开鼠标，通常松开时触发事件比按下时更好 Configure 22 控件的大小发生改变 Deactivate 37 控件的状态由激活变为不可用（灰色），这个事件是由控件的 state 属性变化引起的 Destroy 17 控件被毁灭 Enter 7 鼠标移动到了控件上 Expose 12 控件从被其他窗口遮挡的状态变为可见时 FocusIn 9 控件获得输入焦点时，这个事件可以由程序内部产生，比如调用 .focus_set() 时 FocusOut 10 输入焦点从控件上移开时，这个事件可以由程序内部产生 KeyPress 2 按下键盘按键，具体哪个键被按下由 detail 决定，按了几次由 modifier 决定 KeyRelease 3 松开键盘按键， Leave 8 鼠标从控件上移开 Map 19 控件变为可见时，比如调用 .grid() 方法 Motion 6 在控件内移动鼠标 MouseWheel 38 上下移动鼠标滚轮，只在 Windows 和 macOS 下有效， Linux 不支持 Unmap 18 控件变为不可见状态，比如调用 .grid_remove() 方法 Visibility 15 应用程序窗口的一部分在屏幕上变为可见 9.2. modifier #所有可选的 modifier 名称：\nmodifier 描述 Alt 按住 Alt 键 Any 表示任意的，用于概况一类事件，比如 \u0026lsquo;\u0026rsquo; 表示按下任意按键 Control 按住 control 键 Double 双击，即很短的时间内连续发生两次，例如 \u0026lsquo;\u0026rsquo; 表示双击鼠标左键 Lock 按下 shift lock 键 Shift 按住 shift 键 Triple 三击，即很短的时间内连续发生三次 9.3. detail #对于鼠标事件，1 表示鼠标左键，3 表示鼠标右键。对于键盘事件，Tkinter 提供了多种方式识别按键，这几种方式都是 Event 类支持的属性 ：\n.keysym 表示按键的符号，有的按键有两个符号 .keycode 表示按键的编码，但是这种编码没有区分同一按键上的不同符号，比如小键盘的数字 2 (KP_2) 和向下箭头 (KP_Down) 是同一个按键，编码都是 88 ，也无法区分大小写，所以 a 和 A 的编码是一样的 .keysym_num 表示与按键符号相对应的编码 下表是美式 101-key 键盘通用字符集的部分符号：\n.keysym .keycode .keysym_num Key Alt_L 64 65513 The left-hand alt key Alt_R 113 65514 The right-hand alt key BackSpace 22 65288 backspace Cancel 110 65387 break Caps_Lock 66 65549 CapsLock Control_L 37 65507 The left-hand control key Control_R 109 65508 The right-hand control key Delete 107 65535 Delete Down 104 65364 ↓ End 103 65367 end Escape 9 65307 esc Execute 111 65378 SysReq F1 67 65470 Function key F1 F2 68 65471 Function key F2 Fi 66+i 65469+i Function key Fi F12 96 65481 Function key F12 Home 97 65360 home Insert 106 65379 insert Left 100 65361 ← Linefeed 54 106 Linefeed (control-J) KP_0 90 65438 0 on the keypad KP_1 87 65436 1 on the keypad KP_2 88 65433 2 on the keypad KP_3 89 65435 3 on the keypad KP_4 83 65430 4 on the keypad KP_5 84 65437 5 on the keypad KP_6 85 65432 6 on the keypad KP_7 79 65429 7 on the keypad KP_8 80 65431 8 on the keypad KP_9 81 65434 9 on the keypad KP_Add 86 65451 + on the keypad KP_Begin 84 65437 The center key (same key as 5) on the keypad KP_Decimal 91 65439 Decimal (.) on the keypad KP_Delete 91 65439 delete on the keypad KP_Divide 112 65455 / on the keypad KP_Down 88 65433 ↓ on the keypad KP_End 87 65436 end on the keypad KP_Enter 108 65421 enter on the keypad KP_Home 79 65429 home on the keypad KP_Insert 90 65438 insert on the keypad KP_Left 83 65430 ← on the keypad KP_Multiply 63 65450 × on the keypad KP_Next 89 65435 PageDown on the keypad KP_Prior 81 65434 PageUp on the keypad KP_Right 85 65432 → on the keypad KP_Subtract 82 65453 - on the keypad KP_Up 80 65431 ↑ on the keypad Next 105 65366 PageDown Num_Lock 77 65407 NumLock Pause 110 65299 pause Print 111 65377 PrintScrn Prior 99 65365 PageUp Return 36 65293 The enter key (control-M). The name Enter refers to a mouse-related event, not a keypress; see Section 54, “Events” Right 102 65363 → Scroll_Lock 78 65300 ScrollLock Shift_L 50 65505 The left-hand shift key Shift_R 62 65506 The right-hand shift key Tab 23 65289 The tab key Up 98 65362 ↑ 10. ttk : 主题控件 #从 Tk 8.5 开始，正式加入了 ttk 模块，这个模块可以替代大部分 Tkinter 原有的机制，而且带来了很多优势：\n在 Tk 8.5 以前，开发者经常抱怨的就是 Tkinter 的 UI 风格无法适应操作系统，显得很难看。ttk 可以在自适应不同的操作系统 UI 风格，无需修改程序代码。 原有的控件都有一个 ttk 的版本，还增加了一些新的控件 带来了更加简化和易于操作的控件属性。 推荐使用如下方式导入 ttk 模块：\nfrom tkinter import ttk 这样的话，ttk.Label 就表示 Label 控件。\n10.1. ttk.Button #按钮控件，原型：\nw = ttk.Button(parent, option=value, ...) 常用属性：\ncommand ，按下按钮是调用的函数 image ，设置按钮上显示的图片 text ，设置按钮上显示的文字 compound ，如果同时设置了 image 和 text ，该属性设置了 image 相对于 text 的位置，有四个可选值：tk.TOP (image 在 text 上面) ，tk.BOTTOM (image 在 text 下面) ，tk.LEFT (image 在 text 左边) ，tk.RIGHT (image 在 text 右边) textvariable ，控制变量 StringVal width ，按钮的宽度，单位是字符个数，如果按钮显示的是图片，则单位是像素 underline ，设置一个数字 n ，按钮上的第 n 个字符会显示一条下划线 style ，原 Tkinter 的样式属性都被这个属性代替了 出来通用方法，它还有一个自己的方法：\n.invoke() ，调用 command 指定的函数。 10.2. ttk.Entry #输入框，函数原型：\nw = ttk.Entry(parent, option=value, ...) 常用属性：\nwidth ，输入框能够容纳的字符数，默认是 20 show，默认情况下，输入的字符会直接显示，如果是密码，需要隐藏，可以要求输入的字符都显示为星号： show='*' justify ，输入框内文本的对齐方式，默认是左对齐 justify=tk.LEFT ，还可选 tk.CENTER 和 tk.RIGHT validate ，设置检查输入框内容的时机 validatecommand ，设置一个回调函数，负责检查输入框的内容 textvariable ，为该属性设置一个控制变量 StringVar 类的实例，就可以用 v.get() 方法取回输入框中内容，或者用 v.set(value) 设置，v 就是这个实例 style ，原 Tkinter 的样式属性都被这个属性代替了 ttk.Entry 支持所有 ttk 的通用方法和 tk.Entry 的方法。\n10.3. ttk.Combobox #带下拉菜单的输入框，函数原型：\nw = ttk.Combobox(parent, option=value, ...) 常用属性：\nexportselection ，默认情况下，选中的内容会自动复制到剪贴板，设置 exportselection=0 可以关闭这个特性 height ，设置下拉菜单中选项的最大行数，默认是 20 ，如果超过这个值，会自动出现滚动条 justify ，输入框内文本的对齐方式，默认是左对齐 justify=tk.LEFT ，还可选 tk.CENTER 和 tk.RIGHT postcommand ，设置一个回调函数，当用户点击下拉菜单是会调用，可用于修改 values 属性 textvariable ，为该属性设置一个控制变量 StringVar 类的实例，就可以用 v.get() 方法取回输入框中内容，或者用 v.set(value) 设置，v 就是这个实例 validate ，设置检查输入框内容的时机 validatecommand ，设置一个回调函数，负责检查输入框的内容 values，设置一个字符串序列，作为下拉菜单中的选项 width ，输入框能够容纳的字符数，默认是 20 style ，原 Tkinter 的样式属性都被这个属性代替了 ttk.Combobox 支持所有 ttk 的通用方法和 tk.Entry 的方法，此外还支持：\n.current([index]) , .set(value) ，设置空间输入框中的值为 value ttk.Combobox 的状态会显示不同的行为特性。控件状态由通用方法 .instate() 和 .state() 设置。如果控件处于 disabled 状态，用户无法改变控件的内容；如果空间处于 !disabled \u0026amp; readonly 状态，用户可以通过下拉菜单改变空间内容，但不能直接输入。\n10.4. ttk.Frame #框架控件，函数原型：\nw = ttk.Frame(parent, option=value, ...) 10.5. ttk.Label #标签控件，函数原型：\nw = ttk.Label(parent, option=value, ...) 10.6. ttk.LabelFrame #带标签的框架，函数原型：\nw = ttk.LabelFrame(parent, option=value, ...) 10.7. ttk.Notebook #标签页控件，函数原型：\nw = ttk.Notebook(parent, option=value, ...) 10.8. ttk.Menubutton #下拉菜单，函数原型：\nw = ttk.Menubutton(parent, option=value, ...) 11. ttk 的样式和主题 #绘制 ttk 控件包含三个层面的抽象概念：\ntheme 表示一个应用中所有控件的设计主题\nstyle 描述了一种控件本身的显示方式，一个 theme 是由多种 style 组成的，你可以使用内置的 style ，也可以新建自己的 style 。\n每个 style 都是有一个或者多个 element 组成的，一个按钮的 style 通常有四个 element ：外边框，聚焦时的颜色变化，内边距，按钮标签（文本或者图片）：\n下面依次讨论如何寻找、使用和定制这几层样式。\n11.1. 寻找并使用 theme #与样式相关的操作都需要新建一个 ttk.Style() 类的实例，例如获取所有可用的 theme 列表：\n\u0026gt;\u0026gt;\u0026gt; from tkinter import ttk \u0026gt;\u0026gt;\u0026gt; s=ttk.Style() \u0026gt;\u0026gt;\u0026gt; s.theme_names() ('aqua', 'clam', 'alt', 'default', 'classic') .theme_names() 会返回一个元组，包含了所有可用的 theme 。如果要查看当前默认的 theme ，直接调用 .theme_use() ，在参数里加上 theme 名就可以改变当前的 theme ：\n\u0026gt;\u0026gt;\u0026gt; s.theme_use() 'aqua' \u0026gt;\u0026gt;\u0026gt; s.theme_use('default') \u0026gt;\u0026gt;\u0026gt; s.theme_use() 'default' 11.2. 使用和定制 style #对于一个给定的 theme ，为每一种控件都定义了默认的 style ，本质上是一个类，每个 style 类名就是控件名加上前缀 \u0026ldquo;T\u0026rdquo; ，下表是 ttk 控件对应的 style 名称：\nWidget class Style name Button TButton Checkbutton TCheckbutton Combobox TCombobox Entry TEntry Frame TFrame Label TLabel LabelFrame TLabelFrame Menubutton TMenubutton Notebook TNotebook PanedWindow TPanedwindow (not TPanedWindow!) Progressbar Horizontal.TProgressbar or Vertical.TProgressbar, depending on the orient option. Radiobutton TRadiobutton Scale Horizontal.TScale or Vertical.TScale, depending on the orient option. Scrollbar Horizontal.TScrollbar or Vertical.TScrollbar, depending on the orient option. Separator TSeparator Sizegrip TSizegrip Treeview Treeview (not TTreview!) 运行时可以调用控件的 .winfo_class() 方法获得当前使用的 style 类名：\n\u0026gt;\u0026gt;\u0026gt; b=ttk.Button(None) \u0026gt;\u0026gt;\u0026gt; b.winfo_class() 'TButton' style 类名有两种格式：\n对应内置的 sytle 都是一个单词，例如 \u0026lsquo;TButton\u0026rsquo; 或者 \u0026lsquo;TFrame\u0026rsquo; 在内置 style 之上新建的 style 采用这样的格式： \u0026rsquo;newName.oldName\u0026rsquo; ，例如为输入日期的 Entry 控件新建一个 style 可以命名为 \u0026lsquo;Date.TEntry\u0026rsquo; 每个 style 都定义了一套相应的属性，例如按钮有一个 foreground 属性用于设置按钮上文字的颜色。可以调用 ttk.Style() 类的 .configure() 方法调节这些属性，第一个参数是 style 类名，之后是要修改的属性和相应的值，例如把按钮上的文字改成绿色：\ns.configure('TButton', foreground='green') 这个方法还可以用来新建 style ，第一个参数定义新 style 类的名称 \u0026rsquo;newName.oldName\u0026rsquo; ，例如新建一个 Style ，按钮上的文字是红褐色：\ns = ttk.Style() s.configure('Kim.TButton', foreground='maroon') 然后就可以用这个新的 style 新建一个按钮：\nself.b = ttk.Button(self, text='Friday', style='Kim.TButton',command=self._fridayHandler) 你甚至可以构建一套多级 style 。例如新建一个名叫 \u0026lsquo;Panic.Kim.TButton\u0026rsquo; 的 style ，它会继承 \u0026lsquo;Kim.TButton\u0026rsquo; 的所有属性，ttk 要使用某个属性时，首先在 \u0026lsquo;Panic.Kim.TButton\u0026rsquo; 寻找，如果没找到，会上溯到 \u0026lsquo;Kim.TButton\u0026rsquo; ，如果还找不到，再上溯到 \u0026lsquo;TButton\u0026rsquo; 中寻找。\n还存在一个 root style 叫做 \u0026lsquo;.\u0026rsquo; ，配置这个 style 的某个属性会对所有控件生效。假设我们想要所有的文本都使用 12-point Helvetica 字体，可以这样配置：\ns = ttk.Style() s.configure('.', font=('Helvetica', 12)) 11.3. element #一个控件是由多种 element 组成的，控件就像一个“空腔”，腔体内的空间由 element 填充。以 classic theme 为例，一个按钮拥有四个同心 element ，从外都内分别是 focus highlight ， border ， padding 和 label 。每个 element 都有一个 \u0026lsquo;sticky\u0026rsquo; 属性，它的作用是告诉这个 element 如何填充当前的腔体，如果一个 element 的 sticky=\u0026lsquo;ew\u0026rsquo; ，意味着这个 element 应该左右方向撑开，紧贴腔体左右边。\n大部分内置的 style 使用 layout 概念来组织腔体内的 element ，要获取某个 style 内的 element 显示方式，可以调用 .layout() 方法：\nS.layout(styleName) 该函数返回一个列表，列表内的元素都是描述 element 显示方式的元组，元组的格式是 (eltName, d) ，eltName 是一个字符串， element 的名称，d 是一个字典，描述 element 显示方式的一些属性，比如：\n\u0026lsquo;sticky\u0026rsquo; ，属性取值是一个字符串，描述当前 element 在相对父 element 的位置，可以为空，或者有 \u0026rsquo;n\u0026rsquo; ， \u0026rsquo;s\u0026rsquo; ， \u0026rsquo;e\u0026rsquo; 和 \u0026lsquo;w\u0026rsquo; 四个字符组成，分别代表四个方式的对齐方式 \u0026lsquo;side\u0026rsquo; ，如果当前 element 拥有多个子 element ，该属性的取值定义了这些子 element 的对齐方式，可选 \u0026rsquo;left\u0026rsquo; ， \u0026lsquo;right\u0026rsquo; ， \u0026rsquo;top\u0026rsquo; 或者 \u0026lsquo;bottom\u0026rsquo; \u0026lsquo;children\u0026rsquo; ，如果当前 element 下还有子 element ，可以使用相同格式的列表描述 下面以 classic theme 的按钮控件为例分析它的 Layout：\n\u0026gt;\u0026gt;\u0026gt; from tkinter import ttk \u0026gt;\u0026gt;\u0026gt; s = ttk.Style() \u0026gt;\u0026gt;\u0026gt; s.theme_use('classic') \u0026gt;\u0026gt;\u0026gt; b = ttk.Button(None,text=\u0026quot;Yo\u0026quot;) \u0026gt;\u0026gt;\u0026gt; bClass = b.winfo_class() \u0026gt;\u0026gt;\u0026gt; bClass 'TButton' \u0026gt;\u0026gt;\u0026gt; layout = s.layout('TButton') \u0026gt;\u0026gt;\u0026gt; layout [('Button.highlight', {'sticky': 'nswe', 'children': [('Button.border', {'sticky': 'nswe', 'border': '1', 'children': [('Button.padding', {'sticky': 'nswe', 'children': [('Button.label', {'sticky': 'nswe'})]})]})]})] 这里我们新建了一个按钮，但是没有显示出来，要让它在窗口显示需要调用 .grid() 方法。Button 控件的 style 是 TButton ，它的 element 分为四层：\n[('Button.highlight', {'sticky': 'nswe', 'children': [('Button.border', {'sticky': 'nswe', 'border': '1', 'children': [('Button.padding', {'sticky': 'nswe', 'children': [('Button.label', {'sticky': 'nswe'})]} )]} )]} )] 有外到内：\n最外层是 highlight ，sticky=\u0026lsquo;nswe\u0026rsquo; 表示四个方向都撑满 第二层是 border ，它有一个 border=\u0026lsquo;1\u0026rsquo; 的属性，表示边框宽度一个像素 第三层是 padding ，表示内边距，默认是 0 最里面是 label ，显示按钮上的文字或者图片，也是四个方向撑满 每个 element 都由一个字典描述各自的属性，这些属性的名字都是沿用自 Tkinter ，都可以用 s.configure() 方法配置。要获取这些属性的名字可以调用：\nS.element_options(elementName) 函数返回一个列表：\n\u0026gt;\u0026gt;\u0026gt; d = s.element_options('Button.highlight') \u0026gt;\u0026gt;\u0026gt; d ('highlightcolor', 'highlightthickness') 要找出某个属性的值可以调用：\ns.lookup(layoutName, optName) 继续前面的例子：\n\u0026gt;\u0026gt;\u0026gt; s.lookup('Button.highlight', 'highlightthickness') 1 \u0026gt;\u0026gt;\u0026gt; s.lookup('Button.highlight', 'highlightcolor') '#d9d9d9' \u0026gt;\u0026gt;\u0026gt; s.element_options('Button.label') ('compound', 'space', 'text', 'font', 'foreground', 'underline', 'width', 'anchor', 'justify', 'wraplength', 'embossed', 'image', 'stipple', 'background') \u0026gt;\u0026gt;\u0026gt; s.lookup('Button.label', 'foreground') 'black' 12. ttk 的通用方法 # w.cget(option) ，返回某个属性的值\nw.configure(option=value, \u0026hellip;) ，设置某个属性的值，如果没有参数，它会返回一个字典，记录了该控件所有属性，属性的值保持在一个元组，格式 (name, dbName, dbClass, default, current)，例如：\n\u0026gt;\u0026gt;\u0026gt; from tkinter import ttk \u0026gt;\u0026gt;\u0026gt; b=ttk.Button(text=\u0026quot;Yo\u0026quot;) \u0026gt;\u0026gt;\u0026gt; b.configure() {'takefocus': ('takefocus', 'takeFocus', 'TakeFocus', '', 'ttk::takefocus'), 'command': ('command', 'command', 'Command', '', ''), 'default': ('default', 'default', 'Default', \u0026lt;index object: 'normal'\u0026gt;, \u0026lt;index object: 'normal'\u0026gt;), 'text': ('text', 'text', 'Text', '', 'Yo'), 'textvariable': ('textvariable', 'textVariable', 'Variable', '', ''), 'underline': ('underline', 'underline', 'Underline', -1, -1), 'width': ('width', 'width', 'Width', '', ''), 'image': ('image', 'image', 'Image', '', ''), 'compound': ('compound', 'compound', 'Compound', \u0026lt;index object: 'none'\u0026gt;, \u0026lt;index object: 'none'\u0026gt;), 'padding': ('padding', 'padding', 'Pad', '', ''), 'state': ('state', 'state', 'State', \u0026lt;index object: 'normal'\u0026gt;, \u0026lt;index object: 'normal'\u0026gt;), 'cursor': ('cursor', 'cursor', 'Cursor', '', ''), 'style': ('style', 'style', 'Style', '', ''), 'class': ('class', '', '', '', '')} .state(stateSpec=None) ，获取、设置或者清空当前的状态\n13. ttk 的控件状态 #ttk 的控件有一套 state flags，用于指示控件的状态，这些状态都可以编程打开或者关闭，下表是各种状态的含义：\nstate 描述 active 鼠标指针正处于控件内 alternate 该状态为应用程序保留 background Under Windows or MacOS, the widget is located in a window that is not the foreground window. disabled 禁用控件 focus 控件处于聚焦状态 invalid 控件的内容无效 pressed 控件被按下 readonly 只读 selected 控件被选中 很多方法都通过一个 stateSpec 参数来访问 state 。这个参数可以是以下的值：\nA single state name such as \u0026lsquo;pressed\u0026rsquo;. A ttk.Button widget is in this state, for example, when the mouse cursor is over the button and mouse button 1 is down. A single state name preceded with an exclamation point (!); this matches the widget state only when that state is off. For example, a stateSpec argument \u0026lsquo;!pressed\u0026rsquo; specifies a widget that is not currently being pressed. A sequence of state names, or state names preceded by an \u0026lsquo;!\u0026rsquo;. Such a stateSpec matches only when all of its components match. For example, a stateSpec value of (\u0026rsquo;!disabled\u0026rsquo;, \u0026lsquo;focus\u0026rsquo;) matches a widget only when that widget is not disabled and it has focus. 14. 模块化编程 #前面我们都是在主程序里，用函数一步步新建控件，绘制界面，如果界面很复杂，这种方式就变的非常麻烦，结构也不清晰，难以维护。一个好的编程方法应该模块化的，按界面的布局划分不同的模块，实现不同的类，每个类里集成了模块上的所有控件，实现对控件的操作方法，然后这个模块就可以新建不同的实例，放在不同的位置。通常用户新建的类可以从 tk.Frame 继承，下面是简单的例子：\nimport tkinter as tk from tkinter import ttk class application(ttk.Frame): #新建 application 类，继承了 ttk.Frame def __init__(self, parent=None): #初始化函数，根据模块所处的位置设置父类，默认为空 ttk.Frame.__init__(self, parent) self.grid() #显示这个模块 self._createWidgets() #新建模块上的控件 def _createWidgets(self): self.button = ttk.Button(self, text='Quit', command=self.quit) self.button.grid() window = tk.Tk() #新建一个窗口 window.title('Sample application') app = application(window) #在窗口上放一个 application 模块 window.mainloop() 参考 # Tkinter 8.5 reference: a GUI for Python TkDocs pyinstaller Docs ","date":"2017 December 18","permalink":"/posts/2017/12/18/","section":"Posts","summary":"0. 开始 #Tkinter 是 Python 内置的 GUI 框架，安装后 Python 后即可使用：","title":"Tkinter 学习笔记"},{"content":"1. sysconfig() #sysconfig() 是获取系统运行时配置信息的函数，包括内存、CPU 等。函数声明：\n#include \u0026lt;unistd.h\u0026gt; long sysconf(int name); 参数 name 用于指示要获取的信息，通过返回值将结果返回。新建一个 test.c ，获取当前系统的信息：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define ONE_MB (1024 * 1024) int main() { printf(\u0026#34;The number of processors configured is :%ld\\n\u0026#34;, sysconf(_SC_NPROCESSORS_CONF)); printf(\u0026#34;The number of processors currently online (available) is :%ld\\n\u0026#34;, sysconf(_SC_NPROCESSORS_ONLN)); printf(\u0026#34;The pagesize: %ld\\n\u0026#34;, sysconf(_SC_PAGESIZE)); printf(\u0026#34;The number of pages: %ld\\n\u0026#34;, sysconf(_SC_PHYS_PAGES)); printf(\u0026#34;The number of available pages: %ld\\n\u0026#34;, sysconf(_SC_AVPHYS_PAGES)); printf(\u0026#34;The memory size: %lld MB\\n\u0026#34;, (long long)sysconf(_SC_PAGESIZE) * (long long)sysconf(_SC_PHYS_PAGES) / ONE_MB ); printf(\u0026#34;The number of files max opened:: %ld\\n\u0026#34;, sysconf(_SC_OPEN_MAX)); printf(\u0026#34;The number of ticks per second: %ld\\n\u0026#34;, sysconf(_SC_CLK_TCK)); printf(\u0026#34;The max length of host name: %ld\\n\u0026#34;, sysconf(_SC_HOST_NAME_MAX)); printf(\u0026#34;The max length of login name: %ld\\n\u0026#34;, sysconf(_SC_LOGIN_NAME_MAX)); return 0; } 编译后执行：\n$ gcc test.c $ ./a.out The number of processors configured is :1 The number of processors currently online (available) is :1 The pagesize: 4096 The number of pages: 221303 The number of available pages: 19370 The memory size: 864 MB The number of files max opened:: 1024 The number of ticks per second: 100 The max length of host name: 64 The max length of login name: 256 2. attribute #__attribute__ 是 GCC 提供的一种语法，可以帮助我们在编译时对声明的函数、变量和类型做一些特殊处理或者是检查操作，提升城程序的性能。语法格式为: __attribute__ ((attribute-list)) ，attribute-list 是指令集 , 分为三种类型：函数属性，变量属性，类型属性。__attribute__ 应该出现在函数、变量和类型声明的 “;” 前。\n2.1. packed #packed 用于设置变量或者结构体成员以最小的对齐方式对齐，减少空间浪费，例如：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; struct foo1 { char a; int b[2]; }; struct foo2 { char a; int b[2]; } __attribute__((packed)); int main() { int s1 = sizeof(struct foo1); int s2 = sizeof(struct foo2); printf(\u0026#34;s1 = %d\\ns2 = %d\\n\u0026#34;,s1,s2); return 0; } 运行结果：\ns1 = 12 s2 = 9 2.2. aligned(alignment) #aligned 用于指定变量或者结构体成语按照 alignment 字节大小对齐。如果对齐长度有大于 alignment 的，就按照最大对齐长度对齐。例如：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; struct foo1 { char a; int b[2]; }; struct foo2 { char a; int b[2] __attribute__((aligned(8))); }; int main() { int s1 = sizeof(struct foo1); int s2 = sizeof(struct foo2); printf(\u0026#34;s1 = %d\\ns2 = %d\\n\u0026#34;,s1,s2); return 0; } 运行结果：\ns1 = 12 s2 = 16 2.3. constructor \u0026amp; destructor #函数属性，设置 constructor 可以使函数在 main 方法之前执行，而设置 destructor 可以使函数在 main 方法之后执行。例如：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void __attribute__((constructor)) fun1() { printf(\u0026#34;function 1\\n\u0026#34;); } void __attribute__((destructor)) fun2() { printf(\u0026#34;function 2\\n\u0026#34;); } int main() { printf(\u0026#34;Main\\n\u0026#34;); return 0; } 运行结果：\nfunction 1 Main function 2 2.4. visibility #控制符号可见性，用与设置函数是否被导出，常用的有两个选项：\n__attribute__((visibility(\u0026quot;default\u0026quot;))) ，用它定义的符号将被导出。 __attribute__((visibility(\u0026quot;hidden\u0026quot;))) ，用它定义的符号将不被导出，其他对象无法调用。 2.5 format #format 用于检查格式化字符串与可变参数 ... 的匹配情况，防止出错。标准语法是：\nformat(archetype, string-index, first-to-check) archetype 用于检查格式化字符串的类型，例如 printf 和 scanf 。 string-index 表示传入函数的第几个参数是格式化字符串，从 1 开始数。 first-to-check 表示从传入函数的第几个参数开始检查，从 1 开始数。 例如：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; __attribute__((format(printf, 1, 2))) void mylog(const char *fmt, ...) { va_list ap; va_start(ap, fmt); (void)printf(fmt, ap); va_end(ap); } int main(void) { mylog(\u0026#34;value = %d\\n\u0026#34;, 8); mylog(\u0026#34;value = %d\\n\u0026#34;, \u0026#34;hello\u0026#34;); return 0; } 第二次调用 mylog() 时，因为传给格式化字符串的参数 \u0026quot;hello\u0026quot; 的类型不符，在编译会报错：\n~$ gcc -Wall main.c -o main main.c: In function \u0026#39;main\u0026#39;: main.c:17:11: warning: format \u0026#39;%d\u0026#39; expects argument of type \u0026#39;int\u0026#39;, but argument 2 has type \u0026#39;char *\u0026#39; [-Wformat=] mylog(\u0026#34;value = %d\\n\u0026#34;, \u0026#34;hello\u0026#34;); 3. size_t #size_t 是 C/C++ 标准定义的数据类型，无符号，它在不同的系统中大小是不一样的，32 位系统中通常定义为 unsigned int ，4 Byte ，64 位系统中通常定义为 unsigned long ，8 Byte 。它的含义是当前系统可操作的内存最大值，通常用于内存相关的变量，可以确保不会因为类型太小导致变量溢出，提高程序的有效性和可移植性。例如：\nvoid *malloc(size_t n) 如果把 n 定义为 unsigned int ，那么在 64 位系统中就有溢出的可能性。参考为什么 size_t 很重要 。\n4. container_of #container_of 是 Linux 内核定义的一个宏，在 linux/kernel.h 中声明，它的作用是通过结构体变量中某个成员的地址获得这个结构体变量的地址。定义：\n#define container_of(ptr, type, member) ({ \\ const typeof( ((type *)0)-\u0026gt;member ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type,member) );}) 三个参数分别表示：\nptr ：结构体成员变量 member 的地址 type ：结构体类型的名称 member ：结构体中的成员变量的名称 宏定义包含两条语句：\nconst typeof( ((type *)0)-\u0026gt;member ) *__mptr = (ptr); 首先将 0 转化成 type 类型的指针变量（指向的地址为 0x0 ），然后再引用 member 成员 ((type *)0)-\u0026gt;member ) )。注意这里的 typeof(x)，是返回 x 的数据类型，那么 typeof( ((type *)0)-\u0026gt;member ) 就是返回 member 成员的数据类型。那么这条语句整体就是定义了一个 member 成员的数据类型的指针 __mptr，指向 ptr ，而 ptr 就是 member 的地址。\n(type *)( (char *)__mptr - offsetof(type,member) ); 这条语句中的 offsetof 的作用是获取结构体中某个成员的偏移量，那么从 __mptr 指向的地址向前 offsetof 个字节就是 member 所属结构体变量的首地址。offsetof 的原型：\n#define offsetof(type, member) (size_t)\u0026amp;( ((type *)0)-\u0026gt;member ) type 表示结构体的名称，member 表示成员变量的名称。(type *)0 定义了一个 type 类型的指针，指向的地址是 0 ，那么成员 member 的地址就是它在结构体内的偏移量。\n下面这个历程展示 container_of 和 offsetof 的用法：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define offsetof(type, member) (size_t)\u0026amp;( ((type *)0)-\u0026gt;member ) #define container_of(ptr, type, member) ({ \\ const typeof( ((type *)0)-\u0026gt;member ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type,member) );}) typedef struct foo { char a; int b; }foo; int main() { size_t off_set = 0; off_set = offsetof(foo, b); printf(\u0026#34;foo-\u0026gt;b offset: %lu\\n\u0026#34;,off_set); foo s ; printf(\u0026#34;s address : %lu\\n\u0026#34;,(size_t)\u0026amp;s); s.b = 10; foo *p = container_of(\u0026amp;(s.b), foo, b); printf(\u0026#34;p-\u0026gt;b value : %d\\n\u0026#34;, p-\u0026gt;b); printf(\u0026#34;p address : %lu\\n\u0026#34;, (size_t)p); return 0; } 运行结果：\nfoo-\u0026gt;b offset: 4 s address : 140723509298320 p-\u0026gt;b value : 10 p address : 140723509298320 5. PID 文件 #在 Linux 系统的 /var/run/ 目录下可以看到很多 *.pid 文件，很多程序启动后都会在该目录下新建一个自己的 PID 文件，记录该进程的 PID ，方便管理进程。PID 文件的另一个作用是防止进程启动多个副本，进程启动后新建 PID 文件，然后为文件加独占的记录锁，只有获得 PID 文件写入权限（F_WRLCK）的进程才可以启动，并将自身的 PID 写入文件，锁定失败的进程启动退出。下面是一个例程：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;string.h\u0026gt; int run = 1; //锁定一个文件，参数是文件描述符，出错返回 -1 int lockfile(int fd) { struct flock lock; lock.l_type = F_WRLCK; //独占性写锁 lock.l_whence = SEEK_SET; //为整个文件加锁 lock.l_start = 0; lock.l_len = 0; return fcntl(fd, F_SETLK, \u0026amp;lock); } //新建 PID 文件并加锁，参数是 PID 文件的路径和当前进程的 PID ，失败返回负数 int creat_pidfile(const char *pid_file, pid_t pid) { int fd = 0; fd = open(pid_file, O_RDWR|O_CREAT, (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)); if(fd \u0026lt; 0) { printf(\u0026#34;ERROR: can not open pid file %s\\n\u0026#34;,pid_file); return -1; } if(lockfile(fd)\u0026lt;0) { if(errno==EACCES || errno==EAGAIN) { close(fd); printf(\u0026#34;WARNING: process already run\\n\u0026#34;); return 0; } printf(\u0026#34;ERROR: can not lock pid file: %s error: %s\\n\u0026#34;, pid_file, strerror(errno)); return -2; } if(dprintf(fd, \u0026#34;%d\u0026#34;, pid)\u0026lt;0) { close(fd); printf(\u0026#34;ERROR: write pid failed\\n\u0026#34;); return 0; } return fd; } int remove_pidfile(const char *pid_file, int fd) { close(fd); remove(pid_file); return 0; } void handle_sig(int signo) { if( (signo==SIGINT)|(signo==SIGTERM) ) run=0; } int main() { int fd = 0; const char *pid_file = \u0026#34;/var/run/test.pid\u0026#34;; fd = creat_pidfile(pid_file,getpid()); if(fd\u0026gt;0) close(fd); else { printf(\u0026#34;create pid file error\\n\u0026#34;); return -1; } signal(SIGINT,handle_sig); signal(SIGTERM,handle_sig); while(run) { sleep(5); } remove_pidfile(pid_file,fd); return 0; } 6. Debug #在源文件里声明：\n#ifdef __DEBUG__ #define DEBUG(format, ...) printr(\u0026#34;%03d: \u0026#34;format\u0026#34;\u0026#34;, __LINE__, ##__VA_ARGS__) #else #define DEBUG(format, ...) #endif 调用 DEBUG() 的语法与 printf() 一样，编译时在 gcc 中声明 -D __DEBUG__ 即可打开调试信息。\n","date":"2017 December 14","permalink":"/posts/2017/12/14/","section":"Posts","summary":"1. sysconfig() #sysconfig() 是获取系统运行时配置信息的函数，包括内存、CPU 等。函数声明：","title":"Linux Program Tips"},{"content":"1. Soft Power #早期的计算机主板都是使用 AT 电源管理技术，AT 电源系统非常简单，电源键是机械式开关，只有开闭两种状态，闭合后电流从开关上流过为主板供电，断开后主板上的所有器件同时断电，无法实现待机、软关机等功能，这个时期的 Windows 系统关机后会一直显示一条 \u0026ldquo;It is now safe to turn off your computer\u0026rdquo; 的信息，因为操作系统无法切断电源。这时期的电源可以叫做 Hard Power ，因为全部都是硬件控制的。\n后来英特尔提出了 ATX 主板标准，它带来了 Soft Power ，它使用的 ATX 电源没有直接连到电脑的开关，而是插在主板上，可以通过软件控制，下面是 ATX 主板电源接口的信号定义：\n它还带来了两个重要的变化：\n备份电源：主板电源接口上有一个 \u0026ldquo;+5VSB\u0026rdquo; 或者 \u0026ldquo;+5V Standby\u0026rdquo; 的信号，即使计算机已经关机，这个 5V 信号也会一直供给主板，主板可以持续运行一些最简单的功能，也就是待机状态，我们可以随时唤醒计算机。该信号还有一个作用就是替代 CMOS 电池。 智能电源控制：电源接口还有 PS-ON 和 PW-OK/PS-RDY 信号，代表“电源接通”和“电源就绪”。你可以试试将 PS-ON 信号与地线短接，ATX 电源会立即启动，风扇开始旋转。主板上某个由 +5VSB 供电的组件就是通过短接 PS-ON 和地来启动计算机的。由于电源中有些部分启动一段时间后才能稳定，电源完全稳定后才会打开 PW-OK/PS-RDY 信号，主板会等待该信号打开后才开始引到启动。 所以，计算机的电源键不再是“打开”计算机，它连接在主板的基本控制器上，控制器检测到电源键按下，再启动电源，引导系统。电源键不再是启动系统的唯一方式，扩展总线上的其他设备也可以。这很重要，计算机关机时，以太网适配器还是保持打开的，这样就可以通过以太网远程启动计算机。\n2. 电源管理 #现在的计算机都采用了 ACPI(Advanced Configuration and Power Interface) 技术，它是英特尔等公司提出的操作系统应用程序管理所有电源管理接口的规范，包括了软件和硬件方面的规范，操作系统的电源管理功能通过调用 ACPI 接口，实现对符合 ACPI 规范的硬件设备的电源管理，下面是电源管理与 ACPI 的全局结构图：\nACPI 有个概念叫做 power states ，可以理解为电源状态，操作系统可以通过切换设备的电源状态来控制功耗，主板的电源状态有：\nG0：工作（计算机处于开机工作状态） G1：睡眠（您的计算机的待机状态，分为几个子状态） S1：CPU 和 RAM 的电源保持打开，但 CPU 未执行指令， 外围设备关闭 S2：CPU 关闭，RAM 保持打开 S3：所有组件关闭，除了 RAM 和触发恢复的设备（键盘）， 当你告诉操作系统“Sleep”时，它会关闭所有进程，然后进入这个模式。 S4：休眠，关闭所有组件。 当您将操作系统告知休眠时，它会停止进程，将 RAM 的内容保存到磁盘，然后进入此模式。 G2：软关，这就是计算机的“关机”状态， 除了可以触发引导的设备之外，其他电源均已关闭。 G3：机械关闭，ATX 电源本身都已经断电。 ACPI 为 CPU 和计算机上的其他设备都定义了不同的电源状态。\n3. 重启 #当我们在 Linux 系统中执行 reboot 命令时，它会执行系统调用 reboot() 函数：\nint reboot(int magic, int magic2, int cmd, void *arg); 函数定义在内核的 kernel/reboot.c 文件中：\n/* * Reboot system call: for obvious reasons only root may call it, * and even root needs to set up some magic numbers in the registers * so that some mistake won't make this reboot the whole machine. * You can also set the meaning of the ctrl-alt-del-key here. * reboot doesn't sync: do that yourself before calling this. */ SYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd, void __user *, arg) 该函数有个 cmd 参数，通过不同的选项调用相应的内核函数实现不同的功能：\nLINUX_REBOOT_CMD_CAD_OFF：禁止 CAD ， 这意味着无法通过 ctrl-alt-del 组合键产生 SIGINT 信号触发重启。 LINUX_REBOOT_CMD_CAD_ON：使能 CAD ，可以通过 ctrl-alt-del 组合键触发重启 LINUX_REBOOT_CMD_HALT：关闭操作系统 LINUX_REBOOT_CMD_KEXEC：重新加载内核，当内核配置了 CONFIG_KEXEC 时才有效 LINUX_REBOOT_CMD_POWER_OFF：关机，关闭操作系统，然后让计算机的电源进入 G2 状态 LINUX_REBOOT_CMD_RESTART：立即重启计算机，打印信息 \u0026ldquo;Restarting system.\u0026rdquo; LINUX_REBOOT_CMD_RESTART2：立即重启计算机， 打印信息 \u0026ldquo;Restarting system with command \u0026lsquo;%s\u0026rsquo;\u0026rdquo; LINUX_REBOOT_CMD_SW_SUSPEND：休眠，将运行状态保存到硬盘，系统挂起，当内核配置了 CONFIG_HIBERNATION 时有效 可以看到，除了重启 ，reboot() 函数还可以实现停机和关机的功能，所有 halt 和 poweroff 命令也会调用该函数。以 Linux kernel 4.1 为例，系统重启的流程如下图：\n重启会调用内核函数 kernel_restart() ，定义在 kernel/reboot.c 文件中：\nvoid kernel_restart(char *cmd) { kernel_restart_prepare(cmd); migrate_to_reboot_cpu(); syscore_shutdown(); if (!cmd) pr_emerg(\u0026quot;Restarting system\\n\u0026quot;); else pr_emerg(\u0026quot;Restarting system with command '%s'\\n\u0026quot;, cmd); kmsg_dump(KMSG_DUMP_RESTART); machine_restart(cmd); } EXPORT_SYMBOL_GPL(kernel_restart); 依次完成如下工作:\nkernel_restart_prepare(cmd)：向关心系统重启的进程发出通知，各进程会依次关闭，然后设置系统状态为 SYSTEM_RESTART，关闭所有外部设备。 syscore_shutdow()：关闭操作系统核心，比如中断 machine_restart(cmd)：硬件重置 在 x86 系统中，machine_restart() 函数最终会调用 arch/x86/kernel/reboot.c 文件中的 native_machine_emergency_restart() 函数，根据不同的重置方式，执行相应的 reboot 代码：\nstatic void native_machine_emergency_restart(void) { ...... for (;;) { /* Could also try the reset bit in the Hammer NB */ switch (reboot_type) { case BOOT_ACPI: acpi_reboot(); reboot_type = BOOT_KBD; break; case BOOT_KBD: mach_reboot_fixups(); /* For board specific fixups */ for (i = 0; i \u0026lt; 10; i++) { kb_wait(); udelay(50); outb(0xfe, 0x64); /* Pulse reset low */ udelay(50); } if (attempt == 0 \u0026amp;\u0026amp; orig_reboot_type == BOOT_ACPI) { attempt = 1; reboot_type = BOOT_ACPI; } else { reboot_type = BOOT_EFI; } break; case BOOT_EFI: efi_reboot(reboot_mode, NULL); reboot_type = BOOT_BIOS; break; case BOOT_BIOS: machine_real_restart(MRR_BIOS); /* We're probably dead after this, but... */ reboot_type = BOOT_CF9_SAFE; break; case BOOT_CF9_FORCE: port_cf9_safe = true; /* Fall through */ case BOOT_CF9_SAFE: if (port_cf9_safe) { u8 reboot_code = reboot_mode == REBOOT_WARM ? 0x06 : 0x0E; u8 cf9 = inb(0xcf9) \u0026amp; ~reboot_code; outb(cf9|2, 0xcf9); /* Request hard reset */ udelay(50); /* Actually do the reset */ outb(cf9|reboot_code, 0xcf9); udelay(50); } reboot_type = BOOT_TRIPLE; break; case BOOT_TRIPLE: load_idt(\u0026amp;no_idt); __asm__ __volatile__(\u0026quot;int3\u0026quot;); /* We're probably dead after this, but... */ reboot_type = BOOT_KBD; break; } } } 可以看出，计算机有多种方式可以重置硬件，在一个无限循环里逐一执行，如果成功，机器就会重启，否则就切换到下一种方法。默认使用 ACPI 方式，其次还有 KBD 、CF9、BIOS、EFI等，使用哪种方式主要取决于内核引导选项 reboot 的设置：\nreboot=[mode][,type][,force] 含义：\nmode 用于指定重启模式，可以使用如下两种模式之一：warm (热重启，跳过内存检测)，cold (冷重启，检测并重新初始化所有硬件) type 用于指定重启类型，可以使用如下4种类型之一：bios (为热重启使用 CPU reboot vector)，acpi (优先使用 FADT 中的 ACPI reset register ，若失败再转为 kbd ，这是目前内核的默认值，定义在 kernel/reboot.c 文件： enum reboot_type reboot_type = BOOT_ACPI;)，kbd (使用键盘控制器冷重启)， efi (优先使用 EFI 提供的 reset_system 运行时服务,若失败再转 kbd ) 结尾的 \u0026ldquo;force\u0026rdquo; 表示在重启时不停用其它的 CPU，在某些情况下可以让reboot更可靠。 系统启动后，可以在 /proc/cmdline 文件查看启动时使用的引导选项以和值。可以使用 \u0026ldquo;modinfo -p ${modulename}\u0026rdquo; 命令显示可加载模块的所有可用选项。已经加载到内核中的模块会在 /sys/module/${modulename}/parameters/ 中显示出其选项，并且某些选项的值还可以在运行时通过 \u0026ldquo;echo -n ${value} \u0026gt; /sys/module/${modulename}/parameters/${parm}\u0026rdquo; 进行修改。\n3.1. ACPI reset #ACPI 规定了一个特殊的寄存器 reset register，它可以位于 IO/Memory、或者 PCI bus #0 上的一个设备的配置空间，通过向 reset register 写入特定值来重置计算机。根据 ACPI 的规定，所有硬件必须在这个机制之后重置，主板收到请求后要做如下工作：\n所有逻辑复位。 这意味着将相应的复位命令发送到包括 CPU，存储控制器，外围控制器等的各种硬件。在大多数情况下，这意味着向设备的 RST 线发送复位信号。 然后引导计算机。主板执行的步骤与刚刚在按下电源键后开机的步骤相同。 如果内核使能了 ACPI ，就会通过 ACPI 重置硬件，实现的函数是 acpi_reboot() ，定义在 drivers/acpi/reboot.c 文件：\nvoid acpi_reboot(void) { struct acpi_generic_address *rr; struct pci_bus *bus0; u8 reset_value; unsigned int devfn; if (acpi_disabled) return; rr = \u0026amp;acpi_gbl_FADT.reset_register; /* ACPI reset register was only introduced with v2 of the FADT */ if (acpi_gbl_FADT.header.revision \u0026lt; 2) return; /* Is the reset register supported? The spec says we should be checking the bit width and bit offset, but Windows ignores these fields */ if (!(acpi_gbl_FADT.flags \u0026amp; ACPI_FADT_RESET_REGISTER)) return; reset_value = acpi_gbl_FADT.reset_value; /* The reset register can only exist in I/O, Memory or PCI config space on a device on bus 0. */ switch (rr-\u0026gt;space_id) { case ACPI_ADR_SPACE_PCI_CONFIG: /* The reset register can only live on bus 0. */ bus0 = pci_find_bus(0, 0); if (!bus0) return; /* Form PCI device/function pair. */ devfn = PCI_DEVFN((rr-\u0026gt;address \u0026gt;\u0026gt; 32) \u0026amp; 0xffff, (rr-\u0026gt;address \u0026gt;\u0026gt; 16) \u0026amp; 0xffff); printk(KERN_DEBUG \u0026quot;Resetting with ACPI PCI RESET_REG.\u0026quot;); /* Write the value that resets us. */ pci_bus_write_config_byte(bus0, devfn, (rr-\u0026gt;address \u0026amp; 0xffff), reset_value); break; case ACPI_ADR_SPACE_SYSTEM_MEMORY: case ACPI_ADR_SPACE_SYSTEM_IO: printk(KERN_DEBUG \u0026quot;ACPI MEMORY or I/O RESET_REG.\\n\u0026quot;); acpi_reset(); break; } } ACPI 编程接口的 FADT 数据结构描述了 reset register ：\n// 12 byte structure; see below for details struct GenericAddressStructure { uint8_t AddressSpace; uint8_t BitWidth; uint8_t BitOffset; uint8_t AccessSize; uint64_t Address; }; GenericAddressStructure ResetReg; uint8_t ResetValue; 结构成员 AddressSpace 指示了 reset register 所处的地址空间：\nValue Address Space 0 System Memory 1 System I/O 2 PCI Configuration Space Linux kernel 用 数据结构 struct acpi_table_fadt 实现了 FADT，定义在 include/acpi/actbl.h 文件，并定义了变量 acpi_gbl_FADT 存放所有数据。如果 reset register 位于 Memory 或者 IO ，acpi_reboot() 会调用 acpi_reset() 向 acpi_gbl_FADT.reset_register 写入 acpi_gbl_FADT.reset_value 完成重置。如果 reset register 在 PCI 配置空间，需要先找到配置空间内的地址，然后写入 acpi_gbl_FADT.reset_value 。\n3.2. KBD #KBD 是 keyboard 的缩写，这是通过键盘控制器重置计算机的方式。8042 是早期 x86 计算机上的 PS/2 键盘控制器，80 年代 IBM 推出搭载 80268 CPU 的 PC/AT 计算机时，为了解决某些兼容问题，为它添加了很多与键盘无关的功能，比如重置 CPU 。8024 的控制寄存器位于 IO 端口 0x64 ，向它写入 0xfe 就可以重置 CPU ：\noutb(0xfe, 0x64); 由于历史原因，直到今天，x86 计算机上依然需要兼容 PC/AT 机的 8042，这种方式几乎可以重启一切 x86 计算机。\n3.3. CF9 #主板上的南桥芯片也有电源管理的功能，通过 IO 端口 0xCF9 南桥的 Reset Control Register ，以英特尔的南桥芯片 ICH10 为例，寄存器定义详情可以查看芯片的 Datesheet：\n内核中有两种选择：\n向 IO Port CF9 写 0x06。热重启，这种 reset 方法不会使系统设备掉电，仅仅将 CPU 和系统设备的 status 干净彻底的 reset 一 下。 向 IO Port CF9 写 0x0E。冷重启，这是一种非常彻底的 reset 方法，系统的硬件会掉电，然后重新上电。 3.4. BIOS #这种方式会调用一段汇编代码，使 CPU 跳转到 BIOS 的重置代码处，由 BIOS 重启系统，实现方法在 arch/x86/kernel/reboot.c 文件的 machine_real_restart() 函数：\n#ifdef CONFIG_X86_32 asm volatile(\u0026quot;jmpl *%0\u0026quot; : : \u0026quot;rm\u0026quot; (real_mode_header-\u0026gt;machine_real_restart_asm), \u0026quot;a\u0026quot; (type)); #else asm volatile(\u0026quot;ljmpl *%0\u0026quot; : : \u0026quot;m\u0026quot; (real_mode_header-\u0026gt;machine_real_restart_asm), \u0026quot;D\u0026quot; (type)); 3.5. EFI #调用 EFI/UEFI 提供的接口实现重启。\n4. 参考 # How does a computer restart itself Debugging ACPI Power management ACPI Reboot Linux 内核引导选项简介 ","date":"2017 November 30","permalink":"/posts/2017/11/30/","section":"Posts","summary":"1. Soft Power #早期的计算机主板都是使用 AT 电源管理技术，AT 电源系统非常简单，电源键是机械式开关，只有开闭两种状态，闭合后电流从开关上流过为主板供电，断开后主板上的所有器件同时断电，无法实现待机、软关机等功能，这个时期的 Windows 系统关机后会一直显示一条 \u0026ldquo;It is now safe to turn off your computer\u0026rdquo; 的信息，因为操作系统无法切断电源。这时期的电源可以叫做 Hard Power ，因为全部都是硬件控制的。","title":"计算机是如何实现重启的"},{"content":"以一台 x86 主机为例，用 lsusb 可以查看它的所有 USB 设备：\n# lsusb Bus 001 Device 003: ID 1bc7:0021 Telit HE910 Bus 002 Device 002: ID 04e2:1410 Exar Corp. Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub 在 sys 文件系统的 /sys/bus/usb/devices/ 目录下可以看到所有 USB 设备的树形结构：\n/sys/bus/usb/devices# ls -l total 0 lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-0:1.0 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-0:1.0 lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2 lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.0 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.0 lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.1 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.1 lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.10 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.10 lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.11 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.11 lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.12 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.12 lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.13 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.13 lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.2 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.2 lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.3 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.3 lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.4 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.4 lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.5 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.5 lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.6 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.6 lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.7 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.7 lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.8 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.8 lrwxrwxrwx 1 root root 0 Nov 26 10:57 1-2:1.9 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.3/usb1/1-2/1-2:1.9 lrwxrwxrwx 1 root root 0 Nov 26 10:57 2-0:1.0 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.4/usb2/2-0:1.0 lrwxrwxrwx 1 root root 0 Nov 26 10:57 2-1 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.4/usb2/2-1 lrwxrwxrwx 1 root root 0 Nov 26 10:57 2-1:1.0 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.4/usb2/2-1/2-1:1.0 lrwxrwxrwx 1 root root 0 Nov 26 10:57 2-1:1.1 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.4/usb2/2-1/2-1:1.1 lrwxrwxrwx 1 root root 0 Nov 26 10:57 usb1 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.3/usb1 lrwxrwxrwx 1 root root 0 Nov 26 10:57 usb2 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.4/usb2 usb1 和 usb2 是 PCI 总线上的两个 USB controller ，也就是两个 root hub ，它们扩展出两条 USB 总线，而其他设备都是这两条总线下的子设备，它们的命名格式是 根集线器号-集线器端口号:配置.接口，进入 usb2/1-2 目录，查看设备号：\n/sys/bus/usb/devices/usb1# cd 1-2/ /sys/bus/usb/devices/usb1/1-2# cat devnum 3 可以确认，1-2 就是设备 Bus 001 Device 003: ID 1bc7:0021 Telit HE910 的文件夹，这个设备号是 USB 总线枚举设备时自动分配的，如果拔掉设备重插，设备号会重新分配，自动向后增长。设备目录下还有一些有用的文件：\nbusnum：设备接入的 USB 总线号 idProduct：设备 ID idVendor：厂商 ID 参考：\nhttp://www.linux-usb.org/FAQ.html https://www.kernel.org/doc/Documentation/ABI/stable/sysfs-bus-usb ","date":"2017 November 28","permalink":"/posts/2017/11/28/","section":"Posts","summary":"以一台 x86 主机为例，用 lsusb 可以查看它的所有 USB 设备：","title":"Linux 系统的 USB 设备结构"},{"content":"1. 硬件 #PCI 总线是一个并行总线，一个时钟周期有 32 个 bit （后扩展到 64 bit） 同时传输，带宽 133MB/s ，PCI 设备具有独立的地址空间，叫做 PCI 总线地址空间，通过 Host bridge 隔离处理器系统的存储器域与 PCI 总线域，下面挂在了一个 PCI 总线树，典型的结构如下图：\nPCI 总线主要分为三个部分：\nPCI 设备。符合 PCI 总线标准的设备就被称为 PCI 设备，PCI 总线架构中可以包含多个 PCI 设备。图中的 Audio、LAN 都是一个 PCI 设备。PCI 设备同时也分为主设备和目标设备两种，主设备是一次访问操作的发起者，而目标设备则是被访问者。 PCI 总线。PCI 总线在系统中可以有多条，类似于树状结构进行扩展，每条 PCI 总线都可以连接多个 PCI 设备/桥，上图中有两条 PCI 总线。 PCI 桥。当一条 PCI 总线的承载量不够时，可以用新的 PCI 总线进行扩展，而 PCI 桥则是连接 PCI 总线之间的纽带，如图的 PCI-to-PCI Bridge 。 后期为了提高数据传输速率，又推出了 PCIe 总线，改为串行总线，差分信号传输，带宽提升至 250MB/s ，最新的 PCIe 3.0 已经可以达到 8000MB/s 。\n2. 软件 #在 PCI 总线上，通过 Bus number ，Device number 和 Function number 标识每个 PCI 设备，简称 BDF ，每个 PCI 设备内有单独存储空间，叫做 PCI 配置空间。可以通过 IO 端口 CONFIG_ADDRESS 和 CONFIG_DATA 读取 PCI 配置空间。CONFIG_ADDRESS 的地址是 0xCF8，CONFIG_DATA 的地址是 0xCFC，两个寄存器都为 32bit。CONFIG_ADDRESS 寄存器格式：\nbit31 是使能对 PCI Bus CONFIG_DATA 的访问； bit 30～24 为保留，为只读，访问时返回值为 0； bit 23～16 是Bus号； bit 15～10 是设备号； bit 10～8 是功能号； bit 7～2 是配置空间中的寄存器，单位为 DWORD； bit 1～0 为只读，读取时放回为0。 直接操作 IO 端口读取 PCI 配置信息分为两步：\n向 CONFIG_ADDRESS 寄存器写入要读/写的位置； 从CONFIG_DATA寄存器（端口0xCFC）读/写所需要数据。 配置空间共 256 字节（地址 0x00~0xFF）， 前 64 字节（地址 0x00~0x3F ）是所有 PCI 设备必须支持的：\n配置空间都是小端存储。Vendor ID 是厂商 ID ，为保证唯一性，需要设备厂商向 PCI SIG 申请获得，Device ID 由厂商自定义。 Base Address Registers （BAR）用来定义该设备占用的 Memory/IO 空间的类型、起始地址和大小，PCI 设备做多有六个 BAR，PCI 桥最多有两个 BAR 。BAR 在 bit0 来表示该设备是映射到 memory 还是 IO，bar 的 bit0 是 readonly 的，也就是说，设备寄存器是映射到 memory 还是 IO 是由设备制造商决定的，其他人无法修改。空间的大小可以用如下方法读取：\n向寄存器写 0xFFFFFFFF； 读出寄存器的值，并取反； 再加 1 就是该空间的大小。 下面是 BAR 的结构图：\nPCI 枚举是个不断递归调用发现新设备的过程，系统启动时, 从 Host Bridge 开始寻找设备和桥。发现桥后设置 Bus，会发现一个 PCI 设备子树，递归的过程中，BIOS/UEFI (或者 Linux 内核, 如果配置成这样)与每个 PCI 设备进行配置交易, 为其分配安全的地址空间和中断等资源。在整个过程结束后，一颗完整的资源分配完毕的树就建立好了。\nPCIe 规范在 PCI 规范的基础上，将配置空间扩展到 4KB。原来的 CF8/CFC 方法仍然可以访问所有PCIe设备配置空间的头255B，但是该方法访问不了剩下的（255-4k）配置空间。\n3. Linux #3.1. user space #Linux 系统下查询 PCI 设备主要用 lspci 命令和 /sys 文件系统，一个 x86 主机为例：\n# lspci 00:00.0 Host bridge: Intel Corporation Device 0958 00:14.0 SD Host controller: Intel Corporation Device 08a7 (rev 10) 00:14.1 Serial controller: Intel Corporation Device 0936 (rev 10) 00:14.2 USB controller: Intel Corporation Device 0939 (rev 10) 00:14.3 USB controller: Intel Corporation Device 0939 (rev 10) 00:14.4 USB controller: Intel Corporation Device 093a (rev 10) 00:14.5 Serial controller: Intel Corporation Device 0936 (rev 10) 00:14.6 Ethernet controller: Intel Corporation Device 0937 (rev 10) 00:14.7 Ethernet controller: Intel Corporation Device 0937 (rev 10) 00:15.0 Serial bus controller [0c80]: Intel Corporation Device 0935 (rev 10) 00:15.1 Serial bus controller [0c80]: Intel Corporation Device 0935 (rev 10) 00:15.2 Serial bus controller [0c80]: Intel Corporation Device 0934 (rev 10) 00:17.0 PCI bridge: Intel Corporation Device 11c3 00:17.1 PCI bridge: Intel Corporation Device 11c4 00:1f.0 ISA bridge: Intel Corporation Device 095e 01:00.0 Network controller: Intel Corporation Centrino Advanced-N 6205 [Taylor Peak] (rev 34) 前面的数字依次是总线号：设备号：功能号，第一个设备就是 Host bridge ，00:1f.0 ISA bridge 是一个 ISA 桥，通过 PCI 扩展了一个 ISA 总线，可以兼容过时的 ISA 总线设备。有个两个 PCI bridge ：00:17.0 PCI bridge 和 00:17.1 PCI bridge ，扩展了两条 PCI 总线，也就是说该主机有三条 PCI 总线。而 01:00.0 Network controller 就是 PCI Bus #1 下的一个设备。单独查看该设备的详细信息：\n# lspci -s 01:00.0 -vv 01:00.0 Network controller: Intel Corporation Centrino Advanced-N 6205 [Taylor Peak] (rev 34) Subsystem: Intel Corporation Centrino Advanced-N 6205 AGN Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx+ Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast \u0026gt;TAbort- \u0026lt;TAbort- \u0026lt;MAbort- \u0026gt;SERR- \u0026lt;PERR- INTx- Latency: 0 Interrupt: pin A routed to IRQ 45 #中断管脚和中断号 Region 0: Memory at 90000000 (64-bit, non-prefetchable) [size=8K] #设备占用的地址空间 Capabilities: [c8] Power Management version 3 Flags: PMEClk- DSI+ D1- D2- AuxCurrent=0mA PME(D0+,D1-,D2-,D3hot+,D3cold+) Status: D0 NoSoftRst- PME-Enable- DSel=0 DScale=0 PME- Capabilities: [d0] MSI: Enable+ Count=1/1 Maskable- 64bit+ Address: 00000000fee0100c Data: 4191 Capabilities: [e0] Express (v1) Endpoint, MSI 00 DevCap: MaxPayload 128 bytes, PhantFunc 0, Latency L0s \u0026lt;512ns, L1 unlimited ExtTag- AttnBtn- AttnInd- PwrInd- RBE+ FLReset+ DevCtl: Report errors: Correctable- Non-Fatal- Fatal- Unsupported- RlxdOrd+ ExtTag- PhantFunc- AuxPwr- NoSnoop+ FLReset- MaxPayload 128 bytes, MaxReadReq 128 bytes DevSta: CorrErr+ UncorrErr- FatalErr- UnsuppReq+ AuxPwr+ TransPend- LnkCap: Port #0, Speed 2.5GT/s, Width x1, ASPM L0s L1, Latency L0 \u0026lt;4us, L1 \u0026lt;32us ClockPM+ Surprise- LLActRep- BwNot- LnkCtl: ASPM Disabled; RCB 64 bytes Disabled- Retrain- CommClk+ ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt- LnkSta: Speed 2.5GT/s, Width x1, TrErr- Train- SlotClk+ DLActive- BWMgmt- ABWMgmt- Capabilities: [100 v1] Advanced Error Reporting UESta: DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol- UEMsk: DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol- UESvrt: DLP+ SDES- TLP- FCP+ CmpltTO- CmpltAbrt- UnxCmplt- RxOF+ MalfTLP+ ECRC- UnsupReq- ACSViol- CESta: RxErr- BadTLP- BadDLLP- Rollover- Timeout- NonFatalErr+ CEMsk: RxErr- BadTLP- BadDLLP- Rollover- Timeout- NonFatalErr+ AERCap: First Error Pointer: 00, GenCap- CGenEn- ChkCap- ChkEn- Capabilities: [140 v1] Device Serial Number 10-0b-a9-ff-ff-b4-93-2c Kernel driver in use: iwlwifi #设备驱动 Kernel modules: iwlwifi 查看该设备的配置空间：\n# lspci -s 01:00.0 -x 01:00.0 Network controller: Intel Corporation Centrino Advanced-N 6205 [Taylor Peak] (rev 34) 00: 86 80 82 00 06 04 10 00 34 00 80 02 00 00 00 00 10: 04 00 00 90 00 00 00 00 00 00 00 00 00 00 00 00 20: 00 00 00 00 00 00 00 00 00 00 00 00 86 80 01 13 30: 00 00 00 00 c8 00 00 00 00 00 00 00 ff 01 00 00 通过 /sys 文件系统可以查看更多信息，/sys/bus/pci/ 目录包含的主要文件：\ndevices：目录，包含所有 PCI 设备的文件夹 drivers ：目录，包含所有 PCI 设备所用的驱动 rescan : 文件，只写，写入一个非零值会导致系统重新扫描所有的 PCI 总线设备 在 /sys/bus/pci/devices 下可以查看所有的 PCI 总线设备：\nroot@WR-IntelligentDevice:/sys/bus/pci/devices# ls -l total 0 lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:00.0 -\u0026gt; ../../../devices/pci0000:00/0000:00:00.0 lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:14.0 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.0 lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:14.1 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.1 lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:14.2 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.2 lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:14.3 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.3 lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:14.4 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.4 lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:14.5 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.5 lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:14.6 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.6 lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:14.7 -\u0026gt; ../../../devices/pci0000:00/0000:00:14.7 lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:15.0 -\u0026gt; ../../../devices/pci0000:00/0000:00:15.0 lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:15.1 -\u0026gt; ../../../devices/pci0000:00/0000:00:15.1 lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:15.2 -\u0026gt; ../../../devices/pci0000:00/0000:00:15.2 lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:17.0 -\u0026gt; ../../../devices/pci0000:00/0000:00:17.0 lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:17.1 -\u0026gt; ../../../devices/pci0000:00/0000:00:17.1 lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:00:1f.0 -\u0026gt; ../../../devices/pci0000:00/0000:00:1f.0 lrwxrwxrwx 1 root root 0 Nov 26 10:57 0000:01:00.0 -\u0026gt; ../../../devices/pci0000:00/0000:00:17.0/0000:01:00.0 目录名称的结构是 PCI 域:总线号:设备号:功能号，PCI 域是 Linux 为了容纳更多总线设备而添加的概念。可以看出 0000:01:00.0 是 0000:00:17.0 PCI 桥扩展的 PCI Bus #1 下的设备，而其他设备都在 Host bridge 下。进入目录 0000:01:00.0，可以看到 sys 文件系统已经把配置空间解析，并分别显示到各个文件中，主要文件的类型和功能：\nclass：PCI class (ascii, ro) config：PCI 配置空间 (binary, rw)，可以用 hexdum 命令查看 device\t：PCI device id (ascii, ro) vendor：PCI vendor id (ascii, ro) enable：设备是否已经使能，1 表示激活，0 表示禁用 (ascii, rw) irq：IRQ number (ascii, ro) remove：从内核中删除该设备(ascii, wo) resource：PCI 设备分配的内存资源 (ascii, ro) resource0..N：PCI resource N (binary, mmap, rw[1]) driver：设备驱动（dir, rw) 我们可以向 0000:01:00.0/remove 文件写 1 ，删除该设备，再向 0000:00:17.0/rescan 写 1 ，重新扫描添加该设备：\n/sys/bus/pci/devices# echo 1 \u0026gt; 0000\\:01\\:00.0/remove /sys/bus/pci/devices# ls 0000:00:00.0 0000:00:14.2 0000:00:14.5 0000:00:15.0 0000:00:17.0 0000:00:14.0 0000:00:14.3 0000:00:14.6 0000:00:15.1 0000:00:17.1 0000:00:14.1 0000:00:14.4 0000:00:14.7 0000:00:15.2 0000:00:1f.0 /sys/bus/pci/devices# echo 1 \u0026gt; 0000\\:00\\:17.0/rescan /sys/bus/pci/devices# ls 0000:00:00.0 0000:00:14.3 0000:00:14.7 0000:00:17.0 0000:00:14.0 0000:00:14.4 0000:00:15.0 0000:00:17.1 0000:00:14.1 0000:00:14.5 0000:00:15.1 0000:00:1f.0 0000:00:14.2 0000:00:14.6 0000:00:15.2 0000:01:00.0 在 driver 目录下访问设备驱动，例如 01:00.0 Network controller 是一个 Wi-Fi 网卡，可以看出它用的驱动是 iwlwifi ：\n/sys/bus/pci/devices/0000:01:00.0/driver# ls -l total 0 lrwxrwxrwx 1 root root 0 Nov 29 10:02 0000:01:00.0 -\u0026gt; ../../../../devices/pci0000:00/0000:00:17.0/0000:01:00.0 --w------- 1 root root 4096 Nov 29 10:02 bind lrwxrwxrwx 1 root root 0 Nov 29 10:02 module -\u0026gt; ../../../../module/iwlwifi --w------- 1 root root 4096 Nov 29 10:02 new_id --w------- 1 root root 4096 Nov 29 10:02 remove_id --w------- 1 root root 4096 Nov 27 12:02 uevent --w------- 1 root root 4096 Nov 29 10:02 unbind 在 module/parameters 可以读取驱动的各项参数：\n/sys/bus/pci/devices/0000:01:00.0/driver/module/parametrs# ls -l total 0 -r--r--r-- 1 root root 4096 Nov 29 10:03 11n_disable -r--r--r-- 1 root root 4096 Nov 29 10:03 amsdu_size_8K -r--r--r-- 1 root root 4096 Nov 29 10:03 antenna_coupling -r--r--r-- 1 root root 4096 Nov 29 10:03 bt_coex_active -r--r--r-- 1 root root 4096 Nov 29 10:03 fw_restart -r--r--r-- 1 root root 4096 Nov 29 10:03 led_mode -r--r--r-- 1 root root 4096 Nov 29 10:03 nvm_file -r--r--r-- 1 root root 4096 Nov 29 10:03 power_level -r--r--r-- 1 root root 4096 Nov 29 10:03 power_save -r--r--r-- 1 root root 4096 Nov 29 10:03 swcrypto -r--r--r-- 1 root root 4096 Nov 29 10:03 wd_disable /sys/bus/pci/devices/0000:01:00.0/driver/module/parametrs# cat 11n_disable 0 3.2. kernel #Linux 内核通过 CF8/CFC 端口读写 PCI 配置空间，实现函数是 /arch/x86/pci/direct.c 文件的 pci_conf1_read() 和 pci_conf1_write() ：\n#define PCI_CONF1_ADDRESS(bus, devfn, reg) (0x80000000 | ((reg \u0026amp; 0xF00) \u0026lt;\u0026lt; 16) | (bus \u0026lt;\u0026lt; 16) | (devfn \u0026lt;\u0026lt; 8) | (reg \u0026amp; 0xFC)) static int pci_conf1_read(unsigned int seg, unsigned int bus, unsigned int devfn, int reg, int len, u32 *value) { unsigned long flags; if (seg || (bus \u0026gt; 255) || (devfn \u0026gt; 255) || (reg \u0026gt; 4095)) { *value = -1; return -EINVAL; } raw_spin_lock_irqsave(\u0026amp;pci_config_lock, flags); outl(PCI_CONF1_ADDRESS(bus, devfn, reg), 0xCF8); switch (len) { case 1: *value = inb(0xCFC + (reg \u0026amp; 3)); break; case 2: *value = inw(0xCFC + (reg \u0026amp; 2)); break; case 4: *value = inl(0xCFC); break; } raw_spin_unlock_irqrestore(\u0026amp;pci_config_lock, flags); return 0; } static int pci_conf1_write(unsigned int seg, unsigned int bus, unsigned int devfn, int reg, int len, u32 value) { unsigned long flags; if (seg || (bus \u0026gt; 255) || (devfn \u0026gt; 255) || (reg \u0026gt; 4095)) return -EINVAL; raw_spin_lock_irqsave(\u0026amp;pci_config_lock, flags); outl(PCI_CONF1_ADDRESS(bus, devfn, reg), 0xCF8); switch (len) { case 1: outb((u8)value, 0xCFC + (reg \u0026amp; 3)); break; case 2: outw((u16)value, 0xCFC + (reg \u0026amp; 2)); break; case 4: outl((u32)value, 0xCFC); break; } raw_spin_unlock_irqrestore(\u0026amp;pci_config_lock, flags); return 0; } 访问 PCIe 扩展的配置空间需要用 pci_conf2_read() 和 pci_conf2_write() 函数。\n4. PCI 设备的枚举过程 #系统上电后，会采用深度优先算法，从 Host Bridge 开始对所有的 PCI/PCIe 设备进行扫描，其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。这个过程为 PCI 设备枚举。枚举过程中，系统通过配置读事物包来获取下游设备的信息，通过配置写事物包对下游设备进行设置。以下图为例：\nPCI 设备体系是一个树形结构，Host Bridge 扩展的总线为 Bus 0 ，然后从左开始向下搜索，每个 Bridge 扩展一条总线，依次以数字顺序从小到大命名 Bus ID ，向下到尽头后退回。如果去掉了上图的 Bus 3 ，后面设备的 Bus ID 都会发生改变，并向前递进。\n在 Linux 系统中，可以用 lspci -t 命令查询系统枚举到的 PCI 设备，结果以树形显示依赖关系，例如：\nroot@localhost:~# lspci -t -v -[0000:00]-+-00.0 Intel Corporation Atom Processor Z36xxx/Z37xxx Series SoC Transaction Register +-02.0 Intel Corporation Atom Processor Z36xxx/Z37xxx Series Graphics \u0026amp; Display +-11.0 Intel Corporation Atom Processor Z36xxx/Z37xxx Series SDIO Controller +-12.0 Intel Corporation Atom Processor Z36xxx/Z37xxx Series SDIO Controller +-13.0 Intel Corporation Atom Processor E3800 Series SATA AHCI Controller +-17.0 Intel Corporation Atom Processor E3800 Series eMMC 4.5 Controller +-1a.0 Intel Corporation Atom Processor Z36xxx/Z37xxx Series Trusted Execution Engine +-1b.0 Intel Corporation Atom Processor Z36xxx/Z37xxx Series High Definition Audio Controller +-1c.0-[01]----00.0 Intel Corporation I210 Gigabit Network Connection +-1c.1-[02]----00.0 Intel Corporation I210 Gigabit Network Connection +-1c.2-[03]----00.0 Intel Corporation Wireless 3165 +-1c.3-[04]----00.0 Intel Corporation 82574L Gigabit Network Connection +-1d.0 Intel Corporation Atom Processor Z36xxx/Z37xxx Series USB EHCI +-1f.0 Intel Corporation Atom Processor Z36xxx/Z37xxx Series Power Control Unit \\-1f.3 Intel Corporation Atom Processor E3800 Series SMBus Controller root@localhost:~# lspci 00:00.0 Host bridge: Intel Corporation Atom Processor Z36xxx/Z37xxx Series SoC Transaction Register (rev 11) 00:02.0 VGA compatible controller: Intel Corporation Atom Processor Z36xxx/Z37xxx Series Graphics \u0026amp; Display (rev 11) 00:11.0 SD Host controller: Intel Corporation Atom Processor Z36xxx/Z37xxx Series SDIO Controller (rev 11) 00:12.0 SD Host controller: Intel Corporation Atom Processor Z36xxx/Z37xxx Series SDIO Controller (rev 11) 00:13.0 SATA controller: Intel Corporation Atom Processor E3800 Series SATA AHCI Controller (rev 11) 00:17.0 SD Host controller: Intel Corporation Atom Processor E3800 Series eMMC 4.5 Controller (rev 11) 00:1a.0 Encryption controller: Intel Corporation Atom Processor Z36xxx/Z37xxx Series Trusted Execution Engine (rev 11) 00:1b.0 Audio device: Intel Corporation Atom Processor Z36xxx/Z37xxx Series High Definition Audio Controller (rev 11) 00:1c.0 PCI bridge: Intel Corporation Atom Processor E3800 Series PCI Express Root Port 1 (rev 11) 00:1c.1 PCI bridge: Intel Corporation Atom Processor E3800 Series PCI Express Root Port 2 (rev 11) 00:1c.2 PCI bridge: Intel Corporation Atom Processor E3800 Series PCI Express Root Port 3 (rev 11) 00:1c.3 PCI bridge: Intel Corporation Atom Processor E3800 Series PCI Express Root Port 4 (rev 11) 00:1d.0 USB controller: Intel Corporation Atom Processor Z36xxx/Z37xxx Series USB EHCI (rev 11) 00:1f.0 ISA bridge: Intel Corporation Atom Processor Z36xxx/Z37xxx Series Power Control Unit (rev 11) 00:1f.3 SMBus: Intel Corporation Atom Processor E3800 Series SMBus Controller (rev 11) 01:00.0 Ethernet controller: Intel Corporation I210 Gigabit Network Connection (rev 03) 02:00.0 Ethernet controller: Intel Corporation I210 Gigabit Network Connection (rev 03) 03:00.0 Network controller: Intel Corporation Wireless 3165 (rev 81) 04:00.0 Ethernet controller: Intel Corporation 82574L Gigabit Network Connection 可以看出，Bus 1~Bus 4 是通过 00:1c.0~00:1c.3 四个 Bridge 设备扩展的。\n5. 参考 # 深入PCI与PCIe之一：硬件篇 深入PCI与PCIe之二：软件篇 PCIe 设备的枚举过程 PCI configuration space sysfs-pci.txt sysfs-bus-pci ","date":"2017 November 27","permalink":"/posts/2017/11/27/","section":"Posts","summary":"1. 硬件 #PCI 总线是一个并行总线，一个时钟周期有 32 个 bit （后扩展到 64 bit） 同时传输，带宽 133MB/s ，PCI 设备具有独立的地址空间，叫做 PCI 总线地址空间，通过 Host bridge 隔离处理器系统的存储器域与 PCI 总线域，下面挂在了一个 PCI 总线树，典型的结构如下图：","title":"x86 计算机的 PCI 总线结构"},{"content":"1. 概述 #Appweb 是一个快速、高效、安全的开源嵌入式 web server ，同时包含了 ESP web 框架和一系列扩展支持，可以极大的缩短开放时间，官网：https://embedthis.com/ ，包含如下组件：\nHTTP web server 程序和库 HTTP client 程序和库 管理和监视进程 ESP web 框架 可选的 CGI、Ejscript、ESP 和 PHP 模块 SSL/TLS 支持包 文档和源码 特性：\n快速开发。Appweb 提供最简单、最低消耗的开发 web 应用方法，它包含了嵌入式 web 应用开发所需的全部特性，极大的缩短了开发时间。 最小的资源需求。Appweb 非常简洁和快速，只需要极小的系统资源，最小只需 2MB 的存储空间，运行时最少只需 1MB 内存。 可定制的开发环境。Appweb 高度模块化，你可以只选择所需的特性，并且支持运行时模块加载和编译时控制。 安全可靠。支持 SSL/TLS，提供最基本的验证，沙盒限制，访问和错误日志。 性能。事件驱动的多线程核心提供了最快的响应，。 标准化。Appweb 支持 HTTP/1.0 、HTTP/1.1 、CGI/1.1 、SSL RFC 2246 、HTTP RFC 2617 。 可移植。Appweb 支持 Linux 、Windows 、Mac OSX ，支持 ARM 、MIPS 、i386/X86/X86_64 、PowerPC 等。 2. 安装 #Appweb 以源码形式在 github 上发布：https://github.com/embedthis/appweb ，支持的运行环境：\nLinux — Linux 2.6 with GNU C/C++ Windows — Microsoft Windows 7 with Visual Studio 2010 or later Mac OS X — Mac OS X 10.8 (Mountain Lion) or later 下载后解压，在源码目录下执行 make ，编译完成后生成的文件都在 build 目录下:\n~/appweb-7.0.1 $ cd build/linux-x64-default/bin ~/appweb-7.0.1/build/linux-x64-default/bin $ ls appman ca.key libappweb.dylib libmpr-version.a self.crt appweb ec.crt libesp.dylib libmpr.dylib self.key appweb-esp ec.key libhttp.dylib libpcre.dylib test.crt authpass esp-compile.json libmbedtls.a makerom test.key ca.crt http libmpr-mbedtls.a roots.crt vcvars.bat 然后执行 make install 安装到本地，安装时执行的脚本是 projects/appweb-linux-default.mk ，二进制文件默认都安装在 /usr/local/lib/appweb/ 目录下。安装完成后会自动启动 appweb 。如果想要部署到其他系统，可以执行 make deploy ，会将所有需要安装的文件都输出到 linux-x64-default 目录下。当然还可以交叉编译，常用系统的编译文件都在 projects 目录下，可以用 ARCH 设置目标机的 CPU ，用 CC、CFLAGS、DFLAGS、LD 和 LDFLAGS 等参数设置自己的交叉编译工具链。卸载可以用 make uninstall 。\n3. 运行 #安装后，会自动在 /etc/init.d 下新建一个 appweb 服务，appweb 会作为系统守护进程自动启动，错误日志位于 /var/log/appweb/ 目录下：\n$ ps -ef | grep appweb root 6501 1 0 13:44 ? 00:00:00 /usr/local/bin/appman \u0026ndash;daemon \u0026ndash;program /usr/local/bin/appweb \u0026ndash;home /etc/appweb \u0026ndash;pidfile /var/run/appweb.pid run nobody 6505 6501 0 13:44 ? 00:00:00 /usr/local/bin/appweb \u0026ndash;log stdout:1 $ sudo lsof -i | grep appweb appweb 6505 nobody 6u IPv6 1444273 0t0 TCP *:http (LISTEN) appweb 6505 nobody 7u IPv6 1444274 0t0 TCP *:https (LISTEN)\n如果发现启动不成功，可以查看一下 /etc/appweb/install.conf 文件，把第一行开头的 -e 去掉，然后重启。启动成后通过浏览器访问主机 IP 即可显示默认页面：\nAppweb 提供了一个管理工具 appman ，它可以将 appweb 作为一个守护进程启动，还可以管理 appweb 的运行。appweb 的语法是 appweb [option] ，可用的选项有：\n\u0026ndash;config filename，指定配置文件替代默认的 appweb.conf. \u0026ndash;chroot directory ，改变 Appweb 运行的系统根目录，导致 Appweb 无法访问该目录之外的其他文件。 \u0026ndash;debugger，启动 debug. \u0026ndash;log logSpec ，指定 log 文件。此选项会覆盖配置文件中的 ErrorLog ，logSpec 的语法是 logName[:logLevel][.maxSize] 。当 log 文件的大小超过 maxSize 时，会将 log 文件备份为 logName.old ，再新建一个 logName 。logLevel 是一个 0~9 的数字，0 表示最少的 log 信息。该选项可以缩写为 -l 。 \u0026ndash;home directory ，指定服务器的根目录，该目录包含 Appweb 的配置文件。 \u0026ndash;name uniqueName ，设置程序名称，当同时运行多个 appweb 实例时，可以为当前程序指定唯一名称。 \u0026ndash;threads ，设置线程号。 \u0026ndash;verbose ，\u0026ndash;log stderr:2 的缩写，可以进一步缩写为 -v 。 \u0026ndash;version ，显示 appweb 版本。 如果启动 appweb 时指定了 IP 和端口，就不会去读取默认的 appweb.conf 文件，语法是：\nappweb [IP]:[PORT] [documents] 如果没有指定端口，默认会监听 80 端口。如果没有指定 IP，默认会监听所有 IP 。documents 用于指定 web 页面的目录。如果没有指定配置文件，appweb 会使用一个默认的最简配置。\n4. 配置 #appweb 的配置文件管理着监听的 IP 和端口，要加载的模块，Web 页面的位置，如何记录日志等。置顶的配置文件默认叫做 appweb.conf，允许用 include 语句导入子配置文件。配置文件中每一行设置一个选项，用井号 # 表示注释。一份配置文件是由多种选项构成的：\n全局选项 Route 选项块 Virtual Host 选项块 条件选项块 没有被任何选项块包含的选项就是全局选项，定义一些 appweb 的全局属性。Route 选项块用 \u0026lt;Route \u0026ldquo;URL\u0026rdquo;\u0026gt; 标签标识，用于设置特定的 URL，例如：\n\u0026lt;Route \u0026quot;/myapp/\u0026quot;\u0026gt; SetHandler esp \u0026lt;/Route\u0026gt; 它表示以 \u0026ldquo;/myapp/\u0026rdquo; 开头的 URL 请求转给 esp 处理。\nVirtual Host 选项块用 标签标识，用于定义虚拟子服务，将虚拟子服务的内容与 IP 或者域名绑定，例如：\n\u0026lt;VirtualHost\u0026gt; ServerName www.mycorp.org Documents /var/www/mycorp ... \u0026lt;/VirtualHost\u0026gt; 条件选项块用 标签标识，读取配置文件时会判断 SYMBOL 的值，如果为 true 就会加载这些选项，否则就会忽略，例如：\n\u0026lt;if FILE_MODULE\u0026gt; LoadModule fileHandler mod_file \u0026lt;/if\u0026gt; appweb 支持两种条件选项块：\nBLD_DEBUG ：如果 appweb 使能了 DEBUG ，该符号为 true NAME_MODULE ：如果使能了 NAME_MODULE 模块，该符号为 true 整个配置文件是从头到尾被读取的，所有要注意各选项的排列顺序。说有选项的列表：https://embedthis.com/appweb/doc/users/directives.html\n5. 开发 #Appweb 提供了三种应用开发方式：\n开发额外的模块，由 appweb 程序加载 用 ESP web 框架开发一个应用，有 appweb 程序加载 在自己的程序中使用 Appweb 的 HTTP library 开发应用 Appweb 包含了四个可加载的模块：CGI 、ESP 、PHP 和 SSL 。我们可以开发自己的模块，扩展功能，appweb 支持动态加载和静态链接两种方式调用模块，使用 C 语言接口。新建一个模块时，首先要新建一个初始化函数，格式如下：\nmaNameInit(Http *http, MprModule *module) Name 可以替换成模块的名字，第一个字母必须大写，例如 maCgiHandlerInit 可以做为 CgiHandler 模块的初始化接口，appweb 加载 CgiHandler 的时候首先调用这个函数。\n新建自己的 Handler ，处理 Http 请求。Handler 通常包含在模块里，然后在配置文件里设置，用 LoadModule 命令加载模块，每一个 handler 对应一种 Http 请求，在 Route 选项块里用 AddHandler 或者 SetHandler 命令设置，例如：\nLoadModule myHandler mod_my \u0026lt;Route /my/\u0026gt; SetHandler myHandler \u0026lt;/Route\u0026gt; ","date":"2017 November 24","permalink":"/posts/2017/11/24/","section":"Posts","summary":"1. 概述 #Appweb 是一个快速、高效、安全的开源嵌入式 web server ，同时包含了 ESP web 框架和一系列扩展支持，可以极大的缩短开放时间，官网：https://embedthis.","title":"Appweb 学习笔记"},{"content":"Seafile 是一款开源的企业云盘，注重可靠性和性能。支持 Windows, Mac, Linux, iOS, Android 平台。支持文件同步或者直接挂载到本地访问，国人开发，官方网站：https://www.seafile.com 。\n1. 部署 Seafile 服务器 #我的云服务器是 Ubuntu Server 16.04.1 LTS 64位 ，新建一个工作目录 ~/seafile ，下载最新的服务器安装包 seafile-server_6.2.3_x86-64.tar.gz 到该目录，然后在该目录下做如下工作：\nmkdir installed mv seafile-server_6.2.3_x86-64.tar.gz installed tar xvf installed/seafile-server_6.2.3_x86-64.tar.gz 现在的目录结构如下：\n$ tree -L 2 . |-- installed | `-- seafile-server_6.2.3_x86-64.tar.gz |-- seafile-server-6.2.3 | |-- check_init_admin.py | |-- reset-admin.sh | |-- runtime | |-- seaf-fsck.sh | |-- seaf-fuse.sh | |-- seaf-gc.sh | |-- seafile | |-- seafile.sh | |-- seahub | |-- seahub.sh | |-- setup-seafile-mysql.py | |-- setup-seafile-mysql.sh | |-- setup-seafile.sh | `-- upgrade 安装前先确认已经安装了如下包，也可以安装是根据提示补装：\npython 2.7 python-setuptools python-imaging python-ldap python-urllib3 sqlite3 然后开始安装：\ncd seafile-server-6.2.3/ ./setup-seafile.sh 根据提示配置如下选项：\nseafile server name ，seafile 服务器的名称 seafile server ip or domain ，seafile 服务器的 IP 或者域名 seafile data dir ，seafile 数据存放的目录 seafile fileserver port ，seafile 服务使用的 TCP 端口，默认是 8082 安装成功后的目录结构是这样的：\n$ tree -L 1 . |-- ccnet |-- conf |-- installed |-- seafile-server-6.2.3 |-- seafile-server-latest -\u0026gt; seafile-server-6.2.3 |-- seahub-data `-- seahub.db 6 directories, 1 file 2. 启动 Seafile 服务器 #在 seafile-server-latest 目录下执行如下命令：\n启动 seafile 服务： ./seafile.sh start 启动 seahub 服务： ./seahub.sh start \u0026lt;port\u0026gt; ，默认运行在 8000 端口，第一次启动时会要求新建一个管理员账户 服务启动后, 打开浏览器并输入以下地址:\nhttp://\u0026lt;server ip\u0026gt;:8000 在打开的登录界面上输入之前创建的管理员帐号的用户名/密码即可。如果不想用 8000 端口，先修改 conf/ccnet.conf 文件中的 SERVICE_URL ，将端口号改为你想要的，比如 8001 :\nSERVICE_URL = http://\u0026lt;server ip\u0026gt;:8001 然后用新的端口号重启服务。\n3. 开机自启动 #创建 seafile 的 systemd 服务文件：\nsudo vim /etc/systemd/system/seafile.service 内容如下，将 ${seafile_dir} 替换为 seafile 安装路径，并且将 user 和 group 指向真正运行 seafile 的用户：\n[Unit] Description=Seafile # add mysql.service or postgresql.service depending on your database to the line below After=network.target [Service] Type=oneshot ExecStart=${seafile_dir}/seafile-server-latest/seafile.sh start ExecStop=${seafile_dir}/seafile-server-latest/seafile.sh stop RemainAfterExit=yes User=seafile Group=seafile [Install] WantedBy=multi-user.target 创建 seahub 的 systemd 服务文件：\nsudo vim /etc/systemd/system/seahub.service 内容如下，将 ${seafile_dir} 替换为 seafile 安装路径， 替换需要的端口，并且将 user 和 group 指向真正运行 seafile 的用户，：\n[Unit] Description=Seafile hub After=network.target seafile.service [Service] # change start to start-fastcgi if you want to run fastcgi ExecStart=${seafile_dir}/seafile-server-latest/seahub.sh start \u0026lt;port\u0026gt; ExecStop=${seafile_dir}/seafile-server-latest/seahub.sh stop User=seafile Group=seafile Type=oneshot RemainAfterExit=yes [Install] WantedBy=multi-user.target 使能开机自启动：\nsudo systemctl enable seafile.service sudo systemctl enable seahub.service ","date":"2017 November 18","permalink":"/posts/2017/11/18/","section":"Posts","summary":"Seafile 是一款开源的企业云盘，注重可靠性和性能。支持 Windows, Mac, Linux, iOS, Android 平台。支持文件同步或者直接挂载到本地访问，国人开发，官方网站：https://www.","title":"用 seafile 自建云存储"},{"content":"Supervisor 是一个 Python 编写的进程管理工具，可以帮助我们实现进程的启动、关闭和重启，可以对多个进程独立管理，或者分组管理，通常用于 Linux 服务器的进程管理，官方网站 supervisord.org 。有两个主要的组成部分：\nsupervisord，运行 Supervisor 时会启动一个进程 supervisord，它负责启动所管理的进程，并将所管理的进程作为自己的子进程来启动，而且可以在所管理的进程出现崩溃时自动重启。 supervisorctl，命令行管理工具，可以用来执行 stop、start、restart 等命令，来对这些子进程进行管理。 1. 安装 #可以用 pip 安装：\nsudo pip install supervisor 如果是 Ubuntu 系统，也可以用 apt-get ：\nsudo apt-get install supervisor 2. 配置 #安装成功后，需要手动生成一个配置文件，安装包提供了 echo_supervisord_conf 工具完成这项工作：\nsudo echo_supervisord_conf \u0026gt; /etc/supervisord.conf 出去注释部分，一些有用的配置选项：\n[unix_http_server] file=/tmp/supervisor.sock ; UNIX socket 文件，supervisorctl 会使用 [supervisord] logfile=/tmp/supervisord.log ; 日志文件，默认是 $CWD/supervisord.log logfile_maxbytes=50MB ; 日志文件大小，超出会 rotate，默认 50MB logfile_backups=10 ; 日志文件保留备份数量默认 10 loglevel=info ; 日志级别，默认 info，其它: debug,warn,trace pidfile=/tmp/supervisord.pid ; pid 文件 nodaemon=false ; 是否在前台启动，默认是 false，即以 daemon 的方式启动 minfds=1024 ; 可以打开的文件描述符的最小值，默认 1024 minprocs=200 ; 可以打开的进程数的最小值，默认 200 [rpcinterface:supervisor] supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface [supervisorctl] serverurl=unix:///tmp/supervisor.sock ; 通过 UNIX socket 连接 supervisord，路径与 unix_http_server 部分的 file 一致 ; 包含其他的配置文件 [include] files = relative/directory/*.ini ; 可以是 *.conf 或 *.ini 在这个文件的最底部，可以添加我们要管理的进程。假设有一个定时打印时间的脚本 test.sh ，在 /home/ubuntu/ 目录下：\n#!/bin/sh touch test.log while true : do date \u0026gt;\u0026gt; /home/ubuntu/test.log sleep 10 done 我们把它添加到 supervisord ，在配置文件中添加：\n[program:test] directory=/home/ubuntu/ ; 程序执行的目录 command=/home/ubuntu/test.sh ; 执行程序的命令 autostart = true ; 在 supervisord 启动的时候也自动启动 startsecs = 5 ; 启动 5 秒后没有异常退出，就当作已经正常启动了 autorestart = true ; 程序异常退出后自动重启 startretries = 3 ; 启动失败自动重试次数，默认是 3 user = leon ; 用哪个用户启动 redirect_stderr = true ; 把 stderr 重定向到 stdout，默认 false stdout_logfile_maxbytes = 20MB ; stdout 日志文件大小，默认 50MB stdout_logfile_backups = 20 ; stdout 日志文件备份数 stdout_logfile = /var/log/usercenter_stdout.log ; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件） 其中 [program:test 中的 test 是应用程序的唯一标识，不能重复。对该程序的所有操作（start, restart 等）都通过名字来实现。要注意的是，Supervisor 只能管理在前台运行的程序，所以如果应用程序有后台运行的选项，需要关闭。配置成功后，就可以启动 supervisord ：\n~$ supervisord -c /etc/supervisord.conf ~$ ps -ef | grep super ubuntu 3667 1 0 16:52 ? 00:00:00 /usr/bin/python /usr/local/bin/supervisord -c /etc/supervisord.conf ~$ ps -ef | grep test ubuntu 3668 3667 0 16:52 ? 00:00:00 /bin/sh /home/ubuntu/test.sh 3. 管理 #Supervisorctl 是 supervisord 的一个命令行客户端工具，通过它实现对程序的启动和停止，可以单独关闭一个程序：\n~$ supervisorctl stop test test: stopped 如果要管理所有程序，用保留的名称 all ：\n~$ supervisorctl start all test: started ~$ supervisorctl status test test RUNNING pid 4277, uptime 0:00:20 其他的选项：\nreread ＃ 读取有更新（增加）的配置文件，不会启动新添加的程序 update ＃ 重启配置文件修改过的程序 除了 supervisorctl 之外，还可以配置 supervisrod 启动 web 管理界面，这个 web 后台使用 Basic Auth 的方式进行身份认证。除了单个进程的控制，还可以配置 group，进行分组管理。经常查看日志文件，包括 supervisord 的日志和各个 pragram 的日志文件，程序 crash 或抛出异常的信息一半会输出到 stderr，可以查看相应的日志文件来查找问题。更多的信息可以查看官方的帮助文档：http://supervisord.org/index.html\n4. 开机启动 #在 /etc/systemd/system 目录下添加 supervisord.service 文件，内容如下：\ncat supervisord.service [Unit] Description=supervisord # add mysql.service or postgresql.service depending on your database to the line below After=network.target [Service] Type=oneshot ExecStart=/usr/local/bin/supervisord -c /etc/supervisord.conf ExecStop=/usr/local/bin/supervisorctl shutdown ExecReload=/usr/local/bin/supervisorctl reload RemainAfterExit=yes User=ubuntu Group=ubuntu [Install] WantedBy=multi-user.target 然后执行 systemctl enable supervisord.service 使能该服务开机启动。\n","date":"2017 November 9","permalink":"/posts/2017/11/09/","section":"Posts","summary":"Supervisor 是一个 Python 编写的进程管理工具，可以帮助我们实现进程的启动、关闭和重启，可以对多个进程独立管理，或者分组管理，通常用于 Linux 服务器的进程管理，官方网站 supervisord.","title":"用 Supervisor 管理进程"},{"content":"1. Python 开发环境 #为 vscode 安装 Python 插件，然后选择 Python 版本：\n通过 shift+command+p 组合键打开命令控制板 选择 Python:Select Workspace Interpreter 选择 Python 版本 2. 在终端打开 vscode #在 zsh 终端里用 vscode 直接打开当前目录，编辑配置文件 ~/.zshrc ，在最后加一行：\nalias code='/Applications/Visual\\ Studio\\ Code.app/Contents/Resources/app/bin/code' 保存后重启终端，找一个项目文件夹，直接打开 vscode ：\n$ code . 3. 远程 FTP 同步 #ftp-sync 是一个自动将本地工作目录文件同步到远程 FTP/SFTP 服务器的插件。安装后可以通过三个命令完成同步：\nFtp-sync: Init，在 .vscode 目录下新建一个默认的 ftp-sync 配置文件 Ftp-sync: Sync Local to Remote，同步本地文件到远程服务器 Ftp-sync: Sync Remote to Local，同步远程服务器的文件到本地目录 4. Align 插件 #这个插件可以对选中的代码进行对齐操作，选中几行代码，按下 command+control+a 组合键即可。\n5. Markdown #VScode 原生支持 Markdown 预览，快捷键 command+k 再按 v 就可以分屏预览。而 Markdown preview enhanced 插件可以提供更好的预览效果和写作体验，并且可以导出各种格式，包括 HTML、PDF、Word、eBook 等。\n6. 自定义颜色主题 #默认的颜色主题都安装在安装路径下的 resources/app/extensions/ 目录下，安装的扩展都放在 C:/Users/[username]/.vscode/extensions/ 目录下，我们可以从默认的颜色主题复制一份到扩展安装路径下，然后在此基础上修改。比如复制一份 theme-solarized-dark ，重命名为 theme-solarized-dark-custom 。\n如果是 MacOS ，扩展安装目录在 ~/.vscode/extensions/ 。\n","date":"2017 November 7","permalink":"/posts/2017/11/07/","section":"Posts","summary":"1. Python 开发环境 #为 vscode 安装 Python 插件，然后选择 Python 版本：","title":"VScode 使用笔记"},{"content":"Mac 默认安装的是 Python2.7 ，再安装一个 Python3.6 ，就出现了两个版本共存的问题，不同的项目、不同的程序要用不同的版本，就需要创建虚拟环境，切换版本。Python3 提供了 pyvenv 模块原生支持虚拟环境，\n要创建一个虚拟环境，首先决定一个你想要存放的目录，接着运行 pyvenv 后面携带着目录名:\npyvenv tutorial-env 如果目录不存在的话，这将会创建一个 tutorial-env 目录，并且也在目录里面创建一个包含 Python 解释器，标准库，以及各种配套文件的 Python “副本”。之后你必须激活它：\nsource tutorial-env/bin/activate 激活了虚拟环境会改变你的 shell 提示符，显示你正在使用的虚拟环境，并且修改了环境变量以致运行 python 将会让你得到了特定的 Python 版本，以后用 pip 安装的包都会放在虚拟环境的目录下。例如:\n~$ python --version Python 2.7.10 ~$ source tutorial-env/bin/activate ~(tutorial-env) $ python --version Python 3.6.2 ~(tutorial-env) $ pip --version pip 9.0.1 from /Users/lishaocheng/Workspace/py3/lib/python3.6/site-packages (python 3.6) 如果要退回原来的环境，执行 exit 或者再开一个终端即可。\n参考：虚拟环境和包\n","date":"2017 October 27","permalink":"/posts/2017/10/27/","section":"Posts","summary":"Mac 默认安装的是 Python2.","title":"用 pyvenv 创建虚拟环境"},{"content":"1. 购买 VPS #推荐 https://www.vultr.com ，注册成功后先充值，Vultr 支持信用卡、比特币和支付宝等，支付宝比较方便：\n充值完毕后，点击右上角的蓝色加号购买服务器，然后选择服务器位置、系统和配置，国内推荐东京：\n选择 Ubuntu 16.04 系统，$5/月的套餐，可以先购买一个月试用：\n使能私有 IP ：\n点击左下角的 Deploy Now 完成购买，稍等片刻，安装完成后：\n点击服务器名称，进入详情页，记下 IP Address、Username 和 Password ：\n现在就可以用 SSH 客户端连接服务器，也可以点击右上第一个图标 View Console ，打开一个 Console 对话框，输入用户名和密码登录：\n2. 安装 SSR #有一个一键安装的脚本，项目主页在 https://github.com/teddysun/shadowsocks_install，在服务器上运行如下命令：\nwget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh chmod +x shadowsocksR.sh ./shadowsocksR.sh 2\u0026gt;\u0026amp;1 | tee shadowsocksR.log 根据提示配置：\n服务器端口：自己设定（如不设定，默认为 8989） 密码：自己设定（如不设定，默认为 teddysun.com） 加密方式：自己设定（如不设定，默认为 aes-256-cfb） 协议（Protocol）：自己设定（如不设定，默认为 origin） 混淆（obfs）：自己设定（如不设定，默认为 plain） 安装完成后，脚本会提示如下,，记住自己的配置：\nCongratulations, ShadowsocksR server install completed! Your Server IP :your_server_ip Your Server Port :your_server_port Your Password :your_password Your Protocol :your_protocol Your obfs :your_obfs Your Encryption Method:your_encryption_method Welcome to visit:https://shadowsocks.be/9.html Enjoy it! ShadowsocksR 已经加入开机自启动，查看运行状态：\n~# /etc/init.d/shadowsocks status ShadowsocksR (pid 28287) is running... 如果想要卸载，执行：\n./shadowsocksR.sh uninstall 3. 客户端 # Windows 客户端：https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases Mac 客户端：https://github.com/shadowsocksr-backup/ShadowsocksX-NG/releases 4. 测试 #查看本地 IP 和所在线路 http://www.ipip.net/ip.html ：\n测试各线路 ping 延时 http://www.ipip.net/ping.php :\n路由追踪 http://www.ipip.net/traceroute.php :\n另外有一个测试脚本 bench.sh ，秋水逸冰大神写的，bench.sh 既是脚本名，同时又是域名，下载执行同步，感觉很屌：\nwget -qO- bench.sh | bash 参考：https://teddysun.com/444.html\n5. 加速 #直接访问境外 VPS 的延时普遍很高，有些还不稳定，丢包率飙升。这时需要通过测试，找出连接比较快的大陆节点，然后租一台该节点上的服务器，作为中继加速，最终的线路是：\n本地PC \u0026lt;==\u0026gt; 中继服务器 \u0026lt;==\u0026gt; SSR 代理 \u0026lt;==\u0026gt; FreeInternet 现在中继服务器上安装 HAProxy ，这是一款 HTTP/TCP 负载均衡器，核心功能就是将前端的大流量请求，分流到后端的各个服务器中。原理与我们要实现的代理中继非常类似。Haproxy 监听特定端口的请求，然后将这个请求转发到后台的某一台服务器的端口上。这里使用它将我们发给它的请求转发给 SSR 服务器。以 Ubuntu 为例：\nsudo apt-get install haproxy 安装成功后，编辑配置文件 /etc/haproxy/haproxy.cfg ，用如下内容替换 ：\nglobal ulimit-n 51200 defaults log global mode tcp option dontlognull timeout connect 5000 timeout client 50000 timeout server 50000 frontend ss-in bind *:relay_server_port default_backend ss-out backend ss-out server server1 proxy_server_ip:proxy_server_port maxconn 20480 relay_server_port 是用于本地与中继服务器B的连接的端口。proxy_server_ip 是 SSR 代理服务器的 IP 地址，proxy_server_port 是 SSR 代理服务器的监听端口。\n然后将本地客户端上配置的服务器 IP 和端口改成中继服务器的 IP 和端口即可。\n6. 参考 #利用Haproxy进行SS代理中继\n","date":"2017 October 17","permalink":"/posts/2017/10/17/","section":"Posts","summary":"1. 购买 VPS #推荐 https://www.","title":"用 VPS 自建科学上网"},{"content":"1. 自动填充 #有时我们需要将一个单元格的内容复制到整行，或者整列，那么我们可以选中单元格，然后拖动边框的黄点即可：\n如果想要填充的字母或者数字自动递增，需要先将单元格的数据格式换成文本，然后再拖动黄点：\n2. 拷贝样式 #Numbers 也有类似微软 Office 的格式刷功能，叫做拷贝/粘贴样式。这个两个功能可以在“格式”菜单栏中找到，可以将它们添加到自定义工具栏中，方便使用：\n然后选中一个单元格，拷贝/粘贴样式即可：\n3. 减法 #Numbers 的公式可以用减号直接实现减法，如下实现了两个时间相减，计算出持续时间：\n","date":"2017 September 23","permalink":"/posts/2017/09/23/","section":"Posts","summary":"1. 自动填充 #有时我们需要将一个单元格的内容复制到整行，或者整列，那么我们可以选中单元格，然后拖动边框的黄点即可：","title":"Numbers 使用技巧"},{"content":"iperf 是一个客户端/服务器端工作模式的网络性能测试工具，用于测试 TCP 或者 UDP 的吞吐量，记录延迟、丢包率、MTU等信息。\n1. 语法 #缺省状态下，iperf 使用 TCP 传输协议，服务器端的语法：\niperf -s -p [port] [ options ] 加 -D 参数可以后台运行。\n客户端的语法：\niperf -c [server ip] -p [port] [options] 常用的参数有：\n-f [kmKM] ，分别以 Kbits ， Mbits ， KBytes ， MBytes 格式显示报告，默认是 Mbits 。 -l ，读写缓存区的大小，默认是 8KB 。 -w ，设置 TCP 的窗口大小。 -t ，设置测试时间，默认是 10 秒。 -i ，打印报告的时间间隔，单位是秒。 -o ，输出打印信息到问题。 -u ，设置为 UDP 协议，两端都要加。 -b n[KM] ，设置使用 UDP 协议时的带宽 n bits/sec ，默认是 1Mbit/sec 。 2. 测试 TCP 的带宽 #原理比较简单，在客户端和服务端建立三次握手连接后，客户端带宽的大小等于发送的总数据除以发送的总时间。对服务端测得的带宽，则是接收的总数据除以所花时间。服务器端：\n$ iperf -s -p 8000 ------------------------------------------------------------ Server listening on TCP port 8000 TCP window size: 85.3 KByte (default) ------------------------------------------------------------ [ 4] local 10.104.231.137 port 8000 connected with 14.197.98.229 port 65237 [ ID] Interval Transfer Bandwidth [ 4] 0.0-10.0 sec 36.8 MBytes 30.7 Mbits/sec 客户端：\n$ iperf -c 118.89.16.224 -p 8000 -i 2 -t 10 ------------------------------------------------------------ Client connecting to 118.89.16.224, TCP port 8000 TCP window size: 128 KByte (default) ------------------------------------------------------------ [ 5] local 192.168.1.104 port 65237 connected with 118.89.16.224 port 8000 [ ID] Interval Transfer Bandwidth [ 5] 0.0- 2.0 sec 9.25 MBytes 38.8 Mbits/sec [ 5] 2.0- 4.0 sec 5.75 MBytes 24.1 Mbits/sec [ 5] 4.0- 6.0 sec 6.50 MBytes 27.3 Mbits/sec [ 5] 6.0- 8.0 sec 8.38 MBytes 35.1 Mbits/sec [ 5] 8.0-10.0 sec 6.75 MBytes 28.3 Mbits/sec [ 5] 0.0-10.0 sec 36.8 MBytes 30.8 Mbits/sec 3. 测试 UDP 的性能 #客户端可以用 -u 设置 UDP 数据流的速率。客户端发送数据时，将根据客户端提供的速率计算数据报发送之间的时延。\n客户端还可以指定发送数据报的大小。每个发送的数据报包含一个 ID 号，用来唯一标识报文，服务器端根据该 ID 号来确定数据报丢失和乱序。\n当把 UDP 报文大小设置可以将整个报文放入 IP 层的包内时，那么 UDP 所测得的报文丢失数据即为 IP 层包的丢失数据，这提供了一个有效的测试包丢失情况的方法。\n数据报传输延迟抖动 (Jitter)的测试由服务器端完成，客户发送的报文数据包含有发送时间戳，服务器端根据该时间信息和接收到报文的时间戳来计算传输延迟抖动。传输延迟抖动反映传输过程中是否平滑。由于它是一个相对值，所以并不需要客户端和服务器端时间同步。\n服务器端：\n$ iperf -u -s -p 1080 ------------------------------------------------------------ Server listening on UDP port 1080 Receiving 1470 byte datagrams UDP buffer size: 208 KByte (default) ------------------------------------------------------------ [ 3] local 10.104.231.137 port 1080 connected with 14.197.98.229 port 58756 [ ID] Interval Transfer Bandwidth Jitter Lost/Total Datagrams [ 3] 0.0-20.0 sec 2.50 MBytes 1.05 Mbits/sec 1.030 ms 0/ 1784 (0%) [ 3] 0.0-20.0 sec 1 datagrams received out-of-order 客户端：\n$ iperf -u -c 118.89.16.224 -p 1080 -i 5 -t 20 ------------------------------------------------------------ Client connecting to 118.89.16.224, UDP port 1080 Sending 1470 byte datagrams UDP buffer size: 9.00 KByte (default) ------------------------------------------------------------ [ 5] local 192.168.1.104 port 58756 connected with 118.89.16.224 port 1080 [ ID] Interval Transfer Bandwidth [ 5] 0.0- 5.0 sec 640 KBytes 1.05 Mbits/sec [ 5] 5.0-10.0 sec 640 KBytes 1.05 Mbits/sec [ 5] 10.0-15.0 sec 640 KBytes 1.05 Mbits/sec [ 5] 15.0-20.0 sec 640 KBytes 1.05 Mbits/sec [ 5] 0.0-20.0 sec 2.50 MBytes 1.05 Mbits/sec [ 5] Sent 1785 datagrams [ 5] Server Report: [ 5] 0.0-20.0 sec 2.50 MBytes 1.05 Mbits/sec 1.030 ms 0/ 1784 (0%) [ 5] 0.0-20.0 sec 1 datagrams received out-of-order ","date":"2017 August 1","permalink":"/posts/2017/08/01/","section":"Posts","summary":"iperf 是一个客户端/服务器端工作模式的网络性能测试工具，用于测试 TCP 或者 UDP 的吞吐量，记录延迟、丢包率、MTU等信息。","title":"用 iperf 测试网络性能"},{"content":"netcat 是一个任意 TCP 和 UDP 连接和监听的工具，有时别名也叫 nc 。可以用于各种 TCP 或 UDP 相关的任务，包括打开 TCP 连接，发送 UDP 数据包，监听任意 TCP 和 UDP 端口，同时支持 IPv4 和 IPv6 。\n1. 语法 #netcat [option] ip port 常用参数：\n-e ，建立链接后执行外部程序。 -l ，使 netcat 处于监听状态。 -u ，使用 UDP ，缺省状态下是 TCP 协议。 -v ，输出详细信息。 -z ，执行端口扫描。对于 TCP 端口（缺省），尝试在不发送数据的情况下执行连接扫描（完整三路信号握手）。对于 UDP (–u)，缺省情况下会发送空 UDP 包。 2. 端口扫描 #用于扫描远程主机的某个端口是否处于监听状态，假设一台服务器的端口情况：\n$ netstat -nlp (Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.) Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:8883 0.0.0.0:* LISTEN 19908/mosquitto tcp 0 0 0.0.0.0:8884 0.0.0.0:* LISTEN 19908/mosquitto tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN - tcp6 0 0 :::8883 :::* LISTEN 19908/mosquitto tcp6 0 0 :::22 :::* LISTEN - 可见 TCP 的 22 、8883 和 8884 端口处于监听状态，在本地 PC 上测试 22 端口的连通性：\n$ nc -zv 118.89.16.224 22 Connection to 118.89.16.224 port 22 [tcp/ssh] succeeded! 连接失败的情况，说明端口没有被监听：\n$ nc -zv 118.89.16.224 80 nc: connectx to 118.89.16.224 port 80 (tcp) failed: Connection refused 如果要扫描 UDP 端口，加上 -u 参数：\n$ nc -uvz 118.89.16.224 1080 Connection to 118.89.16.224 port 1080 [udp/*] succeeded! 3. 双向通讯 #在一台主机上开启监听：\n$ netcat -l 8000 在另一台主机上连接\n$ nc 118.89.16.224 8000 之后在一台主机上输入的信息，就会在另一台主机上显示。\n使用 UDP 的例子：\n$ netcat -lu 1080 $ nc -u 118.89.16.224 1080 ","date":"2017 July 31","permalink":"/posts/2017/07/31/","section":"Posts","summary":"netcat 是一个任意 TCP 和 UDP 连接和监听的工具，有时别名也叫 nc 。可以用于各种 TCP 或 UDP 相关的任务，包括打开 TCP 连接，发送 UDP 数据包，监听任意 TCP 和 UDP 端口，同时支持 IPv4 和 IPv6 。","title":"netcat 基本用法"},{"content":" 用 LeetCode 练习 Python ，难度都是选择 Easy 。\n1. Two Sum #Given an array of integers, return indices of the two numbers such that they add up to a specific target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nExample:\nGiven nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Answer：\nclass Solution(object): def twoSum(self, nums, target): \u0026quot;\u0026quot;\u0026quot; :type nums: List[int] :type target: int :rtype: List[int] \u0026quot;\u0026quot;\u0026quot; for i in range(len(nums)): for j in range(i+1,len(nums)): if nums[i]+nums[j]==target: return [i,j] 2. Reverse Integer #Reverse digits of an integer.\nExample1: x = 123, return 321 Example2: x = -123, return -321\nNote:The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows.\nAnswer:\nclass Solution(object): def reverse(self, x): \u0026quot;\u0026quot;\u0026quot; :type x: int :rtype: int \u0026quot;\u0026quot;\u0026quot; temp=abs(x) res=0 while temp\u0026gt;0: res=res*10+temp%10 temp=temp//10 if x\u0026lt;0: res=-res if res\u0026gt;2147483647 or res\u0026lt;-2147483648 : res=0 return res 3. Palindrome Number #Determine whether an integer is a palindrome. Do this without extra space.\n判断一个整数是否是回文数，尽可能的少用额外的内存空间。一个思路是将数字折半，对比两半是否相等。\nAnswer:\nclass Solution(object): def isPalindrome(self, x): \u0026quot;\u0026quot;\u0026quot; :type x: int :rtype: bool \u0026quot;\u0026quot;\u0026quot; if x\u0026lt;0 : return False if x//10==0 : return True if x%10==0 : return False s=0 while x\u0026gt;s : s=s*10+x%10 x=x//10 if x==s or x==s//10 : return True else : return False 还有一种方法是转换为字符串，然后从头尾开始对比字符:\nclass Solution(object): def isPalindrome(self, x): \u0026quot;\u0026quot;\u0026quot; :type x: int :rtype: bool \u0026quot;\u0026quot;\u0026quot; x=str(x) l=len(x) for i in range(l): if x[i] != x[-1-i]: return False return True 还可以在数组中利用 Python 的冒号语法，将数字前后颠倒，然后判断是否相同：\nclass Solution(object): def isPalindrome(self, x): \u0026quot;\u0026quot;\u0026quot; :type x: int :rtype: bool \u0026quot;\u0026quot;\u0026quot; x = str(x) if x == x[::-1]: return True else: return False 4. Roman to Integer #Given a roman numeral, convert it to an integer.\nInput is guaranteed to be within the range from 1 to 3999.\nAnswer:\nclass Solution(object): def romanToInt(self, s): \u0026quot;\u0026quot;\u0026quot; :type s: str :rtype: int \u0026quot;\u0026quot;\u0026quot; rtoi={'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000} buf=0 for i in range(len(s)-1): if rtoi[s[i]] \u0026lt; rtoi[s[i+1]]: buf=buf-rtoi[s[i]] else: buf=buf+rtoi[s[i]] buf=buf+rtoi[s[-1]] return buf 5. Longest Common Prefix #Write a function to find the longest common prefix string amongst an array of strings.\n找出字符串数组中的最长公共前缀，比如 array=[\u0026lsquo;abc\u0026rsquo;,\u0026lsquo;abcd\u0026rsquo;,\u0026lsquo;abe\u0026rsquo;]，最长公共前缀就是 \u0026lsquo;ab\u0026rsquo; 。这道题的思路是先找出数组中最短的字符串，长度为 max ，最长公共前缀不可能超过 max ，然后遍历 max 次字符串数组，依次对比前 max 个字符。\nAnswer:\nclass Solution(object): def longestCommonPrefix(self, strs): \u0026quot;\u0026quot;\u0026quot; :type strs: List[str] :rtype: str \u0026quot;\u0026quot;\u0026quot; res='' strs_len=len(strs) if strs_len\u0026lt;1: return res if strs_len==1: return strs[0] max=len(strs[0]) for i in range(strs_len): if len(strs[i])\u0026lt;max: max=len(strs[i]) if max\u0026lt;1: return res flag=0 for i in range(max): for j in range(1,strs_len): print i,j print strs[j][i] if strs[0][i]!=strs[j][i]: flag=1 break if flag==0: res+=strs[0][i] else: break return res 6. Valid Parentheses #Given a string containing just the characters \u0026lsquo;(\u0026rsquo;, \u0026lsquo;)\u0026rsquo;, \u0026lsquo;{\u0026rsquo;, \u0026lsquo;}\u0026rsquo;, \u0026lsquo;[\u0026rsquo; and \u0026lsquo;]\u0026rsquo;, determine if the input string is valid.\nThe brackets must close in the correct order, \u0026ldquo;()\u0026rdquo; and \u0026ldquo;()[]{}\u0026rdquo; are all valid but \u0026ldquo;(]\u0026rdquo; and \u0026ldquo;([)]\u0026rdquo; are not.\n验证括号是否完全匹配。思路是遍历整个字符串，遇到左括号就压栈，遇到右括号就与栈内括号对比，空栈或者不匹配就说明这个字符串无效。\nAnswer:\nclass Solution(object): def isValid(self, s): \u0026quot;\u0026quot;\u0026quot; :type s: str :rtype: bool \u0026quot;\u0026quot;\u0026quot; if len(s)\u0026lt;2 or len(s)%2!=0 : return False a=[['{','[','('],['}',']',')']] b={'}':'{',']':'[',')':'('} t=[] for i in range(len(s)): if s[i] in a[0] : t.append(s[i]) else: if len(t)==0 : return False l=t.pop() if l!=b[s[i]] : return False if len(t)==0 : return True else : return False 7. Remove Duplicates from Sorted Array #Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.\nDo not allocate extra space for another array, you must do this in place with constant memory.\nFor example, Given input array nums = [1,1,2],\nYour function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn\u0026rsquo;t matter what you leave beyond the new length.\nAnswer:\nclass Solution(object): def removeDuplicates(self, nums): \u0026quot;\u0026quot;\u0026quot; :type nums: List[int] :rtype: int \u0026quot;\u0026quot;\u0026quot; i=0 while True : if i\u0026lt;len(nums)-1 : if nums[i]==nums[i+1] : nums.pop(i+1) else : i+=1 else : break return len(nums) 8. Remove Element #Given an array and a value, remove all instances of that value in place and return the new length.\nDo not allocate extra space for another array, you must do this in place with constant memory.\nThe order of elements can be changed. It doesn\u0026rsquo;t matter what you leave beyond the new length.\nExample:\nGiven input array nums = [3,2,2,3], val = 3\nYour function should return length = 2, with the first two elements of nums being 2.\nAnswer:\nclass Solution(object): def removeElement(self, nums, val): \u0026quot;\u0026quot;\u0026quot; :type nums: List[int] :type val: int :rtype: int \u0026quot;\u0026quot;\u0026quot; i=0 while i\u0026lt;len(nums): if nums[i]==val : nums.pop(i) else: i+=1 return len(nums) 9. Implement strStr() #Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nAnswer:\nclass Solution(object): def strStr(self, haystack, needle): \u0026quot;\u0026quot;\u0026quot; :type haystack: str :type needle: str :rtype: int \u0026quot;\u0026quot;\u0026quot; needle_len=len(needle) haystack_len=len(haystack) if needle_len==0 : return 0 i=0 while i+needle_len\u0026lt;=haystack_len : if needle==haystack[i:i+needle_len] : return i else : i+=1 return -1 其实 Python 为字符串提供了一个 find() 方法:\nstring.find(str,beg=0,end=len(string)) 用于查找字符串 string 内是否包含另一个字符串 str ，如果是返回开始的索引值，否则返回 -1 。\n10. Search Insert Position #Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou may assume no duplicates in the array.\nHere are few examples.\n[1,3,5,6], 5 → 2 [1,3,5,6], 2 → 1 [1,3,5,6], 7 → 4 [1,3,5,6], 0 → 0 Answer:\nclass Solution(object): def searchInsert(self, nums, target): \u0026quot;\u0026quot;\u0026quot; :type nums: List[int] :type target: int :rtype: int \u0026quot;\u0026quot;\u0026quot; for i in range(len(nums)) : if target\u0026lt;=nums[i] : return i return len(nums) 11. Count and Say #The count-and-say sequence is the sequence of integers with the first five terms as following:\n1. 1 2. 11 3. 21 4. 1211 5. 111221 1 is read off as one 1 or 11.\n11 is read off as two 1s or 21.\n21 is read off as one 2, then one 1 or 1211.\nGiven an integer n, generate the nth term of the count-and-say sequence.\nNote: Each term of the sequence of integers will be represented as a string.\nExample 1:\nInput: 1 Output: \u0026quot;1\u0026quot; Example 2:\nInput: 4 Output: \u0026quot;1211\u0026quot; Answer:\nclass Solution(object): def countAndSay(self, n): \u0026quot;\u0026quot;\u0026quot; :type n: int :rtype: str \u0026quot;\u0026quot;\u0026quot; s='1' for i in range(n-1) : pre=s[0] t='' count=0 for a in s : if pre==a : count+=1 else : t+=str(count) t+=pre count=1 pre=a t+=str(count) t+=pre s=t return s ","date":"2017 June 26","permalink":"/posts/2017/06/26/","section":"Posts","summary":"用 LeetCode 练习 Python ，难度都是选择 Easy 。","title":"LeetCode 刷题"},{"content":"list 是一种有序的数据集合，索引从 0 开始，类似 C 语言中的数组。比如定义一个 list ：\n\u0026gt;\u0026gt;\u0026gt; array=[2,3,4] \u0026gt;\u0026gt;\u0026gt; print array [2, 3, 4] \u0026gt;\u0026gt;\u0026gt; print array[0] 2 1. 基本操作 #获取 list 元素的个数可以用 len() 函数：\n\u0026gt;\u0026gt;\u0026gt; len(array) 3 所以，最后一个元素的索引是 len()-1 ，还可以用 -1 做索引，直接获取最后一个元素，以此类推，可以获取倒数第二个，倒数第三个元素：\n\u0026gt;\u0026gt;\u0026gt; array[-1] 4 \u0026gt;\u0026gt;\u0026gt; array[-2] 3 追加一个元素:\n\u0026gt;\u0026gt;\u0026gt; array.append(5) \u0026gt;\u0026gt;\u0026gt; array [2, 3, 4, 5] 在指定位置插入一个元素：\n\u0026gt;\u0026gt;\u0026gt; array.insert(1,9) \u0026gt;\u0026gt;\u0026gt; array [2, 9, 3, 4, 5] 删除某个元素可以用 pop() 函数，参数是元素的索引，不带参数的话，默认删除末尾的元素，返回值是删除的元素的内容：\n\u0026gt;\u0026gt;\u0026gt; array.pop() 5 \u0026gt;\u0026gt;\u0026gt; array [2, 9, 3, 4] \u0026gt;\u0026gt;\u0026gt; array.pop(1) 9 \u0026gt;\u0026gt;\u0026gt; array [2, 3, 4] 获取某个元素的下表,如果有重复的元素，只返回第一个元素的下标：\n\u0026gt;\u0026gt;\u0026gt; a=[1,2,3,4,2] \u0026gt;\u0026gt;\u0026gt; a.index(1) 0 \u0026gt;\u0026gt;\u0026gt; a.index(2) 1 2. 遍历 #Pytion 提供了一个内置函数 enumerate() ，可用于遍历数据：\nenumerate(iterable[, start]) 第一个参数是一个 list ，第二个可选参数允许我们自定义一个计数器，例如 list ：\n\u0026gt;\u0026gt;\u0026gt; array=['a','b','c','d'] \u0026gt;\u0026gt;\u0026gt; for c,v in enumerate(array): ... print c,v ... 0 a 1 b 2 c 3 d \u0026gt;\u0026gt;\u0026gt; for c,v in enumerate(array,1): ... print c,v ... 1 a 2 b 3 c 4 d 如果要从指定索引开始遍历到结尾，可以利用 range() 函数：\n\u0026gt;\u0026gt;\u0026gt; array=['a','b','c','d'] \u0026gt;\u0026gt;\u0026gt; for i in range(1,len(array)): ... print i,array[i] ... 1 b 2 c 3 d 3. 切片 #有时候，我们想要精确的选取 list 中的一部分，Python 提供了优雅的切片语法：\nalist[begin🔚step] begin 表示切片的起始位置，缺省是 list 的开始位置 end 表示切片的结束位置，缺省是 list 的结束位置 step 表示步长，确实是正序的 1 ，逆序用负数表示 以字符串 hello 为例，切片语法的坐标如下：\n0 1 2 3 4 5 +---+---+---+---+---+ | h | e | l | l | o | +---+---+---+---+---+ -6 -5 -4 -3 -2 -1 如果要取中间的 el :\n\u0026gt;\u0026gt;\u0026gt; a='hello' \u0026gt;\u0026gt;\u0026gt; a[1:3:1] 'el' \u0026gt;\u0026gt;\u0026gt; a[1:3] 'el' 将字符串逆序：\n\u0026gt;\u0026gt;\u0026gt; a[::-1] 'olleh' \u0026gt;\u0026gt;\u0026gt; a[-1:-6:-1] 'olleh' 取头尾两个字符：\n\u0026gt;\u0026gt;\u0026gt; a[::4] 'ho' ","date":"2017 June 25","permalink":"/posts/2017/06/25/","section":"Posts","summary":"list 是一种有序的数据集合，索引从 0 开始，类似 C 语言中的数组。比如定义一个 list ：","title":"Python 对 list 的处理"},{"content":"Paho JavaScript Client 是一个用 JavaScript 写的，基于浏览器的 MQTT Client 库，用于使用 WebSockets 协议连接 MQTT Broker 。\n官网是 http://www.eclipse.org/paho/clients/js/ GitHub 是 https://github.com/eclipse/paho.mqtt.javascript 1. 安装 #通过 git 克隆到本地：\ngit clone https://github.com/eclipse/paho.mqtt.javascript.git 默认克隆的是 master 分支，是正式发布的版本，远程还有一个 develop 分支，用于开发测试，包含了一个基于 maven 构建的简单客户端，可以用于单元测试。首先要手动检出：\ngit checkout -b develop remotes/origin/develop 然后再构建测试：\n$ mvn $ cd src/tests $ mvn test -Dtest.server=iot.eclipse.com -Dtest.server.port=80 -Dtest.server.path=/ws ","date":"2017 June 13","permalink":"/posts/2017/06/13/","section":"Posts","summary":"Paho JavaScript Client 是一个用 JavaScript 写的，基于浏览器的 MQTT Client 库，用于使用 WebSockets 协议连接 MQTT Broker 。","title":"Paho JavaScript Client 学习笔记"},{"content":"以 Telit HE910 模块为例，在 Linux 下的 AT 命令端口是 /dev/ttyACM3 。可以通过 pyserial 库直接读写端口来与模块通信，也可以使用更高级的 python-gsmmodem 。\n1. Pyserial #如果要直接发送 AT 指令，需要串口读写库，我们常用的是 pyserial ，Python 2.7 默认没有安装这个库，需要自行下载，参考 https://pypi.python.org/pypi/pyserial/2.7，下面是一个简单的例子：\n#!/usr/bin/python import serial ser=serial.Serial(port='/dev/ttyACM3', baudrate=115200, bytesize=8, parity='N', stopbits=1, timeout=1, xonxoff=False, rtscts=False, dsrdtr=False) cmd=\u0026quot;AT\\r\u0026quot; ser.write(cmd.encode()) msg=ser.read(64) print(msg) 保存到文件 atcommand.py ，执行：\n~# ./atcommand.py AT OK 2. Python-gsmmodem #2.1. 简介 #python-gsmmodem 是一个用于控制 GSM modem 的 Python 包，基于 pyserial ，提供了 API 和一些命令行交互工具。在这里下载，然后安装：https://github.com/faucamp/python-gsmmodem。它的文档在源码的 docs 目录下，Sphinx 格式，你的电脑需要安装 Sphinx ，然后在 docs 目录下执行 make html 命令，就会在 _build 目录下生产 html 格式的文档，在浏览器中打开即可。python-gsmmodem 有如下几个特性：\n提供了发送短信、查询信号强度等功能的简单方法。 提供了处理 USSD 业务和语音通话的 API 。 通过回调函数接电话、收短信。 支持短信的 PDU 和 Text 模式。 支持跟踪短信状态报告。 在 Python 的异常处理中封装了 AT 指令的错误信息。 直接向模块发送 AT 指令，读取返回值。 提供测试套件。 该模块提供了几个工具：\nGSMTerm ：一个简单的串口终端，用于与 GSM modem 通信，内建有 AT 指令帮助。启动后，输入 help 可以获取帮助信息，可以执行 AT 命令，还可以加载外部脚本：\n~# gsmterm.py -b 115200 /dev/ttyACM3 GSMTerm connected to /dev/ttyACM3 at 115200bps. Press CTRL+] or CTRL+D to exit. GSM\u0026gt; help == GSMTerm Help == Command History: Press the up \u0026amp; down arrow keys to move backwards or forwards through your command history. Command Completion: Press the TAB key to provide command completion suggestions. Press the TAB key after a command is fully typed (with or without a \u0026quot;=\u0026quot; character) to quickly see its syntax. Command Documentation: Type a command, followed with two quesetion marks to access its documentation, e.g. \u0026quot;\u0026lt;COMMAND\u0026gt;??\u0026quot;. Alternatively, precede the command with a question mark (\u0026quot;?\u0026lt;COMMAND\u0026gt;\u0026quot;), or type \u0026quot;help \u0026lt;COMMAND\u0026gt;\u0026quot;. List Available Commands: Type \u0026quot;ls [category]\u0026quot; to list the available AT commands known to GSMTerm for the given category (or all commands if no category is specified). Type \u0026quot;lscat\u0026quot; to see a list of categories. Load Script: Type \u0026quot;load \u0026lt;filename\u0026gt;\u0026quot; to load and execute a file containing AT commands, separated by newlines, e.g. \u0026quot;load ./myscript.txt\u0026quot;. To exit GSMTerm, press CTRL+] or CTRL+D. GSM\u0026gt; AT OK GSM\u0026gt; AT+CSQ?? Signal Quality (AT+CSQ) Category: Network Service Description: This command determines the received signal strength indication (\u0026lt;rssi\u0026gt;) and the channel bit error rate (\u0026lt;ber\u0026gt;) with or without a SIM card inserted Values: No parameters. Response Values: \u0026lt;rssi\u0026gt; 0: -113 dBm or less 1: -111 dBm 2 to 30: -109 to -53 dBm 31: -51dBm or greater 99: not known or not detectable \u0026lt;ber\u0026gt; 0...7: as RXQUAL values in the table GSM 05.08 Command Syntax: AT+CSQ sendsms.py ：发送短信的命令行脚本，执行 `` 可以获取帮助信息，下面是一个简单的例子：\n~# sendsms.py -i /dev/ttyACM3 -b 115200 13824741490 Connecting to GSM modem on /dev/ttyACM3... Checking for network coverage... Please type your message and press enter to send it: \u0026gt; Hello World! Sending SMS message... Message sent. identify-modem.py ：用于连接和调试 GSM modem 。\npython-gsmmodem 主要提供了如下几个编程模块：\nserial_comms ，基于 pyserial ，提供了用于低级别串口通讯的类 SerialComms 。 modem ，提供了几个操作 GSM modem 的类，例如 GsmModem ，SentSms 。 exceptions ，提供了一些额外的方法，比如超时处理，中断处理，供 GsmModem 使用。 pdu ，提供了对短信进行 PDU 编码的方法。 2.2. serial_comms #serial_comms 的主类是 SerialComms ，使用前先导入：\nfrom serial_comms import GsmModem 2.3. modem #modem 模块的主类是 GsmModem 类，它的父类是 SerialComms ，提供了与 GSM Modem 交互的大部分方法。使用前要先从 modme 模块导入：\nfrom gsmmodem.modem import GsmModem GsmModem 类的构造函数：\nGsmModem(self, port, baudrate=115200, incomingCallCallbackFunc=None, smsReceivedCallbackFunc=None, smsStatusReportCallback=None) 参数的含义：\nport ，设置 AT 指令端口 baudrate ，波特率 incomingCallCallbackFunc ，处理接听电话的回调函数 smsReceivedCallbackFunc ，处理接收短信的回调函数 smsStatusReportCallback ，处理短信状态报告的回调函数 新建实例后，要先连接端口，初始化 GSM Modem：\nconnect(self, pin=None) 这个函数会打开 AT 指令端口，初始化 GSM Modem 和 SIM 卡。参数 pin 用于设置 SIM 卡内的 PIN 码 ，字符串类型，通常 SIM 卡没有启动 PIN 码锁定，设为 None 即可。如果 SIM 卡需要 PIN 码而这里没有设置，函数会抛出 PinRequiredError 异常。如果 PIN 码设置错误，函数会抛出 IncorrectPinError 异常。相应的，结束时应该调用 close() 关闭串口，这是从 SerialComms 类继承的方法。\n新购买的 SIM 卡背面提示中会写有 PIN 码初始值，也可以在运营商官网查询修改，通常是四位数字。PIN 码的作用是增强 SIM 卡安全性，例如可以在手机上为 SIM 卡启动 PIN 码锁定，这样每次开机都要输入 PIN 码。\n初始化之后，应该确认 GSM Modem 已经成功接入运营商网络。可以调用 waitForNetworkCoverage() ，它会引起阻塞，直到成功入网，或者超时：\nwaitForNetworkCoverage(self, timeout=None) 参数 timeout 可以设置超时时间，int 类型，单位是秒。超时会抛出 TimeoutException 异常，如果有其他错误，会抛出 InvalidStateException 。调用结束后会返回当前的信号强度。\n还有一个单独的函数，可以获取信号强度：\nsignalStrength(self) 返回值是整数，范围在 0~99 表示信号强度，-1 表示未知。\n还有一些功能函数，可以获取 Modem 的一些状态，这些函数都是执行相关的 AT 指令，如果要执行其他 AT 指令，可以通过 SerialComms 类提供的 wirte 方法直接向 Modem 发送：\nmanufacturer(self) ，返回 Modem 的厂家信息 model(self) ，返回 Model 的名称 revision(self) ， 返回 Modem 的固件版本 imei(self) ，返回 Modem 的 IMEI 编码 imsi(self) ，返回 SIM 卡的 IMSI 编码 networkName(self) ，返回当前 Modem 所注册的网络的名称 supportedCommands(self) ，返回 Modem 支持的 AT 指令的列表 设置短信编码的格式可以调用 smsTextMode() ：\nsmsTextMode(self, textMode) 参数 textMode 是布尔型，设为 True 表示 text 格式，否则为 PDU 格式。text 格式是明文传输，不适合传输中文，国内目前都是 PDU 格式，初始化时，已经默认设为 PDU 格式。\n发送文本类型的短信可以用 sendSms() 函数：\nsendSms(self, destination, text, waitForDeliveryReport=False, deliveryTimeout=15, sendFlash=False) 参数的含义：\ndestination ，字符串类型，目标手机的电话号码 text ，要发送的文本内容 waitForDeliveryReport ，布尔型，如果设为 True ，函数会阻塞，知道收到短信状态的返回报告 deliveryTimeout ，整数，或者浮点数，当 waitForDeliveryReport=True 时有效，表示阻塞超时时间。 如果发送过程过程中出现错误，会抛出 CommandError 异常。如果超时，会抛出 TimeoutException 异常。\n","date":"2017 June 1","permalink":"/posts/2017/06/01/","section":"Posts","summary":"以 Telit HE910 模块为例，在 Linux 下的 AT 命令端口是 /dev/ttyACM3 。可以通过 pyserial 库直接读写端口来与模块通信，也可以使用更高级的 python-gsmmodem 。","title":"使用 Python 操作 3G 模块"},{"content":"1. 简介 #Linux Test Projec 是一个开源项目，简称 LTP ，致力于提供一套测试工具，用于测试和验证 Linux 内核的功能和稳定性，官网地址：https://linux-test-project.github.io。\n2. 安装 #安装前要准备 git、gcc、automake、autoconf、m4、bison、byacc、flex 。然后从 github 克隆源码：\n$ git clone https://github.com/linux-test-project/ltp.git $ cd ltp 配置、编译、安装，文件都安装在 /opt/ltp/ 目录下。：\n$ ../configure $ make all $ make install $ cd /opt/ltp/ $ ls bin IDcheck.sh runltp runltplite.sh runtest scenario_groups share testcases testscripts ver_linux Version 3. 结构说明 #整套测试工具分为三大部分：测试脚本、测试驱动和测试用例。测试脚本位于 testscripts/ 目录下，包含了文件系统、磁盘、内核等各种测试项目的脚本；测试驱动位于 bin/ 目录下，主要是一些测试用的辅助脚本，比如 ltp-pan 和 ltp-scanner ；测试用例位于 testcase/ 目录下。其他各目录和文件的功能：\nIDcheck.sh ，检查系统是否缺少执行 LTP 测试套件所需的用户和用户组，如果缺少，就自动创建。 runltp ，执行 LTP 测试套件的脚本。 runltplite.sh ，用于测试 LTP 安装，也可用于执行单项测试。 runtest ，测试驱动，用户连接测试脚本和测试用例。 share ，测试脚本的使用说明。 ver_linux ，打印当前系统各项信息的脚本。 LTP 的执行原理是从一个测试脚本中读取所测条目需要执行的命令行，然后等待该项测试的结束，并记录详细的测试输出。简单地说，LTP 测试套件通过执行测试脚本 runltp (或着 runltplite.sh，testscripts 内的测试脚本），调用驱动程序 ltp-pan 执行 testcases 内的测试项目，输出测试结果，并利用 ltp-scanner 整理数据。默认状态下 ltp-pan 会随机的选择一个命令行来运行，可以指定在同一时间要执行测试的次数。ltp-pan 会记录测试产生的详细的格式复杂的输出，但它不进行数据的整理和统计，数据整理统计的工作由 ltp-scanner 来完成，ltp-scanner 是一个测试结果分析工具，它会理解 ltp-pan 的输出格式，并通过表格的形式总结测试 passed 或 failed 的情况。\n测试套件的使用 #LTP 提供了两个 runltp 和 runltplite.sh 。runltp 用于验证内核。这个脚本串行地运行一组测试，并报告全部结果。默认地，这个脚本执行：\n文件系统压力测试。 硬盘 I/O 测试。 内存管理压力测试。 IPC 压力测试。 SCHED 测试。 命令功能的验证测试。 系统调用功能的验证测试。 LTP 提供的测试内容不完全写入 runltp ，测试时可以根据需求修改 runltp 并添加内容。\n","date":"2017 May 24","permalink":"/posts/2017/05/24/","section":"Posts","summary":"1. 简介 #Linux Test Projec 是一个开源项目，简称 LTP ，致力于提供一套测试工具，用于测试和验证 Linux 内核的功能和稳定性，官网地址：https://linux-test-project.","title":"Linux Test Project 学习笔记"},{"content":"Paho 是一个开源的 MQTT 客户端项目，提供多种语言的 MQTT 客户端实现，包括 C、C++、C#、Java、Python、JavaScript 等，完全支持 MQTT v3.1 和 v3.1.1 。Paho Python Client 是它的 Python 语言版本，支持 Python 2.7 和 3.x 。更多特性可以查看 http://www.eclipse.org/paho/clients/python/ ，源码和文档在 https://github.com/eclipse/paho.mqtt.python 。\n该项目提供了一个测试用的 MQTT broker ：iot.eclipse.org ，端口 1883 ，无密码。\n1. 安装 #在 Python 环境中用 pip install paho-mqtt 命令安装，或者下载源码：\ngit clone https://github.com/eclipse/paho.mqtt.python.git cd org.eclipse.paho.mqtt.python.git python setup.py install 下面是一个简单的例子，连接一个 borker ，订阅系统默认话题，获取 broker 的版本号：\nimport paho.mqtt.client as mqtt def on_connect(client, userdata, flags, rc): print(\u0026quot;Connected with result code \u0026quot;+str(rc)) client.subscribe(\u0026quot;$SYS/broker/version\u0026quot;) def on_message(client, userdata, msg): print(msg.topic+\u0026quot; \u0026quot;+str(msg.payload)) client = mqtt.Client() client.on_connect = on_connect client.on_message = on_message client.connect(\u0026quot;iot.eclipse.org\u0026quot;, 1883, 60) client.loop_forever() 保存到 paho-mqtt.py 文件，执行：\n$ python paho-mqtt.py Connected with result code 0 $SYS/broker/version mosquitto version 1.4.10 2. 编程 #paho.mqtt 包提供了三个类，Client、Publish 和 Subscribe。Publish 和 Subscribe 提供了简单的方法，一次性的发送或者接收消息，不会保持连接。Client 包含了新建客户端、连接、订阅、发送、回调函数等方法。通常的编程步骤是新建一个 Client 的实例，然后调用它提供的连接、发布和订阅等方法与 broker 通讯：\n新建一个 Client 实例 用一个 connect*() 函数连接 broker 用一个 loop*() 函数，维持与 broker 的连接 用 subscribe() 函数订阅一个话题，接收消息 用 publish() 函数发布消息 用 disconnect() 函数断开连接 下面主要介绍 Client 提供的方法，使用前先导入：\nimport paho.mqtt.client as mqtt 2.1. 初始化 #新建一个 Client 实例：\nClient(client_id=\u0026quot;\u0026quot;, clean_session=True, userdata=None, protocol=MQTTv311, transport=\u0026quot;tcp\u0026quot;) 这是 Client 类的构造函数，参数的含义：\nclient_id ，设置客户端的 ID ，应该是一个字符串，连接时向 broker 提交。如果为空，会随机生成一个 id ，此时，clean_session 必须设为 True 。 clean_session ，布尔型，如果为 True ，断开连接时，broker 会清除关于这个 client 的所有信息。如果为 False ，断开连接时，broker 会保留这个客户端的订阅信息和消息队列。 userdata ，用户自定义的数据，可以是任何类型，传递给回调函数。可以用 user_data_set() 函数更新。 protocol ，设置 MQTT 协议的版本，MQTTv31 或者 MQTTv311 。 transport ， 传输协议，默认还是 tcp ，可以设为 websockets 。 构造实例：\nimport paho.mqtt.client as mqtt mqttc = mqtt.Client() 可以调用 reinitialise() 重新初始化 Client ：\nreinitialise(client_id=\u0026quot;\u0026quot;, clean_session=True, userdata=None) 2.2. 配置 #这些函数用来设置 Client 的一些特性，通常在连接 broker 之前调用。\nmax_inflight_messages_set(self, inflight) 这个函数可以设置当 QoS\u0026gt;0 时，最多可以存在几条动态消息（已经发送，还没有确认成功的消息）。默认是 20 ，增加这个值会占用更多的内存，但是可以提升吞吐量。\nmax_queued_messages_set(self, queue_size) 这个函数可以设置当 QoS\u0026gt;0 时，发送消息队列的最大值，默认是 0 ，表示无限制。当队列满时，旧消息会丢弃。\nmessage_retry_set(retry) 当 Qos\u0026gt;0 时，如果发送消息后超过一定时间还没有收到确认报文，就要重发消息，这个函数用于设置超时时间，单位是秒。默认是 5 秒，通常不用修改。\n配置 SSL 证书验证的函数，必须在 connect*() 函数之前调动。几个参数的含义：\nca_certs ，指定 CA 根证书的路径。 certfile,keyfile ，指定客户端私钥和证书的路径。 cert_reqs ，设置客户端对 broker 证书的需求，默认是 ssl.CERT_REQUIRED ，表示 broker 必须提供一个证书。 tls_version ，设置 SSL/TLS 协议的版本，默认是 TLS v1 。 ciphers ，设置本次连接的加密密码，默认是 None 。 设置用户名和密码：\nusername_pw_set(username, password=None)\n设置遗嘱：\nwill_set(topic, payload=None, qos=0, retain=False) 当这个 client 断开连接时，broker 会发布这个遗嘱消息。参数的含义：\ntopic ，遗嘱消息的话题 payload ，遗嘱消息的内容，字符串类型，如果设为 None ，会发送一条长度为 0 消息。如果设置了 int 或者 float 类型的值，会当做字符串发送，如果你想发送真正的 int 或者 float 值，需要用 struct.pack() 生成消息。 qos ，遗嘱消息的安全等级 retain ，如果设为 True ，遗嘱消息会被设为保留消息 如果参数设置错误，函数会抛出 ValueError 异常。\n2.3. 连接 #最基本的连接方法是 connect() ：\nconnect(host, port=1883, keepalive=60, bind_address=\u0026quot;\u0026quot;) 连接到 broker ，这是一个阻塞函数，参数的含义：\nhost ，broker 的 hostname 或者 IP port ，broker 的开放端口，默认是 1883 ，如果使能了 SSL/TLS ，端口可能是 8883 keepalive ，心跳间隔，单位是秒，如果 broker 和 client 在这段时间内没有任何通讯，client 会给 broker 发送一个 ping 消息 bind_address ，如果 client 的本地计算机有多个网络接口，可以用这个参数绑定其中的一个 client 调用该函数发起连接后，如果收到 broker 发来的 CONNACK 消息，就会执行 on_connect() 回调函数。除此之外，还有 connect_async() 和 connect_srv() 两种函数可以连接 broker 。connect_async() 需要配合 loop_start() 函数以非阻塞的方式连接 broker。connect_srv() 是从 SRV DNS 获取 broker 的地址，然后再连接。\n调用过 connect*() 函数之后，可以调用 reconnect() 用现有的参数重新连接。调用 disconnect() 函数可以从 broker 断开连接，断开连接后，会执行 on_disconnect() 回调函数。\n2.4. 网络循环 #网络循环的函数有四种，它们运行在后台，处理收发的消息。最基本的是 loop() ：\nloop(timeout=1.0, max_packets=1) 这个函数会通过 select() 函数阻塞，直到有消息需要收发，阻塞的时间用 timeout 参数设置，不能超过心跳时间 keepalive ，否则你的 client 会定时从 broker 断开。max_packets 参数已经过时，无需设置。\n另一个循环函数是 loop_forever() ，它会一直阻塞，直到 client 调用了 disconnect() ，并且，它会自动重连：\nloop_forever(timeout=1.0, max_packets=1, retry_first_connection=False) timeout 和 max_packets 参数已经过时，无需设置。\n2.5. 发布 #publish(topic, payload=None, qos=0, retain=False) 向指定话题发送一条消息，参数的含义：\ntopic ，这条消息所属的话题 payload ，消息内容，字符串类型，如果设为 None ，会发送一条长度为 0 消息。如果设置了 int 或者 float 类型的值，会当做字符串发送，如果你想发送真正的 int 或者 float 值，需要用 struct.pack() 生成消息。 qos ，消息的安全等级 retain ，如果设为 Ture ，这条消息会被设为保留消息 如果参数设置错误，会抛出 ValueError 异常。消息发送成功后，会执行 on_publish() 回调函数。\n2.6. 订阅 #subscribe(topic, qos=0) 向 broker 订阅话题，参数 topic 设置话题名称，qos 设置安全等级。如果只订阅一个话题，直接设置两个参数即可，例如：\nsubscribe((\u0026quot;my/topic\u0026quot;, 1)) 如果要订阅多个话题，可以将每个话题放在一个元组中，多个话题组成一个列表：\nsubscribe([(\u0026quot;my/topic\u0026quot;, 0), (\u0026quot;another/topic\u0026quot;, 2)]) 当 broker 确认订阅有效后，client 会执行 on_subscribe() 回调函数。如果要取消订阅某个话题，可以调用 unsubscribe(topic) ，参数是字符串型，如果是取消多个话题，参数应该是一个字符串列表。取消成功的话，会执行 on_unsubscribe() 回调函数。\n2.7. 回调函数 #当 broker 对 client 的连接请求做出回应时，会调用 on_connect() 回调函数，可以在该函数中判断连接是否成功:\non_connect(client, userdata, flags, rc) 参数 client 是当前 client 的实例，userdata 是 Client() 或 userdata_set() 设置的用户数据。flags 是 broker 发送的回应 flags ，字典类型。rc 表示连接结果，整数型，0 表示连接成功，连接失败可能的值有：\n1 ，错误的协议版本 2 ，无效的 client ID 3 ，服务器不可用 4 ，错误的用户名或密码 5 ，无法验证 使用实例：\ndef on_connect(client, userdata, flags, rc): print(\u0026quot;Connection returned result: \u0026quot;+connack_string(rc)) mqttc.on_connect = on_connect ... 对应的，与 broker 断开连接后，会执行 on_disconnect() 回调函数：\non_disconnect(client, userdata, rc) rc 表示断开连接的状态，如果是 0 ，表示是调用了 disconnect() 引起的断开连接，其他结果表示意外断开，比如网络中断。使用实例：\ndef on_disconnect(client, userdata, rc): if rc != 0: print(\u0026quot;Unexpected disconnection.\u0026quot;) mqttc.on_disconnect = on_disconnect ... 当 client 接收到已订阅的话题的消息时，会调用 on_message() 回调函数，在该函数中判断是哪个话题的消息，并处理消息内容：\non_message(client, userdata, message) 参数 message 是 MQTTMessage 类的实例，这个类包含的成员有 topic ，payload ，qos ，retain 。使用实例：\ndef on_message(client, userdata, message): print(\u0026quot;Received message '\u0026quot; + str(message.payload) + \u0026quot;' on topic '\u0026quot; + message.topic + \u0026quot;' with QoS \u0026quot; + str(message.qos)) mqttc.on_message = on_message ... 如果要用通配符同时处理多个话题的消息，例如用 sensors/# 匹配 sensors/temperature 和 sensors/humidity 话题，可以用 message_callback_add() 设置回调函数：\nmessage_callback_add(sub, callback) 参数 sub 是一个使用通配符的话题过滤器，字符串型，用 callback 参数指定回掉函数，与 on_message() 相同的类型。\n如果同时设置了 on_message() 和 message_callback_add() 回调函数，会首先寻找合适的 message_callback_add() 定义的话题过滤器，如果没有匹配，才会调用 on_message() 。\n2.8. 实例 #假设 broker 要求提供用户名、密码、证书和密钥，下面是一个简单的 client 例子：\n$ cat path-mqtt.py #!/usr/bin/python import paho.mqtt.client as mqtt cafile = \u0026quot;/etc/mosquitto/ca/ca.crt\u0026quot; certfile = \u0026quot;/home/ubuntu/CA/client.crt\u0026quot; keyfile = \u0026quot;/home/ubuntu/CA/client.key\u0026quot; user = \u0026quot;guest\u0026quot; passwd = \u0026quot;12345678\u0026quot; server = \u0026quot;localhost\u0026quot; port = 8883 def on_connect(client, userdata, flags, rc): print(\u0026quot;Connected with result code \u0026quot;+str(rc)) client.subscribe(\u0026quot;$SYS/broker/version\u0026quot;) def on_message(client, userdata, msg): print(msg.topic+\u0026quot; \u0026quot;+str(msg.payload)) client = mqtt.Client() client.tls_set(cafile,certfile,keyfile) client.username_pw_set(user,passwd) client.on_connect = on_connect client.on_message = on_message client.connect(server, port, 60) client.loop_forever() 执行：\n$ ./path-mqtt.py Connected with result code 0 $SYS/broker/version mosquitto version 1.4.11 ","date":"2017 May 23","permalink":"/posts/2017/05/23/","section":"Posts","summary":"Paho 是一个开源的 MQTT 客户端项目，提供多种语言的 MQTT 客户端实现，包括 C、C++、C#、Java、Python、JavaScript 等，完全支持 MQTT v3.","title":"Paho Python Client 学习笔记"},{"content":"1. RSA 加密算法 #RSA 是一种非对称加密算法，同时生成一对密钥，分为公钥和私钥，它有几个重要的特点：\n公钥可以向外发布给多人，私钥必须单独保留确保安全 使用私钥加密的信息只能要公钥解密，使用公钥加密的信息只能用私钥解密 密钥越长，被破解的难度越大，可靠性越高，普通用户应使用 1024 位密钥，证书认证机构应该使用 2048 位或以上 RSA 加密算法有两个重要的应用：信息加密和数字签名。\n2. 信息加密 #如果将 RSA 用于数据加密，必然不希望别人知道数据内容，只有我可以解密，这时需要用公钥加密，私钥解密。例如，我生成了一对密钥，将公钥分给很多人，私钥自己保留，Alice 想要给我发信息时，就可以用这个公钥加密之后发给我，只有我可以用私钥解密。\nopenssl 集成了多种加密算法和使用工具，生成私钥和相应的公钥：\n~$ openssl genrsa -out rsa.key 1024 Generating RSA private key, 1024 bit long modulus .....................++++++ ....++++++ e is 65537 (0x10001) ~$ openssl rsa -in rsa.key -pubout -out rsa_pub.key writing RSA key ~$ cat rsa_pub.key -----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDHZUoPjBXGA4trMaPosiDJkR3x JGfsZRZ7i6bjKjKmocc0umiFcOCFDrP1u4o90lXa/9XVzZ7OUIZSWCaCm/YQDxih oeXTAIPVeCHbfAb9kcE+GjRpCj7VTwN2e96rYyTwBMPdSsDmcdHUAXNJHpA6eST+ 7JE1OHAYGz33AbYhaQIDAQAB -----END PUBLIC KEY----- 假设有个文件 hello ，内容是 hello ，用公钥加密，并生成加密文件，然后再用私钥解密：\n~$ cat hello hello ~$ openssl rsautl -encrypt -in hello -inkey rsa_pub.key -pubin -out hello.en ~$ ls hello hello.en rsa.key rsa_pub.key ~$ cat hello.en 6\u0026amp;'��RM6..o�q?S�R�σk�(7����*����`��/3�H_�i��f��X7\u0026quot;$H�#U�)Y�-�:����\\��up ϸI2�\u0026gt;�Q\u0026quot;����#�a��� �0��YB�wF% ~$ openssl rsautl -decrypt -in hello.en -inkey rsa.key -out hello.de ~$ cat hello.de hello 3. 数字签名 #RSA 算法的另一个应用是数字签名。既然是签名，必然不希望别人冒充我，只有我才能发布这个签名，所有要用私钥签名，别人收到后可以公钥验证。数字签名的目的是：\n证明消息是我发的。 证明消息内容完整，没有被篡改。 要实现以上两点，通常的做法是，把原文做一次 Hash（md5 或者 sha1 等），生成的 Hash 值也叫做信息摘要或者指纹，用私钥对这个指纹加密作为签名，将原文和签名一起发布，别人收到后，用公钥解密签名得到一段 Hash 值，如果解密成功，则证明信息是我发的，然后对原文做一次 Hash，将结果与前面那一段 Hash 值对比，如果一致，就证明原文没有被篡改。下图是签名和验证的完整过程：\n用 OpenSSL 完成一次签名和验证。首先，使用私钥、sha1 算法，对文件 hello 签名，生成签名文件 sign ：\n~$ openssl dgst -sign rsa.key -sha1 -out sign hello 然后，使用公钥验证签名和原文：\n~$ openssl dgst -verify rsa_pub.key -sha1 -signature sign hello Verified OK 4. 数字证书 #由于公钥是公开的，存在被篡改的可能。假如 Alice 本来拥有我的公钥，却被第三方偷偷替换成第三方的公钥，这样第三方就可以冒充我，用他自己私钥生成数字签名，发送给 Alice ，Alice 用公钥验证成功，以为是我的签名，从而被欺骗。\n为了应对这种情况，就需要我向证书中心（Certificate Authority，简称 CA ，是一种负责发放和管理数字证书的第三方权威机构）申请一份数字证书，CA 会收集我的公钥和其他相关信息做一个证书，再用它的私钥对证书做数字签名，确保证书不被篡改，二者合在一起即使一份数字证书（Digital Certificate）。以后我写信的时候，在签名的同时，都会附上这张数字证书，Alice 收到后，用 CA 的公钥验证数字签名，确保证书有效，获取我的公钥，然后用公钥去验证数字签名。\n这样又带来一个问题，如何获取 CA 的公钥，并保证 CA 公钥的安全？CA 除了给别人签发证书，它们也有自己的证书，证书内含 CA 公钥(明文)和用 CA 私钥生成的数字签名，微软等操作系统厂商会选取一些信用良好且有一定安全认证的 CA ，把这些 CA 的证书默认安装在操作系统里，并设置为操作系统信任的根证书，以 macOS 为例：\n以 https 为例，如果某网站的数字证书的签发机构 (CA) 不在操作系统信任列表里，登录时浏览器就会警告，比如 https://www.12306.cn ：\n现实情况通常更复杂一点，我们不会直接找到根证书签发机构，可能会向一个中级证书签发机构申请证书，而他们自己的证书又通过根 CA 签发，这就形成了一个证书链，浏览器验证证书有效性的时候，也会根据证书中的签发者信息，层层上溯，直到找到受信任的根 CA ，再用相应的公钥向下层层验证。以 google 为例，在 chrome 浏览器中打开 https://www.google.com.hk ，打开开发者工具，点击 Security 标签页中的 View certificate 按钮，就可以看到这个网站的证书详情：\n可以看到每层证书的详情，包括签发者，有效期，公钥的内容和算法，证书指纹的内容和算法等。\n这里有一个通过 OpenSSL 自建 CA 并颁发证书的脚本：https://github.com/owntracks/tools/raw/master/TLS/generate-CA.sh。\n5. 参考 # 数字签名是什么？ SSL/TLS 协议运行机制详解 SSL/TLS原理详解 ","date":"2017 May 16","permalink":"/posts/2017/05/16/","section":"Posts","summary":"1. RSA 加密算法 #RSA 是一种非对称加密算法，同时生成一对密钥，分为公钥和私钥，它有几个重要的特点：","title":"RSA 加密算法与数字证书"},{"content":"0. 准备 # Raspberry Pi 3 Model B 32GB Class10 TF 卡（官方推荐 8GB 以上）和读卡器 5V2A USB 电源，比如 iPad 电源适配器 microUSB 电源线 HDMI 数据线 显示器 USB 键盘 1. 安装系统 #下载 Raspbian jessie lite ：2017-04-10-raspbian-jessie-lite.img ，这是一个官方支持的精简系统，基于 Debian 开发，只有文本界面。\n将 TF 卡插入 MacBook ，在终端里用 df 命令可以看到 TF 卡已经被挂载：\n[22:16]~/ ❯ df Filesystem 512-blocks Used Available Capacity iused ifree %iused Mounted on /dev/disk1 487830528 299357448 187961080 62% 1687373 4293279906 0% / devfs 377 377 0 100% 654 0 100% /dev map -hosts 0 0 0 100% 0 0 100% /net map auto_home 0 0 0 100% 0 0 100% /home /dev/disk3s1 60612608 226616 60385992 1% 76 4294967203 0% /Volumes/Pi 然后卸载：\n[22:39]~/ ❯ diskutil unmount /dev/disk3s1 Volume Pi on disk3s1 unmounted 使用 dd 命令将系统镜像写入:\n[23:43]~/ ❯ sudo dd bs=4m if=2017-04-10-raspbian-jessie-lite.img of=/dev/rdisk3 Password: 309+1 records in 309+1 records out 1297862656 bytes transferred in 112.203648 secs (11567027 bytes/sec) /dev/disk3s1 是分区，/dev/disk3 是块设备，/dev/rdisk3 是原始字符设备\n这样就安装系统好了，再次卸载：\n[23:45]~/ ❯ df Filesystem 512-blocks Used Available Capacity iused ifree %iused Mounted on /dev/disk1 487830528 299358472 187960056 62% 1687450 4293279829 0% / devfs 380 380 0 100% 658 0 100% /dev map -hosts 0 0 0 100% 0 0 100% /net map auto_home 0 0 0 100% 0 0 100% /home /dev/disk3s1 82644 41524 41120 51% 0 0 100% /Volumes/boot [23:49]~/ ❯ diskutil unmount /dev/disk3s1 Volume boot on disk3s1 unmounted 2. 第一次启动 #将 TF 卡插入树莓派，连接电源、显示器、键盘，即可启动。启动后输入用户名 pi ，密码 raspberry 。\n2.1. 配置语言、时区和键盘布局 #执行 sudo raspi-config ，进入 4 Localisation Options ，对系统进行本地化配置：\n在 I1 Change Locale 中设置本地语言，取消 en_GB.UTF-8 UTF-8 ，选中 en_US.UTF-8 UTF-8 。 在 I2 Change Timezone 中设置时区为 Asia 下的 Shanghai 。 在 I3 Change Keyboard Layout 设置键盘布局，依次选择 Generic 104-key PC \u0026gt; Other \u0026gt; English (US) \u0026gt; English (US) \u0026gt; The default for the keyboard layout \u0026gt; No compose key 。 在 I4 Change Wi-fi Country 中设置CN China 完成配置后，选择 Finish ，根据提示重启系统，如果没有提示，可以执行 sudo reboot 重启系统。 2.2. 配置 Wi-Fi #执行 wpa_passphrase [ssid] [password] 命令将 Wi-Fi 名称和密码写入配置文件：\npi@raspberrypi:~ $ sudo wpa_passphrase TP-Link_30BBB8 12345678 | sudo tee -a /etc/wpa_supplicant/wpa_supplicant.conf 重启一下系统，就可以连上 Wi-Fi 了，使用 iwconfig 命令查看连接是否成功，已经获取的 IP ：\npi@raspberrypi:~ $ iwconfig wlan0 IEEE 802.11bgn ESSID:\u0026quot;TP-Link_30BBB8\u0026quot; Mode:Managed Frequency:2.412 GHz Access Point: 8C:A6:DF:0C:7A:09 Bit Rate=28.8 Mb/s Tx-Power=31 dBm Retry short limit:7 RTS thr:off Fragment thr:off Power Management:on Link Quality=44/70 Signal level=-66 dBm Rx invalid nwid:0 Rx invalid crypt:0 Rx invalid frag:0 Tx excessive retries:2 Invalid misc:0 Missed beacon:0 lo no wireless extensions. eth0 no wireless extensions. pi@raspberrypi:~ $ ifconfig eth0 Link encap:Ethernet HWaddr b8:27:eb:11:9b:de inet6 addr: fe80::3f3:df2a:426d:ab83/64 Scope:Link UP BROADCAST MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) wlan0 Link encap:Ethernet HWaddr b8:27:eb:44:ce:8b inet addr:192.168.1.103 Bcast:192.168.1.255 Mask:255.255.255.0 inet6 addr: fe80::dba8:37ce:716a:a85/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:4429 errors:0 dropped:34 overruns:0 frame:0 TX packets:160 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:327762 (320.0 KiB) TX bytes:27347 (26.7 KiB) 2.3. 开启 SSH #系统默认没有开启 SSH ，需要在 TF 卡的根目录下新建一个空文件 SSH ，这样系统启动时就会启动 SSH ：\npi@raspberrypi:~ $ sudo touch /boot/ssh pi@raspberrypi:~ $ sudo reboot 查看 SSH 服务是否启动：\npi@raspberrypi:~ $ systemctl status ssh ● ssh.service - OpenBSD Secure Shell server Loaded: loaded (/lib/systemd/system/ssh.service; enabled) Active: active (running) since Mon 2017-04-10 19:16:40 CST; 2min 2s ago Main PID: 697 (sshd) CGroup: /system.slice/ssh.service └─697 /usr/sbin/sshd -D 在 Mac 的终端里执行 ssh pi@192.168.1.103 登录树莓派。\n可以安装一个 lrzsz ，方便服务器端与客户端的文件传输：sudo apt-get install lrzsz\n2.4. 更换源 #编辑配置文件：\npi@raspberrypi:~ $ sudo vi /etc/apt/sources.list 注释掉原地址，添加阿里云的源地址：\ndeb http://mirrors.aliyun.com/raspbian/raspbian/ wheezy main non-free contrib deb-src http://mirrors.aliyun.com/raspbian/raspbian/ wheezy main non-free contrib 保存文件后，更新系统软件：\npi@raspberrypi:~ $ sudo apt-get update 清华的源速度也不错：\ndeb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ jessie main non-free contrib deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ jessie main non-free contrib 2.5. 替换 Vim #系统原装的 Vim 超难用，先卸载，再按照新的：\npi@raspberrypi:~ $ sudo apt-get remove vim-common pi@raspberrypi:~ $ sudo apt-get install vim 2.6. 设置 SSH 证书登录 #暴露在外围的密码登录容易受到攻击，而且每次都要输密码，不够方便。真正生产环境中还是使用证书登录。配置需要如下几个步骤。\n生成一对秘钥，一路回车默认生成id_rsa和id_rsa.pub，前者是私钥，放在客户端，后者是公钥，需要放在ssh服务器：\npi@raspberrypi:~ $ ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/home/pi/.ssh/id_rsa): Created directory '/home/pi/.ssh'. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/pi/.ssh/id_rsa. Your public key has been saved in /home/pi/.ssh/id_rsa.pub. The key fingerprint is: 63:c8:76:52:c1:14:bc:1b:8b:28:b2:02:7d:86:96:8f pi@raspberrypi The key's randomart image is: +---[RSA 2048]----+ | ++. | | o. | | .. | | . oo | | . o .=.S+ | |o * +..+o. | |.+ * | |o E . | |. | +-----------------+ pi@raspberrypi:~ $ cd .ssh/ pi@raspberrypi:~/.ssh $ ls id_rsa id_rsa.pub 在服务器端将 id_rsa.pub 添加到 authorized_keys ，然后配置 ssh_config\npi@raspberrypi:~/.ssh $ cat id_rsa.pub \u0026gt;\u0026gt; ~/.ssh/authorized_keys pi@raspberrypi:~ $ vim /etc/ssh/ssh_config RSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile %h/.ssh/authorized_keys 把私钥 id_rsa 发送到客户端，由于我是 MacOS ，放在 ~/.ssh/ 目录下，更名为 raspberry_pi ，在 ~/.ssh/config 文件中添加一项配置：\nhost pi HostName 192.168.1.103 Port 22 User pi IdentityFile ~/.ssh/raspberry_pi 在客户端使用 ssh pi 即可登录树莓派。\n2.7. 系统时间 #树莓派没有实时时钟，所以每次启动后要用 ntp 对时，否则时间不准。默认设置的 ntp 服务器连接较慢，可以添加一些境内的 ntp 服务器。编辑 /etc/ntp.conf 文件，找到如下两行：\n# You do need to talk to an NTP server or two (or three). #server ntp.your-provider.example 在这行后面添加：\nserver ntp.fudan.edu.cn iburst server time.asia.apple.com iburst server asia.pool.ntp.org iburst server ntp.nict.jp iburst server time.nist.gov iburst 保存后重启 ntpd ：\npi@raspberrypi:~ $ sudo systemctl restart ntp.service 2.8. 配置以太网 #树莓派有一个以太网卡 eth0 ，默认是 dhcp 方式自动分配 IP ，要改成静态 IP 需要编辑 /etc/network/interfaces 文件，将 eth0 的配置删除，添加如下内容：\nauto eth0 iface eth0 inet static address 192.168.5.252 netmask 255.255.255.0 gateway 192.168.5.50 dns-nameservers 192.168.0.99 保存后重启 network 服务：\npi@raspberrypi:~ $ sudo systemctl restart networking.service 3. 硬件编程开发 #树莓派通过 40 pin 排针引出 26 路 GPIO ，输出高电平 3.3V ，部分 GPIO 有复用功能，包括一个两线 I2C ，一个四线 SPI ，一个 UART ，信号定义如下：\n读写 GPIO 可以用 C 语言或者 Python ，官方推荐的 Python GPIO 是一个小型 Python 库，但是不支持 SPI 、I2C 等 GPIO 的复用功能，使用 C 语言开发的 WiringPi 更受欢迎：http://wiringpi.com/ ，它提供了一个 C 语言开发库， API 风格类似 Arduino ，可以访问 GPIO 管脚的所有功能，还提供了一个命令行工具 gpio ，可以直接访问 GPIO 管脚。\n3.1. 下载安装 #先按照 git ，然后通过 git 下载源码：\npi@raspberrypi:~ $ sudo apt-get install git pi@raspberrypi:~ $ git clone git://git.drogon.net/wiringPi 安装：\npi@raspberrypi:~ $ cd ~/wiringPi pi@raspberrypi:~ $ ./build 测试是否安装成功：\npi@raspberrypi:~/wiringPi $ gpio -v gpio version: 2.44 Copyright (c) 2012-2017 Gordon Henderson This is free software with ABSOLUTELY NO WARRANTY. For details type: gpio -warranty Raspberry Pi Details: Type: Pi 3, Revision: 02, Memory: 1024MB, Maker: Sony * Device tree is enabled. * --\u0026gt; Raspberry Pi 3 Model B Rev 1.2 * This Raspberry Pi supports user-level GPIO access. 3.2. WiringPi 的管脚编码 #WiringPi 的 GPIO 管脚编号与连接器上的硬件硬件编号并不一致，获取当前树莓派的 GPIO 管脚描述的方法是使用 gpio 命令：\npi@raspberrypi:~/wiringPi $ gpio readall +-----+-----+---------+------+---+---Pi 3---+---+------+---------+-----+-----+ | BCM | wPi | Name | Mode | V | Physical | V | Mode | Name | wPi | BCM | +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+ | | | 3.3v | | | 1 || 2 | | | 5v | | | | 2 | 8 | SDA.1 | IN | 1 | 3 || 4 | | | 5v | | | | 3 | 9 | SCL.1 | IN | 1 | 5 || 6 | | | 0v | | | | 4 | 7 | GPIO. 7 | IN | 1 | 7 || 8 | 0 | IN | TxD | 15 | 14 | | | | 0v | | | 9 || 10 | 1 | IN | RxD | 16 | 15 | | 17 | 0 | GPIO. 0 | IN | 0 | 11 || 12 | 0 | IN | GPIO. 1 | 1 | 18 | | 27 | 2 | GPIO. 2 | IN | 0 | 13 || 14 | | | 0v | | | | 22 | 3 | GPIO. 3 | IN | 0 | 15 || 16 | 0 | IN | GPIO. 4 | 4 | 23 | | | | 3.3v | | | 17 || 18 | 0 | IN | GPIO. 5 | 5 | 24 | | 10 | 12 | MOSI | IN | 0 | 19 || 20 | | | 0v | | | | 9 | 13 | MISO | IN | 0 | 21 || 22 | 0 | IN | GPIO. 6 | 6 | 25 | | 11 | 14 | SCLK | IN | 0 | 23 || 24 | 1 | IN | CE0 | 10 | 8 | | | | 0v | | | 25 || 26 | 1 | IN | CE1 | 11 | 7 | | 0 | 30 | SDA.0 | IN | 1 | 27 || 28 | 1 | IN | SCL.0 | 31 | 1 | | 5 | 21 | GPIO.21 | IN | 1 | 29 || 30 | | | 0v | | | | 6 | 22 | GPIO.22 | IN | 1 | 31 || 32 | 0 | IN | GPIO.26 | 26 | 12 | | 13 | 23 | GPIO.23 | IN | 0 | 33 || 34 | | | 0v | | | | 19 | 24 | GPIO.24 | IN | 0 | 35 || 36 | 0 | IN | GPIO.27 | 27 | 16 | | 26 | 25 | GPIO.25 | IN | 0 | 37 || 38 | 0 | IN | GPIO.28 | 28 | 20 | | | | 0v | | | 39 || 40 | 0 | IN | GPIO.29 | 29 | 21 | +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+ | BCM | wPi | Name | Mode | V | Physical | V | Mode | Name | wPi | BCM | +-----+-----+---------+------+---+---Pi 3---+---+------+---------+-----+-----+ 这个命令会生成一张图片，描述当前树莓派的 GPIO 连接器管脚与 WiringPi 中的管脚编号的映射关系，上图是 Raspberry Pi 3 Model B 型的。\n3.3. GPIO #WiringPi 提供了多个初始化函数：\nint wiringPiSetup (void) ; int wiringPiSetupGpio (void) ; int wiringPiSetupPhys (void) ; int wiringPiSetupSys (void) ; 程序开始的时候，必须调用其中一个，且需要 root 权限。通常调用 wiringPiSetup(void) 即可，它的作用是初始化 WiringPi 编程环境和 GPIO 管脚映射。wiringPiSetupGpio(void) 和 wiringPiSetupPhys(void) 会用树莓派的 GPIO 编号或者连接器管脚编号替代 WiringPi 的编号，wiringPiSetupSys(void) 会用 /sys/class/gpio 接口来代替直接访问硬件，也称为 sys 模式，这三个函数都很少使用。\n访问 GPIO 主要需要如下函数，这些函数在 sys 模式下都是无效的：\nvoid pinMode (int pin, int mode) ; 设置某个管脚的模式为 INPUT, OUTPUT, PWM_OUTPUT 或者 GPIO_CLOCK 。只有 wiringPi pin 1 (BCM_GPIO 18) 支持 PWM 输出 ，只有 wiringPi pin 7 (BCM_GPIO 4) 支持 CLOCK 输出。\nvoid pullUpDnControl (int pin, int pud) ; 设置某个输入管脚的上拉和下拉电阻，PUD_OFF 表示关闭上下拉电阻, PUD_DOWN 表示下拉到地，PUD_UP 表示上拉倒 3.3V ，上下拉电阻大约 50KΩ 。\nvoid digitalWrite (int pin, int value) ; 向某个输出管脚写值，HIGH 表示高电平， LOW 表示低电平。\nint digitalRead (int pin) ; 读取某个输入管脚的状态，返回 HIGH 表示高电平，LOW 表示低电平。\n3.4. SPI #编程访问 SPI 前，要用 gpio 加载 SPI 驱动：\ngpio load spi 编辑代码时要包含头文件：\n#include \u0026lt;wiringPiSPI.h\u0026gt; 编译时要手动链接 ： -lwiringPi 。\n3.5. UART #4. 搭建 NAS 服务 #4.1. 硬件配置 #准备一块移动硬盘，因为树莓派的 USB 口驱动能力有限，最好用双 USB 口数据线，为移动硬盘独立供电，格式化为 ext4 ，我这里的分区是 sda1 ：\npi@raspberrypi:~ $ sudo fdisk /dev/sda -l Disk /dev/sda: 149.1 GiB, 160041885696 bytes, 312581808 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x9fd95492 Device Boot Start End Sectors Size Id Type /dev/sda1 2048 312581807 312579760 149.1G 83 Linux 为了让系统启动时自动挂在移动硬盘，需要修改 /etc/fstab 文件，添加 sda1 的配置，记得修改前先备份：\npi@raspberrypi:/etc $ cat fstab proc /proc proc defaults 0 0 PARTUUID=5b2de8de-01 /boot vfat defaults 0 2 PARTUUID=5b2de8de-02 / ext4 defaults,noatime 0 1 /dev/sda1 /home/pi/nas ext4 defaults,noatime 0 0 # a swapfile is not a swap partition, no line here # use dphys-swapfile swap[on|off] for that 创建挂在目录：\npi@raspberrypi:~ $ mkdir /home/pi/nas 重启后查看挂载信息：\npi@raspberrypi:~ $ df Filesystem 1K-blocks Used Available Use% Mounted on /dev/root 29787900 1959324 26593012 7% / devtmpfs 469532 0 469532 0% /dev tmpfs 473864 0 473864 0% /dev/shm tmpfs 473864 12260 461604 3% /run tmpfs 5120 4 5116 1% /run/lock tmpfs 473864 0 473864 0% /sys/fs/cgroup /dev/mmcblk0p1 41322 20763 20559 51% /boot /dev/sda1 153705340 60864 145813600 1% /home/pi/nas 4.2. 文件共享 #Samba 可以实现树莓派上的文件在局域网内的共享。安装必要的文件：\npi@raspberrypi:~ $ sudo apt-get install samba samba-common-bin -y 如果分区是 NTFS 格式，需要安装 NTFS 支持：sudo apt-get install ntfs-3g 。如果是 exFAT 格式，则选用安装 exfat-utils 。\n创建共享文件夹 shares：\npi@raspberrypi:~ $ sudo mkdir /home/pi/nas/shares 编辑配置文件 /etc/samba/smb.conf ，替换成如下内容：\n[global] security = user encrypt passwords = true guest account = nobody map to guest = bad user #======================= Share Definitions ======================= [share] comment = Guest access shares path = /home/pi/nas/shares/ browseable = yes writable = yes #read only = yes guest ok = yes public = yes [NAS-Data] comment = Nas data folder path = /home/pi/nas/ browseable = yes writable = yes valid users = root pi 需要为 samba 添加一个 pi 账户：\npi@raspberrypi:~/nas $ sudo smbpasswd -a pi New SMB password: Retype new SMB password: Added user pi. 重启 samba 服务，确保启动成功：\npi@raspberrypi:~/nas $ sudo systemctl restart smbd.service pi@raspberrypi:~/nas $ sudo systemctl status smbd.service ● smbd.service - LSB: start Samba SMB/CIFS daemon (smbd) Loaded: loaded (/etc/init.d/smbd) Active: active (running) since Mon 2017-04-10 19:17:04 CST; 2s ago Process: 5272 ExecStop=/etc/init.d/smbd stop (code=exited, status=0/SUCCESS) Process: 5122 ExecReload=/etc/init.d/smbd reload (code=exited, status=0/SUCCESS) Process: 5313 ExecStart=/etc/init.d/smbd start (code=exited, status=0/SUCCESS) CGroup: /system.slice/smbd.service ├─5324 /usr/sbin/smbd -D └─5329 /usr/sbin/smbd -D Apr 10 19:17:04 raspberrypi smbd[5313]: Starting SMB/CIFS daemon: smbd. Apr 10 19:17:04 raspberrypi systemd[1]: Started LSB: start Samba SMB/CIFS daemon (smbd). Apr 10 19:17:04 raspberrypi smbd[5324]: [2017/04/10 19:17:04.479386, 0] ../lib/util/become_daemon.c:124(daemon_ready) Apr 10 19:17:04 raspberrypi smbd[5324]: STATUS=daemon 'smbd' finished starting up and ready to serve connections 在 MAC 中打开 Finder \u0026gt; 前往 \u0026gt; 网络 ，就可以看到树莓派的共享文件夹，访问 share 共享目录无需密码，而 NAS-Data 需要密码验证：\n4.3. FTP 服务器 #在树莓派上安装 vsftpd ：\npi@raspberrypi:~ $ sudo apt-get install vsftpd 编辑配置文件 /etc/vsftpd.conf ，修改如下选项：\n#禁止匿名访问 anonymous_enable=NO #设定本地用户可以访问 local_enable=YES #设定可以进行写操作 write_enable=YES #设定上传后文件的权限掩码 local_umask=022 #设定根目录 local_root=/home/pi/ 用 ftp 客户端软件登录：\n5. 移植 UCI #UCI 是 OpenWRT 的一个配置工具，提供 C 语言 API 和 Shell 命令接口，可以方便的自定义配置文件。uci 的编译需要 CMake ，先安装 CMake ：\npi@raspberrypi:~ $ sudo apt-get install cmake 安装 libluajit-dev ，否则会出现 lauxlib.h: No such file or directory 这样的错误 :\npi@raspberrypi:~ $ sudo apt-get install libluajit-5.1-dev 通过 git 下载 uci 的源码包：\npi@raspberrypi:~ $ git clone https://github.com/jkjuopperi/uci.git 用 pkg-config 查询刚才的 libluajit-dev 的头文件目录：\npi@raspberrypi:~ $ pkg-config --cflags --libs luajit -I/usr/include/luajit-2.0 -lluajit-5.1 然后进入 uci 目录，在 CMakeLists.txt 文件中靠前位置添加如下一行，指定头文件目录，否则编译的时候找不到：\nINCLUDE_DIRECTORIES(\u0026quot;/usr/include/luajit-2.0/\u0026quot;) 保存后开始编译安装：\npi@raspberrypi:~/uci $ cmake . pi@raspberrypi:~/uci $ make pi@raspberrypi:~/uci $ sudo make install [ 27%] Built target uci-static [ 54%] Built target uci-shared [ 63%] Built target cli [ 72%] Built target cli-static [ 81%] Built target ucimap [ 90%] Built target ucimap-example [100%] Built target uci_lua Install the project... -- Install configuration: \u0026quot;\u0026quot; -- Installing: /usr/local/include/uci.h -- Installing: /usr/local/include/uci_config.h -- Installing: /usr/local/include/ucimap.h -- Installing: /usr/local/lib/libuci.so -- Installing: /usr/local/lib/libuci.a -- Installing: /usr/local/bin/uci -- Set runtime path of \u0026quot;/usr/local/bin/uci\u0026quot; to \u0026quot;\u0026quot; -- Installing: /usr/local/bin/uci-static -- Installing: /usr/local/lib/lua/5.1/uci.so -- Set runtime path of \u0026quot;/usr/local/lib/lua/5.1/uci.so\u0026quot; to \u0026quot;\u0026quot; 安装后需要执行一次 sudo ldconfig -v，否则可能找不到新装的库文件，uci 默认将配置文件放在 /etc/config 目录下，所以新建该目录，执行 uci ，如下表示安装成功：\npi@raspberrypi:~/uci $ uci Usage: uci [\u0026lt;options\u0026gt;] \u0026lt;command\u0026gt; [\u0026lt;arguments\u0026gt;] Commands: batch export [\u0026lt;config\u0026gt;] import [\u0026lt;config\u0026gt;] changes [\u0026lt;config\u0026gt;] commit [\u0026lt;config\u0026gt;] add \u0026lt;config\u0026gt; \u0026lt;section-type\u0026gt; add_list \u0026lt;config\u0026gt;.\u0026lt;section\u0026gt;.\u0026lt;option\u0026gt;=\u0026lt;string\u0026gt; show [\u0026lt;config\u0026gt;[.\u0026lt;section\u0026gt;[.\u0026lt;option\u0026gt;]]] get \u0026lt;config\u0026gt;.\u0026lt;section\u0026gt;[.\u0026lt;option\u0026gt;] set \u0026lt;config\u0026gt;.\u0026lt;section\u0026gt;[.\u0026lt;option\u0026gt;]=\u0026lt;value\u0026gt; delete \u0026lt;config\u0026gt;[.\u0026lt;section[.\u0026lt;option\u0026gt;]] rename \u0026lt;config\u0026gt;.\u0026lt;section\u0026gt;[.\u0026lt;option\u0026gt;]=\u0026lt;name\u0026gt; revert \u0026lt;config\u0026gt;[.\u0026lt;section\u0026gt;[.\u0026lt;option\u0026gt;]] reorder \u0026lt;config\u0026gt;.\u0026lt;section\u0026gt;=\u0026lt;position\u0026gt; Options: -c \u0026lt;path\u0026gt; set the search path for config files (default: /etc/config) -d \u0026lt;str\u0026gt; set the delimiter for list values in uci show -f \u0026lt;file\u0026gt; use \u0026lt;file\u0026gt; as input instead of stdin -L do not load any plugins -m when importing, merge data into an existing package -n name unnamed sections on export (default) -N don't name unnamed sections -p \u0026lt;path\u0026gt; add a search path for config change files -P \u0026lt;path\u0026gt; add a search path for config change files and use as default -q quiet mode (don't print error messages) -s force strict mode (stop on parser errors, default) -S disable strict mode -X do not use extended syntax on 'show' 6. Web 开发 #使用 Django + Nginx 搭建一个静态站点。\n6.1. 安装 Nginx #安装 nginx ，安装后会自动启动：\npi@raspberrypi:~ $ sudo apt-get install nginx pi@raspberrypi:~ $ systemctl status nginx.service â— nginx.service - A high performance web server and a reverse proxy server Loaded: loaded (/lib/systemd/system/nginx.service; enabled) Active: active (running) since Tue 2017-09-26 22:32:43 CST; 16h ago Main PID: 756 (nginx) CGroup: /system.slice/nginx.service â”œâ”€756 nginx: master process /usr/sbin/nginx -g daemon on; master_process on; â”œâ”€757 nginx: worker process â”œâ”€758 nginx: worker process â”œâ”€759 nginx: worker process â””â”€760 nginx: worker process 通过浏览器访问树莓派的 IP ，可以如下页面：\n6.2. 安装 Django #先安装 pip ：\npi@raspberrypi:~ $ curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py pi@raspberrypi:~ $ sudo python get-pip.py 然后安装 Django 框架：\npi@raspberrypi:~ $ sudo pip install django 6.3. 安装 uWSGI #安装 python-dev ，否则下一步安装 uwsgi 会失败：\npi@raspberrypi:~ $ sudo apt-get install python-dev 安装 uwsgi ：\npi@raspberrypi:~ $ sudo pip install uwsgi 新建一个 test.py 文件，写入如下代码：\n# test.py def application(env, start_response): start_response('200 OK', [('Content-Type','text/html')]) return [\u0026quot;Hello uWSGI\u0026quot;] # python2 保存后执行：\npi@raspberrypi:~ $ uwsgi --http :8000 --wsgi-file test.py 打开浏览器，访问 http://localhost_ip:8000 ，显示 Hello uWSGI，说明 Web client - uWSGI - Python 三个环节是畅通的：\n","date":"2017 May 9","permalink":"/posts/2017/05/09/","section":"Posts","summary":"0. 准备 # Raspberry Pi 3 Model B 32GB Class10 TF 卡（官方推荐 8GB 以上）和读卡器 5V2A USB 电源，比如 iPad 电源适配器 microUSB 电源线 HDMI 数据线 显示器 USB 键盘 1.","title":"RaspberryPi 3 使用笔记"},{"content":"1. 串口简介 #这里的串口是指美国电子工业联盟（EIA）制定的三种串行数据通信的接口标准， RS-232 、RS-485 和 RS422 ，RS-232 是单端信号全双工，RS-485 是差分信号半双工，RS-422 是差分信号全双工。差分信号的通信速率更高，通信距离更长，RS-232 的通信距离通常小于 15 米，而 RS-485 和 RS-422 可以达到 100 米以上。\n以 RS-232 为例，设计之初是用来连接调制解调器做传输之用，也因此它的脚位意义通常也和调制解调器传输有关。RS-232 的设备可以分为数据终端设备（DTE，Data Terminal Equipment, For example, PC）和数据通信设备（DCE，Data Communication Equipment）两类，这种分类定义了不同的线路用来发送和接受信号。一般来说，计算机和终端设备有DTE连接器，调制解调器和打印机有DCE连接器。标准的 232 接口有 25 针，不过常用的是 9 针的 DB-9 接口，信号定义如下：\n脚位 简写 意义 说明 Pin1 DCD Carrier Detect 调制解调器通知电脑有载波被侦测到。 Pin2 RXD Receiver 接收数据。 Pin3 TXD Transmit 发送数据。 Pin4 DTR Data Terminal Ready 电脑告诉调制解调器可以进行传输。 Pin5 GND Ground 地线。 Pin6 DSR Data Set Ready 调制解调器告诉电脑一切准备就绪。 Pin7 RTS Request To Send 电脑要求调制解调器将数据提交。 Pin8 CTS Clear To Send 调制解调器通知电脑可以传数据过来。 Pin9 RI Ring Indicator 调制解调器通知电脑有电话进来。 这个信号说明是从 DTE 设备的角度出发的，TXD、DTR 和 RTS 信号是由 DTE 产生的，RXD、DSR、CTS、DCD 和 RI 信号是由 DCE 产生的。\nRS-232 在发送数据时，并不需要另外使用一条传输线来发送同步信号，就能正确的将数据顺利发送到对方，因此叫做“异步传输”，简称UART（Universal Asynchronous Receiver Transmitter），不过必须在每一笔数据的前后都加上同步信号，把同步信号与数据混和之后，使用同一条传输线来传输。比如数据 11001010b 被传输时，数据的前后就需加入 Start(Low）以及 Stop（High）等两个比特，值得注意的是，Start信号固定为一个比特，但 Stop 停止比特则可以是 1、1.5 或者是 2 比特，由收发双方自行选择，但必须保持一致。常见的设置包括波特率、数据位、奇偶校验、停止位和流控制。\n波特率 (Baud) 表示串口的传输速率叫做波特率，指单位时间内传输符号的个数，在计算机上，通常一个符号就是一个比特，所有可以理解为 bit/s 。因为 5 的 ASCII 码是 01010101b，所以可以发送这个字符，然后用示波器测量出一个 bit 的周期，换算出波特率。典型的波特率是 300, 1200, 2400, 9600, 19200, 115200 等。 数据位 (Data) 表示一个数据帧中数据所占的长度，可以设置 5、6、7 或者 8 bit 。 奇偶校验 (Parity) 用来验证数据的正确性，一般不使用，如果使用，那么既可以做奇校验（Odd Parity）也可以做偶校验（Even Parity）。奇偶校验是通过修改每一发送字节（也可以限制发送的字节）来工作的。 停止位 (Stop)，是在每个字节传输之后发送的，它用来帮助接受信号方硬件重同步，可以设置 1、1.5 或者是 2 bit 。 流控制 (flow control) ，当需要发送握手信号或数据完整性检测时需要制定其他设置。可以使用特定的管脚信号组合 RTS/CTS 和 DTR/DSR ，这叫硬件流控制；或者不使用连接器管脚而在数据流内插入特殊字符 XON/XOFF ，称为软件流控制。 RS-232 的逻辑1(mark)的电平为-3～-15V，逻辑0(space)的电平为+3～+15V，注意电平的定义反相了一次。一个典型的数据帧：\n2. 串口操作 #Linux 中的串口设备文件通常是 /dev/ttyS0、/dev/ttyS1 \u0026hellip; ，使用 POSIX 终端控制接口编程，串口操作所需的头文件：\n#include \u0026lt;stdio.h\u0026gt; /*标准输入输出定义*/ #include \u0026lt;stdlib.h\u0026gt; /*标准函数库定义*/ #include \u0026lt;unistd.h\u0026gt; /*Unix 标准函数定义*/ #include \u0026lt;fcntl.h\u0026gt; /*文件控制定义*/ #include \u0026lt;termios.h\u0026gt; /*POSIX 终端控制定义*/ #include \u0026lt;errno.h\u0026gt; /*错误号定义*/ 2.1. 打开串口 #串口设备也是文件，可以用 open() 函数访问。可能遇到的问题是 Linux 系统禁止普通用户访问设备文件，解决方案包括修改设备文件的访问权限，用 root 用户运行程序，或者改变程序的 owner 。假设任何用户都可以访问设备文件，打开串口的代码如下：\nint open_port(void) { int fd; /* File descriptor for the port */ fd = open(\u0026quot;/dev/ttyS0\u0026quot;, O_RDWR | O_NOCTTY | O_NDELAY); if (fd == -1) perror(\u0026quot;open_port: Unable to open /dev/ttyS0\u0026quot;); else fcntl(fd, F_SETFL, 0); return (fd); } O_RDWR 表示可读可写；O_NOCTTY 表示不会将这个串口作为该进程的控制终端，如果没有设置这一项，程序会受到键盘控制信号的影响；O_NDELAY 表示无需等待对方串口准备完毕，也就是不会检查 DCD 信号，否则会一直等待 DCD 信号变为 space 。\n2.2. 读写串口 #调用 write() 函数向串口写数据即可实现发送：\nn = write(fd, \u0026quot;ATZ\\r\u0026quot;, 4); wirte() 函数返回成功发送的字节数，如果发送失败会返回 -1 。\n从串口读取数据稍显复杂。当串口配置为 raw 数据模式，如果串口的输入缓存区有数据，read() 函数调用会立即读取并返回；如果输入缓存区没有数据，read() 函数可能会阻塞，等待超时，或者返回错误。可以将 read() 函数设为非阻塞模式：\nfcntl(fd, F_SETFL, FNDELAY); 这样，如果没有收到数据，read() 会立即返回 0 。也可以改回阻塞模式：\nfcntl(fd, F_SETFL, 0); 2.3. 关闭串口 #调用 close() 函数关闭串口：\nclose(fd); 2.4. 一个简单的串口收发程序 #send.c ，发送一个字符串 “Hello World”。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main(int argc,char **argv) { int fd = 0; int ret = 0; char *device = \u0026quot;/dev/ttyS0\u0026quot;; char send_buf[20] = \u0026quot;Hello World\u0026quot;; int send_size = 0; fd = open(device,O_RDWR | O_NOCTTY | O_NDELAY ); //打开 ttyS0，默认为阻塞方式 if (fd == -1) perror(\u0026quot;open_port: Unable to open /dev/ttyS0\u0026quot;); else fcntl(fd, F_SETFL, 0);\tsend_size = strlen(send_buf); ret = write(fd,send_buf,send_size+1); //将字符串结尾的 \\0 也发送 if(ret \u0026lt; send_size) { printf(\u0026quot;write error\\n\u0026quot;); return -2; } printf(\u0026quot;Send %d characters\\n\u0026quot;,ret); write(fd,\u0026quot;\\n\u0026quot;,1); //最后发送一个换行符 close(fd);\treturn 0; } recv.c ，接收字符串，read 函数遇到回车或换行符才会返回。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main(int argc,char **argv) { int fd = 0; int ret = 0; char *device = \u0026quot;/dev/ttyS1\u0026quot;; char recv_buf[20]; int recv_size = 0; fd = open(device,O_RDWR | O_NOCTTY | O_NDELAY ); //打开 ttyS1，默认为阻塞方式 if (fd == -1) perror(\u0026quot;open_port: Unable to open /dev/ttyS1\u0026quot;); else fcntl(fd, F_SETFL, 0); recv_size = 20; ret = read(fd,recv_buf,recv_size); //阻塞的读取数据 if(ret \u0026lt; 0) { perror(\u0026quot;read error\u0026quot;); return -2; } printf(\u0026quot;Receive %d character: %s\\n\u0026quot;,ret,recv_buf); close(fd); return 0; } Makefile ：\nall:send recv send:send.c gcc -Wall -o $@ $\u0026lt; recv:recv.c gcc -Wall -o $@ $\u0026lt; clean: rm -rf send rm -rf recv 连接 ttyS0 和 ttyS1 ，首先执行 recv ，因为是阻塞方式，recv 会一直等待数据。然后在另一个终端执行 send ，接收函数就会显示接收到的字符串。\n3. 串口配置 #配置串口涉及到一个结构和两个函数，需要包含头文件 termios.h :\n#include \u0026lt;termios.h\u0026gt; #define NCCS 32 struct termios { tcflag_t c_cflag; //控制选项 tcflag_t c_iflag; //输入选项 tcflag_t c_oflag; //输出选项 tcflag_t c_lflag; //本地选项 cc_t c_line; cc_t c_cc[NCCS]; //控制字符 speed_t c_ispeed; //输入速率 speed_t c_ospeed; //输出速率 }; int tcgetattr(int fd, struct termios *termios_p); //获取当前配置，并保存到 termios_p 中 int tcsetattr(int fd, int option, const struct termios *termios_p); //将 termios_p 写入配置 tcsetattr() 函数的 option 参数可以选择三个常量：\nTCSANOW\t立即写入配置，无需等待数据传输完成 TCSADRAIN\t等待数据传输结束后再更改配置 TCSAFLUSH\t刷新输入输出缓存，然后再更改配置 3.1. 控制选项 #c_cflag 成员用于设置波特率、数据位、校验位、停止位和硬件流控制，下面是常用的宏，位于 bits/termios.h 头文件。\nCBAUD\t波特率的位掩码 B4800\t4800 baud B9600\t9600 baud B115200\t115,200 baud EXTA\tExternal rate clock EXTB\tExternal rate clock CSIZE\t数据位的位掩码 CS5\t5 data bits CS6\t6 data bits CS7\t7 data bits CS8\t8 data bits CSTOPB\t2 stop bits (1 otherwise) CREAD\t使能接收 PARENB\t使能校验位，默认为偶校验 PARODD\t设为奇校验 HUPCL\tHangup (drop DTR) on last close CLOCAL\tLocal line - do not change \u0026ldquo;owner\u0026rdquo; of port LOBLK\tBlock job control output CNEW_RTSCTS/CRTSCTS\t使能硬件流控制 (某些平台不支持) 在传统的POSIX编程中，当不连接一个本地的（通过调制解调器）或者远程的终端（通过调制解调器）时，这里有两个选项应当一直打开，一个是 CLOCAL ，另一个是 CREAD 。这两个选项可以保证你的程序不会变成端口的所有者，而端口所有者必须去处理发散性作业控制和挂断信号，同时还保证了串行接口驱动会读取过来的数据字节。\n下面一段代码将设置串口为 9600 8N1 ：\nstruct termios options; tcgetattr(fd,\u0026amp;options); options.c_cflag |= (CLOCAL|CREAD); options.c_cflag \u0026amp;= ~CBAUD; options.c_cflag |= B9600; options.c_cflag \u0026amp;= ~CSIZE; options.c_cflag |= CS8; options.c_cflag \u0026amp;= ~PARENB; options.c_cflag \u0026amp;= ~CSTOPB; tcsetattr(fd,TCSANOW,\u0026amp;options); 本地模式\nc_lflag 用于控制串口驱动怎样控制接收字符。常用的选项用如下几个。\nICANON\n用于设置接收字符的处理模式，如果设置了 ICANON 标志，就启动了标准行输入模式，接收的字符会被放入一个缓冲之中，这样可以用交互方式编辑缓冲的内容，直到收到CR(carriage return)或者LF(line feed)字符。进入该模式时，通常需要将 ECHO 和 ECHOE 选项打开：\noptions.c_lflag |= (ICANON | ECHO | ECHOE); 如果清除了 ICANON ，就启动了非标准模式。输入字符只是被原封不动的接收。进入该模式时，通常要关闭 ECHO 、ECHOE 和 ISIG 选项：\noptions.c_lflag \u0026amp;= ~(ICANON | ECHO | ECHOE | ISIG); ECHO\n使能输入字符回显。设置该标识后，接收到字符后会自动将字符返回到发送端。\n下面的程序中，为接收端的串口设置了该标识，发送端 write 之后立即 read ，可以读到回显的字符，回显的字符中有一个 ^@ ，表示字符串结尾的空字符，这是因为设置了 ECHOCTL 标识，以 ^char 的方式回显控制字符。\nsend.c：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;termios.h\u0026gt; int main(int argc,char **argv) { int fd = 0; int ret = 0; char *device = argv[1]; char send_buf[20] = \u0026quot;0123456789\u0026quot;; int send_size = 0; fd = open(device,O_RDWR | O_NOCTTY ); if(fd\u0026lt;=0) { printf(\u0026quot;open device error\\n\u0026quot;); return -1; } send_size = strlen(send_buf); ret = write(fd,send_buf,send_size+1); if(ret \u0026lt; send_size) { printf(\u0026quot;write error\\n\u0026quot;); return -2; } printf(\u0026quot;Send %d characters\\n\u0026quot;,ret); write(fd,\u0026quot;\\n\u0026quot;,1); //读取回显的字符 ret = 0; memset(send_buf,0x00,20); ret = read(fd,send_buf,20); if(ret \u0026gt; 0) { printf(\u0026quot;ret = %d\\n\u0026quot;,ret); printf(\u0026quot;%s\\n\u0026quot;,send_buf); }\tclose(fd); return 0; } read.c：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;termios.h\u0026gt; int main(int argc,char **argv) { int fd = 0; int ret = 0; char *device = argv[1]; char recv_buf[20]; int recv_size = 0; struct termios options;\tfd = open(device,O_RDWR | O_NOCTTY ); if(fd\u0026lt;=0) { printf(\u0026quot;open device error\\n\u0026quot;); return -1; } tcgetattr(fd,\u0026amp;options); options.c_lflag |= ICANON; options.c_lflag |= ECHO | ECHOCTL; tcsetattr(fd,TCSANOW,\u0026amp;options); recv_size = 12; ret = read(fd,recv_buf,recv_size); if(ret \u0026lt; 0) { perror(\u0026quot;read error\u0026quot;); return -2; } printf(\u0026quot;Receive %d character: %s\\n\u0026quot;,ret,recv_buf); close(fd); return 0; } 连接 ttyS0 和 ttyS1 ，在第一个终端执行 ./read /dev/ttyS0，在第二个终端执行 ./send /dev/ttyS1 可以看到如下结果：\nSend 11 characters ret = 13 0123456789^@ 如果清除 ECHOCTL 标识，执行的结果如下：\nSend 11 characters ret = 12 0123456789 **注意，**如果通讯双方都设置了 ECHO 标识，可能会陷入互相回显的死循环。\n其他选项\nISIG\t使能 SIGINTR, SIGSUSP, SIGDSUSP, 和 SIGQUIT 信号 XCASE\tMap uppercase \\lowercase (obsolete) ECHOE\tEcho erase character as BS-SP-BS ECHOK\t接收到 kill 字符后回显一个换行符。 ECHONL\t回显换行符(0x0A) NOFLSH\tDisable flushing of input buffers after interrupt or quit characters IEXTEN\tEnable extended functions ECHOPRT\tEcho erased character as character erased ECHOKE\tBS-SP-BS entire line on line kill FLUSHO\tOutput being flushed PENDIN\tRetype pending input at next read or input char TOSTOP\tSend SIGTTOU for background output 输入模式\nc_iflag 用于控制接收的数据在传递给程序之前的处理方式。\n使能奇偶校验\n如果在 c_cflag 中设置了奇偶校验位，就要在这里使能奇偶校验：\noptions.c_iflag |= (INPCK | ISTRIP); INPCK 表示使能奇偶校验，ISTRIP 表示将数据中的奇偶校验位剥离。\n使能软件流控制\n软件流控制可以通过IXON，IXOFF和IXANY常量设置成有效：\noptions.c_iflag |= (IXON | IXOFF | IXANY); XON(start data)和XOFF(stop data)字符在c_cc数组中定义，关于软件流控制的详细内容在后面介绍。\n其他选项\nIGNPAR\tIgnore parity errors PARMRK\tMark parity errors IXON\tEnable software flow control (outgoing) IXOFF\tEnable software flow control (incoming) IXANY\tAllow any character to start flow again IGNBRK\tIgnore break condition BRKINT\tSend a SIGINT when a break condition is detected INLCR\tMap NL to CR IGNCR\tIgnore CR ICRNL\tMap CR to NL IUCLC\tMap uppercase to lowercase IMAXBEL\tEcho BEL on input line too long 输出模式\nc_oflag 用于控制由程序发送的数据在传递给串口或屏幕之前做怎样的处理。很多处理方式和输入模式是相对。\n要使用输出模式必须设置 OPOST 标识，否则其他标识都会被忽略，数据会以原始形式发送。\noptions.c_oflag |= OPOST; OPOST\tPostprocess output (not set = raw output) OLCUC\tMap lowercase to uppercase ONLCR\tMap NL to CR-NL OCRNL\tMap CR to NL NOCR\tNo CR output at column 0 ONLRET\tNL performs CR function OFILL\tUse fill characters for delay OFDEL\tFill character is DEL NLDLY\tMask for delay time needed between lines NL0\tNo delay for NLs NL1\tDelay further output after newline for 100 milliseconds CRDLY\tMask for delay time needed to return carriage to left column CR0\tNo delay for CRs CR1\tDelay after CRs depending on current column position CR2\tDelay 100 milliseconds after sending CRs CR3\tDelay 150 milliseconds after sending CRs TABDLY\tMask for delay time needed after TABs TAB0\tNo delay for TABs TAB1\tDelay after TABs depending on current column position TAB2\tDelay 100 milliseconds after sending TABs TAB3\tExpand TAB characters to spaces BSDLY\tMask for delay time needed after BSs BS0\tNo delay for BSs BS1\tDelay 50 milliseconds after sending BSs VTDLY\tMask for delay time needed after VTs VT0\tNo delay for VTs VT1\tDelay 2 seconds after sending VTs FFDLY\tMask for delay time needed after FFs FF0\tNo delay for FFs FF1\tDelay 2 seconds after sending FFs 控制字符\n控制字符都是一些字符组合，例如 Ctrl+C 。当用户键入这些组合键时，终端会采取一些特殊的处理方式。termios 结构中的 c_cc 数组成员将控制字符映射到对于的支持函数。控制字符的位置用一个宏定义（即数组下标）。\nc_cc 中的控制字符的数组下标：\n常量键字符描述 VINTRCTRL-C VQUITCTRL-Z VERASEBackspase VKILLCTRL-U VEOFCTRL-D VEOLCTRL-D VSTARTCTRL-Q VSTOPCTRL-S VTIME VMIN VTIME 和 VMIN\n只有在非标准输入模式或者没有通过open(2)和fcntl(2)函数传递NDELAY选项时，这两个值才有效。二者结合起来控制对输入的读取。\n4. 流控制 #5. UART、RS-232 与 TTL #逻辑1(mark)的电平为-3～-15V，逻辑0(space)的电平为+3～+15V，注意电平的定义反相了一次。\n参考 #The Serial Programming Guide for POSIX Operating Systems\n","date":"2017 March 27","permalink":"/posts/2017/03/27/","section":"Posts","summary":"1. 串口简介 #这里的串口是指美国电子工业联盟（EIA）制定的三种串行数据通信的接口标准， RS-232 、RS-485 和 RS422 ，RS-232 是单端信号全双工，RS-485 是差分信号半双工，RS-422 是差分信号全双工。差分信号的通信速率更高，通信距离更长，RS-232 的通信距离通常小于 15 米，而 RS-485 和 RS-422 可以达到 100 米以上。","title":"Linux 串口编程笔记"},{"content":"Zmodem 是跨平台的文件传输协议，可以很方便的在不同的操作系统之间接传输文件。lzrsz 是该协议的实现方式：https://ohse.de/uwe/software/lrzsz.html 。安装后，在 Mac 的 ITerm2 中用 SSH 登陆远程的 Linux 主机，然后用 rz 、sz 命令传输文件。\n在 Ubuntu 中安装:\n$ sudo apt-get install lrzsz 在 Mac 中安装：\n$ brew install lrzsz 为方便 ITerm2 中使用，需要下载两个脚本：\ncd /usr/local/bin sudo wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-send-zmodem.sh sudo wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-recv-zmodem.sh sudo chmod 777 /usr/local/bin/iterm2-* 然后打开 ITerm2 ，点击 preferences \u0026gt; profiles ，选中 Default ，在右侧的 Advanced 标签页中，点击 Tirggers 框的 Edit 按钮，按如下设置添加两个条目：\nRegular expression Action Parameters Instant rz waiting to receive.**B0100 Run Silent Coprocess /usr/local/bin/iterm2-send-zmodem.sh checked **B00000000000000 Run Silent Coprocess /usr/local/bin/iterm2-recv-zmodem.sh checked 向远程 Linux 主机发送文件：\n在 Ubuntu 上执行 rc 在弹出的对话框中选中要发送的文件 等待发送完成 接收远程 Linux 发来的文件：\n在 Ubuntu 上执行 sz filename1 filename2 ... 在弹出的对话框中选中接收文件的目录 等待接收完成。 iterm2-send-zmodem.sh 内容：\n#!/bin/bash # Author: Matt Mastracci (matthew@mastracci.com) # AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script # licensed under cc-wiki with attribution required # Remainder of script public domain osascript -e 'tell application \u0026quot;iTerm2\u0026quot; to version' \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026amp; NAME=iTerm2 || NAME=iTerm if [[ $NAME = \u0026quot;iTerm\u0026quot; ]]; then FILE=`osascript -e 'tell application \u0026quot;iTerm\u0026quot; to activate' -e 'tell application \u0026quot;iTerm\u0026quot; to set thefile to choose file with prompt \u0026quot;Choose a file to send\u0026quot;' -e \u0026quot;do shell script (\\\u0026quot;echo \\\u0026quot;\u0026amp;(quoted form of POSIX path of thefile as Unicode text)\u0026amp;\\\u0026quot;\\\u0026quot;)\u0026quot;` else FILE=`osascript -e 'tell application \u0026quot;iTerm2\u0026quot; to activate' -e 'tell application \u0026quot;iTerm2\u0026quot; to set thefile to choose file with prompt \u0026quot;Choose a file to send\u0026quot;' -e \u0026quot;do shell script (\\\u0026quot;echo \\\u0026quot;\u0026amp;(quoted form of POSIX path of thefile as Unicode text)\u0026amp;\\\u0026quot;\\\u0026quot;)\u0026quot;` fi if [[ $FILE = \u0026quot;\u0026quot; ]]; then echo Cancelled. # Send ZModem cancel echo -e \\\\x18\\\\x18\\\\x18\\\\x18\\\\x18 sleep 1 echo echo \\# Cancelled transfer else /usr/local/bin/sz \u0026quot;$FILE\u0026quot; -e -b sleep 1 echo echo \\# Received $FILE fi iterm2-recv-zmodem.sh 内容：\n#!/bin/bash # Author: Matt Mastracci (matthew@mastracci.com) # AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script # licensed under cc-wiki with attribution required # Remainder of script public domain osascript -e 'tell application \u0026quot;iTerm2\u0026quot; to version' \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026amp; NAME=iTerm2 || NAME=iTerm if [[ $NAME = \u0026quot;iTerm\u0026quot; ]]; then FILE=`osascript -e 'tell application \u0026quot;iTerm\u0026quot; to activate' -e 'tell application \u0026quot;iTerm\u0026quot; to set thefile to choose folder with prompt \u0026quot;Choose a folder to place received files in\u0026quot;' -e \u0026quot;do shell script (\\\u0026quot;echo \\\u0026quot;\u0026amp;(quoted form of POSIX path of thefile as Unicode text)\u0026amp;\\\u0026quot;\\\u0026quot;)\u0026quot;` else FILE=`osascript -e 'tell application \u0026quot;iTerm2\u0026quot; to activate' -e 'tell application \u0026quot;iTerm2\u0026quot; to set thefile to choose folder with prompt \u0026quot;Choose a folder to place received files in\u0026quot;' -e \u0026quot;do shell script (\\\u0026quot;echo \\\u0026quot;\u0026amp;(quoted form of POSIX path of thefile as Unicode text)\u0026amp;\\\u0026quot;\\\u0026quot;)\u0026quot;` fi if [[ $FILE = \u0026quot;\u0026quot; ]]; then echo Cancelled. # Send ZModem cancel echo -e \\\\x18\\\\x18\\\\x18\\\\x18\\\\x18 sleep 1 echo echo \\# Cancelled transfer else cd \u0026quot;$FILE\u0026quot; /usr/local/bin/rz -E -e -b sleep 1 echo echo echo \\# Sent \\-\\\u0026gt; $FILE fi ","date":"2017 January 10","permalink":"/posts/2017/01/10/","section":"Posts","summary":"Zmodem 是跨平台的文件传输协议，可以很方便的在不同的操作系统之间接传输文件。lzrsz 是该协议的实现方式：https://ohse.","title":"在 ITerm2 中使用 Zmodem 协议传输文件"},{"content":"0. Package Control #用于下载、管理插件的插件，安装方法见项目主页。有时安装后会出现 “There are no packages available for installation” 这样的错误，这是因为无法下载插件资源列表文件。解决方法是在菜单栏中选择 Preferences \u0026gt; Package Settings \u0026gt; Package Control \u0026gt; Settings-User ，在打开的配置文件中添加：\n\u0026quot;channels\u0026quot;: [ \u0026quot;https://gist.githubusercontent.com/stanwu/679f8af0c9a43f800974/raw/5e3561bfb8b3ddc92680052c89e73c7dabc92f94/channel_v3.json\u0026quot;, \u0026quot;https://web.archive.org/web/20150905194312/https://packagecontrol.io/channel_v3.json\u0026quot; ], 1. Predawn #一款为Sublime和Atom打造的暗色主题，可以定义Tab的大小，SideBar大小，Find栏大小，并提供主题同款的ICON。\n安装后重启 Sublime Text ，通过菜单栏 Preferences -\u0026gt; Settings 打开用户配置文件，添加：\n\u0026quot;theme\u0026quot;: \u0026quot;predawn-DEV.sublime-theme\u0026quot;, //软件 UI 主题 \u0026quot;color_scheme\u0026quot;: \u0026quot;Packages/Predawn/predawn.tmTheme\u0026quot;, //编辑器配色 \u0026quot;font_size\u0026quot;: 15, \u0026quot;predawn_findreplace_small\u0026quot;: true, //查找对话框设为最小 \u0026quot;predawn_sidebar_small\u0026quot;: true, //侧边栏设为最小 \u0026quot;predawn_tabs_active_underline\u0026quot;: true, //使能当前标签页高亮 \u0026quot;predawn_tabs_small\u0026quot;: true, //标签页设为最小 更多选项可以在项目主页查看。\n2. SideBarFolder #打开的文件夹都太多了，可以用这个来管理，安装后会在菜单栏多一个 Folders 。\n3. SideBarEnhancements #扩展右键选项：\n4. SublimeAStyleFormatter #简单好用的代码格式化工具。安装后，对文件点击鼠标右键，会出现格式化选项，可以全文件格式化，也可以对选中的文本格式化：\n也可以在配置文件中设置快捷键，最好打开保存时自动格式化：\n// Auto format on file save \u0026quot;autoformat_on_save\u0026quot;: true, 5. Terminal #在当前文件夹内打开 Terminal 。安装后，对文件或者目录点鼠标右键，会出现 Open Terminal Here\u0026hellip; ：\n必须在配置文件中设置打开 Terminal 的命令，对于在 Mac OS 中的 iTerm2 打开新的标签页，可以这样设置：\n\u0026quot;terminal\u0026quot;: \u0026quot;iTerm.sh\u0026quot;, \u0026quot;parameters\u0026quot;: [\u0026quot;--open-in-tab\u0026quot;] 对于 iTerm2 V3 ：\n\u0026quot;terminal\u0026quot;: \u0026quot;iTerm2-v3.sh\u0026quot; 6. Alignment #选中后按 command+control+a 就可以使其按照等号对其:\n7. C Improved #C 语言语法高亮插件。安装后打开一个 C 源文件，在菜单栏中选中 C Improved ：\n8. Ctags #寻找函数和变量的定义。安装插件后还要在系统中安装 Ctags ：\nbrew install ctags 默认安装在 /usr/local/bin/ctags 。在配置文件中添加命令路径和参数：\n\u0026quot;command\u0026quot;: \u0026quot;/usr/local/bin/ctags -R\u0026quot;, 然后在对源码目录右键选择 Rebuild Tags ，生成索引文件：\n之后再函数上悬停鼠标，就会出现该函数定义的位置，点击可进入：\n或者右键选择 Navigate to Definition :\nJump Back 可以跳回调用处。默认快捷键是 control+shift+左键 跳转到定义处，control+shift+右键 跳回来。\n9. made-of-code-themes #Markdown 语法高亮配色。下载后解压到包目录下，然后打开一个 Markdown 文件，在菜单中选择语法配置：\n在打开的 Markdown 配置文件中添加该配色文件的路径：\n10. OmniMarkupPreviewer #实时预览 Markdown 文件。对 Markdown 文件右键就会出现在浏览器中预览、导出 HTML 文件等选项：\n快捷键：\ncommand+option+O: Preview Markup in Browser. command+option+X: Export Markup as HTML. command+option+C: Copy Markup as HTML. 11. FileHeader #自动为源码文件生成头部注释。可以自定义注释内容，自动识别各种语言的文件。\n12. Pretty JSON #格式化 JSON ，用法是选中 JSON 格式的文本，然后按快捷键是 cmd+ctrl+j，也可以直接按快捷键对全文件格式化。\n13. HTML-CSS-JS prettify #可以格式化 HTML、CSS 和 JS 文本。安装后，选中需要格式化的文本，按快捷键 cmd+shift+h 即可完成格式化。\n参考 # Sublime Text：学习资源篇：http://www.jianshu.com/p/d1b9a64e2e37 ","date":"2017 January 7","permalink":"/posts/2017/01/07/","section":"Posts","summary":"0. Package Control #用于下载、管理插件的插件，安装方法见项目主页。有时安装后会出现 “There are no packages available for installation” 这样的错误，这是因为无法下载插件资源列表文件。解决方法是在菜单栏中选择 Preferences \u0026gt; Package Settings \u0026gt; Package Control \u0026gt; Settings-User ，在打开的配置文件中添加：","title":"Sublime Text 3 常用插件"},{"content":"Markdown 语法解决了文本编辑时，内容与样式分离的问题，让我们更专注于内容，少在排版上浪费时间。\nCmd Markdown 这款编辑器扩展了 Markdown 语法，实现了很多实用的功能：\n实时同步预览 编程语言高亮，显示行号 支持绘制表格、流程图、甘特图 支持 LaTeX 公式 支持段落批注 支持 Vim 编辑模式 可导出 Html 和 PDF 文件 支持云端同步存储 提供 Linux、Windows、Mac 桌面端编辑器和 Web 端编辑器 ","date":"2016 December 24","permalink":"/posts/2016/12/24/","section":"Posts","summary":"Markdown 语法解决了文本编辑时，内容与样式分离的问题，让我们更专注于内容，少在排版上浪费时间。","title":"推荐一款 Markdown 编辑器"},{"content":"这里的无线（Wireless）指无线局域网，它的通用标准是 IEEE 802.11 协议，定义了数据链路层（MAC层）和物理层协议，工作载波的频率为 2.4GHz ，划分了 11 个频道，最新的协议已经有 5GHz 的工作频率。协议的演进方向是 802.11a-\u0026gt;802.11b-\u0026gt;802.11g-\u0026gt;802.11n 。\n而 802.11i 是 802.11 的无线安全协议，它的技术实现是 WPA 和 WPA2 ，都是开放秘钥认证方式，都属于 Wi-Fi 联盟，WPA2 是比 WPA 更高级的一种安全方式，RSN 是 WPA2 的别名。PSK 和 802.1X 是两种无线安全实现的方式，PSK 是个人级别的，而 802.1X 是企业级别的，较为复杂，但更安全。TKIP 和 CCMP 是两种数据加密算法，在 WPA 和 WPA2 中都可以使用。而 AES 是 CCMP 算法中的核心算法，且目前来看，是最可靠的加密算法。\nWi-Fi 是一个厂商联盟的标志，目的是建立一个统一的、基于 IEEE 802.11 协议的技术实现。可以简单把 Wi-Fi 设备理解为符合 IEEE 802.11 协议标准的设备。\nLinux 系统中的无线网卡通常用到两种模式，一种是 Station 模式，也就是作为普通 Wi-Fi 设备去连接无线路由器；另一种是 AccessPoint（AP）模式，就是让无线网卡作为 Wi-Fi 热点，供其他 Wi-Fi 设备连接，这需要用到 hostapd ，可以参考 http://shaocheng.li/post/blog/2016-01-01， 这里主要讲 Station 模式下无线网卡的操作方式。关于无线操作模式：http://shaocheng.li/post/blog/2012-10-27-wireless-oprating-mode 。\n1. 硬件和驱动 #大部分无线网卡是 pci 设备，以 Intel 6205 为例，在 Fedora 21 中查看：\n[root@localhost ~]# lspci 00:00.0 Host bridge: Intel Corporation Atom Processor Z36xxx/Z37xxx Series SoC Transaction Register (rev 0c) ... 01:00.0 Network controller: Intel Corporation Centrino Advanced-N 6205 [Taylor Peak] (rev 34) 04:00.0 Ethernet controller: Intel Corporation 82574L Gigabit Network Connection [root@localhost ~]# lspci -vk -s 01:00.0 01:00.0 Network controller: Intel Corporation Centrino Advanced-N 6205 [Taylor Peak] (rev 34) Subsystem: Intel Corporation Centrino Advanced-N 6205 AGN Flags: bus master, fast devsel, latency 0, IRQ 268 Memory at 90700000 (64-bit, non-prefetchable) [size=8K] Capabilities: [c8] Power Management version 3 Capabilities: [d0] MSI: Enable+ Count=1/1 Maskable- 64bit+ Capabilities: [e0] Express Endpoint, MSI 00 Capabilities: [100] Advanced Error Reporting Capabilities: [140] Device Serial Number 10-0b-a9-ff-ff-b4-99-00 Kernel driver in use: iwlwifi Kernel modules: iwlwifi 可以看到它使用的驱动是 iwlwifi ，这是当前 Intel 无线芯片的通用驱动，针对不同的芯片需要不同的固件，固件名称的格式是 iwlwifi-*.ucode ，存放在 /lib/firmware/ 目录下。在这个页面可以查看支持的芯片和固件下载列表：https://wireless.wiki.kernel.org/en/users/drivers/iwlwifi 。Linux 内核对无线设备的支持也是分层的结构，最上层面向用户空间的接口标准有两个，nl80211 和 wext ，nl80211 正在逐步替代 wext 。我们可以在 /sys/module/iwlwifi/parameters/ 目录下读取驱动的各项参数：\n/sys/module/iwlwifi/parameters# ls -l total 0 -r--r--r-- 1 root root 4096 Nov 29 10:03 11n_disable -r--r--r-- 1 root root 4096 Nov 29 10:03 amsdu_size_8K -r--r--r-- 1 root root 4096 Nov 29 10:03 antenna_coupling -r--r--r-- 1 root root 4096 Nov 29 10:03 bt_coex_active -r--r--r-- 1 root root 4096 Nov 29 10:03 fw_restart -r--r--r-- 1 root root 4096 Nov 29 10:03 led_mode -r--r--r-- 1 root root 4096 Nov 29 10:03 nvm_file -r--r--r-- 1 root root 4096 Nov 29 10:03 power_level -r--r--r-- 1 root root 4096 Nov 29 10:03 power_save -r--r--r-- 1 root root 4096 Nov 29 10:03 swcrypto -r--r--r-- 1 root root 4096 Nov 29 10:03 wd_disable 如果要修改某个参数，需要在 /etc/modprobe.d/ 目录下新建一个 iwlwifi.conf 文件，然后添加选项，比如禁用 11n ：\n/etc/modprobe.d# cat iwlwifi.conf options iwlwifi 11n_disable=1 修改后重新加载驱动，或者重启，就可以在 /sys/module/iwlwifi/parameters 目录下验证该选项是否已经被修改：\n/sys/module/iwlwifi/parameters# cat 11n_disable 1 驱动和固件加载成功后，就会出现设备文件：\n[root@localhost ~]# iw dev phy#0 Interface wlp1s0 ifindex 3 wdev 0x1 addr 10:0b:a9:b4:99:00 type managed 可以看到，这个无线设备的名称是 phy#0 ，接口名称是 wlp1s0 ，addr 段就是 mac 地址，当前的设备类型是 managed ，也就是 station 模式。用 ifconfig -a 也可以看到。\n可以通过内核信息查询当前加载的固件版本：\n[root@localhost ~]# dmesg | grep iwlwifi [27592.118803] iwlwifi 0000:03:00.0: Direct firmware load for iwlwifi-7265D-19.ucode failed with error -2 [27592.118837] iwlwifi 0000:03:00.0: Direct firmware load for iwlwifi-7265D-18.ucode failed with error -2 [27592.118890] iwlwifi 0000:03:00.0: Direct firmware load for iwlwifi-7265D-17.ucode failed with error -2 [27592.128638] iwlwifi 0000:03:00.0: loaded firmware version 16.242414.0 op_mode iwlmvm 2. iw 工具 #iw 是一个管理无线设备的命令行工具，使用 nl80211 接口标准，支持所有最新被添加到 Linux 内核的无线网卡驱动。旧的 iwconfig 工具使用 wext 接口标准。\n用 iw list 命令可以列出当前系统中所有无线设备的功能特性。如果要看指定网卡的特性，语法是 iw devicename info ：\n[root@localhost ~]# iw phy#0 info Wiphy phy0 max # scan SSIDs: 20 max scan IEs length: 195 bytes Coverage class: 0 (up to 0m) Device supports RSN-IBSS. Supported Ciphers: * WEP40 (00-0f-ac:1) * WEP104 (00-0f-ac:5) * TKIP (00-0f-ac:2) * CCMP (00-0f-ac:4) Available Antennas: TX 0 RX 0 Supported interface modes: * IBSS * managed * AP * AP/VLAN * monitor ... Supported commands: * new_interface * set_interface * new_key * start_ap * new_station * new_mpath ... software interface modes (can always be added): * AP/VLAN * monitor ... Device supports TX status socket option. Device supports HT-IBSS. Device supports scan flush. 这个信息很长，首先看到最多可以扫描 20 个热点，支持的加密算法是 WEP 、TKIP、CCMP。在 Supported interface modes 段可以看到该网卡支持的模式，包括 AP ，在 software interface modes 可以看到该网卡支持软 AP 。在 Supported commands 段列出了该网卡支持的命令，这些都是 nl80211 接口提供的命令，可以在 Linux 内核的 nl80211.c 文件中看到。\n运行 iw dev wlp1s0 scan 可以扫描 Wi-Fi 热点，前题是接口已经激活，可以用 ifconfig wlp1s0 up ，否则会失败：\n[root@localhost ~]# iw dev wlp1s0 scan command failed: Network is down (-100) 以扫描到的一个热点为例：\nBSS f4:ec:38:30:bb:b8(on wlp1s0) TSF: 2459924068 usec (0d, 00:40:59) freq: 2437 beacon interval: 100 TUs capability: ESS Privacy ShortPreamble ShortSlotTime (0x0431) signal: -51.00 dBm last seen: 1 ms ago SSID: TP-LINK_30BBB8 Supported rates: 1.0* 2.0* 5.5* 11.0* 6.0 9.0 12.0 18.0 DS Parameter set: channel 6 RSN: * Version: 1 * Group cipher: CCMP * Pairwise ciphers: CCMP * Authentication suites: PSK * Capabilities: 1-PTKSA-RC 1-GTKSA-RC (0x0000) WPA: * Version: 1 * Group cipher: CCMP * Pairwise ciphers: CCMP * Authentication suites: PSK ERP: \u0026lt;no flags\u0026gt; ... 可以读到几个有用的信息，首先是信号强度 signal:-51.00 dBm ，热点的 SSID 是 TP-LINK_30BBB8 ，使用的频道是 6 ，认证方式是 WPA 和 RSN （即 WPA2），秘钥管理算法是 PSK ，加密算法是 CCMP 。\niw 支持手动连接无认证或者 WEP 认证的 Wi-Fi 热点，而不支持 WPA/WPA2 认证热点。如果要加入无认证的热点，执行 iw wlp1s0 connect \u0026lt;SSID\u0026gt; 。对于 WEP 认证的热点，执行 iw wlp1s0 connect \u0026lt;SSID\u0026gt; [key 0:abcde d:1:6162636465] 。连接成功后，可以设置静态 IP ，也可以用 dhclient 动态获取 IP 和 DNS 。我们很少用 iw 来连接 Wi-Fi ，通常是用 wpa_supplicant 。\n还有一个在调试时有用的命令 iw event ，它可以监听 Wi-Fi 连接过程中的所有事件。当启动 wpa_supplicant 去连接一个热点时，可以开启该命令，它会显示完整的连接过程，包括扫描、协商、验证、连接。加一个 -f 选项可以显示连接过程发送的帧，加 -t 选项可以显示每个步骤的时间：\n[root@localhost ~]# iw event -t 1478053617.986731: wlp1s0 (phy #0): scan started 1478053619.947956: wlp1s0 (phy #0): scan finished: 2412 2417 2422 2427 2432 2437 2442 2447 2452 2457 2462 2467 2472 5180 5200 5220 5240 5260 5280 5300 5320 5745 5765 5785 5805 5825, \u0026quot;\u0026quot; 1478053619.977751: wlp1s0: new station f4:ec:38:30:bb:b8 1478053619.988617: wlp1s0 (phy #0): auth f4:ec:38:30:bb:b8 -\u0026gt; 10:0b:a9:b4:99:00 status: 0: Successful 1478053620.043766: wlp1s0 (phy #0): assoc f4:ec:38:30:bb:b8 -\u0026gt; 10:0b:a9:b4:99:00 status: 0: Successful 1478053620.043992: wlp1s0 (phy #0): connected to f4:ec:38:30:bb:b8 查看连接状态：\n[root@localhost ~]# iw wlp1s0 link Not connected. [root@localhost ~]# iw wlp1s0 link Connected to f4:ec:38:30:bb:b8 (on wlp1s0) SSID: TP-LINK_30BBB8 freq: 2437 RX: 6256 bytes (46 packets) TX: 1435 bytes (15 packets) signal: -59 dBm tx bitrate: 1.0 MBit/s bss flags: short-preamble short-slot-time dtim period: 1 beacon int: 100 SSID 字段表示当前连接的热点名称。signal 字段表示当前连接热点的信号强度，它是个负数，越接近 0 ，表示信号越好，小于 -113 就基本没信号了。\n查看当前无线设备的使用情况，包括进出流量等信息：\n[root@localhost ~]# iw dev wlp1s0 station dump Station f4:ec:38:30:bb:b8 (on wlp1s0) inactive time: 175 ms rx bytes: 4635 rx packets: 31 tx bytes: 1095 tx packets: 11 tx retries: 49 tx failed: 2 signal: -68 dBm signal avg: -64 dBm tx bitrate: 1.0 MBit/s rx bitrate: 54.0 MBit/s MCS 3 40MHz authorized: yes authenticated: yes preamble: long WMM/WME: yes MFP: no TDLS peer: no iw 还有其他选项，可以执行 iw help 查看。\n3. wpa_supplicant #wpa_supplicant 是一个命令行式的 Wi-Fi 访问客户端程序，支持 WEP、WPA/WPA2 认证方式，在 Linux 中用于自动连接 Wi-Fi 热点，支持断线后自动重连。同时支持 nl80211 和 wext 两种驱动接口。\n常用选项：\n-B ：让 wpa_supplicant 运行在后台，在 -i 选项前设置。 -c filename ：配置文件的路径，在 -i 选项前设置。 -D ：设置使用的驱动，可选 nl80211 和 wext 等，在 -i 选项前设置。 -i interface ：监听的无线设备接口名称，这里可以设为 wlp1s0 。 -d ：增加调试信息，-dd 可以显示更多。 -t ：在调试信息中加上时间戳。 -f filename ：日志文件的路径。 -P filename ：PID 文件的路径。 -q ：减少调试信息，-qq 可以显示的更少。 -u ：使能 DBus 控制接口。 -N ：如果有多个无线设备，就用 -N 分隔，之后继续设置下一个。例如 wpa_supplicant -c wpa1.conf -i wlan0 -D hostap -N -c wpa2.conf -i ath0 -D madwifi 配置文件通常是 /etc/wpa_supplicant/wpa_supplicant.conf ，可以在文件内设置多个 Wi-Fi 热点的连接信息，wpa_supplicant 启动后会自动选择一个最好的网络，依据是认证方式（ WPA/WPA2 优先）和信号强度。如果完整安装了 wpa_supplicant ，在 /usr/share/doc/wpa_supplicant/ 目录下会有一个 wpa_supplicant.conf 文件，里面有各种情况的详细配置和说明。说几个常用的全局配置选项：\nctrl_interface=filename ：设置控制接口的路径。如果设置了该参数，wpa_supplicant 会打开一个控制接口，供外部程序管理 wpa_supplicant 。推荐设置为 /var/run/wpa_supplicant ，wpa_supplicant 会在此目录下生成 socket ，用于监听外部程序状态的请求。 ap_scan ：通常设为 1 。由 wpa_supplicant 启动扫描和 AP 选择，如果没有找到与配置文件中相匹配的 AP ，则初始化一个新网络（如果有配置）。另外可选 0 或 2 。 每个 Wi-Fi 热点的连接信息都配置在一个 network 段中，几个常用的选项：\nkey_mgmt ：秘钥管理算法，对于 WPA/WPA2 ，根据 Wi-Fi 热点的配置可选 WPA-PSK 和 WPA-EAP 。 ssid ：热点的 ssid 。 psk ：对于 WPA/WPA2 ，密码不能设为明码，需要用 wpa_passphrase 命令生成加密后的 64 位十六进制数，语法是 wpa_passphrase SSID password 。 假如现在要连接一个 WPA/WPA2 认证的无线路由器，配置文件如下：\n[root@localhost ~]# wpa_passphrase TP-LINK_30BBB8 123456789 network={ ssid=\u0026quot;TP-LINK_30BBB8\u0026quot; #psk=\u0026quot;123456789\u0026quot; psk=b9ea0d09776bd4f4d8099b78ab91d924b97366562d620161a1b4ffb1ac99ae33 } [root@localhost ~]# cat /etc/wpa_supplicant/wpa_supplicant.conf ctrl_interface=/var/run/wpa_supplicant ap_scan=1 network={ ssid=\u0026quot;TP-LINK_30BBB8\u0026quot; key_mgmt=WPA-PSK #psk=\u0026quot;123456789\u0026quot; psk=b9ea0d09776bd4f4d8099b78ab91d924b97366562d620161a1b4ffb1ac99ae33 } 对于无许认证的热点，只设置 ssid 即可 ：\nnetwork={ ssid=\u0026quot;MYSSID\u0026quot; key_mgmt=NONE } 然后执行 wpa_supplicant 开始连接：\n[root@localhost ~]# wpa_supplicant -B -Dnl80211 -u -iwlp1s0 -c /etc/wpa_supplicant/wpa_supplicant.conf -f /var/log/wpa_supplicant.log -P /var/run/wpa_supplicant.pid 连接过程可以查看 log 文件，连接成功后可以设置静态 IP ，也可以用 dhclient 获得动态 IP 。\n4. dhclient #DHCP 协议是一种集中管理和自动分配 IP 地址的通信协议，使用 UDP 协议工作。DHCP 使用了租约的概念，即获得的 IP 地址的有效期。一次典型的 DHCP 工作周期分为发现、提供、请求、确认，如图：\n不再租用 IP 后，客户端应该向 DHCP 服务器发送一个请求以释放 DHCP 资源，并注销其IP地址。详情可以参考动态主机设置协议\ndhclient 是一个 DHCP 客户端程序，用于从 DHCP 服务器获取动态 IP ，默认支持 IPV4 ，也支持 IPV6 。成功获得 IP 后，程序会驻留在后台。常用的选项有：\n-lf ：lease 文件的路径，默认是 /var/lib/dhclient/dhclient.leases ，是成功获取 IP 后的数据库。 -pf ：PID 文件的路径，默认是 /var/run/dhclient.pid 。 -cf ：配置文件的路径. 默认是 /etc/dhcp/dhclient.conf 。 -sf ：网络配置脚本文件的路径。默认是 /sbin/dhclient-script ，成功获取 IP 后会执行该脚本，主要作用是配置 IP 、DNS、和默认路由，还会调用 /etc/dhcp/dhclient.d/ 下的用户自定义脚本。 -q ：保持安静，不输出任何信息。 -timeout ：超时时间，超过这个时间而无法获得 IP 即退出。 -r ：告诉 dhclient 释放获取的 IP ，释放后，后台的 dhclient 会退出。 -d ：让 dhclient 在前台运行。 配置文件默认是 /etc/dhcp/dhclient.conf，同目录下还有一个名为 dhclient.d 的文件夹，可以在下面放一些脚本，供 dhclient-script 调用，执行一下获取 IP 后的动作。如果安装了完整的程序，在 /usr/share/doc/dhclient 目录下会有配置文件的例子和 dhclient.d 下脚本文件的说明。\n针对 wlp1s0 这个接口写一个简单的配置文件：\ntimeout 60; retry 60; reboot 10; select-timeout 5; initial-interval 2; reject 192.33.137.209; interface \u0026quot;wlp1s0\u0026quot; { send host-name “my_pc\u0026quot;; send dhcp-lease-time 3600; request subnet-mask, broadcast-address, time-offset, routers,domain-search, domain-name, domain-name-servers, host-name; require subnet-mask, domain-name-servers,host-name; } 解释一下这些配置选项：\ntimeout ：超时时间，这里设置是 60 秒。从尝试与 DHCP server 联系开始，超过这个时间还没有获得 IP ，就结束这次协商，在重试间隔后再重启协商。 retry ：重试间隔，一次与 DHCP server 协商失败后，经过这个时间后重启协商，默认是五分钟。 reboot ：当 dhclient 启动后，它会首先尝试请求上一次连接该网络时获得的 IP ，如果失败，则经过这个时间后在尝试请求新 IP ，默认是十秒。 select-timeout ：如果有多个 DHCP server 为该网络提供服务，client 可能获得多个 IP 提议，而这些提议有先后顺序，client 会在 select-timeout 时间内接收提议，然后选择最优的（比如上一次获得的 IP ），超过这个时间，就停止接收新提议。默认是零秒，就是直接采用第一个接收到的提议。 initial-interval ：第一次尝试到达服务器和第二次尝试到达服务器的间隔。 reject ：拒绝来自某些 DHCP server 的提议。可以指定某个 IP ，也可以通过子网掩码指定拒绝某个网段，多个 IP 用逗号分隔，例如：reject 192.168.0.0/16, 10.0.0.5; 。 设置完全局选项，就可以对网口进行单独设置，这些选项可以在 dhcp-options 的 man 手册中查找。一个配置文件可以为多个网口配置不同的行为，语法是 interface \u0026quot;name\u0026quot; { declarations ... } ，name 就是网口名称，花括号内为它的配置选项：\nsend host-name ：向服务器发送本机的名称。 send dhcp-lease-time ：告诉服务器请求的 IP 租期，这里设置了 3600 秒。 request ：请求服务器向客户端发送指定选项的值，通常不用设置，缺省已经请求了很多必要选项。 require ：列出了必须向服务器发送的选项，以便接收要约，要发送的值用 send 语句设置。没有缺省值。 有了配置文件后，执行 dhclient 即可。与 DHCP server 协商成功后，会将获取的 IP 等信息保存到 dhclient.leases 文件，这是 DHCP client 租赁数据库，如果有多条数据，最后一天有效。\n[root@localhost ~]# cat /var/lib/dhclient/dhclient.leases default-duid \u0026quot;\\000\\001\\000\\001\\037\\234\\226n\\020\\013\\251\\264\\231\\000\u0026quot;; lease { interface \u0026quot;wlp1s0\u0026quot;; fixed-address 192.168.1.105; option subnet-mask 255.255.255.0; option routers 192.168.1.1; option dhcp-lease-time 7200; option dhcp-message-type 5; option domain-name-servers 192.168.1.1; option dhcp-server-identifier 192.168.1.1; renew 1 2016/10/24 08:59:57; rebind 1 2016/10/24 09:51:49; expire 1 2016/10/24 10:06:49; } 然后 dhclient 会调用 dhclient-script 文件，它的作用修改网口 IP 、修改默认路由、替换 /etc/resolv.conf 文件，还会调用 /etc/dhcp/dhclient.d/ 下的用户自定义脚本，详情可以查看 dhclient-script 的 man 手册。\n如果要是否释放 IP ，执行 dhclient -r 。\n最后补充一点，在目前的 Linux 发行版中，已经有集成化的网卡管理工具，比如 NetworkManager ，可以统一的管理以太网、Wi-Fi、3G等网卡设备，简化了很多步骤，比较方便，当然底层还是调用这些基本的程序。\n5. 国别代码问题 #不同的国家和地区对 Wi-Fi 的合法频段有不同的要求，Wi-Fi 模块都支持设置国别代码，使模块使用合法的频段。可以通过 iw 命令读取当前模块设置的国别代码与合法频段：\nroot@localhost:~# iw reg get country CN: DFS-FCC (2402 - 2482 @ 40), (N/A, 20), (N/A) (5170 - 5250 @ 80), (N/A, 23), (N/A) (5250 - 5330 @ 80), (N/A, 23), (0 ms), DFS (5735 - 5835 @ 80), (N/A, 30), (N/A) (57240 - 59400 @ 2160), (N/A, 28), (N/A) (59400 - 63720 @ 2160), (N/A, 44), (N/A) (63720 - 65880 @ 2160), (N/A, 28), (N/A) 在 Linux 系统里通常是通过配置文件这种相应的驱动参数：\nroot@localhost:~# cat /etc/default/crda # Set REGDOMAIN to a ISO/IEC 3166-1 alpha2 country code so that iw(8) may set # the initial regulatory domain setting for IEEE 802.11 devices which operate # on this system. # # Governments assert the right to regulate usage of radio spectrum within # their respective territories so make sure you select a ISO/IEC 3166-1 alpha2 # country code suitable for your location or you may infringe on local # legislature. See `/usr/share/zoneinfo/zone.tab\u0026#39; for a table of timezone # descriptions containing ISO/IEC 3166-1 alpha2 country codes. REGDOMAIN=CN root@localhost:~# cat /etc/modprobe.d/iwlwifi.conf # /etc/modprobe.d/iwlwifi.conf # iwlwifi will dyamically load either iwldvm or iwlmvm depending on the # microcode file installed on the system. When removing iwlwifi, first # remove the iwl?vm module and then iwlwifi. remove iwlwifi \\ (/sbin/lsmod | grep -o -e ^iwlmvm -e ^iwldvm -e ^iwlwifi | xargs /sbin/rmmod) \\ \u0026amp;\u0026amp; /sbin/modprobe -r mac80211 options iwlwifi lar_disable=1 root@localhost:~# cat /etc/modprobe.d/cfg80211.conf options cfg80211 ieee80211_regdom=\u0026#34;CN\u0026#34; 参考 # https://wireless.wiki.kernel.org man 手册 ","date":"2016 October 26","permalink":"/posts/2016/10/26/","section":"Posts","summary":"这里的无线（Wireless）指无线局域网，它的通用标准是 IEEE 802.","title":"Linux Wireless HowTo"},{"content":"Linux 中 3G 模块的层次结构：\n硬件模块就是 3G 模块，通常通过 USB 总线接入计算机。内核中的 3G 模块驱动可以在应用层生成串行设备，例如 ttyUSB*、ttyACM* 等。3G 模块的拨号连接过程遵循 ppp 协议，它提供了通过串行点对点链路传输数据报的方法，Linux 内核集成了 ppp 协议栈，pppd 程序是 ppp 协议在用户空间的守护进程，chat 程序负责通过串行设备与 pppd 之间的通信。\n1. 硬件和驱动 #大部分 3G 模块是挂在 USB 总线上，以 Telit HE910 模块为例，这是一个支持 WCDMA ，即联通 3G 的模块 ：\n[root@localhost ~]# lsusb Bus 001 Device 006: ID 09da:0260 A4Tech Co., Ltd. KV-300H Isolation Keyboard Bus 001 Device 005: ID 0424:2514 Standard Microsystems Corp. USB 2.0 Hub Bus 001 Device 004: ID 1bc7:0021 Telit Wireless Solutions HE910 Linux 系统包含一个通用的 USB 驱动 CDC_ACM，很多 3G 模块都用它来驱动，HE910 就是这样。驱动加载成功后会创建多个 tty 设备文件，其中两个比较重要：\n/dev/ttyACM0: PPP 连接和 AT 指令的通用接口 /dev/ttyACM3: AT 指令接口 不同的模块所用驱动可能不同，具体情况要查看模块的使用手册。Linux 内核要支持 ppp 协议，这已经是现在 Linux 的默认配置。\n2. AT 指令 #对 3G 模块执行 AT 指令用很多方式，最简单的是用 cat 和 echo 命令。例如，在一个终端执行 cat \u0026lt; /dev/ttyACM3，它会持续监听该端口的返回信息，然后在另一个终端用 echo 向 /dev/ttyACM3 发送 AT 指令，在 cat 中就可以看到返回：\n#Terminal 1 [root@localhost ~]# cat \u0026lt; /dev/ttyACM3 OK #Terminal 2 [root@localhost ~]# echo -en \u0026quot;AT\\r\u0026quot; \u0026gt; /dev/ttyACM3 常用的是 minicom ，可以用于交互调试：\n[root@localhost ~]# minicom -D /dev/ttyACM3 -b 115200 Welcome to minicom 2.7 OPTIONS: I18n Compiled on Aug 17 2014, 17:34:01. Port /dev/ttyACM3, 15:39:12 Press CTRL-A Z for help on special keys AT OK ATZ OK AT+CSQ +CSQ: 3,3 还用一个纯命令行工具 comgt ，可以很方便的集成到其他程序中，还支持脚本执行一系列 AT 指令，完成复杂的功能。一般 Linux 系统都没有安装，需要下载编译：https://sourceforge.net/projects/comgt/ 。 这有我写的一篇文档：http://shaocheng.li/post/blog/2015-09-09\nAT 指令分为两部分，一部分是通用标准的指令，各个模块都一样；另一部分是各厂商为自家模块自定义的扩展指令，详细信息可以查看模块的 AT 指令手册。以 HE910 为例，介绍几个常用指令。\nATZ ，软重启 3G 模块。\nAT+CGMI ，读取模块厂商：\nAT+CGMI Telit AT+CGMM ，读取模块名称：\nAT+CGMM HE910-D AT+CGSN ，读取模块的 IMEI：\nAT+CGSN 351579053301782 AT+CGMR ，读取模块的固件版本：\nAT+CGMR\u0026quot; 12.00.024 AT+CIMI ，查询 IMSI 。IMSI 是国际移动用户识别码，储存在 SIM 卡中，每张 SIM 卡都不一样，通常是十五位数字，由三段组成。前三位是国家代码（MCC，中国是 460）。之后的两位或者三位是移动网络代码（MNC)，用于标识不同的运营商网络，中国移动使用 00、02、07（不同的号码可以区分不同的号段），中国联通使用 01、06、09，中国电信使用 03、05、11，更多的可以查看这里。最后是用户识别码（MSIN），由运营商自定义。\nAT+CIMI 460019048517149 AT+CSQ ，获取信号强度，信号强度与是否插 SIM 卡无关：\nAT+CSQ +CSQ: 15,1 第一个数字表示信号轻度，取值0~31，数字越大信号越好，99 表示未知或不可检测，换算方式： CSQ 值=（接收信号强度 dBm + 113）/2 ：\nAT+CPIN? ，可以用来查看 SIM 卡是否插好，插好会返回 READY ：\nAT+CPIN? +CPIN: READY OK AT+CNUM ，查看电话号码，前提是号码已经存储在 SIM 中 ：\nAT+CNUM +CNUM: \u0026quot;\u0026quot;,\u0026quot;+8618589041260\u0026quot;,145 OK AT+WS46=[] ，选择无线网络,三个数字分别是 2G only、3G only、3G first 。\nAT#PSNT? ，查询当前的网络类型，返回的数据格式是 #PSNT: \u0026lt;mode\u0026gt;,\u0026lt;nt\u0026gt; ：\nAT#PSNT? #PSNT: 0,3 OK 数据的含义：\n\u0026lt;mode\u0026gt; 0 - PSNT unsolicited result code disabled 1 - PSNT unsolicited result code enabled \u0026lt;nt\u0026gt; - network type 0 - GPRS network 1 - EGPRS network 2 - WCDMA network 3 - HSDPA network 4 - unknown or not registered. AT#RFSTS ，读取当前的网络状态，数据比较多，具体含义需要查看手册：\nAT#RFSTS #RFSTS: \u0026quot;460 01\u0026quot;,10713,64,-4.5,-89,-80,A53F,02,-128,64,19,4,2,,17030E9,\u0026quot;460010892513284\u0026quot;,\u0026quot;CHN-UNICOM\u0026quot;,3,0 OK AT 指令可能返回错误代码，下面常见错误代码的含义：\nCME ERROR: 0\tPhone failure CME ERROR: 1\tNo connection to phone CME ERROR: 2\tPhone adapter link reserved CME ERROR: 3\tOperation not allowed CME ERROR: 4\tOperation not supported CME ERROR: 5\tPH_SIM PIN required CME ERROR: 6\tPH_FSIM PIN required CME ERROR: 7\tPH_FSIM PUK required CME ERROR: 10\tSIM not inserted CME ERROR: 11\tSIM PIN required CME ERROR: 12\tSIM PUK required CME ERROR: 13\tSIM failure CME ERROR: 14\tSIM busy CME ERROR: 15\tSIM wrong CME ERROR: 16\tIncorrect password CME ERROR: 17\tSIM PIN2 required CME ERROR: 18\tSIM PUK2 required CME ERROR: 20\tMemory full CME ERROR: 21\tInvalid index CME ERROR: 22\tNot found CME ERROR: 23\tMemory failure CME ERROR: 24\tText string too long CME ERROR: 25\tInvalid characters in text string CME ERROR: 26\tDial string too long CME ERROR: 27\tInvalid characters in dial string CME ERROR: 30\tNo network service CME ERROR: 31\tNetwork timeout CME ERROR: 32\tNetwork not allowed, emergency calls only CME ERROR: 40\tNetwork personalization PIN required CME ERROR: 41\tNetwork personalization PUK required CME ERROR: 42\tNetwork subset personalization PIN required CME ERROR: 43\tNetwork subset personalization PUK required CME ERROR: 44\tService provider personalization PIN required CME ERROR: 45\tService provider personalization PUK required CME ERROR: 46\tCorporate personalization PIN required CME ERROR: 47\tCorporate personalization PUK required CME ERROR: 48\tPH-SIM PUK required CME ERROR: 100\tUnknown error CME ERROR: 103\tIllegal MS CME ERROR: 106\tIllegal ME CME ERROR: 107\tGPRS services not allowed CME ERROR: 111\tPLMN not allowed CME ERROR: 112\tLocation area not allowed CME ERROR: 113\tRoaming not allowed in this location area CME ERROR: 126\tOperation temporary not allowed CME ERROR: 132\tService operation not supported CME ERROR: 133\tRequested service option not subscribed CME ERROR: 134\tService option temporary out of order CME ERROR: 148\tUnspecified GPRS error CME ERROR: 149\tPDP authentication failure CME ERROR: 150\tInvalid mobile class CME ERROR: 256\tOperation temporarily not allowed CME ERROR: 257\tCall barred CME ERROR: 258\tPhone is busy CME ERROR: 259\tUser abort CME ERROR: 260\tInvalid dial string CME ERROR: 261\tSS not executed CME ERROR: 262\tSIM Blocked CME ERROR: 263\tInvalid block CME ERROR: 527\tPlease wait, and retry your selection later (Specific Modem Sierra) CME ERROR: 528\tLocation update failure – emergency calls only (Specific Modem Sierra) CME ERROR: 529\tSelection failure – emergency calls only (Specific Modem Sierra) CME ERROR: 772\tSIM powered down 3. pppd #pppd 是 ppp 协议的守护进程，全称点对点协议守护进程。它的 man 手册提供了详细使用说明，这里有中文版：https://docs.oracle.com/cd/E56344_01/html/E54077/pppd-1m.html 。语法是：\npppd [option] 常用的选项：\ntty_name ：指定用于 ppp 拨号的串行设备，通常是 /dev/ 目录下的 tty 设备，对于 HE910 应该设为 /dev/ttyACM0 。 speed : 指定串口波特率，十进制数，常用的有9600、19200、115200、460800。 damand ：仅在有数据通信时启动链路，该选项隐含了 persist 选项。 persist ：连接终止后程序不退出，并尝试重新打开连接，也就是掉线重连。 debug ：启用连接调试工具。如果指定了此选项，则 pppd 将以可阅读格式记录所发送或接收的所有控制包的内容。 dump ：指定此选项后，pppd 会打印所有已经设置的选项的值。 crtscts ：使用硬件流量控制（即 RTS/CTS）来控制串行端口上的数据流。 lock ：为串行设备加锁，确保对设备的独占访问。 user username ：向对等方证明身份的用户名。 password password ： 向对等方证明身份的密码。 defaultroute ：拨号成功完成时，向系统路由表添加一个缺省路由。 usepeerdns ：向对等方请求最多两个 DNS 服务器地址。 nodetach ：设置该选项后，pppd 将保持前台运行，默认是后台运行。 logfile filename ：将日志信息附加到文件 filename 。 connect script ：使用由 script 指定的可执行文件或 shell 命令来设置串行设备。此脚本通常将使用 chat(1M) 程序拨打调制解调器并启动远程 PPP 会话。 disconnect script ：在 pppd 终止链路后，运行由 script 指定的可执行文件或 shell 命令。 call filename ：从 /etc/ppp/peers/ 下的 filename 文件中读取选项。上面这些选项可以在执行命令是设置，也可以放在 /etc/ppp/peers/ 目录下的自定义配置文件中，用 call 选项调用。 local_IP_address:remote_IP_address : 设置本地和/或远程接口 IP 地址。两者都可以省略，但冒号是必需的。IP 地址可以通过主机名来指定，也可以通过十进制点记法来指定，例如：:10.1.2.3。缺省本地地址是系统的第一个 IP 地址，除非提供了 noipdefault 选项。如果未在任何选项中指定远程地址，则将从对等方获取远程地址。因此，在简单情况下，此选项不是必需的。如果通过此选项指定了本地和/或远程 IP 地址，则 pppd 在 IPCP 协商中将不会接受来自对等方的不同值，除非分别指定了 ipcp-accept-local 和/或 ipcp-accept-remote 选项。 noipdefault : 禁用未指定本地 IP 地址时的缺省行为，即通过主机名确定本地 IP 地址（如果可行）。指定了此选项时，对等方在 IPCP 协商期间必须提供本地 IP 地址（除非在命令行上或选项文件中显式指定了该地址）。未指定该选项时，可能被设置缺省地址，而导致拨号失败，比如sent [IPCP ConfReq id=0x2 \u0026lt;addr 192.168.199.152\u0026gt; \u0026lt;ms-dns1 0.0.0.0\u0026gt; \u0026lt;ms-dns2 0.0.0.0\u0026gt;] 。 在 /etc/ppp/peers/ 下新建一个配置文件，命名为 wcdma ，内容如下：\n/dev/ttyACM0 115200 dump debug lcp-echo-failure 3 lcp-echo-interval 3 # user \u0026quot;card\u0026quot; # password \u0026quot;card\u0026quot; defaultroute ipcp-accept-local ipcp-accept-remote crtscts usepeerdns novj nobsdcomp novjccomp nopcomp noaccomp lock show-password logfile /var/log/pppd.log connect \u0026quot;/usr/sbin/chat -v -f /etc/ppp/peers/he910_connect\u0026quot; 对于 user 和 password ，电信 3G 是有用户名和密码的，移动和联通为空，所以最好不要设置，可以用井号注释掉，曾经遇到过随意设置这两个值后，连接被拒绝的情况。最后启动连接用的是 chat ，负责与 3G 模块的串口通信，拨打运营商的调制解调器，目的是建立 pppd 守护进程和远程 pppd 进程之间的连接，如果程序执行错误，会返回错误状态代码，代码的含义可以在 man 手册中查找。chat 通过 -f 选项指定一个脚本，脚本的内容就是执行一些 AT 指令设置拨号相关参数。这个脚本如何设置也可以在模块软件手册里找到，以 HE910 为例：\n[root@localhost ppp]# cat /etc/ppp/peers/he910_connect #!/bin/sh # init TIMEOUT 30 \u0026quot;\u0026quot; ATZ # Connection to the network '' AT+CGDCONT=1,\u0026quot;IP\u0026quot;,\u0026quot;3gnet\u0026quot; # Dial the number. OK ATD*99# # The modem is waiting for the following answer CONNECT '' AT+CGDCONT 指令是设置拨号的各项参数，第二个参数是设置 PDP 类型，IP 表示 Internet Protocol ；第三个参数是设置 APN （接入点名称），由运营商决定。 ATD 指令是设置拨号号码，这个值由运营商决定。 CONNECT 指令表示开始拨号，并等待回应。 下面是针对不同运营商的各项参数设置列表：\n运营商（ISP） APN 拨号号码 用户名 密码 中国联通 WCDMA (China Unicom) 3GNET *99# 空 空 中国电信 CDMA2000 (China Telecom) EVDO网络 空 #777 ctnet@mycdma.cn vnet.mobi 中国移动 TD-SCDMA (China Mobile) CMNET 981# 空 空 中国移动 GPRS (China Mobile) CMNET *99***1# 空 空 4G 模块拨号的设置都没有用户名和密码，拨号号码都用 *99# ，在拨号前要初始化模块，使用 AT^SYSCFG 或者 AT^SYSCFGEX 指令将网络连接顺序设为 LTE 优先。\n设置完毕后，执行 pppd call wcdma ，程序会自动到 /etc/ppp/peers/ 目录下调用名为 wcdma 配置文件，然后开始拨号，整个过程可以在日志文件中查看。拨号成功后会获得 IP 和 DNS ，DNS 保存在 /var/run/ppp/resolv.conf 文件中。之后会调用 /etc/ppp/ip-up 脚本文件 ：\n[root@localhost ppp]# cat /etc/ppp/ip-up #!/bin/bash # This file should not be modified -- make local changes to # /etc/ppp/ip-up.local instead PATH=/sbin:/usr/sbin:/bin:/usr/bin export PATH LOGDEVICE=$6 REALDEVICE=$1 [ -f /etc/sysconfig/network-scripts/ifcfg-${LOGDEVICE} ] \u0026amp;\u0026amp; /etc/sysconfig/network-scripts/ifup-post --realdevice ${REALDEVICE} ifcfg-${LOGDEVICE} /etc/ppp/ip-up.ipv6to4 ${LOGDEVICE} [ -x /etc/ppp/ip-up.local ] \u0026amp;\u0026amp; /etc/ppp/ip-up.local \u0026quot;$@\u0026quot; exit 0 这个脚本先执行了 ifup-post 脚本，作用是配置 IP ，默认路由等网络参数。然后执行了 ip-up.local 脚本，该脚本通常不存在，可以将 /usr/share/doc/ppp/scripts/ip-up.local.add 复制过来改名，这个脚本的作用是，如果在执行 pppd 时设置了 usepeerdns ，就用 /var/run/ppp/resolv.conf 替换当前的 DNS 。\n[root@localhost ppp]# cat ip-up.local.add # # This sample code shows you one way to modify your setup to allow automatic # configuration of your resolv.conf for peer supplied DNS addresses when using # the `usepeerdns' option. # # In my case I just added this to my /etc/ppp/ip-up.local script. You may need to # create an executable script if one does not exist. # # Nick Walker (nickwalker@email.com) # . /etc/sysconfig/network-scripts/network-functions if [ -n \u0026quot;$USEPEERDNS\u0026quot; -a -f /var/run/ppp/resolv.conf ]; then rm -f /var/run/ppp/resolv.prev if [ -f /etc/resolv.conf ]; then cp /etc/resolv.conf /var/run/ppp/resolv.prev rscf=/var/run/ppp/resolv.new grep domain /var/run/ppp/resolv.prev \u0026gt; $rscf grep search /var/run/ppp/resolv.prev \u0026gt;\u0026gt; $rscf if [ -f /var/run/ppp/resolv.conf ]; then cat /var/run/ppp/resolv.conf \u0026gt;\u0026gt; $rscf fi change_resolv_conf $rscf rm -f $rscf else change_resolv_conf /var/run/ppp/resolv.conf fi fi 4. wvdial #wvdial 是一个智能 ppp 拨号工具，替换了 chat ，简化了拨号的步骤，可以一步实现拨号、启动 pppd 、最终连接互联网。它带有一个配置工具 wvdialconf ，用于探测当前系统中 3G 模块的串口，然后生成一个配置文件 /etc/wvdial.conf 。还是以 HE910 为例，生成的配置文件：\n[root@localhost ~]# cat /etc/wvdial.conf [Dialer Defaults] Init2 = ATQ0 V1 E1 S0=0 \u0026amp;C1 \u0026amp;D2 +FCLASS=0 Modem Type = USB Modem ; Phone = \u0026lt;Target Phone Number\u0026gt; ISDN = 0 ; Username = \u0026lt;Your Login Name\u0026gt; Init1 = ATZ ; Password = \u0026lt;Your Password\u0026gt; Modem = /dev/ttyACM0 Baud = 460800 只需要修改账号、密码和拨号号码即可，注意要把前面的分号去掉：\n[root@localhost ~]# cat /etc/wvdial.conf [Dialer Defaults] Init2 = ATQ0 V1 E1 S0=0 \u0026amp;C1 \u0026amp;D2 +FCLASS=0 Modem Type = USB Modem Phone = *99# ISDN = 0 Username = \u0026quot;card\u0026quot; Init1 = ATZ Password = \u0026quot;card\u0026quot; Modem = /dev/ttyACM0 Baud = 460800 配置文件的其他选项可以查看 wvdial.conf 的 man 手册，这些参数最终会传递给 pppd 。然后执行 wvdial ：\n[root@localhost ~]# wvdial --\u0026gt; WvDial: Internet dialer version 1.61 --\u0026gt; Initializing modem. --\u0026gt; Sending: ATZ ATZ OK --\u0026gt; Sending: ATQ0 V1 E1 S0=0 \u0026amp;C1 \u0026amp;D2 +FCLASS=0 ATQ0 V1 E1 S0=0 \u0026amp;C1 \u0026amp;D2 +FCLASS=0 OK --\u0026gt; Modem initialized. --\u0026gt; Sending: ATDT*99# --\u0026gt; Waiting for carrier. ATDT*99# CONNECT --\u0026gt; Carrier detected. Waiting for prompt. ~[7f]}#@!}!}!} }8}\u0026quot;}\u0026amp;} } } } }#}$@#}%}\u0026amp;_}8[14][14]}'}\u0026quot;}(}\u0026quot;[1f]P~ --\u0026gt; PPP negotiation detected. --\u0026gt; Starting pppd at Thu Nov 3 17:36:51 2016 --\u0026gt; Pid of pppd: 3393 --\u0026gt; Using interface ppp0 --\u0026gt; local IP address 10.228.54.19 --\u0026gt; remote IP address 10.228.54.19 --\u0026gt; primary DNS address 210.21.196.6 --\u0026gt; secondary DNS address 221.5.88.88 默认会自动设置 default route 和 DNS 。如果没有自动替换 DNS ，应该是没有 /etc/ppp/ip-up.local 文件，可以复制一个过来。查看 pppd 进程，看看都执行了哪些参数：\n[root@localhost ~]# ps -ef | grep pppd root 955 954 0 09:02 pts/1 00:00:00 /usr/sbin/pppd 460800 modem crtscts defaultroute usehostname -detach user card noipdefault call wvdial usepeerdns idle 0 logfd 6 remotename 0 root 982 799 0 09:03 pts/0 00:00:00 grep --color=auto pppd [root@localhost ~]# route Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface default 0.0.0.0 0.0.0.0 U 0 0 0 ppp0 192.168.5.0 0.0.0.0 255.255.255.0 U 0 0 0 enp4s0 这个程序是前台运行的，用 Ctrl-C 键可以退出。\n","date":"2016 October 25","permalink":"/posts/2016/10/25/","section":"Posts","summary":"Linux 中 3G 模块的层次结构：","title":"Linux 3G Module HowTo"},{"content":"NetworkManager 是目前 Linux 系统中提供网络连接管理服务的一套软件，也支持传统的 ifcfg 类型配置文件。核心是 NetworkManager 守护进程，还提供了命令行工具 nmcli ，以及图形界面配置工具。NetworkManager 可用于以下连接类型：以太网、VLAN、网桥、绑定、成组、Wi-Fi、移动宽带（比如移动网络 3G）及 IP-over-InfiniBand。在这些连接类型中，NetworkManager 可配置网络别名、IP 地址、静态路由器、DNS 信息及 VPN 连接以及很多具体连接参数。最后，NetworkManager 通过 D-bus 提供 API，D-Bus 允许应用程序查询并控制网络配置及状态。\n启动、停止、查看 NetworkManager 服务：\n[root@localhost ~]# systemctl start|stop|restart|status NetworkManager NetworkManager 的配置文件和脚本保存在 /etc/sysconfig/ 目录中。大多数网络配置信息都保存在这里，VPN、移动宽带及 PPPoE 配置除外，这些配置保存在 /etc/NetworkManager/ 子目录中。例如，接口的具体信息是保存在 /etc/sysconfig/network-scripts/ 目录下的 ifcfg-* 文件中。全局设置使用 /etc/sysconfig/network 文件\n在命令行中，可以使用 nmcli 工具与 NetworkManager 进行交互。例如，修改了某个 ifcfg-* 文件后，需要手动载入，可以执行：\n[root@localhost ~]# nmcli connection load /etc/sysconfig/network-scripts/ifcfg-ifname 如果要重新载入全部配置文件，可以执行 ：\n[root@localhost ~]# nmcli connection reload 可以执行 nmcli help 查看该命令的语法，命令的各种参数都可以用 Tab 键补全。\n[root@localhost ~]# nmcli help Usage: nmcli [OPTIONS] OBJECT { COMMAND | help } OPTIONS -t[erse] 简洁输出 -p[retty] 美化输出 -m[ode] tabular|multiline 输出模式 -f[ields] \u0026lt;field1,field2,...\u0026gt;|all|common 指定字段输出 -e[scape] yes|no 指定分隔符 -n[ocheck] 不检测版本 -a[sk] 询问缺失参数 -w[ait] \u0026lt;seconds\u0026gt; 设置超时等待完成操作 -v[ersion] 显示版本 -h[elp] 获得帮助 OBJECT g[eneral] 常规管理 n[etworking] 全面的网络控制 r[adio] 无线网络管理 c[onnection] 网络连接管理 d[evice] 网络设备管理 a[gent] 网络代理管理 列出所有的网络设备：\n[root@localhost ~]# nmcli device show GENERAL.DEVICE: enp4s0 GENERAL.TYPE: ethernet GENERAL.HWADDR: 00:1D:F3:51:95:4D GENERAL.MTU: 1500 GENERAL.STATE: 100 (connected) GENERAL.CONNECTION: enp4s0 GENERAL.CON-PATH: /org/freedesktop/NetworkManager/ActiveConnection/0 WIRED-PROPERTIES.CARRIER: on IP4.ADDRESS[1]: ip = 192.168.5.242/24, gw = 0.0.0.0 IP6.ADDRESS[1]: ip = fe80::21d:f3ff:fe51:954d/64, gw = :: GENERAL.DEVICE: ttyACM3 GENERAL.TYPE: gsm GENERAL.HWADDR: (unknown) GENERAL.MTU: 0 GENERAL.STATE: 30 (disconnected) GENERAL.CONNECTION: -- GENERAL.CON-PATH: -- GENERAL.DEVICE: lo GENERAL.TYPE: loopback GENERAL.HWADDR: 00:00:00:00:00:00 GENERAL.MTU: 65536 GENERAL.STATE: 10 (unmanaged) GENERAL.CONNECTION: -- GENERAL.CON-PATH: -- 查看所有网络设备的状态：\n[root@localhost ~]# nmcli device status DEVICE TYPE STATE CONNECTION enp4s0 ethernet connected enp4s0 ttyACM3 gsm disconnected -- lo loopback unmanaged -- 查看所有的网络连接：\n[root@localhost ~]# nmcli connection show NAME UUID TYPE DEVICE enp4s0 f056272b-e28a-4e69-8264-af9fccfbf45d 802-3-ethernet enp4s0 可以看到，本机有一个以太网卡和一个 3G 网卡，只有以太网使能了连接，3G 网卡处于未连接状态。TYPE 字段表示连接类型，支持的值有：adsl, bond, bond-slave, bridge, bridge-slave, bluetooth, cdma, ethernet, gsm, infiniband, olpc-mesh, team, team-slave, vlan, wifi, wimax。可以在新建或者编辑连接时用 type 参数设置，按 Tab 键查看该列表，或查看 nmcli(1) man page 中的 TYPE_SPECIFIC_OPTIONS 列表。\nDEVICE 表示设备名称，如果是以太网或者WiFi，就是用 ifconfig -a 看到的名称。CONNECTION 表示连接名称，这是在连接配置文件的名称，这里的以太网配置文件是 ifcfg-enp4s0 。可以在新建连接时用 con-name 参数设置。\n1. 以太网 #新建一个以太网连接，使用动态 IP ：\n[root@localhost ~]# nmcli connection add type ethernet con-name connection-name ifname interface-name 这样会在 /etc/sysconfig/network-scripts/ 目录下生成一个 ifcfg-* 配置文件。使用以下命令激活以太网连接：\n[root@localhost ~]# nmcli con up my-office Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/5) 用如下命令可以查看该连接的详细信息：\n[root@localhost ~]# nmcli connection show enp4s0 2. 3G 网卡 #查看这个设备的详情：\n[root@localhost ~]# nmcli device show ttyACM3 GENERAL.DEVICE: ttyACM3 GENERAL.TYPE: gsm GENERAL.HWADDR: (unknown) GENERAL.MTU: 0 GENERAL.STATE: 30 (disconnected) GENERAL.CONNECTION: -- GENERAL.CON-PATH: -- 新建一个 3G 网卡的连接：\n[root@localhost ~]# nmcli connection add type gsm ifname ttyACM3 user 3gnet password 3gnet apn 3gnet Connection 'gsm-ttyACM3' (d15e8860-6dc1-4aa5-b579-b898e651a984) successfully added. 这会在 /etc/NetworkManager/system-connections/ 下生成一个配置文件，并且会自动连接，生成一个 ppp0 的网络设备：\n[root@localhost ~]# cat gsm-ttyACM3 [connection] id=gsm-ttyACM3 uuid=7561e339-43b7-4e7f-bc2c-5886b5a97afc interface-name=ttyACM3 type=gsm [gsm] number=*99# username=3gnet password=3gnet apn=3gnet [root@localhost ~]# nmcli device status DEVICE TYPE STATE CONNECTION enp4s0 ethernet connected enp4s0 ttyACM3 gsm connected gsm-ttyACM3 ppp0 unknown connected ppp0 lo loopback unmanaged -- ~]# nmcli connection show NAME UUID TYPE DEVICE ppp0 9e55469f-b362-4122-8031-aa18360a8d75 generic ppp0 gsm-ttyACM3 7561e339-43b7-4e7f-bc2c-5886b5a97afc gsm ttyACM3 enp4s0 f056272b-e28a-4e69-8264-af9fccfbf45d 802-3-ethernet enp4s0 要取消自动连接，需要将 autoconnect 设为 false ：\n[root@localhost ~]# nmcli connection modify gsm-ttyACM3 connection.autoconnect false [root@localhost ~]# cat /etc/NetworkManager/system-connections/gsm-ttyACM3 [connection] id=gsm-ttyACM3 uuid=86f38b5b-31e3-4250-8304-c94a8fe7ac29 interface-name=ttyACM3 type=gsm autoconnect=false [gsm] number=*99# username=3gnet password=3gnet apn=3gnet 3. WiFi #用如下命令查看可访问的 WiFi 热点：\n[root@localhost ~]# nmcli device wifi list * SSID MODE CHAN RATE SIGNAL BARS SECURITY SBSon Infra 4 54 Mbit/s 84 â–‚â–„â–†â–ˆ WPA1 WPA2 TP-LINK_3 Infra 1 54 Mbit/s 77 â–‚â–„â–†_ WPA2 readtime Infra 1 54 Mbit/s 70 â–‚â–„â–†_ WPA2 sbstest Infra 1 54 Mbit/s 59 â–‚â–„â–†_ WPA1 WPA2 Xiaomi Infra 1 54 Mbit/s 57 â–‚â–„â–†_ WPA2 wifi-360 Infra 6 54 Mbit/s 47 â–‚â–„__ WPA2 新建一个名为 wifi-con 的 WiFi 连接：\n[root@localhost ~]# nmcli connection add con-name wifi-con ifname wlp1s0 type wifi ssid TP-LINK_3 Connection 'wifi-con' (7c5ae676-a2c7-49df-a37b-d93787be2b72) successfully added. 设置加密方式为 WPA2 ，并设置密码：\n[root@localhost ~]# nmcli connection modify wifi-con wifi-sec.key-mgmt wpa-psk [root@localhost ~]# nmcli connection modify wifi-con wifi-sec.psk 87654321 激活该连接：\n[root@localhost ~]# nmcli connection up wifi-con Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/3) [root@localhost ~]# iwconfig lo no wireless extensions. enp4s0 no wireless extensions. wlp1s0 IEEE 802.11abgn ESSID:\u0026quot;TP-LINK_3\u0026quot; Mode:Managed Frequency:2.412 GHz Access Point: 64:09:80:64:2F:8E Bit Rate=1 Mb/s Tx-Power=15 dBm Retry short limit:7 RTS thr:off Fragment thr:off Encryption key:off Power Management:off Link Quality=44/70 Signal level=-66 dBm Rx invalid nwid:0 Rx invalid crypt:0 Rx invalid frag:0 Tx excessive retries:3 Invalid misc:20 Missed beacon:0 ","date":"2016 October 13","permalink":"/posts/2016/10/13/","section":"Posts","summary":"NetworkManager 是目前 Linux 系统中提供网络连接管理服务的一套软件，也支持传统的 ifcfg 类型配置文件。核心是 NetworkManager 守护进程，还提供了命令行工具 nmcli ，以及图形界面配置工具。NetworkManager 可用于以下连接类型：以太网、VLAN、网桥、绑定、成组、Wi-Fi、移动宽带（比如移动网络 3G）及 IP-over-InfiniBand。在这些连接类型中，NetworkManager 可配置网络别名、IP 地址、静态路由器、DNS 信息及 VPN 连接以及很多具体连接参数。最后，NetworkManager 通过 D-bus 提供 API，D-Bus 允许应用程序查询并控制网络配置及状态。","title":"NetworkManager 使用笔记"},{"content":"1. 简介 #BitBake 是用 Python 写的一个程序，它是 OpenEmbedded 构建系统时使用的生产工具，现在有很多嵌入式系统都是在使用，比如Yocto 、WindRiver Linux 等。它是一个多任务引擎，可以并行执行 shell 和 Python 任务，每个任务单元根据预定义的元数据来管理源码、配置、编译、打包，并最终将每个任务生成的文件集合成为系统镜像。例如要从源码构建一个 Linux 系统，需要搭建一个生产环境，然后依次生成 Grub、Kernel、各种库文件、各种可执行文件，然后集合到一个文件系统里。如果你玩过 LFS ，就会了解这个过程的复杂性。BitBake 存在的意义就是提供了一个高效的工具，将这个过程标准化、流程化。BitBake 与 GNU Make 的关系就像 GNU Make 之于 GCC ，运作方式也类似 GNU Make ，又有很多不同：\nBitBake 根据预先定义的元数据执行任务，这些元数据定义了执行任务所需的变量，执行任务的过程，以及任务之间的依赖关系，它们存储在 recipe(.bb)、append(.bbappend)、configuration(.conf)、include(.inc) 和 class(.bbclass) 文件中。 BitBake 包含一个抓取器，用于从不同的位置获取源码，例如本地文件、源码控制器(git)、网站等。 每一个任务单元的结构通过 recipe 文件描述，描述的信息有依赖关系、源码位置、版本信息、校验和、说明等等。 BitBake 包含了一个 C/S 的抽象概念，可以通过命令行或者 XML-RPC 使用，拥有多种用户接口。 几个概念：\nRecipe 。Recipe 文件是最基本的元数据文件，每个任务单元对应一个 Recipe 文件，后缀是 .bb ，这种文件为 BitBake 提供的信息包括软件包的基本信息（作者、版本、License等）、依赖关系、源码的位置和获取方法、补丁、配置和编译方法、如何打包和安装。 Configuration 。Configuration 文件的后缀是 .conf ，它会在很多地方出现，定义了多种变量，包括硬件架构选项、编译器选项、通用配置选项、用户配置选项。主 Configuration 文件是 bitbake.conf ，以 Yocto 为例，位于 ./poky/meta/conf/bitbake.conf ，其他都在源码树的 conf 目录下。 Classes 。Class 文件的后缀是 .bbclass ，它的内容是元数据文件之间的共享信息。BitBake 源码树都源自一个叫做 base.bbclass 的文件，在 Yocto 中位于 ./poky/meta/classes/base.bbclass ，它会被所有的 recipe 和 class 文件自动包含。它包含了标准任务的基本定义，例如获取、解压、配置、编译、安装、打包，有些定义只是框架，内容是空的。 Layers 。Layer 被用来分类不同的任务单元。某些任务单元有共同的特性，可以放在一个 Layer 下，方便模块化组织元数据，也方便日后修改。例如要定制一套支持特定硬件的系统，可以把与低层相关的单元放在一个 layer 中，这叫做 Board Support Package(BSP) Layer 。 Append 。Append 文件的后缀是 .bbappend ，用于扩展或者覆盖 recipe 文件的信息。BitBake 希望每一个 append 文件都有一个相对应的 recipe 文件，两个文件使用同样的文件名，只是后缀不同，例如 formfactor_0.0.bb 和 formfactor_0.0.bbappend 。命名 append 文件时，可以用百分号（%）来通配 recipe 文件名。例如，一个名为 busybox_1.21.%.bbappend 的 apend 文件可以对应任何名为 busybox_1.21.x.bb 的 recipe 文件进行扩展和覆盖，文件名中的 x 可以为任何字符串，比如 busybox_1.21.1.bb、busybox_1.21.2.bb \u0026hellip; 通常用百分号来通配版本号。 BitBake 命令的语法可以执行 bitbake -h 查看。-b 用于指定 recipe 文件，-c 用于指定要执行的任务，如果没有指定任务，会按照 recipe 文件完整的执行一次从获取源码到编译打包的过程。要编译一个名为 foo_1.0.bb 的包，可以执行：\n$ bitbake -b foo_1.0.bb 可以不用 -b ，而只写包的名字，不加下划线后的版本号和后缀，简化为：\n$ bitbake foo 如果要执行清除任务：\n$ bitbake foo -c clean 2. 工作流程 #运行 BitBake 的主要目的是生成一个东西，例如安装包、内核、链接库、或者一个完整的 Linux 系统启动镜像（包括 bootloader、kernel、根文件系统）。当然，你也可以通过使用 bitbake 命令的某些参数，只执行生成过程中的某个步骤，例如编译、获取或清除数据、或者只返回编译环境的信息。\n简单说一下使用 BitBake 生成系统镜像的的执行过程。\n2.1 分析基本元数据 #基本元数据由多个文件组成，包括 bblayers.conf 文件（定义项目所需的 layers）、每个 layer 的 layer.conf 文件、以及 bitbake.conf 文件。数据内容有如下几类：\nRecipes：特定软件包的详情。 Class Data：通用构建信息的抽象总结。 Configuration Data：针对特定机器的设置，相当于粘合剂，把所有软件集合到一起。 基本元数据都具有全局属性，所有它们对所有的 recipes 都有效。\n首先，BitBake 会先搜索当前工作目录下的 conf/bblayers.conf 文件。该文件包含一个 BBLAYERS 变量，它会列出所有项目所需的 layer 的目录。在 BBLAYERS 所列出的 layer 目录中，都会有一个 conf/layer.conf 文件，在这个文件中会有一个 LAYERDIR 变量，它记录了该 layer 的完整路径。这些 layer.conf 文件会自动构建一些关键的变量，例如 BBPATH 和 BBFILES 。BBPATH 记录了 conf 和 classes 目录下的 configuration 和 classes 文件的位置，BBFILES 则用于定位 .bb 和 .bbappdend 文件。如果找不到 bblayers.conf 文件，BitBake 会认为用户已经在环境变量中设置了 BBPATH 和 BBFILES 。\n其次，BitBake 会在 BBPATH 记录的位置中寻找 conf/bitbake.conf 文件。该配置文件包含了\n参考 #BitBake User Manual Yocto 实用笔记\n","date":"2016 September 12","permalink":"/posts/2016/09/12/","section":"Posts","summary":"1. 简介 #BitBake 是用 Python 写的一个程序，它是 OpenEmbedded 构建系统时使用的生产工具，现在有很多嵌入式系统都是在使用，比如Yocto 、WindRiver Linux 等。它是一个多任务引擎，可以并行执行 shell 和 Python 任务，每个任务单元根据预定义的元数据来管理源码、配置、编译、打包，并最终将每个任务生成的文件集合成为系统镜像。例如要从源码构建一个 Linux 系统，需要搭建一个生产环境，然后依次生成 Grub、Kernel、各种库文件、各种可执行文件，然后集合到一个文件系统里。如果你玩过 LFS ，就会了解这个过程的复杂性。BitBake 存在的意义就是提供了一个高效的工具，将这个过程标准化、流程化。BitBake 与 GNU Make 的关系就像 GNU Make 之于 GCC ，运作方式也类似 GNU Make ，又有很多不同：","title":"BitBake 使用笔记"},{"content":"原文：Start Developing iOS Apps (Swift)\nTranslated by Bob\n2016-05-06\nBlog：http://shaocheng.li\n1. Get Start #1.1. Jump Right In #这是一个很好的 iPad/iPhone App 开发入门文档。这一系列课程可以逐步指导你写出第一个 App ，包括工具的使用、主要概念和实践。\n每一节课都包含一个教程和你需要了解的概念。带领你一步一步创建一个简单的可运行 iOS App 。\n在构建 APP 的过程中，你会学习到 iOS App 开发中所需的概念，更深入的理解 Swift 语言，了解到 Xcode 很多有用的特性。\n####About The Lessons\n在这些课程中，你将构建一个名叫 FoodTracker 的 App 。App 中会显示一份美食列表，包含美食的名称、评价和图片。用户可以添加一个新的美食、删除或者编辑已经存在的美食。添加或者编辑时，会进入一个新的页面，那里可以填写美食的名称、评价和图片。\n第一节课是 playground ，playground 是 Xcode 的一种文件，可以让你在编辑代码的同时，立即看到代码执行的结果。其余的课程都是 Xcode project 文件。每节课的结尾提供下载，你可以下载后检查。\n####Get the Tools\n要开发本课程中的 iOS App ，需要一个 Mac 电脑(OSX 10.10 以上版本），运行最新的 Xcode ，Xcode 包含了设计、开发和调试 iOS App 所需的所有特性。 Xcode 还包含 iOS SDK ，它提供了 iOS 开发中所需的工具、编译器和框架。\n本课程使用 Xcode 7.0 和 iOS SDK 9.0 。\n1.2. Learn the Essentials of Swift #####Swift Language\nThe Swift Programming Language 中文版\n####Swift and Cocoa Touch\nCocoa Touch 是开发 iOS App 的框架，Swift 可以与之无缝连接。本节课将帮助你了解怎样在 Swift 语言中使用 Cocoa Touch 。\n目前为止，你用到的都是来自 Swift 标准库的数据类型，例如 String 和 Array ：\nlet sampleString: String = \u0026quot;hello\u0026quot; let sampleArray: Array = [1, 2, 3.1415, 23, 42] 在 Xcode 中，按住 Option 键单击数据类型。\n要开发 iOS App，只有标准库是不够的。最常用的 iOS App 开发框架是 UIKit 。UIKit 包含了大量有用的 UI 类。\n要访问 UIKit ，先导入模块：\nimport UIKit 之后就可以用 Swift 语法调用 UIKit 的类型和方法：\nlet redSquare = UIView(frame: CGRect(x: 0, y: 0, width: 44, height: 44)) redSquare.backgroundColor = UIColor.redColor() 你会在后面的章节遇到很多 UIKit 的类。\n2. Building the UI #2.1. Build a Basic UI #本节课带你熟悉 Xcode 。你将熟悉 Xcode 项目的结构，并学习如何使用基本的项目控件。通过这节课，你要为 FoodTracker 制作一个简单的 UI ，就像下面这样：\n####Learning Objectives\n这节课的学习目标是：\n在 Xcode 中新建一个项目。 熟悉项目模板中主要文件的功能。 在 Xcode 中打开文件，并在各个文件之间切换。 在模拟器中运行 App 。 添加、移动 UI 元素，改变元素的尺寸。 编辑 UI 元素的属性。 用缩略图查看和重新布置 UI 元素。 预览 UI 界面。 更加用户设备的大小自动布局 UI 。 ####Create a New Project\nXcode 包含若干内建的 App 模板，支持常用的集中 iOS App ，例如 Game、Single View Application 。这些模板大部分已经配置好了界面和源码文件，本节课就是从最基础的 Single View Application 模板开始。\n打开 Xcode ，欢迎界面如下：\n如果没有出现欢迎界面，而是直接打开了项目窗口，不要紧张，可能之前已经创建或打开过一个项目，直接到一下步，通过菜单栏新建项目即可。\n在欢迎界面点击“Create a new Xcode project”，或者在菜单中选择 File \u0026gt; New \u0026gt; Project 。Xcode 会打开一个新窗口供你选择模板。\n在左边对话框中的 iOS 标签下选择 Application 。\n在主对话框中选择 Single View Application ，然后点击 Next 。\n在新出现的对话框中，设置 App 的名称和其他选项：\nProduct Name: FoodTracker 。App 的名称。 Organization Name: 公司或组织的名称，可以不填。 Organization Identifier: 公司或组织的标识码，可以不填。 Bundle Identifier: 该项是根据前两项的内容自动生成的。 Language: Swift Devices: Universal 。Universal 表示该 App 可以同时运行在 iPhone 和 iPad 。 Use Core Data: Unselected. Include Unit Tests: Selected. Include UI Tests: Unselected. 点击 Next 。\n在出现的对话框中，选择项目保存的位置，点击 Create 。Xcode 会在 workspace 窗口打开新建的项目。\n在 wrokspace 窗口，有可能看到一条警告信息 “No code signing identities found” ，意思你还没有用 Xcode 做过 iOS 开放，不要紧，这节课后，这条警告就会消失。\n####Get Familiar with Xcode\nXcode 拥有开放 App 所需的一切。它不仅组织了所有的项目文件，还提供了代码编辑器和 UI 控件，允许你创建和允许 App ，还提供了一个功能强大的调试器。\n花一点时间熟悉一下 Xcode workspace 的主界面。界面中的这些区域在接下来的课程中都会用到。不必完全掌握，在后面的课程中遇到时，会有详细讲解。\n####Run Simulator\n由于是基于模板新建的项目，基本的 App 环境以及自动生成了。即使你不写任何代码，也可以直接运行这个 Single View Application 模板。\n可以用 Simulator （模拟器）来运行 App ，它可以让你预览 App 运行在设备上的样子和行为交互。\nSimulator 可以模拟多种设备，例如各种尺寸的 iPhone、iPad 。本节课使用 iPhone 6 。\n在最上层 Toolbar 中的 Scheme 菜单中选择 iPhone 6 。Scheme 菜单用于设置 App 运行的设备。\n点击左上角的 Run 按钮。\n也可以选择 Product \u0026gt; Run ，或者直接按 Command-R 。\n如果是第一次运行 App ，Xcode 会询问你是否要打开 Mac 电脑的开发模式。开发模式下会允许 Xcode 访问 debug 特性时不用每次都输入密码。点击 Enable 。\n如果你选择了 Don\u0026rsquo;t Enable ，后面就要按提示输入密码。\n观察 Toolbar ，等待构建过程结束。Xcode 会在 Activity viewer 中显示构建过程的信息。\n构建完成后，Simulator 会自动运行。第一次需要花一点时间。\nSimulator 在 iPhone 6 模式下打开，然后在模拟出的 iPhone 中启动你的 App 。启动的过程中，会看到 App 的名字。\n然后，就会看到：\n现在，这个模板还没有任何内容，只显示一个空白界面。其他的模板会有更复杂的特性。理解各种模板的用途，对开发 App 是很重要的。\n快速启动 Simulator 可以选择 Simulator \u0026gt; Quit Simulator ，或者按 Command-Q 。\n####Review the Source Code\nSingle View Application 模板来自于几个源码文件，它们设置了 App 的环境。首先看一下 AppDelegate.swift 文件。\n在 navigator area 中打开 project navigator 。\nproject navigator 显示了该项目的所有文件。如果你的 project navigator 没有打开，在 navigator selector 中点击最左的按钮，或者选择 View \u0026gt; Navigators \u0026gt; Show Project Navigator 。\n点击 project navigator 中左边的倒三角可以展开所有文件。\n选择 AppDelegate.swift 。Xcode 会在 Editor area 中打开源码文件。\n或者双击 AppDelegate.swift ，在一个独立的窗口中打开。\nAppDelegate.swift 文件有两个主要的功能：\n为 App 提供入口，并运行了一个传递输入事件的循环。这项工作是由 UIApplicationMain 属性(@UIApplicationMain)完成的， 它位于文件开头处. UIApplicationMain 新建了一个 application 对象，它负责管理 App 的整个生命周期和 app delegate 对象。 定义 AppDelegate 类, 它是 app delegate 对象的类型。 app delegate 创建了 App 的窗口，提供了一个响应 App 状态转换的地方。你可以在 AppDelegate 类中写一些自定义的代码。 AppDelegate 类只包含一个属性：window ，app delegate 用这个属性跟踪 App 的窗口。window 是可选类型（optional），所有它可能没有值（nil）。\nvar window: UIWindow? AppDelegate 类还包含了几个重要的方法，这些方法用于 application 对象与 app delegate 进行对话。\nfunc application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -\u0026gt; Bool func applicationWillResignActive(application: UIApplication) func applicationDidEnterBackground(application: UIApplication) func applicationWillEnterForeground(application: UIApplication) func applicationDidBecomeActive(application: UIApplication) func applicationWillTerminate(application: UIApplication) 当 App 的状态发生变化时——例如启动、转入后台、退出—— application 对象就会调用 AppDelegate 中相应的方法做出回应。无需专门判断这些方法是否被调用，application 对象会帮你完成这个工作。\n这些方法模板都是空实现，可以在里面添加自定义的代码，当它们被调用时就会执行。这节课不会用到自定义的 appdelegate 代码，所有不用修改 AppDelegate.swift 文件。\nSingle View Application 模板还有一个源文件 ViewController.swift 。在项目导航器中选择 ViewController.swift 查看文件内容。\n这个文件中定义了一个 UIViewController 的子类 ViewController 。这个类继承了 UIViewController 的所有行为。要覆盖或者扩展这些行为，需要重写 UIViewController 中定义的方法（例如 ViewController.swift 中重写了 viewDidLoad() 和 didReceiveMemoryWarning() 方法），或者自定义新的方法。\n虽然模板自带了 didReceiveMemoryWarning() 方法，这节课并不会用到，所有删掉它。\n现在，你的 ViewController.swift 文件变成了：\nimport UIKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. } } 稍后会在这个文件中写你自己的代码。\n####Open Your Storyboard\n现在可以在 storyboard 上工作了。Storyboard 是 App 界面的虚拟表现，它展示了 App 屏幕上显示的内容和内容之间的交互关系。我们用 storyboard 设计 App 的界面和交互流程。你可以在设计过程中清楚的看到 App 的样子和交互关系，并且可以随时做出做出所见即所得的修改。\n在项目导航器中选择 Main.storyboard ，Xcode 就会在 Interface Builder 中打开 storyboard 。storyboard 的背景是空白的，可以在上面添加布置各种 UI 元素。\n现在这个 storyboard 上包含了一个场景，相当于你的 App 显示在手机屏幕上的样子。场景左边的那个箭头叫做 storyboard entry point ，表示这个场景是 App 启动时第一个加载的。现在这个场景只有一个界面，由 view controller 管理。你会学到更多关于 view 和 view controller 的使用规则。\n当你在 iPhone 6 模拟器上运行这个 App 时，这个场景上的界面就是最终在设备屏幕上看到的样子。但是会发现，这个场景的大小形状与 iPhone 6 的屏幕尺寸并不匹配。这是因为，这个场景是对于所有可支持设备的一般化表示，最终运行在具体设备上时，会自动调整到合适的尺寸。\n####Build the Basic UI\n现在可以开始构建基本的界面，做一个添加新菜的功能。\nXcode 提供了一个库，包含了按钮、文本框等可以添加到界面上的元素，还有一些不会显示出来的、定义 App 行为的元素，例如 view controller 和手势识别。\n出现在 UI 上元素被称作 view 。它们为用户呈现 App 的内容。view 还有多种內建的行为，包括在屏幕上显示自身，对用户输入做出反应。\niOS 中的 View 对象的类型都是 UIView 或它的子类。很多 UIView 子类都有自己独特的显示方式和行为。现在，我们在场景中添加一个文本域，它属于 UITextField 类。一个文本域允许用户输入一行文本，这里用它来输入一道菜的名字。\n打开对象库（Object library）。\n打开对象库的按钮位于右边的 utility area 。如果没有看到对象库，单击它的按钮，库选择条的左起第三个按钮。（或者在菜单中选择 View \u0026gt; Utilities \u0026gt; Show Object Library)\n会出现一个列表，列出了每个对象的名字、描述、图标。\n在对象库的 Filter field 中输入 text field 就可以找到它。\n将 text field 对象拖到场景中。\n可以在 Editor \u0026gt; Canvas \u0026gt; Zoom 中选择放大或缩小场景。\n把 text field 拖到场景上半部分，左边线对齐的位置。如图：\n蓝色的对齐线会帮助你定位。对齐线只有在拖动或改变对象大小是才能看到；当你放开对象时它就消失了。\n如果有必要，单击 text field ，激活 resize handle。\nResize handle 是出现在 UI 元素四周的白色小方框，拖动它可以改变元素的大小。通过单击元素可以该元素的 resize handle 。如下图这样，已经单击选中的元素可以改变大小。\n改变 text field 左右边框的位置，直到出现三条对齐线：左边对齐线、水平方向中心对齐线、右边对齐线。\n尽管场景上已经有了文本域，但是没有 help 信息告诉用户这里应该填什么。用 Text field 的 Placeholder 告诉用户在这里填入菜名。\n在 utility area 中打开 Text field 的属性检查器（Attributes inspector），在这里可以编辑 storyboard 中对象的属性。\n找到 Placeholder ，输入 Enter meal name 。\n按回车键就可以在文本域中看到刚才输入的文本。\n现在的界面是这样的：\n当用户选中文本域时会显示系统键盘，这里要配置一下系统键盘的属性，\n选中文本域。 在属性检查器中找到 Return Key 并选择 Done 。这个设置会将键盘的 Return 键改为 Done 键。 在属性检查器中勾选 Auto-enable Return Key 。这样的话，如果文本域中没有输入文本，用户是无法点击 Done 键的，这样可以确保用户不能设置空的菜名。 下一步，在场景顶部添加一个标签（UILabel）。标签没有交互，只能显示一段静态文本。为了帮助你理解怎样定义 UI 上元素之间的交互，你要配置这个标签，让它显示用户在文本域中输入的文字。这样可以练习如何获取并处理文本域中的输入信息。\n在对象库中输入 lable ，快速找到 Label 对象。\n把 Label 对象拖到场景中。\n把标签拖到文本域的左上方位置，左对齐，如图：\n双击标签，输入 Meal Name 。\n按回车键，新文本就会显示在标签中。\n场景变成了这个样子：\n现在，添加一个按钮（UIButton）。按钮是可交互的，所有，用户可以点击，然后触发定义好的事件。这里我们创建一个重置标签文本的事件。\n在对象库里输入 button 查找 Button 对象。\n把 Button 拖到场景中。\n将按钮拖到文本域的下方，左对齐，如图：\n双击按钮，输入 Set Default Label Text 。\n按回车显示新文本。\n此时，你的场景变成了这样：\n![](~/23-59-04.jpg) 在 Outline view 中可以看到已经添加到场景中的所有元素，帮助你理解这些元素是如何在场景中布置的。\n在 storyboard 中找到 Outline view 按钮：\n如果没有看到 Outline view ，请单击左下的 Outline view toggle 。 该按钮可以显示或隐藏 Outline view 。\nOutline view 可以让你看清 storyboard 中给个对象的层次关系。在这个等级结构中可看到文本域、标签、按钮。为什么你添加的这些元素都位于 View 下，而不是其他的 view ？\nview 不只是显示自己和接受用户输入，它们还可以作为其他 view 的容器。排列在这个等级结构中的 view 称作 view hierarchy 。它定义了 views 之间的布局关系。一个 view 里面的其他 views 叫做 subviews ，它的上一层 view 叫做 superview 。一个 view 可以有多个 subview ，但只能有一个 superview 。\n通常，每个场景都有自己的 view hierarchy 。每个 view hierarchy 的顶部是一个 content view 。现在这个场景中，content view 就是 View 。你在这个场景中添加的 view 都将是 View 的 subview 。\n####Preview Your Interface\n定期预览你的 App ，检查一下设计结果是否符合预期。用 assistant editor 可以在主编辑器傍边显示一个子编辑器，可以在这里预览 App 的用户界面。\n点击右上角的 Assistant 按钮打开 assistant editor 。\n如果想要更多的工作空间，可以在右上角的工具条中隐藏 Navigator 和 Utilities ，还可以隐藏 outline view 。\n在 assistant editor 顶部的选择器中选择 Automatic \u0026gt; Preview \u0026gt; Main.storyboard(Preview) 。\n在预览中可以看到，文本域的右边没有完全显示，超出了有边框。这是为什么？\n我们构建的是一个可以适应各种尺寸 iPhone 和 iPad 的界面。在 storyboard 中看到的是界面大概的样子。现在，需要设置这个界面上的元素在不同大小的屏幕上该如何调整。例如，当界面缩小到 iPhone 大小时，文本域也要相应的缩小。当界面放大道 iPad 大小时，文本域也要放大。可以用 Auto Layout 设置这些行为。\n####Adopt Auto Layout\nAuto Layout 是一个强大的布局引擎，可以帮助你轻松的设计兼容布局。你只需要告诉 Auto Layout 想要如何摆放场景中的元素，引擎就会自动以最优的方式实现你的意图。描述你的意图要用到 constraints ，使用它来描述元素的相对位置，元素的大小，元素之间的缩放关系。\n配合 Auto Layout 工作的工具是 stack view（UIStackView）。stack view 提供了一个高效的方式在水平或垂直方向排布多个元素。Stack view 让你借助 Auto Layout 的力量，创建可以适应设备方向、屏幕大小、或各种空间变化的 UI 。\n可以轻松的将已经存在的 UI 元素包含到一个 stack view ，然后设定必要的限制，使得 stack view 在各种情况下都能正确的显示。\n点击右上角的 Standard 按钮回到主编辑器。\n按住 Shift 键，同时选中文本域、标签和按钮。\n在画布的右下角选择 Stack 按钮。（或者选择 Editor \u0026gt; Embed In \u0026gt; Stack View)\nXcode 会将这些 UI 元素包含到一个 stack view 中。Xcode 会分析现在的布局，计算出这些元素应该沿垂直方向叠放。\n如果有必要，打开 Outline view ，选择 Stack View 对象。\n在属性检查器的 spacing 中输入 12 ，按回车。你会看到 UI 元素的纵向空间被拉长了。\n在画布右下角打开 Pin 菜单。\n在 “Spacing to nearest neighbor” 上方，点击选中两个横向限制和纵向顶部限制。选中后会变成红色。\n这些限制表示当前的 stack view 与周边 view 的边缘的距离。选中了 “Constrain to margins”，表示这些距离限制是相对于 margins 的，margins 是外边距，是 view 边缘外的一圈空白。\n在左右两个框中输入 0 ，在上面的框中输入 60 。\n在 Update Frames 下拉菜单中选择 Items of New Constraints 。如下图：\n在 Pin 菜单中点击 Add 3 Constraints 按钮。\n界面就会变成这个样子：\n你会注意到文本域并没有扩大到场景右边缘，下面解决这个问题。\n在 storyboard 中选中文本域。\n在画布的右下角打开 Pin 菜单。\n在 “Spacing to nearest neighbor” 上方，单击选中两个水平方向的限制，它们会变成红色。\n在左右两个框中输入 0 。\n在 Update Frames 下拉菜单中选择 Item of New Constraints ，如图：\n在 Pin 菜单中点击 Add 2 Constraints 按钮。\n选中文本域后，在 utility area 中打开 Size inspector 。你可以在这里编辑对象的大小和位置。\n在 Intrinsic Size 的下拉菜单中选择 Placeholder。它位于 Size inspector 的底部，你要往下翻才能看到。文本域的大小由它的内容决定，通过定义 Intrinsic content size 来设定内容的最小数量，内容用占位符（Placeholder）填充。这时，文本域的内容只是占位符组成的字符串，但是用户输入的内容可以比占位符更长。\n现在场景界面如下：\n检查时间：在模拟器中运行 App 。文本域完全不会超出屏幕边界了。你可以点击文本域内部，然后用键盘输入一些文本（可以按 Command-K 切换到软键盘）。如果旋转设备（Command-Left 或 Command-Right），或者在另一种设备上运行 App ，文本域会随着屏幕的变化而伸缩到合适的大小。注意，把屏幕横过来的时候状态栏会消失。\n如果没有得到你期望的结果，可以使用 Auto Layout 调试功能来解决问题。点击 Resolve Auto Layout Issues 图标，选择 Reset to Suggested Constraints ，Xcode 会将界面调整到一个合适的设定。或者点击 Resolve Auto Layout Issues 图标，选择 Clear Constraints，Xcode 会删除 UI 元素的所有限制，然后就可以重新设置。\n虽然没有在这个场景上做多少工作，但是已经有两基本的 UI 和功能。要确保你的布局是健壮的，并且可扩展，为后面的升级打下坚实的基础。\n","date":"2016 May 6","permalink":"/posts/2016/05/06/","section":"Posts","summary":"原文：Start Developing iOS Apps (Swift)","title":"Start Developing iOS Apps (Swift)"},{"content":"1. 简介 #晴天钟是一系列天气预测产品的总称，它们主要提取于美国国家大气海洋局/气候环境预测局(NOAA/NCEP)的“全球预测系统”(Global Forecast System, GFS)数值模式。由叶泉志开发，目前由中国科学院上海天文台中国天文科普网提供硬件及网络支持。\n2. 使用 #域名是 http://7timer.org ，IP 访问 http://202.127.24.18/ 。域名不太稳定，通常用 IP 访问 。由于它使用的是 Google 地图，所有要开启翻墙代理，还要选择英文，否则就看不到地图了。\n我通常用它来查看天文用途的天气预报。在地图上单击选点，然后选择 ASTRO ：\n就可以看到天文用途的三天天气预报：\n各种图标的含义：\n3. API #有两种 API ：图表 API 和程序 API 。\n图表 API #调用图表 API 将会返回类似晴天钟网站所见的预报图表，API 是一个 URL ，返回的图表为PNG格式，直接用浏览器访问如下 URL 即可：\nhttp://202.127.24.18/v4/bin/astro.php?lon=113.17\u0026amp;lat=23.09\u0026amp;ac=0\u0026amp;lang=en\u0026amp;unit=metric\u0026amp;output=internal\u0026amp;tzshift=0\n可以通过参数来控制返回结果，这些参数的含义：\nlon, lat - 指定地点的经纬度，必须是浮点数。 ac – 高度改正，只对天文用途预报有效。可取 0（默认）、2 或 7。只适用于图表 API。 lang – 语言，en 表示英文，zh-CN 表示中文。只适用于图表 API 。 unit – 公制或英制，metric/imperial 。对程序 API 无效。 output – 可设定为 internal（图表输出）、xml 或 json（程序 API ）。 tzshift – 时区微调，可取 0、1 或 -1。对程序 API 无效。 product – 为程序 API 选择产品，应为 astro（天文用途）, civil, civillight, meteo 或 two 。 程序 API #程序 API 若被成功调用，将会返回一系列数据。这些数据使用 XML 或 JSON 格式封装，其地址分别为：\nXML: http://202.127.24.18v4/bin/api.pl?lon=118.093\u0026amp;lat=24.468\u0026amp;product=astro\u0026amp;output=xml JSON: http://202.127.24.18/v4/bin/api.pl?lon=118.093\u0026amp;lat=24.468\u0026amp;product=astro\u0026amp;output=json\nproduct 设为 astro 时，会返回天文用途的数据，返回值的含义：\n变量 返回值 定义 云量 1 0%-6% 2 6%-19% 3 19%-31% 4 31%-44% 5 44%-56% 6 56%-69% 7 69%-81% 8 81%-94% 9 94%-100% 抬升指数 -10 小于-7 -6 -7至-5 -4 -5至-3 -1 -3至0 2 0至4 6 4至8 10 8至11 15 大于11 2米气温 -76至60 -76摄氏度至+60摄氏度 视宁度 1 \u0026lt;0.5\u0026quot; 2 0.5\u0026quot;-0.75\u0026quot; 3 0.75\u0026quot;-1\u0026quot; 4 1\u0026quot;-1.25\u0026quot; 5 1.25\u0026quot;-1.5\u0026quot; 6 1.5\u0026quot;-2\u0026quot; 7 2\u0026quot;-2.5\u0026quot; 8 \u0026gt;2.5\u0026quot; 透明度 1 \u0026lt;0.3 2 0.3-0.4 3 0.4-0.5 4 0.5-0.6 5 0.6-0.7 6 0.7-0.85 7 0.85-1 8 \u0026gt;1 2米相对湿度 -4 0%-5% -3 5%-10% -2 10%-15% -1 15%-20% 0 20%-25% 1 25%-30% 2 30%-35% 3 35%-40% 4 40%-45% 5 45%-50% 6 50%-55% 7 55%-60% 8 60%-65% 9 65%-70% 10 70%-75% 11 75%-80% 12 80%-85% 13 85%-90% 14 90%-95% 15 95%-99% 16 100% 10米风速 1 低于0.3米/秒（无风） 2 0.3-3.4米/秒（1-2级） 3 3.4-8.0米/秒（3-4级） 4 8.0-10.8米/秒（5级） 5 10.8-17.2米/秒（6-7级） 6 17.2-24.5米/秒（8-9级） 7 24.5-32.6米/秒（10-11级） 8 超过32.6米/秒（12级或以上） 降水类型 snow（雪）、rain（雨）、none（无） 无效值 -9999 无效值 ","date":"2016 April 6","permalink":"/posts/2016/04/06/","section":"Posts","summary":"1. 简介 #晴天钟是一系列天气预测产品的总称，它们主要提取于美国国家大气海洋局/气候环境预测局(NOAA/NCEP)的“全球预测系统”(Global Forecast System, GFS)数值模式。由叶泉志开发，目前由中国科学院上海天文台中国天文科普网提供硬件及网络支持。","title":"晴天钟 Documentation"},{"content":"蓝牙 4.0 版本推出了低功耗规范，简称 BLE (Bluetooth Low Energy)，很多小型设备，例如小米手环，都是使用低功耗蓝牙。要与这类模块连接，主设备的蓝牙模块必须支持低功耗，例如 intel 2230 ：\n现在有一个 BLE 的透传模块，会不断的发出数据，我的主机安装了 Linux ，使用 intel 2230 接收数据。协议栈依然是 BlueZ 。\n1. GATT 协议 #BLE 连接都是建立在 GATT 协议之上的。介绍 GATT 之前，需要了解 GAP（Generic Access Profile）。它在用来控制设备连接和广播。GAP 使你的设备被其他设备可见，并决定了你的设备是否可以或者怎样与合同设备进行交互。GAP 给设备定义了若干角色，其中主要的两个是：外围设备（Peripheral）和中心设备（Central），外设必须不停的向外广播，让中心设备知道它的存在。中心设备扫描到外设后，发起并建立 GATT 连接。\nGATT 连接是独占的，也就是一个 BLE 外设同时只能被一个中心设备连接。一旦外设被连接，它就会马上停止广播。中心设备和外设需要双向通信的话，唯一的方式就是建立 GATT 连接。一个外设只能连接一个中心设备，而一个中心设备可以连接多个外设。GATT 定义 BLE 通信的双方是 C/S 关系，外设作为服务端（Server），也叫从设备（Slave），中心设备是客户端（Client），也叫主设备（Master）。所有的通信事件，都是由 Client 发起请求，Server 作出响应。但 GATT 还有两个特性：notification 和 indication。这意味着 server 可以主动发出通知和指示，使 client 端不用轮询。\nGATT 是一个在蓝牙连接之上的发送和接收很短的数据段的通用规范（ATT），这些很短的数据段被称为属性（Attribute）。一个 attribute 由三种元素组成：\n一个16位的句柄（handle） 一个定长的值（value） 一个 UUID，定义了 attribute 的类型，value 的意义完全由 UUID 决定。 attribute 的 handle 具有唯一性，仅用作区分不用的 attribute（因为可能有很多不同的 attribute 拥有相同的 UUID）\nAttribute 只存储在 Server 端，多个 attribute 构成一个 characteristic（特征值），一个或多个 characteristic 构成一个 Service (服务)，一个 BLE 设备可以有多个 Service ，Service 是把数据分成一个个的独立逻辑项。\n一个 GATT Service 始于 UUID 为 0x2800 的 attribute ，直到下一个 UUID 为 0x2800 的 attribute 为止。范围内的所有 attribute 都属于该服务的。例如，一台有三种服务的设备拥有如下所示的 attribute 布局：\nHandle UUID Description Value 0x0100 0x2800 Service A definition 0x1816 (UUID) \u0026hellip; \u0026hellip; Service details \u0026hellip; 0x0150 0x2800 Service B definition 0x18xx \u0026hellip; \u0026hellip; Service details \u0026hellip; 0x0300 0x2800 Service C definition 0x18xx \u0026hellip; \u0026hellip; Service details \u0026hellip; handle 具有唯一性，属于 Service B 的 attribute 的 handle 范围肯定落在 0x0151 和 0x02ff 之中。那么，我如何知道一个 Service 是温度检测，还是 GPS 呢？通过读取该 Service 的 attribute 的 value 。UUID 为 0x2800 的 attribute 作为 Service 的起始标志，它的 value 就是该服务的 UUID ，是该服务的唯一标识，表示了该服务的类型。UUID 有 16 bit 的，或者 128 bit 的。16 bit 的 UUID 是官方通过认证的，需要购买，128 bit 是自定义的，这个就可以自己随便设置。\n每个 Service 都包含一个或多个 characteristic（特征值）。这些 characteristic 负责存储 Service 的数据和访问权限。每个 Characteristic 用 16 bit 或者 128 bit 的 UUID 唯一标识。例如，一个温度计（service）一般会有一个只读的“温度”characteristic，和一个可读写的“日期时间”characteristic：\nHandle UUID Description Value 0x0100 0x2800 Thermometer service definition UUID 0x1816 0x0101 0x2803 Characteristic: temperature UUID 0x2A2B,Value handle: 0x0102 0x0102 0x2A2B Temperature value 20 degrees 0x0110 0x2803 Characteristic: date/time UUID 0x2A08,Value handle: 0x0111 0x0111 0x2A08 Date/Time 1/1/1980 12:00 可以看到，handle 0x0101 定义了一个“温度” characteristic ，该 characteristic 的 UUID 是 0x2A2B，它的值位于 handle 0x0102 。\n除了 value，还可以在 characteristic 的附加 attribute 里获取到其它信息。这些附加的 attribute 称为 descriptor 。例如，当我们我们需要明确温度计的计量单位时，可以通过添加一个 descriptor 来实现：\nHandle UUID Description Value 0x0100 0x2800 Thermometer service definition UUID 0x1816 0x0101 0x2803 Characteristic: temperature UUID 0x2A2B,Value handle: 0x0102 0x0102 0x2A2B Temperature value 20 degrees 0x0104 0x2A1F Descriptor: unit Celsius 0x0110 0x2803 Characteristic: date/time UUID 0x2A08,Value handle: 0x0111 0x0111 0x2A08 Date/Time 1/1/1980 12:00 GATT 知道 handle 0x0104 是属于 characteristic 0x0101 的 descriptor，因为：\n它不是一个 value attribute，因为 value attribute 已经指明是 handle 0x0102 它刚好在 0x0103..0x010F 的范围内，两个 characteristic 之间 每个 service 都可以自定义 desctiptor，GATT 已经预定义了一系列常用的 desctiptor ：\n数据格式和表达方式 可读性描述 有效范围 扩展属性 其中一个很重要的 descriptor 是 client characteristic configuration ，简称 CCC descriptor ，它的 UUID 是 0x2902 ，有一个可读性的 16 位 Value ，低两位已经被占用，用于配置 characteristic 的 notification 和 indication ：\nBit 0 设为 1 表示使能 Notification Bit 1 设为 1 表示使能 Indication 对于具有 Notify 属性的 characteristic ，使能 Notification 后，数据发生变化时会主动通知 Client 端，Client 端只要监听即可。\n2. Linux 中的操作 #在 BlueZ 中就要用 hcitool lescan 命令扫描低功耗蓝牙设备：\nroot@WR-IntelligentDevice:~# hcitool lescan LE Scan ... 20:91:48:6B:65:08 (unknown) 20:91:48:6B:65:08 SPP_2091486B6508 gatttool 是用来访问 BLE 设备的命令，用 gatttool -b 20:91:48:6B:65:08 -I 打开一个与远程设备的会话，-I 表示交互模式：\nroot@WR-IntelligentDevice:~# gatttool -b 20:91:48:6B:65:08 -I [ ][20:91:48:6B:65:08][LE]\u0026gt; help help Show this help exit Exit interactive mode quit Exit interactive mode connect [address [address type]] Connect to a remote device disconnect Disconnect from a remote device primary [UUID] Primary Service Discovery characteristics [start hnd [end hnd [UUID]]] Characteristics Discovery char-desc [start hnd] [end hnd] Characteristics Descriptor Discovery char-read-hnd \u0026lt;handle\u0026gt; [offset] Characteristics Value/Descriptor Read by handle char-read-uuid \u0026lt;UUID\u0026gt; [start hnd] [end hnd] Characteristics Value/Descriptor Read by UUID char-write-req \u0026lt;handle\u0026gt; \u0026lt;new value\u0026gt; Characteristic Value Write (Write Request) char-write-cmd \u0026lt;handle\u0026gt; \u0026lt;new value\u0026gt; Characteristic Value Write (No response) sec-level [low | medium | high] Set security level. Default: low mtu \u0026lt;value\u0026gt; Exchange MTU for GATT/ATT [ ][20:91:48:6B:65:08][LE]\u0026gt; connect 表示连接远程设备，连接成功后，提示符签名的状态会显示 \u0026ldquo;CON\u0026rdquo; :\n[ ][20:91:48:6B:65:08][LE]\u0026gt; connect [CON][20:91:48:6B:65:08][LE]\u0026gt; primary 命令会列出远程设备上所有的 Service ，每个服务所在的 handle 范围:\n[CON][20:91:48:6B:65:08][LE]\u0026gt; primary [CON][20:91:48:6B:65:08][LE]\u0026gt; attr handle: 0x0001, end grp handle: 0x000b uuid: 00001800-0000-1000-8000-00805f9b34fb attr handle: 0x000c, end grp handle: 0x000f uuid: 00001801-0000-1000-8000-00805f9b34fb attr handle: 0x0010, end grp handle: 0x0017 uuid: 0000fee7-0000-1000-8000-00805f9b34fb attr handle: 0x0018, end grp handle: 0x001b uuid: 0000fee0-0000-1000-8000-00805f9b34fb attr handle: 0x001c, end grp handle: 0x0024 uuid: f000ffc0-0451-4000-b000-000000000000 attr handle: 0x0025, end grp handle: 0x002f uuid: 0000ccc0-0000-1000-8000-00805f9b34fb attr handle: 0x0030, end grp handle: 0xffff uuid: 0000180a-0000-1000-8000-00805f9b34fb 用 primary fee7 查看 UUID 为 0xfee7 的 Service ，执行 characteristics 0x0010 0x0017 可以发现它有三个 characteristics ：\n[CON][20:91:48:28:26:AF][LE]\u0026gt; primary fee7 [CON][20:91:48:28:26:AF][LE]\u0026gt; Starting handle: 0x0010 Ending handle: 0x0017 [CON][20:91:48:28:26:AF][LE]\u0026gt; characteristics 0x0010 0x0017 [CON][20:91:48:28:26:AF][LE]\u0026gt; handle: 0x0011, char properties: 0x20, char value handle: 0x0012, uuid: 0000fec8-0000-1000-8000-00805f9b34fb handle: 0x0014, char properties: 0x0a, char value handle: 0x0015, uuid: 0000fec7-0000-1000-8000-00805f9b34fb handle: 0x0016, char properties: 0x02, char value handle: 0x0017, uuid: 0000fec9-0000-1000-8000-00805f9b34fb char properties 表示 characteristic 的属性，char value handle 表示 characteristic 的值所在的 attribute 的 handle 。下面是 characteristic properties 的说明：\n现在远程设备上有一个透传服务是 0xFEE0, 传输数据的特征值是 0xFEE1 ，可以用如下方式查看：\n[CON][20:91:48:6B:65:08][LE]\u0026gt; primary 0xfee0 [CON][20:91:48:6B:65:08][LE]\u0026gt; Starting handle: 0x0018 Ending handle: 0x001b [CON][20:91:48:6B:65:08][LE]\u0026gt; characteristics 0x0018 0x001b [CON][20:91:48:6B:65:08][LE]\u0026gt; handle: 0x0019, char properties: 0x14, char value handle: 0x001a, uuid: 0000fee1-0000-1000-8000-00805f9b34fb [CON][20:91:48:6B:65:08][LE]\u0026gt; char-desc 0x0018 0x001b [CON][20:91:48:6B:65:08][LE]\u0026gt; handle: 0x0018, uuid: 2800 handle: 0x0019, uuid: 2803 handle: 0x001a, uuid: fee1 handle: 0x001b, uuid: 2902 首先执行 primary 0xfee0 ，发现该服务包含 handle 0x0018 到 handle 0x001b 之间的 attribute 。然后用 characteristics 0x0018 0x001b 发现该服务有一个 characteristic ，它的值在 handle 0x001a ，属性是 0x14 ，表示可写无回复/通知（Write without response/Notify）。最后用 char-desc 0x0018 0x001b 列出该特征值的所有 Descriptor ，最后一个 UUID 为 0x2902 ，是一个 CCC Descriptor ，读取它当前的值：\n[CON][20:91:48:28:26:AF][LE]\u0026gt; char-read-hnd 0x001b [CON][20:91:48:28:26:AF][LE]\u0026gt; Characteristic value/descriptor: 00 00 通过 handle 读写的好处是准确，因为 handle 具有唯一性。如果执行 char-read-uuid 0x2902 ，就会发现列出了很多个 attribute 。\n当前的值是 0 ，这个 characteristic 的属性是 Notify ，所以要向 handle 0x001b 写入 0x0100 （X86 是小端），使能 Notify ，然后就会不停的收到数据：\n[CON][20:91:48:28:26:AF][LE]\u0026gt; char-write-req 0x001b 0100 [CON][20:91:48:28:26:AF][LE]\u0026gt; Characteristic value was written successfully Notification handle = 0x001a value: 41 47 3a 20 37 30 34 38 20 37 30 39 35 20 36 30 20 2d 31 37 [CON][20:91:48:28:26:AF][LE]\u0026gt; Notification handle = 0x001a value: 20 2d 32 31 33 20 39 34 36 20 2d 39 33 30 20 2d 31 39 36 20 [CON][20:91:48:28:26:AF][LE]\u0026gt; Notification handle = 0x001a value: 39 33 38 20 2d 39 33 30 0a 41 47 3a 20 37 30 34 31 20 37 31 [CON][20:91:48:28:26:AF][LE]\u0026gt; 在非交互模式下，用 --listen 选项启动监听模式来接收通知：\nroot@WR-IntelligentDevice:~# gatttool -b 20:91:48:28:26:AF --char-write-req --handle=0x001b --value=0100 --listen Characteristic value was written successfully Notification handle = 0x001a value: 32 30 37 32 20 35 33 32 39 20 34 32 39 35 20 41 47 3a 20 2d Notification handle = 0x001a value: 32 30 37 36 20 35 33 32 36 20 34 33 30 30 20 41 47 3a 20 2d Notification handle = 0x001a value: 32 30 37 38 20 35 33 32 37 20 34 33 30 35 20 41 47 3a 20 2d 3. 参考 #Introduction to Bluetooth Low Energy Get started with Bluetooth Low Energy GATT Specifications Bluetooth: ATT and GATT\n","date":"2016 April 5","permalink":"/posts/2016/04/05/","section":"Posts","summary":"蓝牙 4.","title":"Linux 下调试低功耗蓝牙的笔记"},{"content":"1. 简介 #BlueZ 是 Linux 官方的蓝牙协议栈，官网地址：\u0026lt;www.bluez.org\u0026gt; 。\nBlueZ 的代码由两个部分组成：内核代码和用户空间程序。内核代码包括驱动和核心协议栈，用户空间程序包括应用程序接口和操作蓝牙设备的工具。BlueZ 的体系结构如下图：\n我使用的版本是 bluez-4.101 。\n2. 扫描 #下面这个例程展示了搜索蓝牙设备的过程，并显示设备名称和地址。\n//samplescan.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;bluetooth/bluetooth.h\u0026gt; #include \u0026lt;bluetooth/hci.h\u0026gt; #include \u0026lt;bluetooth/hci_lib.h\u0026gt; int main(int argc, char **argv) { inquiry_info *ii = NULL; int max_rsp, num_rsp; int dev_id, sock, len, flags; int i; char addr[19] = { 0 }; char name[248] = { 0 }; dev_id = hci_get_route(NULL); sock = hci_open_dev( dev_id ); if (dev_id \u0026lt; 0 || sock \u0026lt; 0) { perror(\u0026quot;opening socket\u0026quot;); exit(1); } len = 8; max_rsp = 255; flags = IREQ_CACHE_FLUSH; ii = (inquiry_info*)malloc(max_rsp * sizeof(inquiry_info)); num_rsp = hci_inquiry(dev_id, len, max_rsp, NULL, \u0026amp;ii, flags); if( num_rsp \u0026lt; 0 ) perror(\u0026quot;hci_inquiry\u0026quot;); for (i = 0; i \u0026lt; num_rsp; i++) { ba2str(\u0026amp;(ii+i)-\u0026gt;bdaddr, addr); memset(name, 0, sizeof(name)); if (hci_read_remote_name(sock, \u0026amp;(ii+i)-\u0026gt;bdaddr, sizeof(name), name, 0) \u0026lt; 0) strcpy(name, \u0026quot;[unknown]\u0026quot;); printf(\u0026quot;%s %s\\n\u0026quot;, addr, name); } free( ii ); close( sock ); return 0; } 编译 gcc -o simplescan simplescan.c -lbluetooth\nbdaddr_t 是存储蓝牙设备地址的基本数据结构：\ntypedef struct { uint8_t b[6]; } __attribute__((packed)) bdaddr_t; BlueZ 中的所有蓝牙地址都存放在 bdaddr_t ，同时提供了两个函数用于地址字符串与 bdaddr_t 之间的转换：\nint str2ba( const char *str, bdaddr_t *ba ); int ba2str( const bdaddr_t *ba, char *str ); 地址字符串的结构应该是 XX:XX:XX:XX:XX:XX ，XX 是一个十六进制数，str2ba 函数将它转换到 6 Byte 的 bdaddr_t 中。ba2str 的作用相反。\n","date":"2016 March 23","permalink":"/posts/2016/03/23/","section":"Posts","summary":"1. 简介 #BlueZ 是 Linux 官方的蓝牙协议栈，官网地址：\u0026lt;www.","title":"BlueZ 蓝牙编程笔记"},{"content":"朦胧中，好像醒了。\n抬眼看窗外，天还黑，\n拿起手机，才五点。\n隐约听到什么声音，应该是楼上吧，\n持续不断，越来越清晰…\n这声音让我想起去年养过的一只猫。\n有天晚上，不知道它从哪弄来一个核桃，自己扑着玩儿，核桃在地板上滚来滚去，格楞楞地响…\n我清醒了，等了一会儿，那声音还在，就在我家里。\n起床，穿鞋，来到客厅，声音消失了…\n我打开所有房间的灯，在厨房的地板上，发现了一个核桃。\n……\n我家从没买过核桃，那个核桃被猫滚到了床底下，后来猫走了，核桃一直留在那。\n","date":"2016 February 23","permalink":"/posts/2016/02/23/","section":"Posts","summary":"朦胧中，好像醒了。","title":"核桃"},{"content":"在 Linux 系统中存在各种日志文件，例如保存启动信息和内核信息的 /var/log/dmesg ，保存系统日志的 /var/log/syslog 等。如果连续运行时间太长，这些日志会越来越大，最终占据太多系统空间。所以，我们需要定期清理系统日志。Logrotate 的主要功能就是定时将旧的日志文件归档，同时创建一个新的空的日志文件，归档的文件可以选择压缩或者发送到指定的邮箱，这个过程叫做轮替（rotate）：\nLogrotate 是基于 cron 运行的，他的脚本是 /etc/cron.daily/logrotate :\n#!/bin/sh /usr/sbin/logrotate /etc/logrotate.conf EXITVALUE=$? if [ $EXITVALUE != 0 ]; then /usr/bin/logger -t logrotate \u0026quot;ALERT exited abnormally with [$EXITVALUE]\u0026quot; fi exit 0 cron 用于设置周期性被执行的指令，是运行在后台的守护进程。\nLogrotate 的主配置文件是 /etc/logrotate.conf ：\n# see \u0026quot;man logrotate\u0026quot; for details # rotate log files weekly weekly # keep 4 weeks worth of backlogs rotate 4 # create new (empty) log files after rotating old ones create # use date as a suffix of the rotated file dateext # uncomment this if you want your log files compressed #compress # RPM packages drop log rotation information into this directory include /etc/logrotate.d # no packages own wtmp and btmp -- we'll rotate them here /var/log/wtmp { monthly create 0664 root utmp minsize 1M rotate 1 } /var/log/btmp { missingok monthly create 0600 root utmp rotate 1 } # system-specific logs may be also be configured here. 其中，以 # 开头的都是注释。include /etc/logrotate.d 之前的是默认配置，全局有效。之后以花括号包围的是针对单个文件的配置，这里的配置项会覆盖默认配置。配置项的含义：\nweekly 表示每周对日志文件进行一次轮替，类似的可选项还有 monthly （每月一次，通常是每月的第一天），daily（每天一次） 。 rotate 4 表示保留最近四次的归档，之前的全部清除。 create 表示轮替后立即创建新的空的日志文件，它可以带三个参数：mode owner group ，分别表示新文件的权限、所有者和用户组，例如 create 0600 root utmp。 dateext 表示为归档后的文件名添加日期信息，日期的格式由 dateformat 选项设置。 compress 表示压缩归档文件，注释掉这个配置项就表示不压缩。 另外，在 /etc/logrotate.d/ 目录下的配置文件会被读入到 /etc/logrotate.d ，我们自行添加的配置文件都可以放在这里。\n","date":"2016 January 21","permalink":"/posts/2016/01/21/","section":"Posts","summary":"在 Linux 系统中存在各种日志文件，例如保存启动信息和内核信息的 /var/log/dmesg ，保存系统日志的 /var/log/syslog 等。如果连续运行时间太长，这些日志会越来越大，最终占据太多系统空间。所以，我们需要定期清理系统日志。Logrotate 的主要功能就是定时将旧的日志文件归档，同时创建一个新的空的日志文件，归档的文件可以选择压缩或者发送到指定的邮箱，这个过程叫做轮替（rotate）：","title":"Logrotate"},{"content":"Openemu 是一款多功能游戏机模拟器软件，可以在 Mac 上模拟多种游戏机，从早期的 GBA 到索尼的 PSP ，有了它，我就可以在 Mac 上玩超级马里奥顶蘑菇了。\n你可以在官网 Openemu.org 下载，解压后即可运行。模拟器没有自带游戏，可以在 Homebrew 中浏览下载，但是可选择的并不多。另一个网站 emuparadise.me 提供了大量的游戏 ROM ，我在这里可以搜索马里奥：\n然后下载、解压，将游戏 ROM 拖拽到模拟器界面即可完成安装。\n","date":"2016 January 10","permalink":"/posts/2016/01/10/","section":"Posts","summary":"Openemu 是一款多功能游戏机模拟器软件，可以在 Mac 上模拟多种游戏机，从早期的 GBA 到索尼的 PSP ，有了它，我就可以在 Mac 上玩超级马里奥顶蘑菇了。","title":"Openemu on Mac"},{"content":" 以前只是用 lsof 命令查看某个文件被那些进程打开了，直到看了这篇文章：An lsof Primer ，展示了 lsof 强大的一面。网上有很多翻译，找不到原始版本了，我修改了一些地方。\nlsof 是系统管理/安全的高级工具（über-tool）。大多数时候，我用它来获取系统中与网络连接相关的信息，但那只是这个强大有小众的命令的第一步。将这个工具称之为 lsof 真是名副其实，因为它是指“列出打开的文件（lists openfiles）”。切记，在 Unix 中一切（包括网络套接字）都是文件。\n有趣的是，lsof 也是有着最多开关的 Linux/Unix 命令之一。它有那么多的开关，许多选项支持使用 - 和 + 前缀。\nusage: [-?abhlnNoOPRstUvV] [+|-c c] [+|-d s] [+D D] [+|-f[cgG]] [-F [f]] [-g [s]] [-i [i]] [+|-L [l]] [+|-M] [-o [o]] [-p s] [+|-r [t]] [-S [t]] [-T [t]] [-u s] [+|-w] [-x [fl]] [--] [names] 如你所见，lsof 有着实在是令人惊讶的选项数量。你可以使用它来获得系统上的设备信息，了解指定的用户在指定的地点正在碰什么东西，甚至是一个进程正在使用什么文件或网络连接。\n对于我，lsof 替代了 netstat 和 ps 的全部工作。它带来那些工具的所有功能，而且要比那些工具还多得多。那么，让我们来看看它的一些基本能力吧。\n1. 关键选项 #理解一些关于 lsof 工作方式的关键点是很重要的。最重要的是，当你给它传递选项时，默认行为是对结果进行“或”运算。因此，如果你正是用 -i 来拉出一个端口列表，同时又用 -p 来拉出一个进程列表，那么默认情况下你会获得两者的结果。\n下面这些需要牢记：\n默认 : 没有选项时，lsof 列出活跃进程的所有打开文件 组合 : 可以将选项组合到一起，如-abc，但要注意哪些选项需要参数 -a : 结果进行“与”运算（而不是“或”） -l : 在输出显示用户 ID 而不是用户名 -h : 获得帮助信息 -t : 仅获取进程 ID -U : 获取 UNIX 套接字地址 -F : 格式化输出结果，用于其它命令。可以通过多种方式格式化，如 -F pcfn（用于进程 id、命令名、文件描述符、文件名，并以空终止） 2. 获取网络信息 #正如我所说的，我主要用 lsof 获取关于系统和网络交互的信息。这里提供了关于此信息的一些主题。\n2.1. 使用 -i 显示所有连接 #有些人喜欢用 netstat 来获取网络连接，但是我更喜欢使用 lsof 来进行此项工作。获取的信息以很直观的方式呈现，我仅仅只需改变我的语法，就可以通过同样的命令来获取更多信息。\n# lsof -i COMMAND PID USER FD TYPE DEVICE SIZE NODE NAME dhcpcd 6061 root 4u IPv4 4510 UDP *:bootpc sshd 7703 root 3u IPv6 6499 TCP *:ssh (LISTEN) sshd 7892 root 3u IPv6 6757 TCP 10.10.1.5:ssh-\u0026gt;192.168.1.5:49901 (ESTABLISHED) 2.2. 使用 -i 6 仅获取 IPv6 流量 ## lsof -i 6 2.3. 仅显示 TCP 连接（同理可获得 UDP 连接） #可以通过在 -i 后提供对应的协议来仅仅显示 TCP 或者 UDP 连接信息。\n# lsof -iTCP COMMAND PID USER FD TYPE DEVICE SIZE NODE NAME sshd 7703 root 3u IPv6 6499 TCP *:ssh (LISTEN) sshd 7892 root 3u IPv6 6757 TCP 10.10.1.5:ssh-\u0026gt;192.168.1.5:49901 (ESTABLISHED) 2.4. 使用 -i:port 来显示与指定端口相关的网络信息 #你也可以通过端口搜索，这对于要找出什么阻止了另外一个应用绑定到指定端口实在是太棒了。\n# lsof -i :22 COMMAND PID USER FD TYPE DEVICE SIZE NODE NAME sshd 7703 root 3u IPv6 6499 TCP *:ssh (LISTEN) sshd 7892 root 3u IPv6 6757 TCP 10.10.1.5:ssh-\u0026gt;192.168.1.5:49901 (ESTABLISHED) 2.5. 使用 @host 来显示指定到指定主机的连接 #这对于你在检查是否开放连接到网络中或互联网上某个指定主机的连接时十分有用。\n# lsof -i@172.16.12.5 sshd 7892 root 3u IPv6 6757 TCP 10.10.1.5:ssh-\u0026gt;172.16.12.5:49901 (ESTABLISHED) 2.6. 使用 @host:port 显示基于主机与端口的连接 #你也可以组合主机与端口的显示信息。\n# lsof -i@172.16.12.5:22 sshd 7892 root 3u IPv6 6757 TCP 10.10.1.5:ssh-\u0026gt;172.16.12.5:49901 (ESTABLISHED) 2.7. 找出监听端口 #找出正等候连接的端口。\n# lsof -i -sTCP:LISTEN 也可以用 grep 筛选出信。\n# lsof -i | grep -i LISTEN iTunes 400 daniel 16u IPv4 0x4575228 0t0 TCP *:daap (LISTEN) 2.8. 找出已建立的连接 #你也可以显示任何已经连接的连接。\n# lsof -i -sTCP:ESTABLISHED 也可以通过 grep 筛选。\n# lsof -i | grep -i ESTABLISHED firefox-b 169 daniel 49u IPv4 0t0 TCP 1.2.3.3:1863-\u0026gt;1.2.3.4:http (ESTABLISHED) 3. 用户信息 #你也可以获取各种用户的信息，以及它们在系统上正干着的事，包括它们的网络活动、对文件的操作等。\n3.1. 使用 -u 显示指定用户打开了什么 ## lsof -u daniel -- snipped -- Dock 155 daniel txt REG 14,2 2798436 823208 /usr/lib/libicucore.A.dylib Dock 155 daniel txt REG 14,2 1580212 823126 /usr/lib/libobjc.A.dylib Dock 155 daniel txt REG 14,2 2934184 823498 /usr/lib/libstdc++.6.0.4.dylib Dock 155 daniel txt REG 14,2 132008 823505 /usr/lib/libgcc_s.1.dylib Dock 155 daniel txt REG 14,2 212160 823214 /usr/lib/libauto.dylib -- snipped -- 3.2. 使用 -u user 来显示除指定用户以外的其它所有用户所做的事情 ## lsof -u ^daniel -- snipped -- Dock 155 jim txt REG 14,2 2798436 823208 /usr/lib/libicucore.A.dylib Dock 155 jim txt REG 14,2 1580212 823126 /usr/lib/libobjc.A.dylib Dock 155 jim txt REG 14,2 2934184 823498 /usr/lib/libstdc++.6.0.4.dylib Dock 155 jim txt REG 14,2 132008 823505 /usr/lib/libgcc_s.1.dylib Dock 155 jim txt REG 14,2 212160 823214 /usr/lib/libauto.dylib -- snipped -- 3.3. 杀死指定用户所做的一切事情 #可以消灭指定用户运行的所有东西，这真不错。\n# kill -9 `lsof -t -u daniel` 4. 命令和进程 #可以查看指定程序或进程由什么启动，这通常会很有用，而你可以使用lsof通过名称或进程ID过滤来完成这个任务。下面列出了一些选项：\n4.1. 使用 -c 查看指定的命令正在使用的文件和网络连接 ## lsof -c syslog-ng COMMAND PID USER FD TYPE DEVICE SIZE NODE NAME syslog-ng 7547 root cwd DIR 3,3 4096 2 / syslog-ng 7547 root rtd DIR 3,3 4096 2 / syslog-ng 7547 root txt REG 3,3 113524 1064970 /usr/sbin/syslog-ng -- snipped -- 4.2. 使用 -p 查看指定进程ID已打开的内容 ## lsof -p 10075 -- snipped -- sshd 10068 root mem REG 3,3 34808 850407 /lib/libnss_files-2.4.so sshd 10068 root mem REG 3,3 34924 850409 /lib/libnss_nis-2.4.so sshd 10068 root mem REG 3,3 26596 850405 /lib/libnss_compat-2.4.so sshd 10068 root mem REG 3,3 200152 509940 /usr/lib/libssl.so.0.9.7 sshd 10068 root mem REG 3,3 46216 510014 /usr/lib/liblber-2.3 sshd 10068 root mem REG 3,3 59868 850413 /lib/libresolv-2.4.so sshd 10068 root mem REG 3,3 1197180 850396 /lib/libc-2.4.so sshd 10068 root mem REG 3,3 22168 850398 /lib/libcrypt-2.4.so sshd 10068 root mem REG 3,3 72784 850404 /lib/libnsl-2.4.so sshd 10068 root mem REG 3,3 70632 850417 /lib/libz.so.1.2.3 sshd 10068 root mem REG 3,3 9992 850416 /lib/libutil-2.4.so -- snipped -- 4.3. 使 -t 选项只返回 PID ## lsof -t -c Mail 350 5. 文件和目录 #通过查看指定文件或目录，你可以看到系统上所有正与其交互的资源——包括用户、进程等。\n显示与指定目录交互的所有一切\n# lsof /var/log/messages/ COMMAND PID USER FD TYPE DEVICE SIZE NODE NAME syslog-ng 7547 root 4w REG 3,3 217309 834024 /var/log/messages 显示与指定文件交互的所有一切\n# lsof /home/daniel/firewall_whitelist.txt 6. 高级用法 #与 tcpdump 类似，当你开始组合查询时，它就显示了它强大的功能。\n6.1. 显示 daniel 连接到 1.1.1.1 所做的一切 ## lsof -u daniel -i @1.1.1.1 bkdr 1893 daniel 3u IPv6 3456 TCP 10.10.1.10:1234-\u0026gt;1.1.1.1:31337 (ESTABLISHED) 6.2. 同时使用 -t 和 -c 选项以给进程发送 HUP 信号 ## kill -HUP `lsof -t -c sshd` 6.3. 显示某个端口范围内打开的连接 ## lsof -i @fw.google.com:2150=2180 7. 结尾 #本入门教程只是管窥了 lsof 功能的一斑，要查看完整参考，运行 man lsof 命令或查看在线版本。希望本文对你有所助益，也随时欢迎你的评论和指正。\nlsof手册页：http://www.netadmintools.com/html/lsof.man.html\n","date":"2016 January 8","permalink":"/posts/2016/01/08/","section":"Posts","summary":"以前只是用 lsof 命令查看某个文件被那些进程打开了，直到看了这篇文章：An lsof Primer ，展示了 lsof 强大的一面。网上有很多翻译，找不到原始版本了，我修改了一些地方。","title":"lsof 命令入门"},{"content":"1. About #hostapd 是一个运行在 Linux 用户空间的 daemon 程序，它可以将 IEEE 802.11 无线网卡切换为 AP 模式，也就是实现软 AP 功能，并提供 IEEE 802.1X/WPA/WPA2/EAP/RADIUS 的认证服务。它使用 nl80211 接口与内核进行通信，支持基于 mac80211 框架的无线驱动。下面是 Linux 的无线网络架构：\nIEEE 802.11 是现在的无线局域网通用的标准，我们通常把它与 Wi-Fi 混为一谈。 mac80211 是 Linux 内核的 802.11 无线设备驱动框架，intel 的无线网卡驱动 iwlwifi 就是基于这个框架。 cfg80211 是 Linux 内核中配置和管理 802.11 无线设备的接口，与 FullMAC 驱动, mac80211 驱动一起工作。 nl80211 和 wext 是两种面向用户空间的接口标准，用于在用户空间配置和管理 802.11 无线设备，内核的 cfg80211 一起工作，目前两种标准同时存在于内核中，nl80211 正在逐步替代 wext ，hostapd 只支持 nl80211 。 iw 就是一个使用 nl80211 接口的命令，用它可以查看和配置无线网卡，支持 nl80211 标准，不支持老的 wext 标准。用 iw list 可以获取当前无线网卡的全部特性，在 Supported interface modes 和 software interface modes 中看到无线网卡是否支持 AP 模式，已经 AP 类型：\nroot@WR-IntelligentDevice:~# iw list Wiphy phy0 ...... Supported interface modes: * IBSS * managed * AP * AP/VLAN * monitor * P2P-client * P2P-GO software interface modes (can always be added): * AP/VLAN * monitor ...... 用 ethtool 工具可以确定网卡使用的驱动：\nroot@WR-IntelligentDevice:~# ethtool -i wlan0 driver: iwlwifi version: 3.4.91-WR5.0.1.24_standard_IDP- firmware-version: 18.168.6.1 bus-info: 0000:01:00.0 supports-statistics: yes supports-test: no supports-eeprom-access: no supports-register-dump: no supports-priv-flags: no 查看连接在 AP 上的终端：\nroot@WR-IntelligentDevice:~# iw dev wlan0 station dump Station bc:6c:21:6e:04:c3 (on wlan0) inactive time: 20 ms rx bytes: 159304 rx packets: 2076 tx bytes: 4368817 tx packets: 3068 tx retries: 293 tx failed: 2 signal: -41 dBm signal avg: -40 dBm tx bitrate: 54.0 MBit/s authorized: yes authenticated: yes preamble: short WMM/WME: no MFP: no TDLS peer: no 2. 配置 #hostapd 的配置文件是 /etc/hostapd.conf ，这个文件里有详细的配置说明，下面是一些常用选项。\n2.1. 无线接口 # interface：无线网卡的设备节点名称，就是 iwconfig 看到的名称，例如 wlan0 。 bridge：指定所处网桥，对于一个同时接入公网、提供内部网和无线接入的路由器来说，设定网桥很有必要 。 driver：设定无线驱动，我这里是 nl80211 。 2.2. 无线环境 # ssid：这个无线接入点对外显示的名称 。 hw_mode：指定802.11协议，a = IEEE 802.11a, b = IEEE 802.11b, g = IEEE 802.11g 。这个选项是根据硬件特性设置的，g 是最常用的设置，它向下兼容 b 。 channel：设定信道，必须是 hw_mode 指定协议能够支持的信道。信道的选择应该避免与同区域内的其他 AP 的信道产生重叠，这与 802.11 标准的信道划分有关，在 802.11b/g 中，83.5MHz 的带宽划分了 14 个信道，相邻的多个信道存在频率重叠，整个频段内只有 1、6、11 ，三个信道互不干扰。 2.3. 认证与加密 # ignore_broadcast_ssid: 使能/禁止广播 SSID 。\nmacaddr_acl：可选，指定 MAC 地址过滤规则，0 表示除禁止列表外都允许，1 表示除允许列表外都禁止，2 表示使用外部 RADIUS 服务器。\naccept_mac_file：指定 MAC 允许列表文件路径。\ndeny_mac_file：指定 MAC 禁止列表文件路径。\nauth_algs: 指定认证算法，低两位有效，0 表示禁止，1 表示使能。bit0 表示开放系统认证（OSA），bit1 表示共享密钥认证（SKA），如果设为 3 ，表示两种认证方式都支持。\nwpa: 指定加密算法，低两位有效，0 表示禁止，1 表示使能。bit0 表示 wpa，bit1 表示 wpa2 ，如果设为 3 ，表示 WPA/WPA2 加密方式。\nwpa_passphrase: 共享秘钥，就是我们连接 Wi-Fi 时输入的密码。\nwpa_psk：对共享秘钥加密后的 64 位十六进制数。可以通过 wpa_passphrase 命令获得：\nroot@WR-IntelligentDevice:~# wpa_passphrase usage: wpa_passphrase \u0026lt;ssid\u0026gt; [passphrase] If passphrase is left out, it will be read from stdin root@WR-IntelligentDevice:~# wpa_passphrase TP-Link password network={ ssid=\u0026quot;TP-Link\u0026quot; #psk=\u0026quot;password\u0026quot; psk=895b209c4c7ff1ea45d079eb5b04155cc1793669c6dc08470157c23fa6532694 } wpa_key_mgmt: 指定秘钥管理算法，可选 WPA-PSK 和 WPA-EAP 。\nwpa_pairwise: WPA 的加密选项，可选 TKIP 和 CCMP 。\nrsn_pairwise: WPA2 和 RSN 的加密选项，可选 TKIP 和 CCMP 。\n关于认证算法：\n开放系统认证（Open system authentication）\n开放系统认证是缺省使用的认证机制，也是最简单的认证算法，即不认证。如果认证类型设置为开放系统认证，则所有请求认证的客户端都会通过认证。开放系统认证包括两个步骤：第一步是无线客户端发起认证请求，第二步AP确定无线客户端是否通过无线链路认证并回应认证结果。如果认证结果为“成功”，那么客户端成功通过了AP的链路认证。\n共享密钥认证（shared key authentication）\n共享密钥认证是除开放系统认证以外的另外一种链路认证机制。共享密钥认证需要客户端和设备端配置相同的共享密钥。共享密钥认证的认证过程为：客户端先向AP发送认证请求，AP端会随机产生一个Challenge（即一个字符串）发送给客户端；客户端会将接收到Challenge加密后再发送给AP；AP接收到该消息后，对该消息解密，然后对解密后的字符串和原始字符串进行比较。如果相同，则说明客户端通过了Shared Key链路认证；否则Shared Key链路认证失败。\n3. 运行 #root@WR-IntelligentDevice:/etc# hostapd -h hostapd v2.3 User space daemon for IEEE 802.11 AP management, IEEE 802.1X/WPA/WPA2/EAP/RADIUS Authenticator Copyright (c) 2002-2014, Jouni Malinen \u0026lt;j@w1.fi\u0026gt; and contributors usage: hostapd [-hdBKtv] [-P \u0026lt;PID file\u0026gt;] [-e \u0026lt;entropy file\u0026gt;] \\ [-g \u0026lt;global ctrl_iface\u0026gt;] [-G \u0026lt;group\u0026gt;] \\ \u0026lt;configuration file(s)\u0026gt; options: -h show this usage -d show more debug messages (-dd for even more) -B run daemon in the background -e entropy file -g global control interface path -G group for control interfaces -P PID file -K include key data in debug messages -t include timestamps in some debug messages -v show hostapd version 分享一个在 Ubuntu 12.04 下设置无线 AP 的脚本 install_wifi_access_point.sh ，内容如下：\n#!/bin/bash ### Setup a wifi Access Point on Ubuntu 12.04 (or its derivatives). ### make sure that this script is executed from root if [ $(whoami) != 'root' ] then echo \u0026quot; This script should be executed as root or with sudo: sudo $0 \u0026quot; exit 1 fi ############################################################## ## Check whether the wireless card supports Access Point mode ############################################################## ### make sure that iw is installed apt-get -y install iw ### check that AP is supported supports_access_point=$(iw list | sed -n -e '/* AP$/p') if [ \u0026quot;$supports_access_point\u0026quot; = '' ] then echo \u0026quot;AP is not supported by the driver of the wireless card.\u0026quot; echo \u0026quot;This script does not work for this driver.\u0026quot; exit 1 fi ############################################################## ## Setup and host a network ############################################################## ### install hostapd apt-get -y install hostapd ### it should not start automatically on boot update-rc.d hostapd disable ### get ssid and password ssid=$(hostname --short) read -p \u0026quot;The name of your hosted network (SSID) [$ssid]: \u0026quot; input ssid=${input:-$ssid} password='1234567890' read -p \u0026quot;The password of your hosted network [$password]: \u0026quot; input password=${input:-$password} ### get wifi interface rfkill unblock wifi # enable wifi in case it is somehow disabled (thanks to Darrin Wolf for this tip) wifi_interface=$(lshw -quiet -c network | sed -n -e '/Wireless interface/,+12 p' | sed -n -e '/logical name:/p' | cut -d: -f2 | sed -e 's/ //g') ### create /etc/hostapd/hostapd.conf cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/hostapd/hostapd.conf interface=$wifi_interface driver=nl80211 ssid=$ssid hw_mode=g channel=1 macaddr_acl=0 auth_algs=1 ignore_broadcast_ssid=0 wpa=3 wpa_passphrase=$password wpa_key_mgmt=WPA-PSK wpa_pairwise=TKIP rsn_pairwise=CCMP EOF ### modify /etc/default/hostapd cp -n /etc/default/hostapd{,.bak} sed -i /etc/default/hostapd \\ -e '/DAEMON_CONF=/c DAEMON_CONF=\u0026quot;/etc/hostapd/hostapd.conf\u0026quot;' ################################################ ## Set up DHCP server for IP address management ################################################ ### make sure that the DHCP server is installed apt-get -y install isc-dhcp-server ### it should not start automatically on boot update-rc.d isc-dhcp-server disable ### set the INTERFACES on /etc/default/isc-dhcp-server cp -n /etc/default/isc-dhcp-server{,.bak} sed -i /etc/default/isc-dhcp-server \\ -e \u0026quot;/INTERFACES=/c INTERFACES=\\\u0026quot;$wifi_interface\\\u0026quot;\u0026quot; ### modify /etc/dhcp/dhcpd.conf cp -n /etc/dhcp/dhcpd.conf{,.bak} sed -i /etc/dhcp/dhcpd.conf \\ -e 's/^option domain-name/#option domain-name/' \\ -e 's/^option domain-name-servers/#option domain-name-servers/' \\ -e 's/^default-lease-time/#default-lease-time/' \\ -e 's/^max-lease-time/#max-lease-time/' sed -i /etc/dhcp/dhcpd.conf \\ -e '/subnet 10.10.0.0 netmask 255.255.255.0/,+4 d' cat \u0026lt;\u0026lt;EOF \u0026gt;\u0026gt; /etc/dhcp/dhcpd.conf subnet 10.10.0.0 netmask 255.255.255.0 { range 10.10.0.2 10.10.0.16; option domain-name-servers 8.8.4.4, 208.67.222.222; option routers 10.10.0.1; } EOF ################################################# ## Create a startup script ################################################# cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/init.d/wifi_access_point #!/bin/bash ext_interface=\\$(ip route | grep default | cut -d' ' -f5) function stop_wifi_ap { ### stop services dhcpd and hostapd service isc-dhcp-server stop service hostapd stop ### disable IP forwarding echo 0 \u0026gt; /proc/sys/net/ipv4/ip_forward iptables -t nat -D POSTROUTING -s 10.10.0.0/16 -o \\$ext_interface -j MASQUERADE 2\u0026gt;/dev/null ### remove the static IP from the wifi interface if grep -q 'auto $wifi_interface' /etc/network/interfaces then sed -i /etc/network/interfaces -e '/auto $wifi_interface/,\\$ d' sed -i /etc/network/interfaces -e '\\$ d' fi ### restart network manager to takeover wifi management service network-manager restart } function start_wifi_ap { stop_wifi_ap sleep 3 ### see: https://bugs.launchpad.net/ubuntu/+source/wpa/+bug/1289047/comments/8 nmcli nm wifi off rfkill unblock wlan ### give a static IP to the wifi interface ip link set dev $wifi_interface up ip address add 10.10.0.1/24 dev $wifi_interface ### protect the static IP from network-manger restart echo \u0026gt;\u0026gt; /etc/network/interfaces echo 'auto $wifi_interface' \u0026gt;\u0026gt; /etc/network/interfaces echo 'iface $wifi_interface' inet static \u0026gt;\u0026gt; /etc/network/interfaces echo 'address 10.10.0.1' \u0026gt;\u0026gt; /etc/network/interfaces echo 'netmask 255.255.255.0' \u0026gt;\u0026gt; /etc/network/interfaces ### enable IP forwarding echo 1 \u0026gt; /proc/sys/net/ipv4/ip_forward iptables -t nat -A POSTROUTING -s 10.10.0.0/16 -o \\$ext_interface -j MASQUERADE ### start services dhcpd and hostapd service hostapd start service isc-dhcp-server start } ### start/stop wifi access point case \u0026quot;\\$1\u0026quot; in start) start_wifi_ap ;; stop) stop_wifi_ap ;; esac EOF chmod +x /etc/init.d/wifi_access_point ### make sure that it is stopped on boot sed -i /etc/rc.local \\ -e '/service wifi_access_point stop/ d' sed -i /etc/rc.local \\ -e '/^exit/ i service wifi_access_point stop' ### display usage message echo \u0026quot; ====================================== Wifi Access Point installed. You can start and stop it with: service wifi_access_point start service wifi_access_point stop \u0026quot; 4. 参考 # https://wireless.wiki.kernel.org/en/users/Documentation/hostapd http://blog.csdn.net/myarrow/article/details/7930131 http://www.cnblogs.com/zhuwenger/archive/2011/03/11/1980294.html https://github.com/hotice/AP-Hotspot ","date":"2016 January 1","permalink":"/posts/2016/01/01/","section":"Posts","summary":"1. About #hostapd 是一个运行在 Linux 用户空间的 daemon 程序，它可以将 IEEE 802.","title":"hostapd HOWTO"},{"content":"1. 配置 #git 的全局配置文件是用户目录下的 .gitconfig 文件。设置用户信息：\ngit config [--global] user.name \u0026quot;[name]\u0026quot; git config [--global] user.email \u0026quot;[email address]\u0026quot; 2. 创建新仓库 # 在当前目录下创建新仓库 git init 克隆远程服务器上的仓库 git clone [url] 创建新仓库时会生成 .git 文件夹，包含了该仓库的所有配置文件。\n3. 工作流 #源码目录称为工作区 workspace ,本地仓库叫做 Repository ，远程仓库叫做 Remote ，在本地仓库和工作区之间存在一个暂存区 Index 。通常的工作流程是修改源码、放入暂存区、提交到仓库、推送到远程服务器：\n4. 添加 add # 添加当前目录的所有文件到暂存区 git add . 添加指定文件到暂存区 git add [file1] [file2] ... 添加指定目录到暂存区，包括子目录 git add [dir] 5. 删除 delete # 删除工作区文件，并且将这次删除放入暂存区 git rm [file1] [file2] ... 停止追踪指定文件，但该文件会保留在工作区 git rm --cached [file] 改名文件，并且将这个改名放入暂存区 git mv [file-original] [file-renamed] 6. 提交 commit # 提交暂存区到仓库区 git commit -m [message] 提交暂存区的指定文件到仓库区 git commit [file1] [file2] ... -m [message] 提交工作区自上次commit之后的变化，直接到仓库区 git commit -a 提交时显示所有diff信息 git commit -v 使用一次新的commit，替代上一次提交，如果代码没有任何新变化，则用来改写上一次commit的提交信息 git commit --amend -m [message] commit 之后，就会在 git 记录中形成一个新的版本。\n7. 查看信息 # 显示工作区中有变更的文件 git status 显示当前分支的版本历史 git log 显示版本历史，以及每次 commit 发生变更的文件 git log --stat 显示某次提交的元数据和内容变化 git show [commit] 显示某次提交发生变化的文件 git show --name-only [commit] 显示某次提交时，某个文件的内容 git show [commit]:[filename] 显示工作区相对暂存区的差异 git diff 显示工作区相对暂存区，那些文件文件被改动了 git diff --stat 显示暂存区相对上一个commit的差异 git diff --cached [file] 显示工作区相对当前分支最新commit之间的差异 git diff HEAD 显示两个分支之间的差异 git diff [commit] [commit] 显示两个分支之间的差异 git diff [first-branch] [second-branch] 8. 回退 # 恢复暂存区的指定文件到工作区 git checkout [file] 恢复某个commit的指定文件到工作区 git checkout [commit] [file] 恢复上一个commit的所有文件到工作区 git checkout . 重置暂存区的指定文件到上一次commit保持一致，但工作区不变 git reset [file] 重置当期分支的 HARD 、暂存区、工作区到指定的 commit git reset --hard [commit] 重置当前分支的 HARD、暂存区到指定的 commit ，但工作区不变 git reset –soft [commit] 9. 远程同步 # 上传本地指定分支到远程仓库 git push [remote] [branch] 下载远程仓库的所有变动 git fetch [remote] 10. 补丁 #将 git diff 输出的信息保存到文件，就是一个标准补丁，要生成 git 专用补丁，需要 git format-patch 命令：\n将最后一个 commit 生成补丁 git format-patch -1 将最后两个 commit 分别生成补丁 git format-patch -2 用 git apply 应用补丁文件，它只会修改工作区，还要手动提交：\n应用一个 git 补丁并检查是否成功 git apply --check [patch file] 11. 版本号 #版本号以小写字母 v 开头，格式是：主版本号.次版本号-修订版本号-SHA 。\n大的功能变更升级主版本号，小的功能变更升级次版本号，正式发布前的主版本号可以是 0 ，这样第一次发布时的版本号就是 v1.0。修订版本号不涉及功能更新，它是指上次标记主次版本号之后的修复 Bug 次数。每次重新标记主次版本号之后，修订版本号重置。SHA 是本次 commit 的 SHA 值的前几位\n主版本号和次版本号需要用 git tag 标记，而修订次数和 SHA 可以由 git 自动记录。举例，一次本地 commit 之后，使用 git tag 为本次提交标记版本号：\n$ git log commit d3b0c251d0546194659a7a121f6404b9e28b1229 Author: lishaocheng \u0026lt;lishaocheng@*.com.cn\u0026gt; Date: Fri Nov 18 15:42:49 2016 +0800 v1.0 release $ git tag -a v1.0 -m \u0026quot;v1.0 release\u0026quot; 查看当前版本号：\n$ git describe v1.0 $ git describe --long v1.0-0-gd3b0c25 第一次发布，没有修订，所以修订版本号为 0 。SHA 中的 g 是 git 的缩写，后面本次 commit 的 SHA 值前几位。 推送时使用 \u0026ndash;tags 带上所有的本地标签：\n$ git push --tags origin master Counting objects: 9, done. Delta compression using up to 4 threads. Compressing objects: 100% (7/7), done. Writing objects: 100% (9/9), 445.64 KiB | 0 bytes/s, done. Total 9 (delta 0), reused 0 (delta 0) To 192.168.5.253:lishaocheng/ftp_transfer.git 95105d6..d3b0c25 master -\u0026gt; master * [new tag] v1.0 -\u0026gt; v1.0 如果发现了 Bug ，需要修改，就 clone 到本地，修改后 commit ，然后查看版本号：\n$ git describe v1.0-1-g740c0c4 修订版本号变成了 1 ，SHA 变成了本次的 commit 。然后推送：\n$ git push --tags origin master 12. 使用SSH Key #在客户端执行如下命令生成一个密钥对：\nssh-keygen -t ed25519 -C \u0026#34;lishaocheng_20220201\u0026#34; -t 选项指定了加密类型，我们选择 ed25519 ，也可以选择其他类型。\n-C 选项是设置密钥对的注释，我习惯设置用户名和日期。\n设置一个便于记忆的文件名，密码可以跳过，生成的密钥对文件位于当前目录下，后缀为 .pub 的文件是公钥，另一个是私钥，把两个文件复制到 ~/.ssh/ 目录下，把公钥文件的内容添加到 git 服务器。\n没次使用 git 前，需要添加key 。\n$ eval \u0026#34;$(ssh-agent -s)\u0026#34; $ ssh-add.exe ~/.ssh/lishaocheng_20220201 手动添加 key 比较麻烦，可以将这个过程写入 ssh 的配置文件。新建一个配置文件：\ntouch ~/.ssh/config 添加如下内容：\nHost 192.168.0.202 Hostname 192.168.0.202 Port 3022 User lishaocheng PreferredAuthentications publickey IdentityFile ~/.ssh/lishaocheng_20220201 Host 是服务器的名称，可用任意字符串，这里设置为服务器 IP\nHostname 必须设置为服务器 IP 或者域名 Port 是服务器 SSH 的端口\nUser 是用户名\nPreferredAuthentications 设为公钥验证\nIdentityFile 设置私钥文件的路径\n之后使用 git 的时候，就不用手动添加 key 了。\n13. 参考 # Git 简明指南 常用 Git 命令清单 图解 Git ","date":"2015 December 29","permalink":"/posts/2015/12/29/","section":"Posts","summary":"1. 配置 #git 的全局配置文件是用户目录下的 .","title":"Git 笔记"},{"content":"Swift # The Swift Programming Language 中文版 如果没有苹果电脑，可用 swift 在线编译器 使用 Playground 快速练习 Swift 语法 ","date":"2015 November 30","permalink":"/posts/2015/11/30/","section":"Posts","summary":"Swift # The Swift Programming Language 中文版 如果没有苹果电脑，可用 swift 在线编译器 使用 Playground 快速练习 Swift 语法 ","title":"学习 Swift\u0026iOS"},{"content":"1. What is IPv6 #IPv6 是为了解决 IPv4 地址资源日渐枯竭的问题，使用的是 128bit 地址，可以提供更多的地址空间。IPv6 地址以 16bit 为一组，每组用冒号隔开，可以分为八组，每组以 4 个十六进制数表示，共 32 个十六进制数，例如 2001:0db8:85a3:08d3:1319:8a2e:0370:7344 是一个合法的 IPv6 地址，它又可以分为两个逻辑部分：一个 64 位的网络前缀和一个 64 位的主机地址。\nIPv6 中的 loopback interface 定义为 0000:0000:0000:0000:0000:0000:0000:0001 ，也可以表示为 ::1 ，因为每组中的前导 0 可以省略，一对连续的冒号表示多组 0 ，一个 IPv6 地址中允许出现一对连冒号。\nIPv4 位址可以很容易的转化为 IPv6 格式。如果 IPv4 的一个地址为135.75.43.52（十六进制为 0x874B2B34 ），它可以被转化为0000:0000:0000:0000:0000:ffff:874B:2B34 或者 ::ffff:874B:2B34 。同时，还可以使用混合符号（IPv4-compatible address），则地址可以为 ::ffff:135.75.43.52 。\n2. Linux support #首先需要内核支持，2.6 之后的内核都支持 IPv6 ，在 3.x 版本中，通常默认已经编译入内核：\n如果 IPv6 编译成了模块，可以用 modprobe ipv6 命令加载。内核支持后就可以在 /proc 文件系统中看到 if_net6 文件：\n要将网口配置成 IPv6 ，也需要配置命令支持 IPv6 ，可以用如下命令检查 ifconfig 是否支持 IPv6 :\n~# ifconfig -? 2\u0026gt;\u0026amp; 1 | grep -qw 'inet6' \u0026amp;\u0026amp; echo \u0026quot;utility 'ifconfig' is IPv6-ready\u0026quot; 检查 route 是否支持 IPv6 :\n~# route -? 2\u0026gt;\u0026amp; 1 | grep -qw 'inet6' \u0026amp;\u0026amp; echo \u0026quot;utility 'route' is IPv6-ready\u0026quot; 3. Configuration #为网口添加一个 IPv6 地址 ：\n可以用 del 参数删除 ：ifconfig eth0 inet6 del 2001:0db8:0:f101::1/64\n4. Test #可以用 IPv6 可以用 ping6 命令，例如测试 loopback interface ：\nping6 的 -I 参数可以指定网口，例如要测试 eth0 可以用 ping6 -I eth0 fe80::2e0:18ff:fe90:9205 。\n测试路由的 traceroute 命令也有 IPv6 版本： traceroute6 。\n5. 参考 #http://tldp.org/HOWTO/Linux+IPv6-HOWTO/index.html\n","date":"2015 November 27","permalink":"/posts/2015/11/27/","section":"Posts","summary":"1. What is IPv6 #IPv6 是为了解决 IPv4 地址资源日渐枯竭的问题，使用的是 128bit 地址，可以提供更多的地址空间。IPv6 地址以 16bit 为一组，每组用冒号隔开，可以分为八组，每组以 4 个十六进制数表示，共 32 个十六进制数，例如 2001:0db8:85a3:08d3:1319:8a2e:0370:7344 是一个合法的 IPv6 地址，它又可以分为两个逻辑部分：一个 64 位的网络前缀和一个 64 位的主机地址。","title":"Linux IPv6 HOWTO"},{"content":"1. 蓝牙简介 #蓝牙是一种支持设备短距离通信的无线电技术，使用 2.4GHz 频段，数据速率为1Mbps 。采用时分复用方案实现全双工传输。\n蓝牙技术将设备分为两种：主设备和从设备。\n蓝牙主设备的特点：主设备一般具有输入端。在进行蓝牙匹配操作时，用户通过输入端可输入随机的匹配密码来将两个设备匹配。蓝牙手机、安装有蓝牙模块的 PC 等都是主设备。（例如：蓝牙手机和蓝牙 PC 进行匹配时，用户可在蓝牙手机上任意输入一组数字，然后在蓝牙PC上输入相同的一组数字，来完成这两个设备之间的匹配。）\n蓝牙从设备特点：从设备一般不具备输入端。因此从设备在出厂时，在其蓝牙芯片中，固化有一个4位或6位数字的匹配密码。蓝牙耳机等都是从设备。（例如：蓝牙 PC 与蓝牙耳机匹配时，用户将蓝牙耳机上的匹配密码输入到蓝牙 PC 上，完成匹配。）\n蓝牙设备的呼叫过程：\n蓝牙主端设备发起呼叫，首先是查找，找出周围处于可被查找的蓝牙设备，此时从端设备需要处于可被查找状态。 主端设备找到从端蓝牙设备后，与从端蓝牙设备进行配对，此时需要输入从端设备的 PIN 码。 配对完成后，从端蓝牙设备会记录主端设备的信任信息，此时主端即可向从端设备发起呼叫，根据应用不同，可能是ACL数据链路呼叫或SCO语音链路呼叫，已配对的设备在下次呼叫时，不再需要重新配对。 已配对的设备，做为从端的蓝牙耳机也可以发起建链请求，但做数据通讯的蓝牙模块一般不发起呼叫。 链路建立成功后，主从两端之间即可进行双向的数据通讯。在通信状态下，主端和从端设备都可以发起断链，断开蓝牙链路。 蓝牙协议栈：\nRFCOMM 叫做电缆替代协议，它在蓝牙基带协议上仿真 RS-232 控制和数据信号，为使用串行线传送机制的上层协议（如 OBEX ）提供服务。 OBEX 叫做对象交换协议，采用简单的和自发的方式交换目标，用于传输文件。 2. Linux 对蓝牙的支持 #2.6 之后的内核都提供了蓝牙支持，通常都已经是默认的设置：\n[*] Networking support ---\u0026gt; [CONFIG_NET] \u0026lt;/M\u0026gt; Bluetooth subsystem support ---\u0026gt; [CONFIG_BT] \u0026lt;*/M\u0026gt; RFCOMM protocol support [CONFIG_BT_RFCOMM] [*] RFCOMM TTY support [CONFIG_BT_RFCOMM_TTY] \u0026lt;*/M\u0026gt; BNEP protocol support [CONFIG_BT_BNEP] [*] Multicast filter support [CONFIG_BT_BNEP_MC_FILTER] [*] Protocol filter support [CONFIG_BT_BNEP_PROTO_FILTER] \u0026lt;*/M\u0026gt; HIDP protocol support [CONFIG_BT_HIDP] Bluetooth device drivers ---\u0026gt; (Select the appropriate drivers for your Bluetooth hardware) \u0026lt;*/M\u0026gt; RF switch subsystem support ---\u0026gt; [CONFIG_RFKILL] Linux 官方的蓝牙协议栈是 BlueZ ，BlueZ 包括 ：\nHCI Core HCI UART, USB and Virtual HCI device drivers L2CAP module Configuration and testing utilities BlueZ 包提供了蓝牙编程库和各种工具：\nbccmd : is used to issue BlueCore commands to Cambridge Silicon Radio devices. bluemoon : is a Bluemoon configuration utility. bluetoothctl : is the interactive Bluetooth control program. bluetoothd : is the Bluetooth daemon. btmon : provides access to the Bluetooth subsystem monitor infrastructure for reading HCI traces. ciptool : is used to set up, maintain, and inspect the CIP configuration of the Bluetooth subsystem in the Linux kernel. hciattach : is used to attach a serial UART to the Bluetooth stack as HCI transport interface. hciconfig : is used to configure Bluetooth devices. hcidump : reads raw HCI data coming from and going to a Bluetooth device and prints to screen commands, events and data in a human-readable form. hcitool : is used to configure Bluetooth connections and send some special command to Bluetooth devices. hex2hcd : is used to convert a file needed by Broadcom devices to hcd (Broadcom bluetooth firmware) format. l2ping : is used to send a L2CAP echo request to the Bluetooth MAC address given in dotted hex notation. l2test : is L2CAP testing program. rctest : is used to test RFCOMM communications on the Bluetooth stack. rfcomm : is used to set up, maintain, and inspect the RFCOMM configuration of the Bluetooth subsystem in the Linux kernel. sdptool : is used to perform SDP queries on Bluetooth devices. libbluetooth.so : contains the BlueZ 4 API functions. 安装了 BlueZ 之后，配置文件都在 /etc/bluetooth 目录下。\n3. 在 Linux 中配置蓝牙 #使用的模块是 Intel 2330 ，同时支持 WIFI 和 Bluetooth 。调试前应该先下载模块的固件 iwlwifi-2030-6.ucode ，放入系统的 /lib/fireware 目录下，系统加载驱动 iwlwifi 时会自动查找。使用的系统是 yocto linux ，运行在 Intel Quark 平台的主板。\n系统启动后可以查看设备：\nroot@WR-IntelligentDevice:~# lsusb Bus 001 Device 002: ID 0424:2514 Standard Microsystems Corp. USB 2.0 Hub Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub Bus 001 Device 003: ID 8087:07da Intel Corp. 应该加载的驱动：\nroot@WR-IntelligentDevice:~# lsmod | grep bt bluetooth 200527 6 rfcomm,hidp,btusb btusb 11506 0 如果驱动加载成功，会出现蓝牙的设备节点，使用 hciconfig 命令查看：\nroot@WR-IntelligentDevice:~# hciconfig -a hci0: Type: BR/EDR Bus: USB BD Address: 00:15:00:A1:E3:83 ACL MTU: 310:10 SCO MTU: 64:8 DOWN RX bytes:495 acl:0 sco:0 events:22 errors:0 TX bytes:369 acl:0 sco:0 commands:22 errors:0 Features: 0xff 0xff 0x8f 0xfe 0xdb 0xff 0x5b 0x87 Packet type: DM1 DM3 DM5 DH1 DH3 DH5 HV1 HV2 HV3 Link policy: RSWITCH HOLD SNIFF PARK Link mode: SLAVE ACCEPT 可以看到设备的状态是 DOWN ，表示蓝牙还没有启动。手动启动蓝牙，可以看到蓝牙状态变为 UP RUNNING ，而且是从设备：\nroot@WR-IntelligentDevice:~# hciconfig hci0 up root@WR-IntelligentDevice:~# hciconfig -a hci0: Type: BR/EDR Bus: USB BD Address: 00:15:00:A1:E3:83 ACL MTU: 310:10 SCO MTU: 64:8 UP RUNNING RX bytes:990 acl:0 sco:0 events:44 errors:0 TX bytes:738 acl:0 sco:0 commands:44 errors:0 Features: 0xff 0xff 0x8f 0xfe 0xdb 0xff 0x5b 0x87 Packet type: DM1 DM3 DM5 DH1 DH3 DH5 HV1 HV2 HV3 Link policy: RSWITCH HOLD SNIFF PARK Link mode: SLAVE ACCEPT Name: 'PC Controller App v1.4' Class: 0x000000 Service Classes: Unspecified Device Class: Miscellaneous, HCI Version: 4.0 (0x6) Revision: 0x1ebd LMP Version: 4.0 (0x6) Subversion: 0xfc00 Manufacturer: Intel Corp. (2) 更好的方法是用 bluetoothd 启动蓝牙， bluetoothd 是一个守护进程，启动时会根据 /etc/bluetooth/ 下的配置文件初始化蓝牙，直接执行 bluetoothd 。\n3.1 连接手机蓝牙 #打开手机的蓝牙，测试用的是小米手机。这里要注意一点，手机上的蓝牙在打开后会有一段时间处于可检测状态，也就是其他蓝牙设备可以扫描到它，之后会关闭可检测性，这段时间的长短通常可以设置，有的手机在熄屏时也会关闭蓝牙的可检测性。\n然后扫描一下周边的蓝牙设备：\nroot@WR-IntelligentDevice:~# hcitool scan Scanning ... A2:CF:49:FD:99:AF MI-ONE Plus scan 用于扫描经典蓝牙设备，如果是低功耗蓝牙设备（BLE），例如手环之类，要 用 lescan 选项，调试 BLE 设备要用 gatttool 工具。\n测试能否连通：\nroot@WR-IntelligentDevice:~# l2ping -i hci0 -c 4 A2:CF:49:FD:99:AF Ping: A2:CF:49:FD:99:AF from 00:15:00:A1:E3:83 (data size 44) ... 44 bytes from A2:CF:49:FD:99:AF id 0 time 25.03ms 44 bytes from A2:CF:49:FD:99:AF id 1 time 25.32ms 44 bytes from A2:CF:49:FD:99:AF id 2 time 26.96ms 44 bytes from A2:CF:49:FD:99:AF id 3 time 27.06ms 4 sent, 4 received, 0% loss 利用 SDP 协议，我们还可以查看每个设备都有功能，能提供什么服务，每种基于 RFCOMM 的服务都使用某种协议，占据哪个“频道 (channel)”，这是使用服务时的一个重要参数，先看看自己：\nroot@WR-IntelligentDevice:~# sdptool browse local Browsing FF:FF:FF:00:00:00 ... Service Name: SIM Access Server Service RecHandle: 0x10000 Service Class ID List: \u0026quot;SIM Access\u0026quot; (0x112d) \u0026quot;Generic Telephony\u0026quot; (0x1204) Protocol Descriptor List: \u0026quot;L2CAP\u0026quot; (0x0100) \u0026quot;RFCOMM\u0026quot; (0x0003) Channel: 8 Profile Descriptor List: \u0026quot;SIM Access\u0026quot; (0x112d) Version: 0x0101 Service Name: Headset Audio Gateway Service RecHandle: 0x10001 Service Class ID List: \u0026quot;Headset Audio Gateway\u0026quot; (0x1112) \u0026quot;Generic Audio\u0026quot; (0x1203) Protocol Descriptor List: \u0026quot;L2CAP\u0026quot; (0x0100) \u0026quot;RFCOMM\u0026quot; (0x0003) Channel: 12 Profile Descriptor List: \u0026quot;Headset\u0026quot; (0x1108) Version: 0x0102 Service Name: Hands-Free Audio Gateway Service RecHandle: 0x10002 Service Class ID List: \u0026quot;Handsfree Audio Gateway\u0026quot; (0x111f) \u0026quot;Generic Audio\u0026quot; (0x1203) Protocol Descriptor List: \u0026quot;L2CAP\u0026quot; (0x0100) \u0026quot;RFCOMM\u0026quot; (0x0003) Channel: 13 Profile Descriptor List: \u0026quot;Handsfree\u0026quot; (0x111e) Version: 0x0105 Service Name: Audio Source Service RecHandle: 0x10003 Service Class ID List: \u0026quot;Audio Source\u0026quot; (0x110a) Protocol Descriptor List: \u0026quot;L2CAP\u0026quot; (0x0100) PSM: 25 \u0026quot;AVDTP\u0026quot; (0x0019) uint16: 0x102 Profile Descriptor List: \u0026quot;Advanced Audio\u0026quot; (0x110d) Version: 0x0102 Service Name: AVRCP TG Service RecHandle: 0x10004 Service Class ID List: \u0026quot;AV Remote Target\u0026quot; (0x110c) Protocol Descriptor List: \u0026quot;L2CAP\u0026quot; (0x0100) PSM: 23 \u0026quot;AVCTP\u0026quot; (0x0017) uint16: 0x103 Profile Descriptor List: \u0026quot;AV Remote\u0026quot; (0x110e) Version: 0x0104 Service Name: AVRCP CT Service RecHandle: 0x10005 Service Class ID List: \u0026quot;AV Remote\u0026quot; (0x110e) Protocol Descriptor List: \u0026quot;L2CAP\u0026quot; (0x0100) PSM: 23 \u0026quot;AVCTP\u0026quot; (0x0017) uint16: 0x103 Profile Descriptor List: \u0026quot;AV Remote\u0026quot; (0x110e) Version: 0x0100 Service Name: Dial-Up Networking Service RecHandle: 0x10006 Service Class ID List: \u0026quot;Dialup Networking\u0026quot; (0x1103) \u0026quot;Generic Networking\u0026quot; (0x1201) Protocol Descriptor List: \u0026quot;L2CAP\u0026quot; (0x0100) \u0026quot;RFCOMM\u0026quot; (0x0003) Channel: 1 Profile Descriptor List: \u0026quot;Dialup Networking\u0026quot; (0x1103) Version: 0x0100 再看看手机的蓝牙服务：\nroot@WR-IntelligentDevice:~# sdptool browse A2:CF:49:FD:99:AF Browsing A2:CF:49:FD:99:AF ... Service RecHandle: 0x10000 Service Class ID List: \u0026quot;PnP Information\u0026quot; (0x1200) Profile Descriptor List: \u0026quot;PnP Information\u0026quot; (0x1200) Version: 0x0102 Service Name: Audio Source Service RecHandle: 0x10001 Service Class ID List: \u0026quot;Audio Source\u0026quot; (0x110a) Protocol Descriptor List: \u0026quot;L2CAP\u0026quot; (0x0100) PSM: 25 \u0026quot;AVDTP\u0026quot; (0x0019) uint16: 0x102 Profile Descriptor List: \u0026quot;Advanced Audio\u0026quot; (0x110d) Version: 0x0102 Service Name: AVRCP TG Service RecHandle: 0x10002 Service Class ID List: \u0026quot;AV Remote Target\u0026quot; (0x110c) Protocol Descriptor List: \u0026quot;L2CAP\u0026quot; (0x0100) PSM: 23 \u0026quot;AVCTP\u0026quot; (0x0017) uint16: 0x103 Profile Descriptor List: \u0026quot;AV Remote\u0026quot; (0x110e) Version: 0x0100 Service Name: Voice Gateway Service RecHandle: 0x10003 Service Class ID List: \u0026quot;Handsfree Audio Gateway\u0026quot; (0x111f) \u0026quot;Generic Audio\u0026quot; (0x1203) Protocol Descriptor List: \u0026quot;L2CAP\u0026quot; (0x0100) \u0026quot;RFCOMM\u0026quot; (0x0003) Channel: 10 Profile Descriptor List: \u0026quot;Handsfree\u0026quot; (0x111e) Version: 0x0105 Service Name: Voice Gateway Service RecHandle: 0x10004 Service Class ID List: \u0026quot;Headset Audio Gateway\u0026quot; (0x1112) \u0026quot;Generic Audio\u0026quot; (0x1203) Protocol Descriptor List: \u0026quot;L2CAP\u0026quot; (0x0100) \u0026quot;RFCOMM\u0026quot; (0x0003) Channel: 11 Profile Descriptor List: \u0026quot;Headset\u0026quot; (0x1108) Version: 0x0102 Service Name: OBEX Object Push Service RecHandle: 0x10005 Service Class ID List: \u0026quot;OBEX Object Push\u0026quot; (0x1105) Protocol Descriptor List: \u0026quot;L2CAP\u0026quot; (0x0100) \u0026quot;RFCOMM\u0026quot; (0x0003) Channel: 12 \u0026quot;OBEX\u0026quot; (0x0008) Profile Descriptor List: \u0026quot;OBEX Object Push\u0026quot; (0x1105) Version: 0x0100 Service Name: OBEX Phonebook Access Server Service RecHandle: 0x10006 Service Class ID List: \u0026quot;Phonebook Access - PSE\u0026quot; (0x112f) Protocol Descriptor List: \u0026quot;L2CAP\u0026quot; (0x0100) \u0026quot;RFCOMM\u0026quot; (0x0003) Channel: 19 \u0026quot;OBEX\u0026quot; (0x0008) Profile Descriptor List: \u0026quot;Phonebook Access\u0026quot; (0x1130) Version: 0x0100 使用 openobex 包提供的 obex_test 工具，在 yocto 的官网可以下载到 recipes 文件和补丁。或者在下载源码：https://github.com/zuckschwerdt/openobex\n3.2 连接蓝牙耳机 #先启动本地的蓝牙服务并配置：\nroot@WR-IntelligentDevice:~# bluetoothd root@WR-IntelligentDevice:~# hciconfig hci0 noencrypt root@WR-IntelligentDevice:~# hciconfig hci0 piscan root@WR-IntelligentDevice:~# hciconfig hci0 name \u0026quot;bluez4\u0026quot; root@WR-IntelligentDevice:~# hciconfig hci0 pageto 65535 然后启动蓝牙耳机，使之处于可检测状态，然后扫描：\nroot@WR-IntelligentDevice:~# hcitool scan Scanning ... 50:C9:71:AA:E0:AE JABRA EASYGO 准备一个 test.wav 的音频文件，然后用如下脚本测试蓝牙耳机：\n#!/bin/sh local mac=\u0026quot;50:C9:71:AA:E0:AE\u0026quot; local asoundconf=\u0026quot;/etc/asound.conf\u0026quot; #add service sdptool add a2snk sdptool add a2src sdptool add avrct sdptool add avrtg sdptool add hf sdptool add hs echo \u0026quot;\u0026quot; \u0026gt;\u0026gt; $asoundconf echo \u0026quot;pcm.bluetooth{\u0026quot; \u0026gt;\u0026gt; $asoundconf echo \u0026quot; type bluetooth\u0026quot; \u0026gt;\u0026gt; $asoundconf echo \u0026quot; device $mac\u0026quot; \u0026gt;\u0026gt; $asoundconf echo \u0026quot; profile \\\u0026quot;hifi\\\u0026quot;\u0026quot; \u0026gt;\u0026gt; $asoundconf echo \u0026quot;}\u0026quot; \u0026gt;\u0026gt; $asoundconf echo \u0026quot;Bind to $mac ...\u0026quot; simple-agent hci0 $mac || { echo \u0026quot;simple-agent failed!\u0026quot; exit 1 } echo \u0026quot;Connect $mac ...\u0026quot; bluez-test-audio connect $mac || { echo \u0026quot;audio connect failed!\u0026quot; exit 1 } echo \u0026quot;Connection result ...\u0026quot; hcitool con echo \u0026quot;Play audio ...\u0026quot; aplay -D bluetooth ./test.wav 正常情况会打印如下信息，蓝牙耳机可以听到音频内容：\nAudio sink service registered Audio source service registered Remote control service registered Remote target service registered Handsfree service registered Headset service registered Bind to 50:C9:71:AA:E0:AE ... Release New device (/org/bluez/3319/hci0/dev_50_C9_71_AA_E0_AE) Connect 50:C9:71:AA:E0:AE ... Connection result ... Connections: \u0026lt; ACL 50:C9:71:AA:E0:AE handle 34 state 1 lm MASTER AUTH ENCRYPT Play audio ... Playing WAVE './test.wav' : Signed 16 bit Little Endian, Rate 44100 Hz, Stereo ","date":"2015 October 22","permalink":"/posts/2015/10/22/","section":"Posts","summary":"1. 蓝牙简介 #蓝牙是一种支持设备短距离通信的无线电技术，使用 2.","title":"Linux 下调试蓝牙模块的笔记"},{"content":"comgt帮助文档\ncomgt 是一个 GPRS/EDGE/3G/HSDPA 和 3G/GPRS 模块配置工具。它更像是一个脚本语言解释器，通过调用内建、或者外部脚本与 GPRS 和 3G 模块通讯。\n语法 #comgt -d device -ehstvVx script\n参数 # -d device ：指定模块的通讯口，例如 /dev/ttyUSB2 或 /dev/modem -e ：打开串口通信的 echo -h ：显示帮助信息 -s ：在外部脚本执行前，不要运行内建的默认脚本 -t ：使用备用线路终端 -v ：运行详细模式，会显示详细的通讯过程 -V ：显示版本信息 -x ：将内建和外部脚本中的波特率 115200 改为 57600 内建脚本 # comgt ：运行默认的内建脚本。如果运行 comgt 时没有指定任何脚本，例如 comgt -d /dev/ttyS1 ,它会依次执行几个内建的脚本 PIN 、reg、sig 。 comgt help ：列出所有帮助信息。 comgt info ：列出当前模块的配置。 comgt sig ：获取信号强度。 comgt reg ：显示注册状态。 comgt 3G ：将模块设为 3G only (UMTS/HSDPA) 模式。 comgt 2G ：将模块设为 2G only (GSM/GPRS/EDGE) 模式。 comgt 3G2G ：将模块设为 3G preferred (UMTS/HSDPA and GSM/GPRS/EDGE) 模式 外部脚本 #以 sendmsg.gcom 为例，该脚本实现了发送短信的功能：\nopengt set com 115200n81 set comecho off set senddelay 0.02 waitquiet 0.2 0.2 flash 0.1 :start send \u0026quot;AT+CMGF=1^m\u0026quot; get 1 \u0026quot;\u0026quot; $s print $s send \u0026quot;AT+CSCS=GSM^m\u0026quot; get 1 \u0026quot;\u0026quot; $s print $s send \u0026quot;AT+CSMP=17,168,0,0^m\u0026quot; get 1 \u0026quot;\u0026quot; $s print $s print \u0026quot;Input message:\\n\u0026quot; input $m send \u0026quot;AT+CMGS=+8613824741490^m\u0026quot; send $m+\u0026quot;^Z\u0026quot; get 1 \u0026quot;\u0026quot; $s print $s :continue exit 0 opengt 段用于设置串口的各项参数,之后会一次执行 start 段的命令，这里涉及到几个常用的命令：\nsend : 向串口发送字符串。这个字符应该以 ^m 结尾，表示一个回车符。几个字符串可以用加号连接。有时一个 AT 命令后会等待用户输入，比如 AT+CMGS 后会等待输入短信内容，此时继续调用 send 命令即可。^Z 表示 Ctrl+Z 组合键。 input : 等待用户输入，输入的字符串放入变量 $x 中。 print : 在终端打印一行字符串。 get : 获取串口返回从字符串。语法是 get timeout \u0026quot;terminators\u0026quot; $string 执行该脚本：\ngcom -d /dev/ttyUSB2 -s sendmsg.gcom ","date":"2015 September 9","permalink":"/posts/2015/09/09/","section":"Posts","summary":"comgt帮助文档","title":"Linux 命令行下的 3G 模块配置工具 comgt"},{"content":"常见的 GPS 数据文件格式有 GPS、CVS、KML 等，这些数据格式本身并不复杂，基本都是对坐标点的集合，大部分 GPS 记录仪都支持多种格式的数据文件的导入和导出。但是有时还是需要做格式转换，比如 Google Earth 只支持 KML 格式导入。所以，我准备做一个 GPS 数据格式转换工具，使用 Python，做一个基于命令行的工具。\n1. GPX #GPX（GPS eXchange Format，GPS交换格式）是一个XML格式，它可以用来描述路点、轨迹、路程。这个格式是免费的，可以在不需要付任何许可费用的前提下使用。它的标签保存位置，海拔和时间。\n在GPX中，一个没有顺序关系的点集合，叫路点。一个有顺序的点的集合叫轨迹或者路程。轨迹是一个人曾经走过的记录，路程是一个建议的下一步要走的地方。所以，一般来讲，轨迹里的点，包含时间信息，路程里的点，没有时间信息。\n最小的一个GPX文件，仅仅包含一个经纬度坐标的点，其它的都是可选的。\nGPX 1.1 : http://www.topografix.com/GPX/1/1/\n2. CSV #CSV （Comma-Separated Values，逗号分隔值） 文件格式并没有通用的标准，其文件以纯文本形式存储表格数据（数字和文本）。纯文本意味着该文件是一个字符序列，不含必须像二进制数字那样被解读的数据。CSV 文件由任意数目的记录组成，记录间以某种换行符分隔；每条记录由字段组成，字段间的分隔符是其它字符或字符串，最常见的是逗号或制表符。CSV 文件是纯文本文件，但是可以直接用 Office Excel 软件打开。\n下图是一个 CSV 格式的 GPS 轨迹数据文件，每条记录有三个字段，分别表示经度、纬度、海拔。（注：北纬为正，南纬为负，东经为正，西经为负）\n对 CSV 数据读写可以直接调用 Python 的 csv 模块 ：https://docs.python.org/2/library/csv.html\ncsv 模块定义了如下几个函数：\ncsv.reader(csvfile, dialect=\u0026lsquo;excel\u0026rsquo;, **fmtparams)\n改函数会遍历 csvfile 中的每一行，然后返回一个 reader 对象， csvfile 可以是任何支持 iterator 协议的对象，每次调用它的 next() 方法都会返回一个字符串。\n3. KML #KML 也是基于 XML 语法的标记语言，是 Google Earth 特有的格式，它不仅可以记录 GPS 轨迹，还可以标记很多地理数据，包括点、线、面、多边形、多面体等等。\n","date":"2015 September 8","permalink":"/posts/2015/09/08/","section":"Posts","summary":"常见的 GPS 数据文件格式有 GPS、CVS、KML 等，这些数据格式本身并不复杂，基本都是对坐标点的集合，大部分 GPS 记录仪都支持多种格式的数据文件的导入和导出。但是有时还是需要做格式转换，比如 Google Earth 只支持 KML 格式导入。所以，我准备做一个 GPS 数据格式转换工具，使用 Python，做一个基于命令行的工具。","title":"用 Python 解析 GPS 轨迹数据"},{"content":" Keep an eye on what is happening on your machine and in the World\nhttp://tracesof.net/uebersicht/\nAt a Glance #Übersicht lets you run system commands and display their output on your desktop in little containers, called widgets. Widgets are written using HTML5, which means they\nare easy to write and customize can show data in tables, charts, graphs \u0026hellip; you name it can react to different screen sizes The following screenshots give you a glimpse of Übersicht in action:\nRolling your own #Widgets are written in CoffeeScript or plain JavaScript. A minimal widget, written in CoffeeScript looks like this:\ncommand: \u0026quot;echo Hello World!\u0026quot; refreshFrequency: 5000 # ms render: (output) -\u0026gt; \u0026quot;\u0026lt;h1\u0026gt;#{output}\u0026lt;/h1\u0026gt;\u0026quot; style: \u0026quot;\u0026quot;\u0026quot; left: 20px top: 20px color: #fff \u0026quot;\u0026quot;\u0026quot; Please visit the GitHub page for the full documentation : https://github.com/felixhageloh/uebersicht\n","date":"2015 August 29","permalink":"/posts/2015/08/29/","section":"Posts","summary":"Keep an eye on what is happening on your machine and in the World","title":"可自定义的 Mac 桌面扩展 Übersicht"},{"content":"About #http://freegeoip.net provides a public HTTP API for software developers to search the geolocation of IP addresses. It uses a database of IP addresses that are associated to cities along with other relevant information like time zone, latitude and longitude.\nYou\u0026rsquo;re allowed up to 10,000 queries per hour by default. Once this limit is reached, all of your requests will result in HTTP 403, forbidden, until your quota is cleared.\nThe freegeoip web server is free and open source so if the public service limit is a problem for you, download it and run your own instance.\nAPI #The HTTP API takes GET requests in the following schema:\nfreegeoip.net/{format}/{IP_or_hostname} Supported formats are: csv, xml, json and jsonp. If no IP or hostname is provided, then your own IP is looked up.\nExamples # CSV\nfreegeoip.net/csv/8.8.8.8 XML\nfreegeoip.net/xml/4.2.2.2 JSON\nfreegeoip.net/json/github.com 要获取本机的公网 IP 可以用 http://httpbin.org 提供的服务。在 Linux 中只需 curl http://httpbin.org/ip 即可返回本机的公网 IP ：\n~$ curl http://httpbin.org/ip { \u0026quot;origin\u0026quot;: \u0026quot;218.18.232.122\u0026quot; } 其他类似功能的网站还有：\nhttp://ip-api.com/ https://ipstack.com/ ","date":"2015 August 22","permalink":"/posts/2015/08/22/","section":"Posts","summary":"About #http://freegeoip.","title":"获得 IP 所在地的网站 freegeoip.net"},{"content":"1. MQTT 介绍 #http://mqtt.org/\nMQTT 是一个轻型协议，使用基于 TCP/IP 协议的发布/订阅消息转发模式，专门用于机器对机器 (M2M) 通信。 MQTT 协议的中心是 MQTT 服务器或代理 (broker) ，支持发布程序和订阅程序进行访问，如下图所示：\n用户可以使用 MQTT 构建一个传感器网络，其中各种传感器都能够以其传感器独有的消息形式发布传感器值。 订阅程序能够订阅不同的消息，以据此采取措施。 MQTT 代理将处理从发布程序到订阅程序的转发消息。\n如果已经有了一个 broker ，可以直接用 MQTT 客户端软件测试。这里有一个跨平台的 MQTT 客户端 MQTT.fx 。\n2. Mosquitto #mosquitto 是一个开源的 MQTT broker ，目前支持 v3.1 和 v3.1.1 协议 ，同时提供了一个 C 语言动态链接库 libmosquitto ，用于实现 mqtt 客户端：\nhttp://mosquitto.org/documentation/\n下载 mosquitto-1.4.2.tar.gz 后，解压，然后执行 make ，make install 。即可得到几个二进制可执行文件：\nmosquitto : mqtt broker mosquitto_passwd : 管理 mosquitto 密码文件的命令行工具 mosquitto_sub : mqtt 订阅者程序 mosquitto_pub ： mqtt 发布者程序 相关的配置文件安装在 /etc/mosquitto/ 目录下。在 Ubuntu 下可以直接安装 sudo apt-get install mosquitto 。\n现在测试一下客户端和服务端程序。为了测试方便，将客户端和服务端程序都在本机，使用 localhost 连接。执行 mosquitto -v 启动 broker ，-v 参数表示打印出运行信息，可以看到默认使用的端口是1883 :\n如果你的系统出现如下问题，就需要添加一个 mosquitto 用户：\n可以使用 systemd 让 mosquitto 自动启动，添加如下配置文件：\nubuntu@VM-231-137-ubuntu:/etc/systemd/system$ cat mosquitto.service [Unit] Description=Mosquitto MQTT Broker ConditionPathExists=/etc/mosquitto/mosquitto.conf After=network.target [Service] ExecStart=/usr/local/sbin/mosquitto -c /etc/mosquitto/mosquitto.conf ExecReload=/bin/kill -HUP $MAINPID User=mosquitto Restart=on-failure RestartSec=10 [Install] WantedBy=multi-user.target 然后在第二个终端启动订阅者程序: mosquitto_sub -h localhost -t test -v，用 -h 参数指定服务器 IP ，用 -t 参数指定订阅的话题。\n在第三个终端启动发布者程序: mosquitto_pub -h localhost -t test -m \u0026quot;Hello world\u0026quot;，用 -m 参数指定要发布的信息内容，然后在订阅者的终端就可以看到由 broker 推送的信息：\n在 broker 的终端也可以看到处理信息的过程：\nmosquitto 语法是\nmosquitto [-c config file] [ -d | --daemon ] [-p port number] [-v] -c 是指定配置文件的路径，默认不需要配置文件。 -d 表示作为守护进程运行在后台。 -p 用来指定监听的端口，默认是 1883 ，使用 TCP 连接，如果要使用 UDP 连接，需要设为 1884。 -v 表示生成详细的运行日志，等价于配置文件中将 log_type 设为 all 。 mosquitto 默认是不需要配置文件的，它会对所有的选项采用默认值，比如用户名和密码。默认不需要用户名和密码，如果需要，可以用 mosquitto_passwd 新建用户和密码，并管理，语法是：\nmosquitto_passwd [ -c | -D ] passwordfile username mosquitto_passwd -b passwordfile username password mosquitto_passwd -U passwordfile -c 表示新建一个密码文件，如果文件已经存在，会被覆盖，用户名中不能包含冒号，因为密码文件中用户名和密码是用冒号隔开的。执行之后会要求设置密码，输入内容不可见，密码以加密 hash 值的方式存储在密码文件中。 -D 表示删除用户名。 -b 表示在命令行中，以明文方式设置密码。 -U 用来将密码文件中的明文密码改成加密格式。如果文件中的密码已经是 hash 值，千万不要用这个选项，否则它会对 hash 值再做一次运算，然后修改密码文件。 设好密码后，在配置文件中设置 allow_anonymous false 再用 password_file 指定密码文件的路径就可以使用了。配置文件可以放在任何位置，只要 mosquitt 能找到它。配置文件中，每一行设置一个选项，选项名称和值用空格隔开，用井号可以注释。安装好的 mosquitto 在 /etc/mosquitto/ 目录下有配置文件和密码文件的例子，复制一份皆可使用：\n$ ls /etc/mosquitto/ aclfile.example mosquitto.conf.example pskfile.example pwfile.example 客户端可以通过订阅 $SYS 层的主题来获取 broker 的信息，这些主题每 sys_interval 秒更新一次，如果 sys_interval 设为 0 则不会发送，标记为 static 的主题只会为每个订阅者发送一次。如果是在命令行中使用，要用反斜杠把 $SYS 作为普通字符串传递给客户端，否则 $SYS 会被当做环境变量来处理。\n$SYS/broker/bytes/received ，broker 从启动开始收到的总字节数。 $SYS/broker/bytes/sent ，broker 从启动开始发送的总字节数。 $SYS/broker/clients/connected, $SYS/broker/clients/active (不建议使用)，当前连接的客户端数目。 $SYS/broker/clients/expired ，由于 persistent_client_expiration 选项过期而断开的客户端数量。 $SYS/broker/clients/disconnected, $SYS/broker/clients/inactive (不建议使用)，所有断开的已注册客户端（包括清除进程）的数量。 $SYS/broker/clients/maximum ，过去所有时间所连接的最大客户端数量（从服务器开机开始）。 $SYS/broker/clients/total ，所有连接过的客户端数量(包括活跃的客户端和已经断开的客户端数量)。 $SYS/broker/connection/# ，当代理服务器被配置为桥接模式的时候, 通常做法是提供一种状态话题来只是连接的状态，这个话题默认为 $SYS/broker/connection/， 如果数值为1，证明连接是活跃的,为0证明连接不活跃. 查看桥接一节来获取更多信息。 $SYS/broker/heap/current size ，mosquitto 当前使用的最大内存，请注意，由于编译时候的选择这个话题可能不可用。 $SYS/broker/heap/maximum size ，mosquitto 曾经使用的最大内存，请注意，由于编译时候的选择这个话题可能不可用。 $SYS/broker/load/connections/+ ，不同的时间间隔内代理服务器收到连接数据包的平均数量， 最后的+可以为 5分钟、10分钟、15分钟。 $SYS/broker/load/bytes/received/+ ，不同的时间间隔内代理服务器收到的平均比特数， 最后的+可以为 5分钟、10分钟、15分钟。 $SYS/broker/load/bytes/sent/+ ，不同的时间间隔内代理服务器发送的平均比特数， 最后的+可以为 5分钟、10分钟、15分钟。 $SYS/broker/load/messages/received/+ ，不同的时间间隔内代理服务器收到各种类型数据包的平均数量， 最后的+可以为 5分钟、10分钟、15分钟。 $SYS/broker/load/messages/sent/+ ，不同的时间间隔内代理服务器发送各种类型数据包的平均数量， 最后的+可以为 5分钟、10分钟、15分钟。 $SYS/broker/load/publish/dropped/+ ，不同的时间间隔内代理服务器发布数据包丢失的数量， 最后的+可以为 5分钟、10分钟、15分钟。 $SYS/broker/load/publish/received/+ ，不同的时间间隔内代理服务器发布数据包被收到的平均数量， 最后的+可以为 5分钟、10分钟、15分钟。 $SYS/broker/load/publish/sent/+ ，不同的时间间隔内代理服务器发布的数据包被发送的平均数量， 最后的+可以为 5分钟、10分钟、15分钟。 $SYS/broker/load/sockets/+ ，不同的时间间隔内代理服务器打开socket连接平均数量， 最后的+可以为 5分钟、10分钟、15分钟。 $SYS/broker/messages/inflight ，具有QoS\u0026gt;0正在等待的确认消息的数量。 $SYS/broker/messages/received ，从代理服务器开机开始收到的消息总数。 $SYS/broker/messages/sent ，从服务器开机开始所发送的各种类型消息的总数。 $SYS/broker/messages/stored ，在消息存储机制中保留的消息总数，包括客户端保留消息和持久客户端的队列消息。 $SYS/broker/publish/messages/dropped ， 由于队列机制或者传输限制所丢弃数据包的数量. 参照mosquitto.conf 的 max_inflight_messages 和 max_queued_messages 选项获取更多解释。 $SYS/broker/publish/messages/received ，从代理服务器开机开始发布的信息被收到总数。 $SYS/broker/publish/messages/sent ，从代理服务器开机开始发布的信息总数。 $SYS/broker/retained messages/count ，代理服务器中活跃的保留消息的总数。 $SYS/broker/subscriptions/count ，代理服务器中活跃的订阅的总数。 $SYS/broker/timestamp ，代理服务器编译的时间戳. Static. $SYS/broker/uptime ，服务器合计在线时间（以秒计）。 $SYS/broker/version ，代理服务器版本. Static. 3. 安全性 #MQTT 协议没有对安全性设置强制标准，只是在第五章提出了建议，提供合适的安全功能是实现者的责任。默认情况下，mosquitto 不需要任何验证，用户可以匿名连接。如果设置了 allow_anonymous false ，客户端必须提供正确的用户名和密码进行验证，连接时应该将用户名和密码加密传输，否则有被拦截的危险。此外，mosquitto 还提供基于 SSL/TLS 证书的安全验证，使用 OpenSSL 作为 SSL/TLS 的实现。\n3.1. SSL/TLS #我们可以通过这个脚本https://github.com/owntracks/tools/raw/master/TLS/generate-CA.sh 自建 CA 并颁发证书：\n$ wget https://github.com/owntracks/tools/raw/master/TLS/generate-CA.sh . $ ./generate-CA.sh 生成的文件：\nca.crt ，CA 根证书 localhost.crt ，mosquitto 服务器上的证书 localhost.key ，mosquitto 服务器上的密钥 将这三个文件复制到 /etc/mosquitto/certificates/ 目录下。然后修改配置文件，开启 SSL/TLS ：\nport 8883 cafile /etc/mosquitto/certificates/ca.crt certfile /etc/mosquitto/certificates/localhost.crt keyfile /etc/mosquitto/certificates/localhost.key require_certificate true 启动 mosquitto :\n$ mosquitto -c /etc/mosquitto/mosquitto.conf -v 1495335112: mosquitto version 1.4.11 (build date 2017-05-20 17:44:03+0800) starting 1495335112: Config loaded from /etc/mosquitto/mosquitto.conf. 1495335112: Opening ipv4 listen socket on port 8883. 1495335112: Opening ipv6 listen socket on port 8883. 再用根证书为客户端生成密钥和证书：\n$ openssl genrsa -out client.key 2048 $ openssl req -new -out client.csr -key ./client.key $ openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAserial ./ca.srl -out client.crt -days 3650 -addtrust clientAuth 将根证书 ca.crt 、客户端密钥 client.key 、证书 client.crt 发送给客户端，本地测试的话，直接连接 localhost :\n$ mosquitto_sub -h localhost -p 8883 -t \\$SYS/broker/bytes/\\# -v --cafile ca.crt --cert client.crt --key client.key $SYS/broker/bytes/received 0 $SYS/broker/bytes/sent 0 如果设置了 require_certificate false ，就是 SSL 单向认证，客户端只需提供 cafile，也无需设置 \u0026ndash;cert 和 \u0026ndash;key 。如果设置了 allow_anonymous false ，还要提供用户名和密码，否则会客户端会报错：\n$ mosquitto_sub -h localhost -p 8883 -t \\$SYS/broker/bytes/\\# -v --cafile ca.crt --cert client.crt --key client.key Connection Refused: not authorised. 3.2. WebSockets with SSL/TLS #mosquitto 编译时默认是不支持 WebSockets 的，需要在 config.mk 中将 WITH_LIBWEBSOCDETS:=no 改为 yes 。在配置文件中追加 WebSockets 的选项，并加上用户名和密码：\nlistener 8884 protocol websockets password_file /etc/mosquitto/mosquitto.password 然后重启 mosquitto 。可以在 http://www.hivemq.com/demos/websocket-client/ 页面测试，这是一个 Websockets Client 。输入 mosquitto 服务器的 IP 、端口、用户名和密码，即可连接，然后添加订阅话题：\n4. libmosquitto 库 #关于客户端的编程可以参考 mosquitto_sub 和 mosquitto_pub 的源码。libmosquitto API 文档：http://mosquitto.org/api/files/mosquitto-h.html\n4.1. 获取库版本 #libmosquitto 是 C 语言共享库，可以创建 MQTT 客户端程序。所有的 API 函数都有 mosquitto_ 前缀。\nint mosquitto_lib_version(int *major,int *minor,int *revision); 获取库的版本信息，返回到三个参数中。\n4.2. 初始化和清除 #int mosquitto_lib_init();\tint mosquitto_lib_cleanup();\t使用 libmosquitto 库函数前，要先调用 mosquitto_lib_init() 初始化；使用 libmosquitto 库后，要调用 mosquitto_lib_cleanup() 完成清除工作。\n4.3. 构建和释放客户端 #struct mosquitto *mosquitto_new(const char *id, bool clean_session, void *userdata);\t新建一个 mosquitto 客户端实例。调用成功时，返回一个 struct mosquitto 指针，失败时返回 NULL 指针，并产生错误代码，可以用 mosquitto_strerror() 函数获取错误代码的含义。第一个参数需要传递一个字符串作为 client ID ，如果设为 NULL ，会自动生成一个随机 ID 。第二个参数是布尔型，如果设为 false ，当 client 断开连接后，broker 会保留该 client 的订阅和消息，直到再次连接成功；如果设为 true ，client 断开连接后，broker 会将所有的订阅和消息删除。第三个参数是传递给回调函数的用户数据。\n释放一个 mosquitto 客户端对象：\nvoid mosquitto_destroy(struct mosquitto *mosq);\t还用一个函数 mosquitto_reinitialise() 可以重新初始化一个已经存在的客户端实例。\n4.4. 验证和编码 #如果 broker 要求提供用户名和密码，可以通过函数设置提供，用户名和密码都是通过字符串传递的：\nint mosquitto_username_pw_set(\tstruct mosquitto *\tmosq, const char *username, const char *password ); 4.5. 发布 #int mosquitto_publish(\tstruct mosquitto *mosq, int *mid, const char *topic, int payloadlen, const void *payload, int qos, bool retain\t); 发布一个消息。第一个参数是 client 实例。第二个参数要指向一个整数，不能为 NULL ，它会被当做这个消息的 ID 。payloadlen 表示消息的长度，*playload 表示消息的内容。 qos 表示服务质量，retain 表示是否保留信息，详细含义可以查看 MQTT 协议的 3.1 节，对 PUBLISH 控制报文的详细描述。\n4.6. 订阅 #int mosquitto_subscribe( struct mosquitto *mosq, int *mid, const char *sub, int qos\t); 向 broker 发送 SUBSCRIBE 报文请求订阅一个话题。第一个参数是 client 实例。第二个参数如果不为 NULL ，函数会把它作为该话题消息的 ID ，它可以用于订阅回调函数。第三个参数是话题名称。第四个参数是向 broker 请求的服务质量：\n0 表示最多分发一次，消息的分发依赖于底层网络的能力。接收者不会发送响应，发送者也不会重试。消息可能送达一次也可能根本没送达。 1 表示确保消息至少送达一次，需要发布者和订阅者双方在报文中确认，可能重复。 2 表示仅分发一次，这是最高等级的服务质量，消息丢失和重复都是不可接受的。使用这个服务质量等级会有额外的开销。 调用成功会返回 MOSQ_ERR_SUCCESS ，但这不代表订阅成功。关于消息质量的详情可以查看 MQTT 协议的 4.3 节。\n取消订阅的函数是：\nint mosquitto_unsubscribe( struct mosquitto *mosq, int *mid, const char *sub, ); 4.7. 遗嘱 #简单的说，当 broker 检测到网络故障、客户端异常等问题，需要关闭某个客户端的连接时，可以向该客户端发布一条消息，叫做遗嘱消息。默认是没有遗嘱消息的，需要用函数设置遗嘱消息的话题、内容、服务质量等，在连接时由客户端告诉 broker ：\nint mosquitto_will_set(struct\tmosquitto *mosq, const char *topic, int payloadlen, const void *payload, int qos, bool retain ); 该函数必须在 mosquitto_connect() 之前调用。对应的清除遗嘱的函数是：\nint mosquitto_will_clear(struct mosquitto *mosg); 4.8. 连接和断开 #int mosquitto_connect(\tstruct mosquitto *mosq, const char *host, int port, int keepalive, ); 连接一个 broker 。第一个参数是 client 实例。第二个参数是 broker 的 IP 或者 hostname 。第三参数是连接的端口，通常是 1883 。第四个参数是保持连接的时间间隔，单位是秒，关于这个参数的详细含义可以查看 MQTT 协议的 CONNECT 报文格式。连接成功会返回 MOSQ_ERR_SUCCESS 。\n该函数还有一些扩展，比如可以绑定本地网络接口的 mosquitto_connect_bind 。如果调用了这两个函数连接 broker ，就必须使用 mosquitto_loop() 或者 mosquitto_loop_forever() 启动网络循环。还有一些非阻塞的连接函数，例如 mosquitto_connect_async()，调用它们的时候，必须使用 mosquitto_loop_start() 启动网络循环。断开连接可以调用 int mosquitto_disconnect(struct mosquitto *mosq) ，此外还有重连函数 mosquitto_reconnect()。\n4.9. 网络循环 #int mosquitto_loop(struct mosquitto *mosq, int timeout, int max_packets ); 客户端主网络循环，必须调用该函数来保持 client 和 broker 之间的通讯。收到或者发送消息时，它会调用相应的回调函数处理。当 QoS\u0026gt;0 时，它还会尝试重发消息。第一个参数是 client 实例。timeout 是阻塞等待时间，单位是微妙，设为 0 表示立即返回，设为负数表示使用默认值 1000ms 。max_packets 目前没有使用，设为 1 即可。\n通常不会直接调用 mosquitto_loop() 。如果程序里只会运行一个 MQTT client 的循环，可以调用 mosquitto_loop_forever() ，参数完全相同:\nint mosquitto_loop_forever(struct mosquitto *mosq, int timeout, int max_packets ); 它会在一个阻塞的无限循环里调用 mosquitto_loop() ，如果从服务器掉线了，它会自动重连。直到在某个回调函数中调用了 mosquito_disconnect() ，该函数才会返回。\n另一种方法是使用 mosquitto_loop_start() ，调用一次就会新建一个线程，在线程里不停的调用 mosquitto_loop() 来处理网络信息。\n如果要将 mosquitto 客户端操作与您自己的 select() 调用集成，请使用 mosquitto_socket()，mosquitto_loop_read()，mosquitto_loop_write() 和 mosquitto_loop_misc() 函数。\n4.10. 回调函数 #设置不同的回调函数，mosquitt_loop() 会根据不同的情况，调用相应的回掉函数。\n####确认连接回调函数\nvoid mosquitto_connect_callback_set(struct mosquitto *mosq,\tvoid (*on_connect)(struct mosquitto *mosq, void *obj, int rc) ); 当 client 请求连接后，broker 会回应一条 CONNECK 消息（确认连接请求），client 收到后会调用回调函数。我们可以在这个回调函数里判断连接是否成功，成功后再调用 mosquitto_subscribe() 订阅话题，可以依次订阅多个话题。第一个参数是用 mosquitto_new() 函数新建的 client 实例。第二个参数是回调函数。回调函数的三个参数：\nmosq ，client 实例 obj ， mosquitto_new() 函数提供的用户数据 rc ，broker 回应的代码，0 表示连接成功，其他值表示拒绝连接，可以用 mosquitto_connack_string() 函数获取代码的含义。 ####断开连接回调函数\nvoid mosquitto_disconnect_callback_set(struct mosquitto *mosq, void (*on_disconnect)(struct mosquitto *mosq, void *obj, int rc) ); 当 client 与 broker 断开连接后，会调用这里设置的函数。回调函数中的 rc 表示断开连接的原因，0 表示 client 调用了 mosquitt_disconnect() ，其他值都表示未知原因。我们可以在这个函数里判断客户端是否意外掉线。\n####消息回调函数\nvoid mosquitto_message_callback_set( struct mosquitto *mosq, void (*on_message)(struct mosquitto *mosq, void *obj, const struct mosquitto_message *message) ); 当 client 收到 broker 发来的消息时会调用它。第一个参数是 client 实例。第二个参数是回调函数，它的第二个参数是 mosquitto_new() 函数提供的用户数据。第三个参数保存了收到的消息，回掉函数退出后这个指针指向的内存就会被释放，它的定义是：\nstruct mosquitto_message{ int mid; char *topic; //消息话题 void *payload; //消息内容，MQTT 中叫做有效载荷 int payloadlen; //消息的长度，单位是字节 int qos; //服务质量 bool retain; //是否保留消息 }; qos 和 retain 的详细含义可以查看 MQTT 协议的 3.1 节，对 PUBLISH 控制报文的详细描述。\n####订阅回调函数\nvoid mosquitto_subscribe_callback_set(struct mosquitto *mosq, void (*on_subscribe)(struct mosquitto *mosq, void *obj, int mid, int qos_count, const int *granted_qos) ); broker 收到订阅请求后，会向 client 发送一个 SUBACK 报文作为回应，client 收到后就会调用这里设置的函数，可以在回调函数里判断订阅是否成功。回调函数中， mid 表示消息 ID ，granted_qos 指向一个数组，里面存放的是每一个已经批准的订阅的 QoS ，qos_count 表示 granted_qos 数组的大小。\n####取消订阅回调函数\nvoid mosquitto_unsubscribe_callback_set(struct mosquitto *mosq, void (*on_unsubscribe)(struct mosquitto *mosq, void *obj, int mid) ); broker 收到取消订阅的请求后，会想 client 发送一个 UNSUBACK 报文作为回应，client 收到后就会调用这里设置的函数。\n####日志回调函数\nvoid mosquitto_log_callback_set(struct mosquitto *mosq, void (*on_log)(struct mosquitto *mosq, void *obj, int level, const char *str) ); 当 libmosquitto 产生日志信息时会调用这里设置的函数，我们可以在回调函数中打印这些日志。level 表示日志信息的等级，包括 MOSQ_LOG_INFO、MOSQ_LOG_NOTICE、MOSQ_LOG_WARNING、MOSQ_LOG_ERR 和 MOSQ_LOG_DEBUG 。str 是日志信息的内容。\n5. 后记 #其实，目前可选的 MQTT Borker 很多，除了 mosquitto ，还有 Apache Apollo，支持多种协议，还有国人开发 emqtt，号称是百万级分布式开源物联网MQTT消息服务器。还有一个跟好用的 MQTT client —— paho ，也是开源产品，支持多种语言，包括 C 、C++、Python、Java、JavaScript 等。\n6. 参考 # MQTT 协议中文版 MQTT 入门篇 MQTT 进阶篇 MQTT 安全篇 MQTT 实战篇 mosquitto 协议之 mosquitto(8) – the broker Mosquitto SSL Configuration ","date":"2015 August 11","permalink":"/posts/2015/08/11/","section":"Posts","summary":"1. MQTT 介绍 #http://mqtt.","title":"MQTT 协议和 mosquitto"},{"content":"Python 的标准库提供了两个模块支持多线程：thread 和 threading ，thread 是低级模块，threading 是对 thread 进行了封装的高级模块，通常直接用 threading 模块。\nthreading 库：https://docs.python.org/2/library/threading.html\n1. 创建线程 #threading 模块定义了 Thread 对象，创建一个线程就是创建一个 Thread 实例，用 name 参数指定线程的名称，用 target 参数指定该线程执行的函数。然后调用 start() 方法开始执行，join() 方法的作用是等待线程结束，它可以带一个参数，表示超时时间：\nimport threading,time def loop(): print \u0026quot;this a thread\u0026quot; n=0 while n\u0026lt;5: print \u0026quot;n = %d\u0026quot; %(n) n=n+1 time.sleep(1) print \u0026quot;thread exit\u0026quot; print \u0026quot;thread running...\u0026quot; t=threading.Thread(target=loop) t.start() t.join() print \u0026quot;thread ended\u0026quot; 我们还可以通过创建自己的线程类来使用多线程，这个类需要继承 threading.Thread ,然后重写 Thread 对象的 run() 方法，run() 方法就是这个线程要实现的功能，调用 start() 方法就会执行 run() ，例如：\nimport threading,time class my_thread(threading.Thread): def __init__(self,t_name): self.n=0 threading.Thread.__init__(self,name=t_name) def run(self): while self.n\u0026lt;5: print self.getName(),\u0026quot;:\u0026quot;,self.n self.n=self.n+1 time.sleep(1) def main(): t=my_thread('thread_a') t.start() t.join() if __name__=='__main__': main() 输出结果是：\nthread_a : 0 thread_a : 1 thread_a : 2 thread_a : 3 thread_a : 4 threading 提供了一个属性 deamon ，默认值是 False ，表示这个线程不是守护线程，当主线程退出时，该线程也会退出。如果设为 True ，这个线程就是守护线程，当主线程退出时，该线程可以继续运行。\n2. 线程同步 #当多个线程访问共享资源时，需要实现线程间的同步，threading 提供了多个对象实现不同的同步功能。\n2.1 Lock #Lock 对象是最基本的同步方式，相当于互斥锁。使用时，先创建一个锁，然后在访问共享资源时调用 acquire() 方法获取锁，访问完毕再调用 release() 方法释放锁。\nacquire() 方法有一个参数 blocking ，默认值为 True ，表示该函数会阻塞，直到获取锁；如果设为 False ，表示非阻塞，函数会立即返回。\nrelease() 方法会释放当前的锁，如果这个锁本来就没被获取，会抛出 ThreadError 异常；\nimport threading,time n=0 lock=threading.Lock() def add_num(): global n while True: lock.acquire() n=n+1 n=n-1 print n lock.release() time.sleep(1) print \u0026quot;thread running...\u0026quot; t1=threading.Thread(target=add_num) t2=threading.Thread(target=add_num) t1.start() t2.start() t1.join() t2.join() print \u0026quot;thread ended\u0026quot; 2.2 RLock #Lock 锁是不能嵌套申请的，否则必然死锁。Threading 模块提供了另一个对象 RLock ，可重入的互斥锁。该对象内部维护了一个 Lock 对象和一个引用计数，记录 acquire 的次数，可以多次 acquire ，acquire 和 release 必须严格配对，所有的 acquire 最后必须都 release 。\nimport threading,time n=0 lock=threading.RLock() def add_num(): global n while True: if lock.acquire(): n=n+1 print \u0026quot;1 \u0026quot;,n if lock.acquire(): n=n-1 print \u0026quot;2 \u0026quot;,n lock.release() lock.release() time.sleep(1) print \u0026quot;thread running...\u0026quot; t=threading.Thread(target=add_num) t.start() t.join() print \u0026quot;thread ended\u0026quot; 2.3 Condition #Condition 可以称为条件变量。它的构造函数需要一个 Lock 对象作为参数，如果没有这个参数，Condition 将在内部自行创建一个 Rlock 对象，所有它依然可以调用 acquire() 和 release() 方法。它还提供了 wait() 和 notify() 方法。\n当一个线程用 acquire() 获取了一个条件变量，可以调用 wait() 使线程放弃这个锁，进入阻塞状态，直到其他线程用同一个条件变量的 notify() 方法唤醒它。wait() 方法有一个 timeout 参数可以设置阻塞超时。notify() 方法的参数 n 表示唤醒 n 个线程，默认值是 1 。如果是调用 notifyAll() 方法，将会唤醒该条件变量上阻塞的所有线程。\n下面是一个生产者和消费者的例程：\nimport threading x=0 con = threading.Condition() class Producer(threading.Thread): def __init__(self, t_name): threading.Thread.__init__(self, name=t_name) def run(self): global x con.acquire() if x \u0026gt; 0: con.wait() else: for i in range(5): x=x+1 print \u0026quot;producing...\u0026quot; + str(x) con.notify() print x con.release() class Consumer(threading.Thread): def __init__(self, t_name): threading.Thread.__init__(self, name=t_name) def run(self): global x con.acquire() if x == 0: print 'consumer wait...' con.wait() else: for i in range(5): x=x-1 print \u0026quot;consuming...\u0026quot; + str(x) con.notify() print x con.release() print 'start consumer' c=Consumer('consumer') print 'start producer' p=Producer('producer') p.start() c.start() p.join() c.join() print x 3. Timer #Timer 是 Thread 的子类，可以实现定时执行某个函数的功能。Timer 的构造方法如下：\nclass threading.Timer(interval, function, args=[], kwargs={}) fuction 会在 Timer 启动后 interval 秒开始执行，args 和 kwargs 表示传入 fuction 的参数和可变参数。构造了 Timer 的实例后，可以直接调用 start() 方法启动 Timer 。调用 cancel() 方法可以停止 Timer ，并停止 Timer 启动的函数。\n下面这个例程会在启动 Timer 后 5 秒是执行 hello 函数：\nimport threading def hello(arg): print \u0026quot;Hello World\u0026quot; print arg t=threading.Timer(5,hello,[\u0026quot;Yes\u0026quot;]) t.start() ","date":"2015 July 27","permalink":"/posts/2015/07/27/","section":"Posts","summary":"Python 的标准库提供了两个模块支持多线程：thread 和 threading ，thread 是低级模块，threading 是对 thread 进行了封装的高级模块，通常直接用 threading 模块。","title":"Python 的多线程"},{"content":"1.什么是 JSON #JSON 介绍：http://json.org/json-zh.html\nJSON 是 JavaScript 对象表示法语法的子集，是一种轻量级的数据交换格式。一个 JSON 对象是 “名称:值” 对的无序集合，用花括号包含，“名称:值” 对包含一个字段名称（在双引号中），然后跟一个冒号，最后是值，例如：\n{ \u0026quot;name\u0026quot;: \u0026quot;sample_app\u0026quot;, \u0026quot;cmd\u0026quot;: [\u0026quot;python\u0026quot;, \u0026quot;$MOD/sample.py\u0026quot;, \u0026quot;-c\u0026quot;, \u0026quot;$MOD/init.cfg\u0026quot;], \u0026quot;depends\u0026quot;: [\u0026quot;modbus_USBV0\u0026quot;, \u0026quot;cloud_client\u0026quot;, \u0026quot;defaultdb\u0026quot;], \u0026quot;version\u0026quot;: \u0026quot;1.0.0\u0026quot; } 这里的值可以是：\n数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） 对象（在花括号中） null 2.json 库 #Python 提供了 json 库（https://docs.python.org/2/library/json.html），可以完成对 JSON 对象的编解码（encoding and decoding），就是 JSON 对象转换为 Python 的数据结构，或者逆过程：\nJSON Python Object dict string string number int,long,float array list,tuple true True false False null None 基本操作 #dumps 方法可以将 Python 数据转换为 JSON 格式的字符串，然后返回，例如：\n\u0026gt;\u0026gt;\u0026gt; import json \u0026gt;\u0026gt;\u0026gt; obj={ 'name':'Bob', 'data':(1,3) } \u0026gt;\u0026gt;\u0026gt; encodedjson=json.dumps(obj) \u0026gt;\u0026gt;\u0026gt; print obj {'data': (1, 3), 'name': 'Bob'} \u0026gt;\u0026gt;\u0026gt; print encodedjson {\u0026quot;data\u0026quot;: [1, 3], \u0026quot;name\u0026quot;: \u0026quot;Bob\u0026quot;} \u0026gt;\u0026gt;\u0026gt; print type(encodedjson) \u0026lt;type 'str'\u0026gt; 从输出结果看，元组转换为了数组，字符串改成了双引号。\nloads 方法可以将 JSON 格式的字符串转换为 Python 的 dict 结构，例如：\n\u0026gt;\u0026gt;\u0026gt; import json \u0026gt;\u0026gt;\u0026gt; jsoncode='{ \u0026quot;name\u0026quot;:\u0026quot;Bob\u0026quot;,\u0026quot;data\u0026quot;:[1,2,3] }' \u0026gt;\u0026gt;\u0026gt; obj=json.loads(jsoncode) \u0026gt;\u0026gt;\u0026gt; print obj {u'data': [1, 2, 3], u'name': u'Bob'} \u0026gt;\u0026gt;\u0026gt; print type(obj) \u0026lt;type 'dict'\u0026gt; \u0026gt;\u0026gt;\u0026gt; print obj['name'] Bob 转换后的字符串前都带有 u 字符，表示这个字符串是 Unicode 编码，并不会影响 dict 的使用。\nEncoders and Decoders #json 模块提供了两个子类 JSONDecoder 和 JSONEncoder ，负责 JSON 的解码和编码。\nJSONDecoder 是解码器，提供了两种方法：\ndecode(s) ，将 JSON 结构的字符串 s 转换为 Python 结构，并返回。 raw_decode(s) ， 同样是解码，但是会返回两个值，第一个是解码后的 Python 结构，第二个值表示解码结束时，走到了 s 的哪个位置，这个方法适用于 s 的末尾有无效数据的情况。 例如：\n\u0026gt;\u0026gt;\u0026gt; import json \u0026gt;\u0026gt;\u0026gt; file=open(\u0026quot;package.cfg\u0026quot;) \u0026gt;\u0026gt;\u0026gt; text=file.read() \u0026gt;\u0026gt;\u0026gt; print text { \u0026quot;name\u0026quot;: \u0026quot;sample_app\u0026quot;, \u0026quot;cmd\u0026quot;: [\u0026quot;python\u0026quot;, \u0026quot;$MOD/sample.py\u0026quot;, \u0026quot;-c\u0026quot;, \u0026quot;$MOD/init.cfg\u0026quot;], \u0026quot;depends\u0026quot;: [\u0026quot;modbus_USBV0\u0026quot;, \u0026quot;cloud_client\u0026quot;, \u0026quot;defaultdb\u0026quot;], \u0026quot;version\u0026quot;: \u0026quot;1.0.0\u0026quot; } hello \u0026gt;\u0026gt;\u0026gt; obj,raw=json.JSONDecoder().raw_decode(text) \u0026gt;\u0026gt;\u0026gt; print obj {u'depends': [u'modbus_USBV0', u'cloud_client', u'defaultdb'], u'cmd': [u'python', u'$MOD/sample.py', u'-c', u'$MOD/init.cfg'], u'name': u'sample_app', u'version': u'1.0.0'} \u0026gt;\u0026gt;\u0026gt; print raw 166 \u0026gt;\u0026gt;\u0026gt; obj=json.JSONDecoder().decode(text) Traceback (most recent call last): File \u0026quot;\u0026lt;stdin\u0026gt;\u0026quot;, line 1, in \u0026lt;module\u0026gt; File \u0026quot;/usr/lib/python2.7/json/decoder.py\u0026quot;, line 369, in decode raise ValueError(errmsg(\u0026quot;Extra data\u0026quot;, s, end, len(s))) ValueError: Extra data: line 8 column 1 - line 9 column 1 (char 168 - 174) package.cfg 的末尾有无效的字符 hello ，用 raw_decode() 可以忽略并解码，用 decode() 就会报错。\nJSONEncoder 是编码器，提供了 encode(o) 方法，可以将 Python 结构 o 转换为 JSON 结构的字符串，并返回。\n","date":"2015 July 21","permalink":"/posts/2015/07/21/","section":"Posts","summary":"1.什么是 JSON #JSON 介绍：http://json.","title":"Python 对 JSON 的处理"},{"content":"1. 时区 #Linux 系统中通过 /etc/localtime 文件设置系统时区，所有的时区文件在 /usr/share/zoneinfo/ 目录下\n如果要修改时区，直接将 /usr/share/zoneinfo/ 下的相应时区文件复制到 /etc/ 下，改名为 localtime 即可。\n2. 系统时间的显示和设置 #常用的显示或设置系统时间的命令是 date 。\n直接执行 date 就可以显示当前的日期时间和时区，如果要格式化显示，需要用加号指定格式化参数，例如按 “年-月-日 时:分:秒”当前时间：\n~# date +\u0026quot;%Y-%m-%d %H:%M:%S\u0026quot; 2015-07-01 11:00:40 设置时间需要用 -s 参数，例如：\n~# date -s \u0026quot;20150701 12:03:00\u0026quot; Wed Jul 1 12:03:00 HKT 2015 查看硬件时钟的时间用 hwclock命令：\n~# hwclock Wed Jul 1 11:09:54 2015 -0.127600 seconds 将系统时间写入硬件时钟：\n~# hwclock --systohc 读取硬件时钟设置系统时间：\n~# hwclock --hctosys 3. C语言的时间转换 #C语言对时间的处理函数大部分在 \u0026lt;time.h\u0026gt; 头文件。\n函数 time 会返回从 ”1970 年 1 月 1 日 0 点“ 到当前的秒数，如果参数 t 不为空，也会存储在该指针指向的内存里。失败会返回 -1 。函数原型：\ntime_t time(time_t *t); time 返回的时间可读性不好，如果要看到类似 ”2014 年 12 月 7 日“ 这样的显示，需要将其转换。用 localtime 函数可以将 time_t 类型转换为本地时间，存储在 tm 结构中：\nstruct tm { int tm_sec; /* Seconds (0-60) */ int tm_min; /* Minutes (0-59) */ int tm_hour; /* Hours (0-23) */ int tm_mday; /* Day of the month (1-31) */ int tm_mon; /* Month (0-11) */ int tm_year; /* Year since 1900 */ int tm_wday; /* Day of the week (Sunday = 0)*/ int tm_yday; /* Day in the year (0-365; 1 Jan = 0)*/ int tm_isdst; /* Daylight saving time flag \u0026gt; 0: DST is in effect; = 0: DST is not effect; \u0026lt; 0: DST information not available */ }; struct tm *localtime(const time_t *timep); tm 结构的格式就很清晰了，还可以进一步将这个结构按照指定的格式转换为字符串，这需要 strftime 函数：\nsize_t strftime(char *outstr, size_t maxsize, const char *format, const struct tm *timeptr); strftime 会将 timeptr 结构按照 format 指定的格式转换为字符串，并存储在 outstr 中。maxsize 指定 outstr 的字节数。format 的常用格式命令有 ：\n%y 不带世纪的十进制年份（值从0到99） %Y 带世纪部分的十制年份 %m 十进制表示的月份 %B 月份的全称 %b 月份的简写 %d 十进制表示的每月的第几天 %H 24小时制的小时 %I 12小时制的小时 %M 十时制表示的分钟数 %S 十进制的秒数 %x 标准的日期串 %X 标准的时间串 获取系统时间并格式化显示的例程：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main () { time_t sys_time; struct tm * local_time; char time_buf[30]; time(\u0026amp;sys_time); local_time=localtime(\u0026amp;sys_time); strftime(time_buf,30,\u0026quot;%Y-%m-%d %H:%M:%S\u0026quot;,local_time); printf(\u0026quot;NOW:%s\\n\u0026quot;,time_buf); return 0; } 该程序的输出：\nNOW:2015-07-01 11:53:59 4. C语言的时间测量 #C语言提供了 gettimeofday 函数，它会返回从 1970 年 1 月 1 日 0 点到现在的时间，精确到微秒，保存在 timeval 结构中，函数原型：\n#include \u0026lt;sys/time.h\u0026gt; int gettimeofday(struct timeval *tv, struct timezone *tz); struct timeval { time_t tv_sec; /* seconds */ suseconds_t tv_usec; /* microseconds */ }; 注：第二个参数已经废止，传入 NULL 即可。\n例如，计算输出 Hello world 的耗时：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/time.h\u0026gt; int main () { struct timeval start_time,end_time; gettimeofday(\u0026amp;start_time,NULL); printf(\u0026quot;Hello world\\n\u0026quot;); gettimeofday(\u0026amp;end_time,NULL); printf(\u0026quot;%ld s %ld us\\n\u0026quot;,end_time.tv_sec-start_time.tv_sec,end_time.tv_usec-start_time.tv_usec); return 0; } 该程序的输出：\nHello world 0 s 41 us 5. 计时器 #要定时执行某段代码，最简单的方法是用 sleep 函数，它会使进程挂起一段时间，单位是秒，更精确的睡眠需要调用 usleep 函数，它单位是微秒 。\n更好的方法是使用 POSIX Timer 。POSIX Timer 可以为一个进程设置多个计时器，时间到达后，可以通过信号或其他方式通知进程，最高可以达到纳秒级别的精度。\n涉及的函数：\ntimer_create ：创建一个新的 Timer；并且指定定时器到时通知机制 timer_delete ：删除一个 Timer timer_gettime ：Get the time remaining on a POSIX.1b interval timer timer_settime ：开始或者停止某个定时器。 timer_getoverrun ：获取丢失的定时通知个数。 创建 Timer #使用 Posix Timer 的基本流程很简单，首先调用 timer_create 函数创建一个 Timer。函数原型：\nint timer_create(clockid_t clockid, struct sigevent *sevp, timer_t *timerid); 创建的时候需要指定该 Timer 的一些特性，比如 clock ID。clock ID 即 Timer 的种类，可以为如下任意一种：\nCLOCK_REALTIME ：Settable system-wide real-time clock； CLOCK_MONOTONIC\t：Nonsettable monotonic clock CLOCK_PROCESS_CPUTIME_ID\t：Per-process CPU-time clock CLOCK_THREAD_CPUTIME_ID\t：Per-thread CPU-time clock CLOCK_REALTIME 时间是系统保存的时间，即可以由 date 命令显示的时间，该时间可以重新设置。比如当前时间为上午 10 点 10 分，Timer 打算在 10 分钟后到时。假如 5 分钟后，我用 date 命令修改当前时间为 10 点 10 分，那么 Timer 还会再等十分钟到期，因此实际上 Timer 等待了 15 分钟。假如您希望无论任何人如何修改系统时间，Timer 都严格按照 10 分钟的周期进行触发，那么就可以使用 CLOCK_MONOTONIC。\nCLOCK_PROCESS_CPUTIME_ID 的含义与 setitimer 的 ITIMER_VIRTUAL 类似。计时器只记录当前进程所实际花费的时间；比如还是上面的例子，假设系统非常繁忙，当前进程只能获得 50%的 CPU 时间，为了让进程真正地运行 10 分钟，应该到 10 点 30 分才允许 Timer 到期。\nCLOCK_THREAD_CPUTIME_ID 以线程为计时实体，当前进程中的某个线程真正地运行了一定时间才触发 Timer。\ntimer_create 的第二个参数 struct sigevent 用来设置定时器到时时的通知方式。该数据结构如下：\nstruct sigevent { int sigev_notify; /* Notification method */ int sigev_signo; /* Notification signal */ union sigval sigev_value; /* Data passed with notification */ void (*sigev_notify_function) (union sigval); /* Function used for thread notification (SIGEV_THREAD) */ void *sigev_notify_attributes; /* Attributes for notification thread (SIGEV_THREAD) */ pid_t sigev_notify_thread_id; /* ID of thread to signal (SIGEV_THREAD_ID) */ }; union sigval { int sival_int; /* Integer value */ void *sival_ptr; /* Pointer value */ }; 其中 sigev_notify 表示通知方式，有如下几种：\nSIGEV_NONE\t：定时器到期时不产生通知。。。 SIGEV_SIGNAL\t：定时器到期时将给进程投递一个信号，用 sigev_signo 指定信号值。 SIGEV_THREAD\t：定时器到期时将启动新的线程进行需要的处理 SIGEV_THREAD_ID ：（仅针对 Linux)定时器到期时将向指定线程发送信号。 如果采用 SIGEV_NONE 方式，使用者必须调用timer_gettime 函数主动读取定时器已经走过的时间。类似轮询。\n如果采用 SIGEV_SIGNAL 方式，使用者可以选择使用什么信号，用 sigev_signo 表示信号值，比如 SIG_ALARM。\n如果使用 SIGEV_THREAD 方式，则需要设置 sigev_notify_function，当 Timer 到期时，将使用该函数作为入口启动一个线程来处理信号；sigev_value 保存了传入 sigev_notify_function 的参数。sigev_notify_attributes 如果非空，则应该是一个指向 pthread_attr_t 的指针，用来设置线程的属性（比如 stack 大小,detach 状态等）。\nSIGEV_THREAD_ID 通常和 SIGEV_SIGNAL 联合使用，这样当 Timer 到期时，系统会向由 sigev_notify_thread_id 指定的线程发送信号，否则可能进程中的任意线程都可能收到该信号。这个选项是 Linux 对 POSIX 标准的扩展，目前主要是 GLibc 在实现 SIGEV_THREAD 的时候使用到，应用程序很少会需要用到这种模式。\n启动 Timer #创建 Timer 之后，便可以调用 timer_settime() 函数指定定时器的时间间隔，并启动了。函数原型：\nint timer_settime(timer_t timerid, int flags, const struct itimerspec *new_value, struct itimerspec * old_value); new_value 和 old_value 都是 struct itimerspec 数据结构：\nstruct itimerspec { struct timespec it_interval; //定时器周期值 struct timespec it_value; //定时器到期值 }; struct timespec { time_t tv_sec; //秒 long\ttv_nsec; //纳秒 }; 启动和停止 Timer 都可以通过设置 new_value 来实现：\nnew_value-\u0026gt;it_interval 为定时器的周期值，比如 1 秒，表示定时器每隔 1 秒到期； new_value-\u0026gt;it_value 如果大于 0，表示启动定时器，Timer 将在 it_value 这么长的时间过去后到期，此后每隔 it_interval 便到期一次。如果 it_value 为 0，表示停止该 Timer。 有些时候，应用程序会先启动用一个时间间隔启动定时器，随后又修改该定时器的时间间隔，这都可以通过修改 new_value 来实现；假如应用程序在修改了时间间隔之后希望了解之前的时间间隔设置，则传入一个非 NULL 的 old_value 指针，这样在 timer_settime() 调用返回时，old_value 就保存了上一次 Timer 的时间间隔设置。多数情况下我们并不需要这样，便可以简单地将 old_value 设置为 NULL，忽略它。\n例程 #下面这个例程使用 SIGEV_THREAD 方式的 timer ，每隔两秒调用一次 timer_thread 函数，将 counter 加一，并打印。主函数等待 counter 等于 5 时退出。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;signal.h\u0026gt; int counter = 0; void timer_thread(union sigval val) { counter++; printf(\u0026quot;counter = %d\\n\u0026quot;,counter); } int main () { int ret = 0; timer_t timer_id; struct sigevent se; struct itimerspec ts; se.sigev_notify=SIGEV_THREAD; se.sigev_notify_function = timer_thread; se.sigev_notify_attributes = NULL; ret = timer_create(CLOCK_MONOTONIC,\u0026amp;se,\u0026amp;timer_id); if(ret\u0026lt;0) { perror(\u0026quot;timer create failed\\n\u0026quot;); return -1; } ts.it_value.tv_sec = 2; ts.it_value.tv_nsec = 0; ts.it_interval.tv_sec = 2; ts.it_interval.tv_nsec = 0; ret = timer_settime(timer_id,0,\u0026amp;ts,NULL); if(ret\u0026lt;0) { perror(\u0026quot;timer set failed\\n\u0026quot;); return -1; } printf(\u0026quot;...start\\n\u0026quot;); while(counter\u0026lt;5) { sleep(1); } return 0; } 编译时要带 -lrt 参数，该程序的输出是：\n~# gcc test.c -Wall -lpthread -lrt -o test ~# ./test ...start counter = 1 counter = 2 counter = 3 counter = 4 counter = 5 参考 #浅析 Linux 中的时间编程和实现原理\n","date":"2015 July 1","permalink":"/posts/2015/07/01/","section":"Posts","summary":"1. 时区 #Linux 系统中通过 /etc/localtime 文件设置系统时区，所有的时区文件在 /usr/share/zoneinfo/ 目录下","title":"Linux 系统中的时间"},{"content":"基础教程： # 廖雪峰的 Python 2.7 教程 ：http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000 Python 标准库 ： http://python.usyiyi.cn/python_278/library/index.html 网络编程： # Python Socket 网络编程 ：http://www.jianshu.com/p/49750ca1589d Sockets programming in Python ：http://www.ibm.com/developerworks/linux/tutorials/l-pysocks/ Python TCP Communication ：https://wiki.python.org/moin/TcpCommunication 数据库 # SQLite 教程 ：http://www.w3cschool.cc/sqlite/sqlite-tutorial.html Pillow # Pillow 快速入门 ：http://pillow-cn.readthedocs.org/zh_CN/latest/handbook/tutorial.html Pillow Tutorial ：https://pillow.readthedocs.org/handbook/tutorial.html#cutting-pasting-and-merging-images Pillow Reference ：https://pillow.readthedocs.org/reference/index.html Requests # Python Requests的安装与简单运用 ：http://www.zhidaow.com/post/python-requests-install-and-brief-introduction Python Requests 1.1.0 快速上手： http://requests-docs-cn.readthedocs.org/zh_CN/latest/user/quickstart.html 爬虫 # Python 爬虫系列教程 ：http://cuiqingcai.com/1052.html Scrapy 框架文档 ：http://scrapy-chs.readthedocs.org/zh_CN/0.24/index.html ","date":"2015 June 13","permalink":"/posts/2015/06/13/","section":"Posts","summary":"基础教程： # 廖雪峰的 Python 2.","title":"Python 学习资料"},{"content":"项目主页：http://libmodbus.org\n程序中必须包含头文件，编译时连接到 libmodbus ：\n#include \u0026lt;modbus.h\u0026gt; cc `pkg-config --cflags --libs libmodbus` files 在程序中使用 libmodbus 主要是如下几个步骤。\n1. 新建环境 #新建一个 libmodbus 环境，如果是串口连接的modbus设备，用 modbus_new_rtu() 函数，如果是tcp连接的modbus 设备，用 modbus_new_tcp() 函数。如果新建成功会返回一个 struct modbus_t 指针，以后我们操作modbus设备，就是对这个指针进行操作；失败返回空指针。\n一个物理接口可以连接多个 modbus 从设备，每个modbus 从设备有自己独立的 ID， 叫做”从设备编号“，是一个整数。所有要用 modbus_set_slave() 函数为 modbus_t 结构设置从设备编号，表示要连接的是哪个 modbus 设备。\n释放一个 libmodbus 环境，用 modbus_free() 函数。\n2. 连接 #新建成功后，就可以建立连接，用 modbus_connect() 函数。 关闭连接用 modbus_class() 函数。 刷新连接用 modbus_flush() 函数。\n3. 读写 #连接成功后，可以调用相关函数对modbus设备进行操作。\n4. 相关函数说明 # 新建一个 RTU 类型的 libmodbus 环境，返回一个 modbus_t 结构\nmodbus_t *modbus_new_rtu(const char *device, int baud, char parity, int data_bit, int stop_bit); 新建一个 TCP 类型 的 libmodbus 环境 ，返回一个 modbus_t 结构\nmodbus_t *modbus_new_tcp(const char *ip, int port); 设置 slave id ，返回值 EINVAL 表示 slave 值无效\nint modbus_set_slave(modbus_t *ctx, int slave); 使能 debug\nvoid modbus_set_debug(modbus_t *ctx, int boolean); 如果 boolean 为 true ，会使能 ctx 的 debug 标志位，在 stdout 和 stderr 上显示 modbus message ，例如 ：\n[00][14][00][00][00][06][12][03][00][6B][00][03] Waiting for a confirmation… \u0026lt;00\u0026gt;\u0026lt;14\u0026gt;\u0026lt;00\u0026gt;\u0026lt;00\u0026gt;\u0026lt;00\u0026gt;\u0026lt;09\u0026gt;\u0026lt;12\u0026gt;\u0026lt;03\u0026gt;\u0026lt;06\u0026gt;\u0026lt;02\u0026gt;\u0026lt;2B\u0026gt;\u0026lt;00\u0026gt;\u0026lt;00\u0026gt;\u0026lt;00\u0026gt;\u0026lt;00\u0026gt; 设置故障恢复模式\nint modbus_set_error_recovery(modbus_t *ctx,modbus_error_recovery_mode error_recovery); 参数 error_recovery 可以设置0，或者如下的值：\nMODBUS_ERROR_RECOVERY_LINK\n建立一个 modbus 连接。返回0表示成功。失败返回 -1\nint modbus_connect(modbus_t *ctx); 释放一个 modbus_t 结构。\nvoid modbus_free(modbus_t *ctx); function id 0x01\nint modbus_read_bits(modbus_t *ctx, int addr, int nb, uint8_t *dest); 使用 modbus 功能码 0x01 ，从 addr 读取连续的 nb 个状态位，结果放在 *dest 指向的数组，每个状态位占用一个数组元素，状态为 TRUE 或 FALSE 。成功返回 0 ，失败返回 -1 。\nfunction id 0x02\nint modbus_read_input_bits(modbus_t *ctx, int addr, int nb, uint8_t *dest); 使用 modbus 功能码 0x02 ，从 addr 读取 nb 个输入状态位，结果放在 *dest 指向的数组，每个状态位占用一个素组元素，状态为 TRUE 或 FALSE 。成功返回 0 ，失败返回 -1 。\nfunction id 0x03\nint modbus_read_registers(modbus_t *ctx, int addr, int nb, uint16_t *dest); 使用 modbus 功能码 0x03 ，从 addr 地址开始，读取连续的 nb 个寄存器的值，一个寄存器是两个字节。结果存放在 dest 。返回读取寄存器的个数，失败返回 -1 。\n设备上的地址是从 1 开始的，modbus是从0开始寻址，如果要读取1的数据，addr应该设为0.\nfunction id 0x05\nint modbus_write_bit(modbus_t *ctx, int addr, int status); 使用 modbus 功能码 0x05 ，向 addr 写一个状态：TRUE 或 FALSE ，成功会返回 0 ，失败返回 -1 。\nfunction id 0x0F\nint modbus_write_bits(modbus_t *ctx, int addr, int nb, const uint8_t *src); 使用 modbus 功能码 0x0F ，将 *src 指向的数组写入从 addr 开始的 nb 个状态位，数组元素的值应该是 TRUE 或 FALSE ，每个元素对应一个状态位。成功会返回 0 ，失败返回 -1 。\nfunction id 0x06\nint modbus_write_register(modbus_t *ctx, int addr, int value); 使用 modbus 功能码 0x06 ，将 value 写入地址为 addr 的一个寄存器中。成功会返回 1 ，失败返回 -1 。\n","date":"2015 May 24","permalink":"/posts/2015/05/24/","section":"Posts","summary":"项目主页：http://libmodbus.org","title":"Libmodbus 编程说明"},{"content":" 项目主页：http://hardysimpson.github.io/zlog/ 下载地址：https://github.com/HardySimpson/zlog/releases 中文使用手册：http://hardysimpson.github.io/zlog/UsersGuide-CN.html 下载后解压安装：\n[21:15]Workspace/ ❯ tar xvf zlog-latest-stable.tar.gz [21:16]Workspace/ ❯ cd zlog-latest-stable [21:17]zlog-latest-stable/ ❯ make ","date":"2015 February 6","permalink":"/posts/2015/02/06/","section":"Posts","summary":"项目主页：http://hardysimpson.","title":"C 语言日志函数库 zlog"},{"content":"Shadowsocks 可以为浏览器，支持代理服务器的软件（例如 Dropbox）提供代理服务。\n首先购买一个付费的 Shadowsocks 服务账号，推荐 https://shadowsocks.com，不限流量，速度还不错。购买后会提供多个可用的服务器地址，端口，密码和加密方式。\n欢迎使用我的推广链接：https://portal.shadowsocks.com/aff.php?aff=424\n下载 OS X 客户端：ShadowsocksX。安装后启动，选择 “打开服务器设定” ：\n添加服务器，输入服务商提供的域名，端口，密码：\n然后就可以科学上网了。客户端已经集成了 GFWList ，可以自动识别访问地址，墙内地址走国内路径，墙外地址走代理服务器。可以添加多个服务器，感觉日本的节点速度更快。\nDropbox 已经完全被墙，修改 hosts 也无法连接，只能用代理。打开 “首选项” ，在“网络”标签中选择 “代理服务器设置”，手动设置服务器类型为 SOCK5 ，服务器地址 127.0.0.1 ，端口 1080：\n点击 “更新”，Dropbox 就复活了。\n","date":"2015 January 20","permalink":"/posts/2015/01/20/","section":"Posts","summary":"Shadowsocks 可以为浏览器，支持代理服务器的软件（例如 Dropbox）提供代理服务。","title":"科学上网利器 Shadowsocks"},{"content":"OS X Yosemite 新增了一个通知中心，可以在上面放一些小部件。而 Today Script 这个小部件可以让你写自己的脚本，在通知栏显示自己想要的东西。\n主页：https://github.com/SamRothCA/Today-Scripts 脚本列表：https://github.com/SamRothCA/Today-Scripts/wiki 在主页上点击下载链接，下载一个压缩包：Today-Scripts.tar.gz，解压得到 Today Scripts.app ，放到应用程序文件夹内，然后打开。在通知中心就会出现 Scripts :\n点击加号，把它添加到通知栏。按照提示，点击右上角的 Info 图标来添加一个脚本：\n添加一个显示当前月份的命令：\ncal | grep --before-context 6 --after-context 6 --color -e \u0026quot; $(date +%e)\u0026quot; -e \u0026quot;^$(date +%e)\u0026quot; 记得写上标题：\n效果如下：\n","date":"2015 January 10","permalink":"/posts/2015/01/10/","section":"Posts","summary":"OS X Yosemite 新增了一个通知中心，可以在上面放一些小部件。而 Today Script 这个小部件可以让你写自己的脚本，在通知栏显示自己想要的东西。","title":"Today Scripts —— 通过脚本打造自己的通知栏部件"},{"content":"Lua （英语发音：/ˈluːə/）是一种轻量级的脚本语言，可以方便的嵌入到其他语言中，很易学习。它是用C语言编写的。广泛应用于游戏和 web 开发中。据说 Adobe Photoshop Lightroom 中 50% 的代码是有 Lua 写的。我学习这个语言是因为目前的项目要用到 LuCI 。\nLua 的主页：http://www.lua.org 中国开发者论坛：http://www.luaer.cn Lua 程序设计：http://book.luaer.cn Lua 在线手册：http://manual.luaer.cn 酷壳的 Lua 简明教程：http://coolshell.cn/articles/10739.html 1.Hello World #Mac 平台默认已经安装了 Lua , 直接执行 lua 就可以进入它的 shell , 首先输出一个 Hello World , 语法很像 C , 结尾有没有分号都可以：\n[18:54]~/ ❯ lua Lua 5.2.3 Copyright (C) 1994-2013 Lua.org, PUC-Rio \u0026gt; print(\u0026quot;Hello World\u0026quot;) Hello World \u0026gt; 也可以写一个脚本文件，直接执行：\n[18:57]Workspace/ ❯ cat test.lua #!/usr/local/bin/lua print(\u0026quot;Hello World\u0026quot;) [18:57]Workspace/ ❯ ./test.lua Hello World 2.基本语法 #注释 #两个减号是行注释，两个减号加方括号是块注释：\n#!/usr/local/bin/lua --行注释 --[[ 块注释 --]] print(\u0026quot;Hello World\u0026quot;) 数据类型和变量 #Lua 支持动态数据类型，定义变量时无需声明类型，几个基本的数据类型有：\n字符串，用引号包含，单引号和双引号都可以；Lua 还支持 C 语言类型的转义字符，例如 \\n 换行，\\r 回车 实数，Lua 的数只有 double 型，64 bits 浮点数 布尔，true 和 false 空，Lua 的空类型用 nil 表示，没有声明过的变量就是 nil type 是一个函数，它会返回数据的类型\nLua 中的变量分为全局变量和局部变量，未加说明的都是全局变量，用 local 关键字定义局部变量 ：\ntheGlobalVar = 50 local theLocalVar = \u0026quot;local variable\u0026quot; 表达式 #Lua 的表达式由数字，字符串，变量，运算符组成，运算符分为几个类别，和 C 语言很像：\n数学运算符：+-*/^ (加减乘除幂），- (负号），这些运算符只能用于实数 关系运算符：\u0026lt; ，\u0026gt; ，\u0026lt;= ，\u0026gt;= ，== ，还有一个 ~= 表示不等；比较结果返回 true 或 false ；如果两个值的类型不同，那么一定是不等的，nil 之和自己相等；比较字符串时，是按照字母的顺序进行的 逻辑运算符：and , or , not ；not 只会返回 true 和 false，除了 false 和 nil ，其他都是 true ，所以 not nil 就是 ture。and 和 or 返回的结果不是 true 或 false，而是和操作数有关：a and b \u0026ndash; 如果a为false，则返回a，否则返回b；a or b \u0026ndash; 如果a为true，则返回a，否则返回b 连接运算符：..(两个点)，用于连接字符串，如果操作符是数字，会连接后转为字符串。 控制语句 #if 语句\nif conditions then then-part end; if conditions then then-part else else-part end; if conditions then then-part elseif conditions then elseif-part .. ---\u0026gt;多个elseif else else-part end; while 循环\nwhile condition do statements; end; for 循环\nfor var=exp1,exp2,exp3 do loop-part end exp1 是初始值，exp2 是终止值，exp3是每一步的间隔，如果exp3，默认是1，例如：\n函数 #函数的定义以 function 关键字开头，以 end 结尾，可以返回多个值。\nLua 有个特别的语法，就是可以一行为多个变量赋值，那么多个返回值就可以依次赋给多个变量。如果值的数量比变量多，多余的会舍弃；如果变量比值多，后面的变量会被赋 nil 。\n","date":"2015 January 7","permalink":"/posts/2015/01/07/","section":"Posts","summary":"Lua （英语发音：/ˈluːə/）是一种轻量级的脚本语言，可以方便的嵌入到其他语言中，很易学习。它是用C语言编写的。广泛应用于游戏和 web 开发中。据说 Adobe Photoshop Lightroom 中 50% 的代码是有 Lua 写的。我学习这个语言是因为目前的项目要用到 LuCI 。","title":"Lua语言学习笔记"},{"content":"2014年的最后一天了\n这一年，得到了一些，失去了很多，赚了一点钱，虚度了很多美好的时光。在某个突然醒来的黎明，就在想，应该把生命中最好的时光留给最爱的人，这比什么都重要。\n这一年的最后一个月，我在这个城市买了一套房子，人生中的第一套房。12月2日晚上11点，在合同上写下自己的名字，回来的路上下着小雨。\n这一年的日志写的太少，可能是因为我没学到什么东西，希望明年会好一点。\n","date":"2014 December 31","permalink":"/posts/2014/12/31/","section":"Posts","summary":"2014年的最后一天了","title":"2014-12-31"},{"content":"电脑的音频输入通常有两个通道：Mic 和 Line in。Mic就是麦克风，Line in 用于连接未经放大的模拟音频信号，例如 Mp3 播放器的耳机插孔，可以将其连接到 PC 的 Line in 插孔。\nLinux 上只要用 alsa 管理声卡，它还提供很多工具，alsamixer用于配置音频的各个参数，基于文本下的图形界面。\n在命令行输入 alsamixer 就可以启动它的界面，然后按 F6 就可以看到当前系统的网卡，每个网卡都由一个独立的数字 ID ：\n这里的网卡是 HDA Intel，ID 是 0。\namixer 是 alsamixer 的命令行模式。\n先看看 amixer 的语法：\n用 amixer -c 0 scontrols 就可以看到 ID 为 0 的网卡的所有可配置接口：\n用 scontents 可以查看这些接口的详细内容，包括可选的选项和当前的选项：\n用 sget 可以查看某个接口的详细信息，然后有 sset 就可以设置：\n如上图所示，Input source 有三个通道可选：Mic ，Front Mic，Line。Line 就表示 Line in 。用 sset 设置具体通道后，就可以用 arecord 对相应通道录音。\n","date":"2014 October 26","permalink":"/posts/2014/10/26/","section":"Posts","summary":"电脑的音频输入通常有两个通道：Mic 和 Line in。Mic就是麦克风，Line in 用于连接未经放大的模拟音频信号，例如 Mp3 播放器的耳机插孔，可以将其连接到 PC 的 Line in 插孔。","title":"在 Linux 中使用 amixer 设置 Input source"},{"content":"Mapbox 想要构建世界上最漂亮的地图。支持多种平台，可以免费创建并定制个性化的地图，实现非常绚丽的效果。\n主页：http://www.mapbox.com 这里有一个介绍：http://www.pingwest.com/demo/mapbox 定制自己的地图 #首先要注册一个账号，然后在主页面上方点击 Project ，进入到如下界面，点击 Create project 就可以新建一个自己的地图。\n我新建了一个 My First Map 。点击它，就可以进入编辑界面，左上方是定制地图所需的工具：\nStyle # 这个标签用来设置地图的样式，包括：\nColor ：设置街道，绿地，建筑，水在地图上显示的颜色。 Baselayer ：设置地图的基本图层，有街道地图，地形图和卫星图。 Language ：设置地图的语言，Localized 表示本地语言。 Data # 这个标签用来向地图添加自定义的数据，包括：\nMarker ：点状标记。 Line ：线，轨迹。 Poygon ：一块图形，或者区域。 另外，点击下方的 import ，可以导入 csv 、kml 、gpx 格式的数据文件。\nProject # 这个标签中可以设置地图名称和描述，还可以在此下载和分享地图。\nInfo ：Data 栏可以选择下载 GeoJSON 或 KML 格式的地图文件。Map ID 是这个地图的唯一标识符，用于开发。Share 栏是该地图的分享链接。Embed 是该地图嵌入 Web 页面的代码，下面可以选择页面中是否显示放大缩小，搜索和分享链接按钮。 Settings ：设置地图名称和描述。 Advanced ：这里有两个选项，选中 Save current map position 后，通过分享的地图会显示现在所选的位置和大小。选中 Hind Project frome public API ，通过分享的地图可以看到在 Data 中添加的数据。 修改地图后一定要点击上方的 Save 保存。\n","date":"2014 October 9","permalink":"/posts/2014/10/09/","section":"Posts","summary":"Mapbox 想要构建世界上最漂亮的地图。支持多种平台，可以免费创建并定制个性化的地图，实现非常绚丽的效果。","title":"个性化定制地图 —— Mapbox"},{"content":"1.键盘操作 #使用 Macbook ，没有合适的鼠标，用了外接键盘后，触摸板也离得远了，尽量是用键盘操作，熟练后效率很高。\n按 F1 键打开 Spotlight ,输入要打开的程序名称，同样适用于搜索并打开文件。\nMac 键盘快捷键 ：https://support.apple.com/zh-cn/HT201236\n常用快捷键 # command + shift + f ：全屏显示当前窗口 command + q ：退出当前程序 command + w ： 关闭当前窗口或标签页 command + t ： 新建窗口或标签页 command + n ： 新建窗口 command + shift + 4 ：截屏，如果再按一次空格，鼠标会变成相机图标，可以选择要解取的程序窗口 Safari 快捷键 # command + option + f ：选择到地址栏 command + option + 2 ：打开历史记录 command + d ：收藏当前页面 2. 常用软件 #Keka —— 免费开源的文件解压缩软件 # http://www.kekaosx.com/ 苹果系统自带的压缩软件功能太单一，而且压缩后的 zip 文件在 windows 下会出现乱码，导致识别文件损坏。\nKeka 支持多种压缩格式： 7z，zip，tar，gzip 。\nMou —— 免费 Markdown 编辑器 # mouapp.com Mou 编辑器的界面非常简洁，分为左右两部分，在左栏写 Markdown 代码，右侧就能实时显示输出效果。还可以设置多种编辑器主题和 CSS 样式，支持导出 HTML 和 PDF 文档。\n该软件的作者是 80 后国人。\nOnyx —— 免费的系统维护软件 # http://www.onyxmac.com/ Onyx 可以实现很多 “系统偏好设置” 里没有提供的设置，例如默认的截屏保持路径。\nbrew —— OS X 的包管理器 # http://brew.sh/ 用于从开源社区安装各种包。通过 brew 安装到包都位于 /usr/local/ 目录下，不会与系统已有的软件产生干扰。\nxmarks # www.xmarks.com 在 Mac 上主要使用 Safari 浏览器，在 Windows 平台主要使用 Chrome 。xmarks 可以实现多个浏览器之间的书签同步，而且是插件的形式。\nXtrafinder # http://www.trankynam.com/xtrafinder/ 在 Mac 的 Finder 不太好用，无法新建文件，显示文件属性也比较麻烦，还没有剪切功能。这个软件可以解决这个问题。它将这些功能都集成到了 Finder 中。\n","date":"2014 September 9","permalink":"/posts/2014/09/09/","section":"Posts","summary":"1.键盘操作 #使用 Macbook ，没有合适的鼠标，用了外接键盘后，触摸板也离得远了，尽量是用键盘操作，熟练后效率很高。","title":"Mac OS X 常用软件和技巧"},{"content":"在 http://www.telegraphics.com.au/sw/product/ICOFormat#icoformat页面下载 ico 格式插件。\n在如下界面选择 Mac CS5/CS6 ：\n然后打开下载的 DMG 文件 。将其中的 ICOFormat.plugin 文件复杂到 photoshop 的插件目录下 :\n/Applications/Adobe Photoshop C6/Plug-ins/ OK!\n这样就可以新建，保存 ICO 图片了。\n","date":"2014 July 12","permalink":"/posts/2014/07/12/","section":"Posts","summary":"在 http://www.","title":"让 Mac 的 Photoshop CS6 支持 ICO 文件"},{"content":" google-code-prettify 可以通过 javascript 和 css 文件为 html 页面实现代码段的语法高亮。\n1. 下载 #在 https://code.google.com/p/google-code-prettify/ 下载 prettify-small-4-Mar-2013.tar.bz2 ，解压后的文件夹放在博客模板的 include 目录下，改名为 prettify 。\n2. 导入 #在模板的 base.html 文件的 \u0026lt;head\u0026gt; 段添加 ：\n\u0026lt;link href=\u0026quot;/template/include/prettify/prettify.css\u0026quot; type=\u0026quot;text/css\u0026quot; rel=\u0026quot;stylesheet\u0026quot; /\u0026gt; js 文件添加到 \u0026lt;body\u0026gt; 段的尾部，这样可以提升加载速度 ：\n\u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;/template/include/prettify/prettify.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; 3. 实现代码高亮 #在 base.html 文件的 \u0026lt;body\u0026gt; 段尾部添加如下代码，它会在页面的 \u0026lt;pre\u0026gt; 标签添加 class=\u0026quot;prettyprint linenums prettyprinted\u0026quot; style=\u0026quot;overflow: auto;\u0026quot; ，用于识别需要高亮的代码块 ：\n\u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; $(document).ready(function() { $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto'); prettyPrint(); }); \u0026lt;/script\u0026gt; 这段 js 代码用到了 jQuery ，需要提前引入。\n如果对代码高亮的主题不满意，可以修改 prettify.css 文件。\n","date":"2014 July 11","permalink":"/posts/2014/07/11/","section":"Posts","summary":"google-code-prettify 可以通过 javascript 和 css 文件为 html 页面实现代码段的语法高亮。","title":"用 google-code-prettify 实现代码语法高亮"},{"content":" 添加后的效果如右下角。\n1. 导入 jQuery #在 http://jquery.com/download/ 中下载压缩过的 jQuery ：jquery-1.11.1.min.js ,放入博客模板的相应目录下，比如 include/ 。\n在 base.html 的 中添加：\n\u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;/template/include/jquery-1.11.1.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; 2. 添加 div #在 base.html 中添加:\n\u0026lt;div id=\u0026quot;back-top\u0026quot;\u0026gt; \u0026lt;a href=\u0026quot;#top\u0026quot; title=\u0026quot;回到顶部\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; 3. 添加js代码 #使用 js 响应窗口滚动事件和按钮的点击事件，其中 100 表示向下滚动 100 个像素时出现按md钮，800 表示使用 800ms 的时间滚动到顶部。\n\u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; $(\u0026quot;#back-top\u0026quot;).hide(); $(document).ready(function () { $(window).scroll(function () { if ($(this).scrollTop() \u0026gt; 100) { $('#back-top').fadeIn(); } else { $('#back-top').fadeOut(); } }); $('#back-top a').click(function () { $('body,html').animate({ scrollTop: 0 }, 800); return false; }); }); \u0026lt;/script\u0026gt; 可以将这段代码添加到 \u0026lt;div id=\u0026quot;back-top\u0026quot;\u0026gt; 段的后面。\n4. 添加样式 #此处使用一个背景透明的向上箭头图片 bg_up_arrow.png，将其放入 include/ 目录下。通过 backgroud-color 指定正常时和鼠标放上时的背景颜色，border-radius 指定圆角的半径。\n#back-top { position: fixed; bottom: 30px; right: 80px; } #back-top a { width: 54px; height: 54px; display: block; background: #ddd url(/template/include/bg_up_arrow.png) no-repeat center center; background-color: #e9e9e9; -webkit-border-radius: 7px; -moz-border-radius: 7px; border-radius: 7px; -webkit-transition: 1s; -moz-transition: 1s; transition: 1s; } #back-top a:hover { background-color: #c8c8c8; } ","date":"2014 July 9","permalink":"/posts/2014/07/09/","section":"Posts","summary":"添加后的效果如右下角。","title":"在博客添加返回顶部按钮"},{"content":"Telnet #在QNX中，telnet 服务必须用 inetd启动，所以，先确保 /etc/inetd.conf 文件中有一行 ：\ntelnet stream tcp nowait root /usr/sbin/telnetd in.telnetd 且没有被注释。\n各自字段的含义：\n\u0026lt;service_name\u0026gt; \u0026lt;socket_type\u0026gt; \u0026lt;proto\u0026gt; \u0026lt;flags\u0026gt; \u0026lt;user\u0026gt; \u0026lt;server_pathname\u0026gt; \u0026lt;args\u0026gt; 其中 \u0026lt;user\u0026gt; 为启动服务的用户名，必须为系统中已经存在的用户。\n然后执行 inetd \u0026amp; 即可启动telnet服务。\n执行 netstat 命令，可以看到 telnet 已经打开：\n如果要开机启动，可以将 /usr/sbin/inetd \u0026amp; 命令添加到 /etc/rc.d/rc.local 文件中。\nFTP #在QNX中，FTP 服务必须用 inetd启动，所以，先确保 /etc/inetd.conf 文件中有一行 ：\nftp stream tcp nowait root /usr/sbin/ftpd in.ftpd -l 且没有被注释。\n各自字段的含义：\n\u0026lt;service_name\u0026gt; \u0026lt;socket_type\u0026gt; \u0026lt;proto\u0026gt; \u0026lt;flags\u0026gt; \u0026lt;user\u0026gt; \u0026lt;server_pathname\u0026gt; \u0026lt;args\u0026gt; 其中 \u0026lt;user\u0026gt; 为启动服务器的用户名，必须为系统中已经存在的用户。\n然后执行 inetd \u0026amp; 即可启动ftp服务。\n执行 netstat 命令，可以看到 ftp 已经打开：\n如果要开机启动，可以将 /usr/sbin/inetd \u0026amp; 命令添加到 /etc/rc.d/rc.local 文件中。\n/etc/ftpuser 文件用于控制访问ftpd 的用户。要使root用户登陆，将文件中把禁止root用户使用ftp这项屏蔽掉（root前面加#号）:\n并且，root 用户必须有密码，否则无法通过 ftp 登陆。\n","date":"2013 December 27","permalink":"/posts/2013/12/27/","section":"Posts","summary":"Telnet #在QNX中，telnet 服务必须用 inetd启动，所以，先确保 /etc/inetd.","title":"QNX 的 Telnet 和 FTP 服务"},{"content":"Google Fonts 是一套高品质的 Web 字体，可以通过 Google Fonts API 添加到任意 Web 页面中，只需在 HTML 文件的头部添加一个 stylesheet 链接，然后就可以通过 CSS 使用字体。\n优势：\n高品质，开源 支持大多数浏览器 极其易用 劣势：\n墙内链接不稳定 Google Fonts API ：https://developers.google.com/fonts/\nExample #下面是一个简单的例子，将这份代码复制并保存为 html 文件。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; type=\u0026quot;text/css\u0026quot; href=\u0026quot;https://fonts.googleapis.com/css?family=Tangerine\u0026quot;\u0026gt; \u0026lt;style\u0026gt; body { font-family: 'Tangerine', serif; font-size: 48px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;Making the Web Beautiful!\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 然后在浏览器中打开这个 html 文件，就会看到如下效果：\nMaking the Web Beautiful!\n这是普通文本，所以可以用 CSS 改变它的样式，试着添加阴影:\nbody { font-family: 'Tangerine', serif; font-size: 48px; text-shadow: 4px 4px 4px #aaa; } 效果如下：\nMaking the Web Beautiful!\nOverview #使用 Google Fonts API 只需两步：\n添加一个 stylesheet 链接：\n\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; type=\u0026quot;text/css\u0026quot; href=\u0026quot;https://fonts.googleapis.com/css?family=Font+Name\u0026quot;\u0026gt; 为一个元素指定需要的字体：\nCSS selector { font-family: 'Font Name', serif; } 或者用内联式的 style ：\n\u0026lt;div style=\u0026quot;font-family: 'Font Name', serif;\u0026quot;\u0026gt;Your text\u0026lt;/div\u0026gt; 注意，推荐在 href 中使用 https 的 url ，否则可能无法连接到 googleapis.com 。\n在 Google Fonts 中可以看到可用的字体列表。\n","date":"2013 October 16","permalink":"/posts/2013/10/16/","section":"Posts","summary":"Google Fonts 是一套高品质的 Web 字体，可以通过 Google Fonts API 添加到任意 Web 页面中，只需在 HTML 文件的头部添加一个 stylesheet 链接，然后就可以通过 CSS 使用字体。","title":"Google Fonts"},{"content":"项目主页：http://fortawesome.github.io/Font-Awesome/\n目前的 Version 3.2.1 版本支持如下特性：\n一个字体文件， 361 个图标 用 CSS 控制样式 无限缩放 免费 支持视网膜屏幕 为 Bootstrap 设计，也可集成到非 Bootstrap 项目 1.集成 # 复制 font 目录到项目根目录下 复制 css 目录到项目根目录下，主要使用 font-awesome.min.css 文件 修改 font-awesome.min.css 文件中的字体路径，默认是 ../font/ 在 html 文件中引用 css 文件：\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;./css/font-awesome.min.css\u0026quot; type=\u0026quot;text/css\u0026quot; /\u0026gt; 2.实例 #使用图标 #\u0026lt;i class=\u0026quot;icon-youtube\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; icon-youtube icon-youtube\n其中的 icon-youtube 是图标的名称，所有支持的图标名称可以在 font-awesome.min.css 文件中查找，也可在 Font-Awesome icons 中预览。\n更大的图标 #通过给图标设置 icon-large、icon-2x、 icon-3x 或 icon-4x 样式，可以让图标相对于它所在的容器变得更大：\n\u0026lt;p\u0026gt;\u0026lt;i class=\u0026quot;icon-camera-retro icon-large\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; icon-camera-retro\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;i class=\u0026quot;icon-camera-retro icon-2x\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; icon-camera-retro\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;i class=\u0026quot;icon-camera-retro icon-3x\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; icon-camera-retro\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;i class=\u0026quot;icon-camera-retro icon-4x\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; icon-camera-retro\u0026lt;/p\u0026gt; icon-camera-retro\nicon-camera-retro\nicon-camera-retro\nicon-camera-retro\n动画微调 #使用 icon-spin 使图标旋转，对于 icon-spinner 和 icon-refresh 图标可以得到很好的效果：\n\u0026lt;i class=\u0026quot;icon-spinner icon-spin\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; Spinner icon when loading content... Spinner icon when loading content\u0026hellip;\n\u0026lt;i class=\u0026quot;icon-refresh icon-spin\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; Refresh icon when refresh content... Refresh icon when refresh content\u0026hellip;\n列表 #在列表中使用图标：\n\u0026lt;ul class=\u0026quot;icons\u0026quot;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;i class=\u0026quot;icon-ok\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; Lists\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;i class=\u0026quot;icon-ok\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; Buttons\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;i class=\u0026quot;icon-ok\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; Button groups\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;i class=\u0026quot;icon-ok\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; Navigation\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;i class=\u0026quot;icon-ok\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; Prepended form inputs\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; Lists Buttons Button groups Navigation Prepended form inputs ","date":"2013 October 15","permalink":"/posts/2013/10/15/","section":"Posts","summary":"项目主页：http://fortawesome.github.io/Font-Awesome/","title":"Font Awesome 矢量字体图标"},{"content":"第一节 #1.1 #####1.1.1\n正文\n无序列表1 无序列表2 无序列表子项 无序列表子项 无序列表3 第二节 #正文\n有序列表1 有序列表2 代码段：\ninclude\u0026lt;stdio.h\u0026gt; int main() { printf(\u0026quot;hello farbox\\n!\u0026quot;); return 0; } 注意事项\n插入图片：\n正文\n","date":"2013 October 12","permalink":"/posts/2013/10/12/","section":"Posts","summary":"第一节 #1.","title":"Hello Farbox"},{"content":"QNX Neutrino 支持多种触摸屏，可以在官网上查找支持的型号和对应的驱动：\nhttp://www.qnx.com/developers/hardware_support/\n或者在 Utilities Reference 中查看 devi-* 驱动，然后确定所需的参数，启动驱动。例如，启动一个 Dynapro SC4 触摸屏：\ndevi-dyna dyna -4 fd -d/dev/ser1 \u0026amp; 使用 devi-dyna 驱动，SC4 协议（-4），串口1（/dev/ser1）。\n第一次使用驱动时，会返回一个错误状态，无法获取校准文件。要校准触摸屏，需要在 Photon 下使用 calib 工具。\ncalib #用于校准触摸屏。成功配置触摸屏后（已经创建了设备文件），必须校准。calib 工具的配置文件保存在 /etc/system/config/calib.$hostname 。关于该文件的格式，可以在 “Writing an Input Device Driver” 的 “Calibration file format” 查看.\n校准的步骤是：\n启动 Photon. 运行 calib. 触摸屏幕上的目标点. 点击 Press to Complete Calibration 按钮，完成校准. 语法 #calib [options] 参数 # -a alg ：指定校准算法。有效算法是 3 和 4 ，默认值是 3 。\n-b val ：指定触摸点的验收方差（范围是 0 - 2000）。使能该参数将会强制检查触摸点。\n-c ：如果已经配置文件 /etc/system/config/calib.$(hostname) 已经存在，就停止运行。\n-d w,h ：触摸屏的宽度和高度。如果不设置该参数，calib 会尝试从硬件获取信息。\n-f file ：校准文件的名称和路径，代替默认的 /etc/system/config/calib.$hostname 。\n-l limit ：校准触摸点的个数，默认值是 15 。\n-o offset ：相对于十字线的偏移，用于调整校验。只能用在四点校验。\n-O ：将触摸屏的起点（0,0）设为右下角。默认为左上角。\n-p x,y ：相对于校验起点的偏移。\n-P ：关闭提示。默认会在屏幕上显示提示信息。\n-s server ：服务器节点或设备名称。\n-S ：使用小触摸目标。默认是大的。\n-t timer ：完成按钮的定时值，默认是 10 。\n-v ：输出详情。\n-x x ：初始化 x 坐标。\n-y y ：初始化 y 坐标。\n例 #校准一个四分子一的标准 640*480 VGA 屏：\ncalib -d 320,240 ELO 触摸屏 #Elographics 触摸屏的驱动是 devi-elo ，它会在 Photon 上启动一个 Elographics 输入管理器 。\n语法 #devi-elo [general_opts] protocol* [protocol_opts]* device* [device_opts]* filter* [filter_opts]* 使用 devi-* 触摸屏驱动时，需要一个校准文件。用 calib 工具产生：\ncalib \u0026gt; calib_file.txt\n参数 #general_opts：\n-b ：禁止使用 Ctrl-Alt-Shift-Backspace 组合键结束 Photon （默认是允许的）。\n-d device ：设备（默认：/dev/photon 或 $PHOTON ）。\n-G ：启动触摸屏驱动时无需图形驱动。在调试时很有用。\n-g input_group ：输入组（默认是 1 ）。\n-l ：列出内部模块。模块用如下格式显示：\nmodule name | date compiled | revision | class -v[v]\u0026hellip; ：输出详情，更多的 v 字符导致输出更多的详情。\nprotocol* [protocol_opts]*：\nsmartset [smartset_opts] [fd fd_opts]|[uart uart_opts] smartset —— Elographics smartset 协议\n-b baud ：波特率（默认是9600）\n-R ：不要 reset 设备（默认是 reset ）\ndevice* [device_opts]*：\nfd —— 通过 open() 打开一个设备\n-d device ：设备文件名（默认是 /dev/ser1）\n-s ：输入接口是串口\nuart —— 直接访问 8250/16550/16450 UART\n-1 ：COM1\n-2 ：COM2\n-i irq ：串口的 IRQ （默认是 4 ）\n-p ioport ：串口的端口地址（默认是 3f8）\nfilter* [filter_opts]*：\nabs —— 转换和压缩绝对坐标\n-b ：点击屏幕代表鼠标右键（默认是左键）\n-c ：校准模式；不转换坐标\n-f filename ：校准文件\n-o x,y ：显示区域的起始点（默认是图形区域的起始点）\n-s x,y ：显示区域右下角的坐标（默认是图形区域的宽和高）\n-x ：翻转 x 坐标\n-y ：翻转 y 坐标\n例 #使用 COM1 ，点击屏幕代表鼠标右键：\ndevi-elo smartset fd -d/dev/ser1 abs -b ","date":"2013 September 15","permalink":"/posts/2013/09/15/","section":"Posts","summary":"QNX Neutrino 支持多种触摸屏，可以在官网上查找支持的型号和对应的驱动：","title":"QNX 对触摸屏的支持"},{"content":"处理中断的线程应该先获得 I/O 权限，调用 ThreadCtl() 函数：\n#include \u0026lt;sys/neutrino.h\u0026gt; ThreadCtl( _NTO_TCTL_IO, 0 ); QNX 提供了两种捆绑中断服务程序和中断号的方式：InterruptAttach() 和 InterruptAttachEvent() 。两种方式调用中断服务程序的方式也不同。分离可以调用 InterruptDetach() 函数：\n#define IRQ3 3 /* A forward reference for the handler */ extern const sigevent *serint (void *, int); … /* * Associate the interrupt handler, serint, * with IRQ 3, the 2nd PC serial port */ ThreadCtl( _NTO_TCTL_IO, 0 ); id = InterruptAttach (IRQ3, serint, NULL, 0, 0); … /* Perform some processing. */ … /* Done; detach the interrupt source. */ InterruptDetach (id); 中断服务程序 #中断服务程序中应该完成如下几个工作：\n判断中断源\n根据你的硬件配置，可能出现多个硬件共享一个中断号。大部分PIC(可编程中断控制器)芯片可以编程配置为电平触发中断或边沿触发中断。触发方式决定了中断是否可以共享。\n下面是多中断源请求中断的示意图：\n在上面这种情况下，如果 PIC 配置为电平触发，只要电平为高，就认为 IRQ 处于激活状态。第二个中断请求(step2)本身并不会产生新的中断，中断一直被认为处于激活状态，即使最初引起中断的中断源已经删除(step3)。直到最后一个中断源被清除，该中断才会被认为处于未激活状态。\n如果是边沿触发模式，中断只会被“注意”一次，即 step1 。只有当中断线被清除，然后被再次请求，PIC 才会认为有新的中断产生。\nQNX 允许多个中断服务程序关联一个中断号。这样的话，每个服务程序必须找到自己关联的硬件并且判断是否是由该硬件引起的中断。这项工作在电平触发环境下是可靠的，边沿触发环境就不一定了。\n处理硬件\n通常是读写硬件寄存器。\n需要注意的是，在 ISR 中不能使用大部分内核调用。在使用库函数时也要小心，因为它们的底层实现可能使用了系统调用，例如 printf() 函数。\n在 ISR 中可以使用的内核调用有：\n* InterruptMask() * InterruptUnmask() * TraceEvent() InterruptMask() 和 InterruptUnmask() 用于关闭和使能一个特定的中断号。 TraceEvent() 用于跟踪内核事件。\n更新数据结构\n另一个问题是如何安全的更新 ISR 和软件线程共同使用的数据结构。有两个特点值得重申：\nISR 拥有比任何软件线程都高的优先级 ISR 不能使用内核调用(特别声明的除外) 这意味着不能在 ISR 中使用线程级别的同步(例如互斥)。\n唤醒应用层代码\n因为 ISR 中的操作受到很大限制，通常需要将大量的操作放在线程级别运行\n为了做到这一点，有两个选择：\n在 ISR 中完成一些对时限要求严格的工作，其他的安排给唤醒的线程来处理 在 ISR 中什么都不做，只是唤醒一个线程 这也是 InterruptAttach() 和 InterruptAttachEvent() 的区别。\n使用 InterruptAttach #InterruptAttach() 函数的原型：\n#include \u0026lt;sys/neutrino.h\u0026gt; int InterruptAttach( int intr, const struct sigevent * (* handler)(void *, int), const void * area, int size, unsigned flags ); 参数：\nintr : 中断号\nhandler : 中断服务函数\narea : 线程与中断服务函数进行通讯的空间，如果不需要可以设为NULL\nsize : 通讯空间的大小\nflags : 表示捆绑中断服务函数的方式，有三个可选值：\n_NTO_INTR_FLAGS_END : 将新的中断服务函数放在该中断的处理函数队列的尾部。\n_NTO_INTR_FLAGS_PROCESS : 将中断服务函数关联到进程，而不是当前线程.\n_NTO_INTR_FLAGS_TRK_MSK : 跟踪调用 InterruptMask() 和 InterruptUnmask() 来安全的分离中断服务函数。\n调用成功的话会返回一个 id ，用于 InterruptMask() 和 InterruptUnmask() 等函数。失败返回-1。\n中断服务函数(ISR)的原型是：\nconst struct sigevent *handler (void *area, int id); 参数：\narea : 即 InterruptAttach() 函数的 area id : 即 InterruptAttach() 函数的返回值 在 handler() 函数中完成了相应的中断服务后，可以选择安排一个线程来完成后续的工作。为此，ISR 需要返回一个指向 const struct sigevent 结构的指针，当内核收到这个结构后，就会将 event 带到目的地。\nstruct sigevent 定义在 \u0026lt;sys/siginfo.h\u0026gt; 头文件，结构成员 sigev_notify 指定了产生怎样的通知。该文件提供了一些宏来初始化这个结构，第一个参数都是 struct sigevent 类型的指针，中断服务函数中常用的宏有如下两个：\nSIGEV_INTR_INIT(\u0026amp;event)\n设置 sigev_notify 为 SIGEV_INTR，表示发送一个中断通知到指定的线程。\nSIGEV_NONE_INIT(\u0026amp;event)\n设置 sigev_notify 为 SIGEV_NONE，表示不发送任何通知。\n典型的处理中断的方法是，在一个线程中调用 InterruptAttach() 绑定中断服务函数，然后调用 InterruptWait() 阻塞线程，直到 ISR 返回一个 SIGEV_INTR ，InterruptWait() 才会返回：\nmain () { // perform initializations, etc. … // start up a thread that is dedicated to interrupt processing pthread_create (NULL, NULL, int_thread, NULL); … // perform other processing, as appropriate … } // this thread is dedicated to handling and managing interrupts void * int_thread (void *arg) { // enable I/O privilege ThreadCtl (_NTO_TCTL_IO, NULL); … // initialize the hardware, etc. … // attach the ISR to IRQ 3 InterruptAttach (IRQ3, isr_handler, NULL, 0, 0); … // perhaps boost this thread's priority here … // now service the hardware when the ISR says to while (1) { InterruptWait (NULL, NULL); // at this point, when InterruptWait unblocks, // the ISR has returned a SIGEV_INTR, indicating // that some form of work needs to be done. … // do the work … // if the isr_handler did an InterruptMask, then // this thread should do an InterruptUnmask to // allow interrupts from the hardware } } // this is the ISR const struct sigevent * isr_handler (void *arg, int id) { // look at the hardware to see if it caused the interrupt // if not, simply return (NULL); … // in a level-sensitive environment, clear the cause of // the interrupt, or at least issue InterruptMask to // disable the PIC from reinterrupting the kernel … // return a pointer to an event structure (preinitialized // by main) that contains SIGEV_INTR as its notification type. // This causes the InterruptWait in \u0026quot;int_thread\u0026quot; to unblock. return (\u0026amp;event); } 这种方案相对于使用 SIGEV_SIGNAL 或 SIGEV_PULSE 类型有几个优点：\n应用程序无需调用 MsgReceive() 函数(用于等到一个pulse)。 应用程序无需一个 signal-handler 函数(用于等待一个signal)。 如果中断处理很急迫，可以定义一个具有高优先级的 int_thread() 线程；当 isr_handler() 返回 SIGEV_INTR 时，只要 int_thread() 的优先级足够高，它就会立即执行。 使用 InterruptWait() 时需要注意一点，被绑定的中断必须产生 SIGEV_INTR 。\n使用 InterruptAttachEvent #InterruptAttachEvent() 函数的原型：\nint InterruptAttachEvent( int intr, const struct sigevent* event, unsigned flags ); 前面关于 InterruptAttach() 的讨论大部分都适用于 InterruptAttachEvent() ，除了 ISR 。这里不需要提供 ISR ,InterruptAttachEvent() 会自己处理中断，因为已经为中断号绑定了一个 struct sigevetn 结构，内核可以检查到这个事件。这样的好处是我们无需考虑进入 ISR 以及如何返回。\n需要注意的是，使用该函数时，内核会在处理中断时自动调用 InterruptMask() 。因此，你应该在中断处理线程中调用 InterruptUnmask() 清除中断。\n","date":"2013 July 28","permalink":"/posts/2013/07/28/","section":"Posts","summary":"处理中断的线程应该先获得 I/O 权限，调用 ThreadCtl() 函数：","title":"QNX 编程"},{"content":"devc-ser8250 是 QNX 下的8250串口驱动，支持8250s, 14450s 和 16550s 。\n必须以 root 用户运行该程序。\n语法： #devc-ser8250 [[options] [port[^shift][,intr]]]... \u0026amp; 选项： # -b number：初始化波特率，默认是 57600。\n-C size ：canonical buffer 的大小，单位是字节，默认是 256 。\n-c clock[/divisor] ：自定义时钟频率，单位是 Hz ，divisor 是串口。\n-E ：raw 模式（默认）。默认关闭软件流控制。\n-e ：edited 模式。默认使能软件流控制。\n-F ：关闭硬件流控制，默认使能硬件流控制。edited 模式不支持硬件流控制。\n-f ：使能硬件流控制。\n-I number ：中断输入 buffer 的大小，单位是字节，默认是2048 。\n-O number ：中断输出 buffer 的大小，单位是字节，默认是2048 。\n-o opt[,opt\u0026hellip;] ：额外选项，用逗号隔开，包括：\nnodaemon —— 不要调用 procmgr_daemon() 是驱动在后台运行。如果你需要知道设备终止的时间，可以使用这个选项。 priority=prio —— 设置内部脉冲的工作优先级。 -S|s ：关闭/使能软件流控制。默认：raw 模式时关闭，edited 模式时使能。\n-T number ：使能发送 FIFO 并设置每次 TX 中断发送的字符数：1,4,8 或 14 。默认是 0 （FIFO 关闭）\n-t number ：使能接收 FIFO 并设置字符数为 1,4,8 或 14 。默认是 0 。\n-u number ：在设备名前缀(/dev/ser)附加号码。默认是 1 ；添加设备。\nport ：一个串口的十六进制的 I/O 地址（X86系统）或物理内存地址（PowerPC和MIPS）。\nshift ：设备寄存器的间隔为 2 的幂。例如：\n0 寄存器是 1 byte 间隔 1 寄存器是 2 byte 间隔 2 寄存器是 4 byte 间隔 \u0026hellip; n 寄存器是 2^n byte 间隔 默认 shift 是 0 。\nintr ： 该 port 使用的中断。\n描述： #如果没有指定 I/O 端口，默认为 COM1(3f8,4) 和 COM2(2f8,3) 。\n","date":"2013 June 9","permalink":"/posts/2013/06/09/","section":"Posts","summary":"devc-ser8250 是 QNX 下的8250串口驱动，支持8250s, 14450s 和 16550s 。","title":"QNX下的串口驱动——devc-ser8250"},{"content":"要读写 I/O 端口，必须获得 I/O 权限，这需要以 root 权限运行线程，并且调用 ThreadCtl() 函数：\n#include \u0026lt;sys/neutrino.h\u0026gt; ThreadCtl( _NTO_TCTL_IO, 0 ); 然后调用 mmap_device_io 函数映射 I/O 端口地址：\n#include \u0026lt;stdint.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; uintptr_t mmap_device_io( size_t len, uint64_t io ); io 表示要访问的 I/O 端口地址（基地址），len 表示要访问的 I/O 端口的字节数。如果调用成功会返回映射后的起始地址，可以直接用 in8 和 out8 等函数访问；如果失败则返回 MAP_DEVICE_FAILED。\n调用读写 I/O 端口的函数要包括头文件：\n#include \u0026lt;hw/inout.h\u0026gt; 主要的函数有：\nuint8_t in8( uintptr_t port ); 从指定端口读取 8 位数据，port 表示端口地址，返回值是读到的数据。\nvoid out8( uintptr_t port, uint8_t val ); 向指定端口写一个 8 位数据。\n","date":"2013 June 2","permalink":"/posts/2013/06/02/","section":"Posts","summary":"要读写 I/O 端口，必须获得 I/O 权限，这需要以 root 权限运行线程，并且调用 ThreadCtl() 函数：","title":"QNX 编程读写 I/O 端口"},{"content":"30天评估版页面：http://www.qnx.com/products/evaluation/ 在该页面下载所需软件，并申请 License 。\n系统环境为：Windows XP 和 VMware 7.0\n1. 安装 Windows 平台的 QNX 开发套件 #下载 QNXSDP-6.5.0 和 QNXSDP-6.5.0-SP1 ，依次安装，安装过程中需要输入 License 。\n注意：安装目录不能有空格，否则以后使用过程中会出错。\n安装后在桌面会出现 QNX Momentics IDE 4.7 的图标:\n2. 在 VMWare 中运行 QNX #在该页面中选择 VMware (PC) target ，下载文件 650SP1-VM.tar 。下载后解压。\n然后用 VMware Workstation 7.0 或 VMware Player 3.0 打开其中的 650SP1-VM.vmx 文件。\n如果在启动过程中 VMWare 弹出对话框提示“虚拟机被移动”，选择 Create 并点击 OK 。\n启动后无需密码可直接用 root 用户登录。\n登录后打开终端，用 ifconfig 查看网卡配置，用 ping 命令查看网络连接。确保可以和宿主机联通。\n默认是用 DHCP 方式获取 IP 。\n3. 创建程序项目 #打开 QNX Momentics IDE 。首次打开是根据提示设置 Workspace ，路径中不能有空格。\n在菜单上选择 File / New / QNX C Project ，打开 New Project 对话框:\n输入 Project Name ，点击 Next 。在 Build Variants 标签页中选择 X86(Little Endian) 。最后点击 Finish :\n这时 IDE 可能还处于 Welcome 页面，点击右上方的 Workbench 图标，进入项目页面。\n4. QNX 的通讯 #目标机系统需要能够响应来自开发环境的请求，所以要保证网络连通，并且在目标机系统的终端里启动 qconn 程序：\n然后在开发环境的 Window 菜单中选择 Open Perspective\u0026ndash;\u0026gt;QNX System Information ，在打开的 Target Navigator 标签页的空白处点击鼠标右键并选择 New QNX Target\u0026hellip; :\n在打开的对话框中输入 Target Name，也可以选择 Same as hostname ，输入目标机的 IP 。点击 Finish :\n然后在 Target Navigator 中点击刚才新建的目标就可以在右边的 System Summary 页面看到目标机系统的进程列表:\n5. 编译和链接 #点击右上方的 C/C++ 图标从 QNX System Information 页面返回项目源码编辑页面:\n在项目名称上点击鼠标右键，选择 Build Project 开始编译链接。编译过程应该不会报错。\n6. 启动和调试 #首先要创建一个启动配置。在工具栏上的 bug 图标下拉菜单中选择 Debug Configurations… ：\n然后会出现一个对话框，在这里可以创建、管理和启动配置。\n在左栏中选择 C/C++ QNX QConn (IP) ，然后点击 New launch configuration 图标：\n现在只需要设置 main 标签页中的内容。在 C/C++ Application 中点击 C/C++ Application 按钮，选择需要启动和调试的二进制文件，其中带有 _g 后缀的文件带有调试信息，否则只能运行不能调试。选择后点击 OK 。\n确保目标机在 Target Options 下列表中，然后点击 Apply ，一个新的启动配置就完成了。\n现在点击 Debug ，集成开发环境就进入了调试界面，并通过网络将可执行程序传送到了目标机的系统中，然后在调试器中启动它。\n","date":"2013 May 2","permalink":"/posts/2013/05/02/","section":"Posts","summary":"30天评估版页面：http://www.qnx.com/products/evaluation/ 在该页面下载所需软件，并申请 License 。","title":"搭建 QNX 开发环境"},{"content":" xagrs \u0026ndash; 从标准输入获得参数并执行命令\nxargs 有点类似反引号 ，但是功能更强大，它从标准输入获得参数列表，然后分割小块分段，再逐条传递给其他命令并执行。例如：\nfind ./ -type f | xargs grep date 该命令相当于对当前目录下的每个文件执行一次 grep date ，也就是将列出当前目录下文件内容中包含 date 的文件 。如果没有 xargs，只会列出当前目录下文件名中包含 date 字段的文件。\n但是上面这个例子存在一个问题，如果文件名中包含有空格，会出错，这是因为 xargs 默认是按照空白字符来分割输入的。一个简单的解决办法就是告诉find使用NUL(\\0)来分割结果（向find提供-print0选项），并且告诉xargs也使用Nul来分隔输入（-0）。例如删除当前目录下所有的 python 文件：\nfind ./ -name '*.py' -type f -print0 | xargs -0 rm 如果要指定参数在命令中的文件，可以用 -i 选项和 {} 的组合，参数就会被放到 {} 所在的位置。例如，将当前目录下的文件移动到 back 目录下：\nfind ./ -type f | xargs -i mv {} ./back/ 有的命令执行时需要不止一个参数，xargs 提供了 -n 选项指定参数数目。一个简单的例子，逐对比较当前目录下的文件的不同：\nfind ./ -type f | xargs -n 2 diff 还用两个有用的选项：\n-t 每次执行命令前将完整的命令打印一次 -r 在无输入情况下则不构造命令执行 ","date":"2013 April 28","permalink":"/posts/2013/04/28/","section":"Posts","summary":"xagrs \u0026ndash; 从标准输入获得参数并执行命令","title":"xargs 命令"},{"content":" 下载源码前必须确保已经安装了 dpkg-dev 。使用 apt-get install dpkg-dev 命令安装。\n查找带ubuntu补丁的内核源码\napt-cache search linux-source 该条命令会查找到很多版本的内核源码，选择所需要的，然后执行：\napt-get source linux-source-[version] 开始将内核源码包下载到当前目录中。源码包中有三个文件：*.dsc 、*.diff.gz 和 *.orig.tar.gz 。\n下载完成后会自动调用 dpkg-source 命令，根据 dsc 文件中的信息，将源码包解压到同名目录中。然后就可以在源码目录下编译内核了。\n不只是内核源码，用 apt-get 下载其他源码也是这样的方式。\n在编译源码包前，还可以用下面命令安装具有依赖关系的相关软件包：\napt-get build-dep 在源码目录下执行 dpkg-buildpackage 命令，会生成 Deb 软件包，并放置在上层目录中。\n","date":"2013 April 27","permalink":"/posts/2013/04/27/","section":"Posts","summary":"下载源码前必须确保已经安装了 dpkg-dev 。使用 apt-get install dpkg-dev 命令安装。","title":"在 ubuntu 中下载内核源码"},{"content":"GRUB2 指南中文版\n修改 GRUB2 的配置文件后，都要执行 update_grub 命令生成 /boot/grub/grub.cfg 文件，这样才能使修改生效。任何情况下都不建议手动更改该文件。\n1.显示启动菜单 #默认情况下，如果只安装了一个系统，GRUB2是不会显示启动菜单的。\n可以在启动时按住 Shift 键，强制显示启动菜单。\n2.修改默认启动项 #在 /etc/default/grub 文件中，设置 GRUB_DEFAULT：\nGRUB_DEFAULT = 0 /boot/grub/grub.cfg 文件中的第一个菜单项为 0 ，第二个为 1 \u0026hellip;\n也可以设置为 saved ，表示默认启动项为上一次选择的项目。\n3.修改 Linux 内核参数 #在 /etc/default/grub 文件中，有两个选项用于设置向 Linux 内核传递的参数：\nGRUB_CMDLINE_LINUX 若存在，无论在一般或是救援模式，此行将追加到所有的 \u0026rsquo;linux\u0026rsquo; 命令行后面（传统 GRUB 的「kernel」选项）。类似于 menu.lst 中的「altoptions 」选项。 GRUB_CMDLINE_LINUX_DEFAULT 此行将追加在 \u0026rsquo;linux\u0026rsquo; 命令行后面（传统 GRUB 的「kernel」选项）。此选项只会追加在一般模式的最后方。类似于 menu.lst 中的「defoptions」选项。如果想显示黑色屏幕以及启动进程文字，请移除「quiet splash」。若想看到 grub 引导画面及简短的文字输出，使用「splash」。若有需要的话，也可以在此行输入选项「acpi=off」。 ","date":"2013 April 25","permalink":"/posts/2013/04/25/","section":"Posts","summary":"GRUB2 指南中文版","title":"GRUB2常用配置"},{"content":"原理 #X86架构的蜂鸣器连接图如下：\n由图可见，蜂鸣器的声调是由定时器8254的计数器2的输出 OUT2 控制的，OUT2 输出一定频率的正弦波就可以驱动蜂鸣器发声。8254 的端口地址是 0x40~0x43 。\n计数器2是否工作由门控信号 GATE2 决定，GATE2 接并口 PB0 位，即 IO 端口 0x61 的 D0 位。OUT2 和 PB1 经过一个与门后连接到蜂鸣器，PB1 是 IO 端口 0x61 的 D1 位。所以只有当 PB0 和 PB1 同时为高，OUT2 的输出才会到达蜂鸣器。\n编程 #在 Linux 下，可以直接在用户空间访问 IO 端口。下面程序将是蜂鸣器发声 2 秒。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/io.h\u0026gt; /* * val 为写入计数器的值 * delay 为蜂鸣器发声持续的时间，单位是毫秒 */ void beep(unsigned short int val,int delay) { unsigned char reg_val = 0; iopl(3); outb(0xb6,0x43); //counter 2 , mode 3 outb(val\u0026amp;0x00ff,0x42); outb(val\u0026gt;\u0026gt;8,0x42); reg_val = inb(0x61); outb(reg_val|0x03,0x61); //PB0和PB1输出高电平 usleep(1000*delay); outb(reg_val\u0026amp;0xfc,0x61); //PB0和PB1输出低电平 iopl(0); } int main() { beep(500,2000); return 0; } ","date":"2013 January 24","permalink":"/posts/2013/01/24/","section":"Posts","summary":"\u003ch2 id=\"原理\" class=\"relative group\"\u003e原理 \u003cspan class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100\"\u003e\u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\" style=\"text-decoration-line: none !important;\" href=\"#%e5%8e%9f%e7%90%86\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e\u003c/h2\u003e\u003cp\u003eX86架构的蜂鸣器连接图如下：\u003c/p\u003e\n\u003cp\u003e\n\n\n\n\n  \n  \n  \n    \u003cfigure\u003e\n      \u003cimg\n        class=\"mx-auto my-0 rounded-md\"\n        src=\"./pics_1.JPG\"\n        alt=\"\"\n        \n          loading=\"lazy\"\n        \n      /\u003e\n      \n    \u003c/figure\u003e\n  \n\u003c/p\u003e\n\u003cp\u003e由图可见，蜂鸣器的声调是由定时器8254的计数器2的输出 OUT2 控制的，OUT2 输出一定频率的正弦波就可以驱动蜂鸣器发声。8254 的端口地址是 0x40~0x43 。\u003c/p\u003e","title":"Linux 系统下编程控制蜂鸣器"},{"content":"udev 是 linux 2.6 内核提供的一种动态管理设备器，主要功能是管理 /dev 目录下的设备节点，同时也替换了 devfs 和 hotplug 的功能，这意味着它要在添加/删除硬件时处理 /dev 目录以及所有用户空间的行为，包括加载 firmware 时。\nudev 依赖于内核提供的 uevent 接口，每次添加或删除设备时，内核都会发送 uevent 向 udev 通知更改。udev 的守护进程是 udevd ，在系统启动时会读取并分析 udev 规则文件提供的所有规则，并保存在内存。 当 udev 接收到内核发出的设备更改事件后，会将设备信息与规则进行匹配，然后执行相应的操作。\nlinux内核中的设备信息都是通过 sysfs 文件系统导出的，位于 /sys 目录下。\n1. udevadm #udevadm 是一个 udev 管理工具。可用于监视和控制 udev 的运行时行为、请求内核事件、管理事件队列，以及提供简单的调试机制。\n1.1 监视正在运行的 udev 守护进程 #程序 udevadm monitor 用于将驱动程序核心时间和 udev 事件处理的计时可视化。执行 udevadm monitor 后，会出现如下内容：\nmonitor will print the received events for: UDEV - the event which udev sends out after rule processing KERNEL - the kernel uevent 之后发生的所有 udev 事件都会显示。例如下面是插入 U 盘后显示的前几行：\nKERNEL[1356423352.040293] add /devices/pci0000:00/0000:00:11.0/0000:02:03.0/usb1/1-1 (usb) KERNEL[1356423352.098881] add /devices/pci0000:00/0000:00:11.0/0000:02:03.0/usb1/1-1/1-1:1.0 (usb) UDEV [1356423352.181389] add /devices/pci0000:00/0000:00:11.0/0000:02:03.0/usb1/1-1 (usb) KERNEL[1356423352.239535] add /module/usb_storage (module) UDEV [1356423352.241499] add /module/usb_storage (module) 每行表示一个事件。第一个字段中，KERNEL 表示这是一个内核产生的事件，UDEV 表示 udev 事件。第二个字段是计时，单位是微秒。第三个字段表示事件的动作，add 表示添加，如果卸载 U 盘会显示 remove 。最后是 sysfs 文件系统中添加或删除的文件和目录。\n1.2 查询设备信息 #udevadm info 用于查询 sysfs 文件系统中的设备信息，信息是按照 Linux 设备模型的层次结构显示的，首先是这个设备的路径和信息，然后依次遍历它的父设备。\n例如要查询 U 盘 sdb1 的信息，就执行：\nudevadm info -a -p /sys/class/block/sdb1 显示的第一段信息如下：\nlooking at device '/devices/pci0000:00/0000:00:11.0/0000:02:03.0/usb1/1-1/1-1:1.0/host5/target5:0:0/5:0:0:0/block/sdd/sdd1': KERNEL==\u0026quot;sdd1\u0026quot; SUBSYSTEM==\u0026quot;block\u0026quot; DRIVER==\u0026quot;\u0026quot; ATTR{partition}==\u0026quot;1\u0026quot; ATTR{start}==\u0026quot;1040128\u0026quot; ATTR{size}==\u0026quot;6848768\u0026quot; ATTR{alignment_offset}==\u0026quot;0\u0026quot; ATTR{stat}==\u0026quot; 143 6874 9334 1493 1 0 1 3 0 1266 1496\u0026quot; ATTR{inflight}==\u0026quot; 0 0\u0026quot; KERNEL 是设备在内核中的名称，SUBSYSTEM 表示它所属的子系统，ATTR{} 表示各种属性。这些字段都会在 udev 规则中 用到。\n2. udev 规则 #udev 规则可以与内核添加到事件本身的属性或者内核导出到 sysfs 的任何信息匹配。规则还可以从外部程序请求其他信息。根据提供的规则匹配每个事件。所有规则都位于 /etc/udev/rules.d 目录下。\n规则文件中的每一行至少包含一个关键字值对。有两种类型的关键字，匹配关键字和指派关键字。如果所有匹配关键字与它们的值匹配，则应用此规则并将指派关键字指派给特定的值。匹配规则可以指定设备节点的名称、添加指向该节点的符号链接或者运行作为事件处理一部分的特定程序。如果找不到匹配的规则，则使用默认设备节点名来创建设备节点。udev 手册页中描述了有关规则语法和提供用来与数据匹配或导入数据的关键字的详细信息。\n下面这个例子来自 /etc/udev/rules.d/10-automount.rules 。\nKERNEL==\u0026quot;sd[b-z]\u0026quot;,SUBSYSTEM==\u0026quot;block\u0026quot;,BUS==\u0026quot;usb\u0026quot;,SYMLINK+=\u0026quot;usb_%k\u0026quot; KERNEL==\u0026quot;sd[b-z][1-9]\u0026quot;,SUBSYSTEM==\u0026quot;block\u0026quot;,BUS==\u0026quot;usb\u0026quot;,SYMLINK+=\u0026quot;usb_%k\u0026quot; ACTION==\u0026quot;add\u0026quot;,KERNEL==\u0026quot;sd[b-z][1-9]\u0026quot;,SUBSYSTEM==\u0026quot;block\u0026quot;,BUS==\u0026quot;usb\u0026quot;,RUN+=\u0026quot;/bin/mkdir -m 777 /media/usb_%k\u0026quot;,RUN+=\u0026quot;/bin/mount -t auto /dev/usb_%k /media/usb_%k\u0026quot; ACTION==\u0026quot;remove\u0026quot;,KERNEL==\u0026quot;sd[b-z][1-9]\u0026quot;,SUBSYSTEM==\u0026quot;block\u0026quot;,BUS==\u0026quot;usb\u0026quot;,RUN+=\u0026quot;/bin/rm -rf /media/usb_%k\u0026quot; 前两条规则由四个键构成：三个匹配键 (KERNEL,SUBSYSTEM,BUS) 和一个赋值键 (SYMLINK)。三个匹配规则搜索设备列表以查找所有的 U 盘。只有完全匹配才能触发执行此规则。在这种情况下，SYMLINK 指派关键字会在 /dev 目录下生产一个的链接，指向默认的设备节点。匹配此特殊设备类型的任何后续规则都不产生任何影响。\n后两条规则分别对应插入(add)和拔出(remove) U 盘的事件。RUN 表示事件发生时执行的程序。\n所有规则具有一些共同的特征:\n每个规则由一个或多个以逗号分隔的关键字值对构成。\n关键字的运算由运算符确定，udev 规则支持多个不同的运算符。\n每个给定值必须用引号引起来。\n规则文件的每一行代表一个规则。如果一个规则超过一行，请使用 \\ 合并不同行，就像在壳层语法中一样。\nudev 规则支持与 *、? 和 [] 模式匹配的外壳式模式。\nudev 规则支持替换。\n2.1 在 udev 规则中使用运算符 #创建可以从若干不同运算符选择的关键字，具体取决于希望创建的关键字类型。匹配关键字通常仅用于查找匹配或明显不匹配搜索值的值。匹配关键字包含以下运算符之一：\n==\t比较等于性。如果关键字包含搜索模式，则匹配该模式的所有结果均有效。\n!=\t比较不等于性。如果关键字包含搜索模式，则匹配该模式的所有结果均有效。\n赋值关键字可以使用下面的任何运算符：\n=\t为关键字指派值。如果关键字以前由一列值构成，关键字将重置，并且仅指派一个值。\n+=\t为包含一列项的关键字添加一个值。\n:=\t指派最终值。不允许后面的规则进行任何后续更改。\n2.2 在 udev 规则中使用替换项 #udev 规则支持使用占位符和替换项。请按照在其他任何脚本中的相同方式使用。在 udev 规则中可使用以下替换项：\n%r、$root\n设备目录 /dev（默认）。\n%p、$devpath\nDEVPATH 的值。\n%k、$kernel\nKERNEL 的值或内部设备名称。\n%n、$number\n设备号。\n%N、$tempnode\n设备文件的临时名称。\n%M、$major\n设备的主编号。\n%m、$minor\n设备的次编号。\n%s{attribute}/$attr{attribute}\nsysfs 属性的值（由 attribute 指定）。\n%E{variable}、$attr{variable}\n环境变量的值（由 variable 指定）。\n%c、$result\nPROGRAM 的输出。\n%%\n%字符。\n$$\n$ 字符。\n2.3 使用 udev 匹配关键字 #匹配关键字描述应用 udev 规则之前必须满足的条件。以下匹配关键字可用：\nACTION\n事件操作的名称，如 add 或 remove（添加或删除设备时）。\nDEVPATH\n事件设备的设备路径，如 DEVPATH=/bus/pci/drivers/ipw3945，用于搜索与 ipw3945 驱动程序有关的所有事件。\nKERNEL\n事件设备的内部（内核）名称。\nSUBSYSTEM\n事件设备的子系统，如 SUBSYSTEM=usb（用于与 USB 设备有关的所有事件）。\nATTR{filename}\n事件设备的 sysfs 属性。例如，要匹配 vendor 属性文件名中包含的字符串，可以使用 ATTR{vendor}==\u0026ldquo;On(sS)tream\u0026rdquo;。\nKERNELS\n让 udev 向上搜索设备路径以查找匹配的设备名称。\nSUBSYSTEMS\n让 udev 向上搜索设备路径以查找匹配的设备子系统名称。\nDRIVERS\n让 udev 向上搜索设备路径以查找匹配的设备驱动程序名称。\nATTRS{filename}\n让 udev 向上搜索设备路径以查找具有匹配的 sysfs 属性值的设备。\nENV{key}\n环境变量的值，如 ENV{ID_BUS}=\u0026ldquo;ieee1394，用于搜索与该 FireWire 总线 ID 有关的所有事件。\nPROGRAM\n让 udev 执行外部程序。程序必须返回退出码零，才能成功。程序的输出（打印到 stdout）可用于 RESULT 关键字。\nRESULT\n匹配上次 PROGRAM 调用的输出字符串。在与 PROGRAM 关键字相同的规则中包含该关键字，或在后面的一个中。\n2.4 使用 udev 指派关键字 #与上述匹配键相比，赋值键未描述必须满足的条件。它们将值、名称和操作指派给由 udev 维护的设备节点。\nNAME\n将创建的设备节点的名称。在一个规则设置节点名称之后，将对该节点忽略带有 NAME 关键字的其他所有规则。\nSYMLINK\n与要创建的节点有关的符号链接名称。多个匹配的规则可添加要使用设备节点创建的符号链接。也可以通过使用空格字符分隔符号链接名称，在一个规则中为一个节点指定多个符号链接。\nOWNER, GROUP, MODE\n新设备节点的权限。此处指定的值重写已编译的任何值。\nATTR{key}\n指定要写入事件设备的 sysfs 属性的值。如果使用 == 运算符，也将使用该关键字匹配 sysfs 属性的值。\nENV{key}\n告知 udev 将变量导出到环境。如果使用 == 运算符，也将使用该关键字匹配环境变量。\nRUN\n告知 udev 向程序列表添加要为该设备执行的程序。请记住，将此程序限制于很短的任务，以免妨碍此设备的后续事件。\nLABEL\n添加 GOTO 可跳至的标签。\nGOTO\n告知 udev 跳过一些规则，继续执行具有按 GOTO 关键字引用的标签的规则。\nIMPORT{type}\n将变量装载入外部程序输出之类的事件环境中。udev 导入不同类型的若干变量。如果未指定任何类型，udev 将尝试根据文件许可权限的可执行位来自行确定类型。\nprogram 告知 udev 执行外部程序并导入其输出。 file 告知 udev 导入文本文件。 parent 告知 udev 从父设备导入储存的关键字。 WAIT_FOR_SYSFS\n告知 udev 等待要为某个设备创建的指定 sysfs 文件。例如，WAIT_FOR_SYSFS=\u0026ldquo;ioerr_cnt\u0026rdquo; 通知 udev 等待 ioerr_cnt 文件创建完成。\nOPTIONS\nOPTION 关键字可能有若干值：\nlast_rule 告知 udev 忽略后面的所有规则。 ignore_device 告知 udev 完全忽略此事件。 ignore_remove 告知 udev 忽略后面针对设备的所有删除事件。 all_partitions 告知 udev 为块设备上的所有可用分区创建设备节点。 3. udev 使用的文件 # /sys/*\nLinux 内核提供的虚拟文件系统，用于导出所有当前已知设备。此信息由 udev 用于在 /dev 中创建设备节点\n/dev/*\n动态创建的设备节点和引导时从 /lib/udev/devices/* 复制的静态内容\n/etc/udev/udev.conf\n主 udev 配置文件。\n/etc/udev/rules.d/*\nudev 事件匹配规则.\n/lib/udev/devices/*\n静态 /dev 内容。\n/lib/udev/*\n从 udev 规则调用的帮助程序。\n","date":"2013 January 5","permalink":"/posts/2013/01/05/","section":"Posts","summary":"udev 是 linux 2.","title":"使用 udev 管理设备"},{"content":"假设字符设备名为 led ，源文件为led.c ，不涉及实际的硬件操作。基本的驱动代码结构如下：\n1. 包含必要的头文件 ##include \u0026lt;linux/init.h\u0026gt; //module_init() 和 module_exit() #include \u0026lt;linux/sched.h\u0026gt; //包含大部分内核API的定义 #include \u0026lt;linux/module.h\u0026gt; //什么模块信息的宏，例如MODULE_AUTHOR(author) #include \u0026lt;linux/version.h\u0026gt; //包含内核版本信息的头文件 #include \u0026lt;linux/moduleparam.h\u0026gt; //创建模块参数的宏 #include \u0026lt;linux/kernel.h\u0026gt; //printk等函数 #include \u0026lt;linux/types.h\u0026gt; //内核模块的各种数据类型，例如dev_t #include \u0026lt;linux/fs.h\u0026gt; //文件系统 #include \u0026lt;linux/cdev.h\u0026gt; 还可以根据需要添加其他头文件。\n2. 定义一个设备私有数据结构 #通常会将设备名，设备号，cdev等都放入这个数据结构。\nstruct led_dev_t { char dev_name[10]; dev_t dev_num; struct cdev cdev; } struct led_dev_t *led_dev; 3. 实现 file_operations 结构 #file_operations 结构首先要实现 .owner 然后再根据需要实现相关函数。\nstruct file_operations led_fops = { .owner = THIS_MODULE, .open = led_open, .release = led_close, } 4. 实现模块初始化函数 #模块加载函数应该依次完成如下几个步骤：\n为设备私有数据结构分配内存，然后初始化。 申请设备号。 注册字符设备。即初始化 cdev ，将 file_operations 结构和设备号与 cdev 绑定。 最后用 module_init() 宏向内核说明初始化函数的位置。\n5. 实现模块卸载函数 #模块卸载函数的内容基本是加载函数的逆过程：\n释放设备号。 删除 cdev 。 释放申请的内存。 最后用 module_exit() 宏向内核说明卸载函数的位置。\n6. 实现文件操作函数 #open 和 close 函数通常是必须的。\nopen 函数的原型是\nint (*open)(struct inode *,struct file *) inode 结构的成员 i_cdev 指向的就是先前设置的 cdev 。要确保设备成功打开，应该通过 inode-\u0026gt;i_cdev 找到包含 cdev 的设备私有数据结构的实例。内核提供 container_of 宏来完成这项工作：\ncontainer_of(poiner,container_type,container_field); 用法如下：\nstruct led_dev_t *dev; dev = container_of(inode-\u0026gt;i_cdev,struct led_dev_t,cdev); DEBUG(\u0026quot;open %s\\n\u0026quot;,dev-\u0026gt;dev_name); filp-\u0026gt;private_data = dev; close 函数的原型是\nint (*release)(struct inode *,struct file *) 7. 模块参数 #模块的参数通过 module_param(name,type,flag) 声明，并且应该有一个默认值，例如：\nstatic int addr=0x300; module_param(addr,int,S_IRUGO|S_IWUSR); 如果参数类型为字符串，type 应该设为 charp 。\nflag 是访问许可值，可用的值定义在 \u0026lt;linux/stat.h\u0026gt; 中。S_IRUGO 表示任何人都可以读取该参数，但不能修改；S_IWUSR 表示 root 用户可以修改该参数。\n8. 声明许可证 #MODULE_LICENSE(\u0026quot;GPL\u0026quot;); 9. 关于调试 #最常用的调试手段是内核打印函数 printk ，使用方法与标准库函数 printf 类似。printk 打印的信息通常用 dmesg 命令查看。\n为了方便在最终发布时去掉打印的调试信息，通常将 printk 函数封装为一个宏 ：\n#define PRINT_DEBUG #ifdef PRINT_DEBUG #define DEBUG(fmt,args...) printk(\u0026quot;LED:\u0026quot;fmt,##args) #else #define DEBUG(fmt,args...) #endif 发布时只需将第一行注释掉，就可以去掉打印信息。\n10. Makefile #KERNELDIR=/lib/modules/$(shell uname -r)/build PWD=$(shell pwd) obj-m := led.o default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules clean: $(MAKE) -C $(KERNELDIR) M=$(PWD) clean 如果模块包含多个源文件，比如 file1.c 和 file2.c ，Makefile 应该如下编写：\nobj-m := modulename.o modulename-objs := file1.o file2.o modulename 是模块的名称，最好不要与源文件同名。\n11. 加载驱动 #用 insmod 命令加载驱动，加载时可以指定参数，例如：\ninsmod led.ko addr=0x300 加载成功后，/sys/modules/ 下会出现相应的目录，/proc/modules文件（lsmod 即查看的该文件）中会出现模块的信息， /proc/devices 文件中可以看到设备名和主设备号：\ncat /proc/devices | grep led 可以根据主设备号创建设备节点。\n12. 附录：完整代码 ##include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/slab.h\u0026gt; #include \u0026lt;linux/mm.h\u0026gt; #include \u0026lt;linux/fs.h\u0026gt; #include \u0026lt;linux/types.h\u0026gt; #include \u0026lt;linux/cdev.h\u0026gt; #include \u0026lt;linux/version.h\u0026gt; #define PRINT_DEBUG #ifdef PRINT_DEBUG #define DEBUG(fmt,args...) printk(\u0026quot;LED : \u0026quot;fmt,##args) #else #define DEBUG(fmt,args...) #endif struct led_dev_t { const char *dev_name; dev_t dev_num; struct cdev cdev; }; struct led_dev_t *led_dev; int led_open(struct inode *inode,struct file *filp) { struct led_dev_t *dev; dev = container_of(inode-\u0026gt;i_cdev,struct led_dev_t,cdev); DEBUG(\u0026quot;open %s\\n\u0026quot;,dev-\u0026gt;dev_name); filp-\u0026gt;private_data = dev; return 0; } int led_close(struct inode *inode,struct file *filp) { DEBUG(\u0026quot;close %s\\n\u0026quot;,((struct led_dev_t *)filp-\u0026gt;private_data)-\u0026gt;dev_name); return 0; } struct file_operations led_fops = { .owner = THIS_MODULE, .open = led_open, .release = led_close, }; static int __init led_init(void) { int ret = 0; unsigned int dev_major = 0; unsigned int dev_minor = 0; //初始化设备私有数据结构 led_dev = kmalloc(sizeof(struct led_dev_t),GFP_KERNEL); if(led_dev \u0026lt;= 0) { DEBUG(\u0026quot;led init kmalloc failed\\n\u0026quot;); return -1; } memset(led_dev,0,sizeof(struct led_dev_t)); led_dev-\u0026gt;dev_name = \u0026quot;led\u0026quot;; //定义设备名 //申请设备号 if(dev_major) { led_dev-\u0026gt;dev_num = MKDEV(dev_major,dev_minor); ret = register_chrdev_region(led_dev-\u0026gt;dev_num,1,led_dev-\u0026gt;dev_name); } else { ret = alloc_chrdev_region(\u0026amp;(led_dev-\u0026gt;dev_num),dev_minor,1,led_dev-\u0026gt;\tdev_name); dev_major = MAJOR(led_dev-\u0026gt;dev_num); } if(ret) { DEBUG(\u0026quot;register chrdev region failed\\n\u0026quot;); return ret; } else { DEBUG(\u0026quot;Major: %d, Minor: %d\\n\u0026quot;,dev_major,dev_minor); } //初始化 cdev cdev_init(\u0026amp;(led_dev-\u0026gt;cdev),\u0026amp;led_fops); led_dev-\u0026gt;cdev.owner = THIS_MODULE; ret = cdev_add(\u0026amp;(led_dev-\u0026gt;cdev),led_dev-\u0026gt;dev_num,1); if(ret\u0026lt;0) { DEBUG(\u0026quot;cdev add failed\\n\u0026quot;); return ret; } DEBUG(\u0026quot;led init\\n\u0026quot;); return 0; } static void __exit led_exit(void) { DEBUG(\u0026quot;device is %s\\n\u0026quot;,led_dev-\u0026gt;dev_name); unregister_chrdev_region(led_dev-\u0026gt;dev_num,1); cdev_del(\u0026amp;led_dev-\u0026gt;cdev); kfree(led_dev); DEBUG(\u0026quot;led exit\\n\u0026quot;); } module_init(led_init); module_exit(led_exit); MODULE_AUTHOR(\u0026quot;Li Shaocheng\u0026quot;); MODULE_LICENSE(\u0026quot;GPL\u0026quot;); ","date":"2013 January 4","permalink":"/posts/2013/01/04/","section":"Posts","summary":"假设字符设备名为 led ，源文件为led.","title":"Linux 字符驱动的基本结构"},{"content":"一个最简单的内核模块 #编写一个最简单的内核模块 hellomod，源码 hellomod.c 如下：\n#include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; static int __init hellomod_init(void) { printk(\u0026quot;hellomod init\\n\u0026quot;); return 0; } static void __exit hellomod_exit(void) { printk(\u0026quot;hellomod exit\\n\u0026quot;); } module_init(hellomod_init); module_exit(hellomod_exit); MODULE_LICENSE(\u0026quot;GPL\u0026quot;); Makefile 文件如下：\nKERDIR=/lib/modules/$(shell uname -r)/build PWD=$(shell pwd) obj-m:=hellomod.o default: make -C ${KERDIR} M=${PWD} modules clean: make -C ${KERDIR} M=${PWD} clean 直接运行 make 即可将其编译为 hellomod.ko 。下面以该模块为例介绍添加到内核的步骤。\n添加到内核 #将一个模块源码添加到内核需要如下三个步骤：\n1.将源码文件复制的相应的目录中 #我们将 hellomod.c 复制到内核源码的 driver/char/ 目录下。\n2.修改 Makefile 文件 #在 driver/char/Makefile 文件中添加新的模块：\nobj-$(CONFIG_HELLOMOD) += hellomod.o 其中 CONFIG_HELLOMOD 变量是在配置内核是确定的，通常可以取三个值：y 、n 、m 。其中 CONFIG_ 是固定的， HELLOMOD 是自定义的，但必须与 Kconfig 文件中的设置一致。\n3.修改 Kconfig 文件 #drivers/char/Kconfig 文件的基本结构如下：\nmenu \u0026quot;Characters devices\u0026quot; config ... ... source \u0026quot;drivers/char/ipmi/Kconfig\u0026quot; ... endmenu menu 和 endmenu 之间定义了一个 Characters devices 菜单。config 字段定义了一个模块选项，source 导入了一个外部的 Kconfig 。\n在 menu 和 endmenu 之间添加：\nconfig HELLOMOD tristate \u0026quot;hellomod\u0026quot; default m help just a module HELLOMOD 与 Makefile 中定义的变量是一致的。tristate 设置的是显示在配置界面的条目，default 设置的是该配置的默认值。help 显示的是帮助内容。\n如上修改之后，运行 make menuconfig ，就可以在 Device Drivers -\u0026gt; Character devices 中看到 \u0026lt;M\u0026gt;hellomod 。退出保存后可以在 .config 文件中看到 CONFIG_HELLOMOD=m 。\n新增一个模块目录 #如果要为 hellomod 新建一个单独的目录，可以按如下步骤完成：\n1.新建目录并添加源文件 #在 drivers/char/ 目录下新建 hellomod 目录，并将 hellomod.c 复制到该目录下。\n2.添加 Makefile #在 drivers/char/hellomod/ 目录下新建 Makefile 文件，内容如下：\nobj-$(CONFIG_HELLOMOD) += hellomod.o 3.添加 Kconfig #在 drivers/char/hellomod/ 目录下新建 Kconfig 文件，内容如下：\nmenu \u0026quot;hello module\u0026quot; config HELLOMOD tristate \u0026quot;hellomod\u0026quot; default m help just a module endmenu 然后在上层目录 drivers/chars 的 Kconfig 文件中添加：\nsource drivers/char/hellomod/Kconfig ","date":"2012 December 18","permalink":"/posts/2012/12/18/","section":"Posts","summary":"一个最简单的内核模块 #编写一个最简单的内核模块 hellomod，源码 hellomod.","title":"在 Linux 内核中新增模块代码"},{"content":"实现步骤 #假设设备驱动名为 module ，设备的私有数据结构为 module_dev_t ，实现异步通知的步骤如下 ：\n1.定义一个 struct fasync_struct *类型的指针，通常是在设备的私有数据结构中定义。\nstruct module_dev_t module_dev { ... strcut fasync_struct * fasync_queue; } 2.实现 fasync 方法,在 fasync 方法中调用 fasync_helper 函数。\nstatic int module_fasync(int fd,struct file *filp,int mode) { struct module_dev_t *dev = filp-\u0026gt;private_data; return fasync_helper(fd,filp,mode,\u0026amp;dev-\u0026gt;fasync_queue); } struct file_operations fops = { ... .fasync = module_fasync, } 3.在数据到达时调用 kill_fasync 函数产生信号。\nif(dev-\u0026gt;fasync_queue) kill_fasync(\u0026amp;dev-\u0026gt;fasync_queue,SIGIO,POLL_IN); 4.在关闭设备是调用 fasync 方法。\nmodule_fasync(-1,filp,0); 应用程序的编程方法 #1.为信号注册一个处理函数\nsignal(SIGIO,sig_handler); 当进程接收到 SIGIO 信号是会执行 sig_handler 函数：\nvoid (*sig_handler)(int sig) 2.设置将要接收 SIGIO 或 SIGURG 信号的进程 id 。\nfcntl(fd,F_SETOWN,getpid()); 这样会将进程的 ID 保存到 filp-\u0026gt;f_woner 中，内核就知道当信号到达时应该通知哪个进程。\n3.为文件设置 FASYNC 标志。\noflas = fcntl(fd,F_GETFL); fcntl(fd,F_SETFL,oflags | FASYNC); 设置 FASYNC 时就会调用驱动的 fasync 方法。在文件打开时，FASYNC 标志是默认清除的。\n","date":"2012 November 20","permalink":"/posts/2012/11/20/","section":"Posts","summary":"实现步骤 #假设设备驱动名为 module ，设备的私有数据结构为 module_dev_t ，实现异步通知的步骤如下 ：","title":"Linux 驱动的异步通知"},{"content":"数据文件 datefile\nSteve Blenheim:238-923-7366:95 Latham Lane, Easton, PA 83755:11/12/56:20300 Betty Boop:245-836-8357:635 Cutesy Lane, Hollywood, CA 91464:6/23/23:14500 Igor Chevsky:385-375-8395:3567 Populus Place, Caldwell, NJ 23875:6/18/68:23400 Norma Corder:397-857-2735:74 Pine Street, Dearborn, MI 23874:3/28/45:245700 Jennifer Cowan:548-834-2348:583 Laurel Ave., Kingsville, TX 83745:10/1/35:58900 Jon DeLoach:408-253-3122:123 Park St., San Jose, CA 04086:7/25/53:85100 Karen Evich:284-758-2857:23 Edgecliff Place, Lincoln, NB 92743:7/25/53:85100 Karen Evich:284-758-2867:23 Edgecliff Place, Lincoln, NB 92743:11/3/35:58200 Karen Evich:284-758-2867:23 Edgecliff Place, Lincoln, NB 92743:11/3/35:58200 Fred Fardbarkle:674-843-1385:20 Parak Lane, Duluth, MN 23850:4/12/23:780900 Fred Fardbarkle:674-843-1385:20 Parak Lane, Duluth, MN 23850:4/12/23:780900 Lori Gortz:327-832-5728:3465 Mirlo Street, Peabody, MA 34756:10/2/65:35200 Paco Gutierrez:835-365-1284:454 Easy Street, Decatur, IL 75732:2/28/53:123500 Ephram Hardy:293-259-5395:235 CarltonLane, Joliet, IL 73858:8/12/20:56700 James Ikeda:834-938-8376:23445 Aster Ave., Allentown, NJ 83745:12/1/38:45000 Barbara Kertz:385-573-8326:832 Ponce Drive, Gary, IN 83756:12/1/46:268500 Lesley Kirstin:408-456-1234:4 Harvard Square, Boston, MA 02133:4/22/62:52600 William Kopf:846-836-2837:6937 Ware Road, Milton, PA 93756:9/21/46:43500 Sir Lancelot:837-835-8257:474 Camelot Boulevard, Bath, WY 28356:5/13/69:24500 Jesse Neal:408-233-8971:45 Rose Terrace, San Francisco, CA 92303:2/3/36:25000 Zippy Pinhead:834-823-8319:2356 Bizarro Ave., Farmount, IL 84357:1/1/67:89500 Arthur Putie:923-835-8745:23 Wimp Lane, Kensington, DL 38758:8/31/69:126000 Popeye Sailor:156-454-3322:945 Bluto Street, Anywhere, USA 29358:3/19/35:22350 Jose Santiago:385-898-8357:38 Fife Way, Abilene, TX 39673:1/5/58:95600 Tommy Savage:408-724-0140:1222 Oxbow Court, Sunnyvale, CA 94087:5/19/66:34200 Yukio Takeshida:387-827-1095:13 Uno Lane, Ashville, NC 23556:7/1/29:57000 Vinh Tranh:438-910-7449:8235 Maple Street, Wilmington, VM 29085:9/23/63:68900 把 Jon 的名字改为 Jonathan\nsed -e 's/^Jon /Jonathan /' datebook 删除前 3 行\nsed -e '1,3d' datebook 打印第 5~10 行\nsed -n -e '5,10p' datebook 删除含有 Lane 的所有行\nsed -e '/Lane/d' datebook 删除不含有 Lane 的所有行\nsed -e '/Lane/!d' datebook 打印所有生日在十一月或十二月的行\nsed -n -e '/:1[12]\\//p' datebook 在以 James 开头的各行末尾加上 3 颗星号\nsed -e '/^James/s/$/***\u0026amp;/' datebook 将所有包含 Jose 的行都替换为 JOSE HAS RETIRED\nsed -e '/Jose/c\\JOSE HAS RETIRED' datebook 把 Popeye 的生日改为 11/14/46 ，假定您不知道 Popeye 的生日，设法用正则表达式查找出来\nsed -n -e '/^Popeye /s/:[0-9]*\\/[0-9]*\\/[0-9]*/:11\\/14\\/46:/p' datebook 删除所有空行\nsed -e '/^$/d' datebook 写一个能完成下列任务的 sed 脚本\na) 在第一行上方插入标题 PERSONNEL FILE\nb) 删除以 500 结尾的工资项\nc) 把名和姓的位置颠倒后，打印文件内容\nd) 在文件末尾加上 THE END\n1i\\PERSONNEL FILE /500$/d s/\\([a-zA-Z]*\\) \\([a-zA-Z]*\\)/\\2 \\1/ $a\\THE END ","date":"2012 November 4","permalink":"/posts/2012/11/04/","section":"Posts","summary":"数据文件 datefile","title":"《Unix Shell 范例精解》第五章 sed 习题"},{"content":"数据文件：\nSteve Blenheim:238-923-7366:95 Latham Lane, Easton, PA 83755:11/12/56:20300 Betty Boop:245-836-8357:635 Cutesy Lane, Hollywood, CA 91464:6/23/23:14500 Igor Chevsky:385-375-8395:3567 Populus Place, Caldwell, NJ 23875:6/18/68:23400 Norma Corder:397-857-2735:74 Pine Street, Dearborn, MI 23874:3/28/45:245700 Jennifer Cowan:548-834-2348:583 Laurel Ave., Kingsville, TX 83745:10/1/35:58900 Jon DeLoach:408-253-3122:123 Park St., San Jose, CA 04086:7/25/53:85100 Karen Evich:284-758-2857:23 Edgecliff Place, Lincoln, NB 92743:7/25/53:85100 Karen Evich:284-758-2867:23 Edgecliff Place, Lincoln, NB 92743:11/3/35:58200 Karen Evich:284-758-2867:23 Edgecliff Place, Lincoln, NB 92743:11/3/35:58200 Fred Fardbarkle:674-843-1385:20 Parak Lane, Duluth, MN 23850:4/12/23:780900 Fred Fardbarkle:674-843-1385:20 Parak Lane, Duluth, MN 23850:4/12/23:780900 Lori Gortz:327-832-5728:3465 Mirlo Street, Peabody, MA 34756:10/2/65:35200 Paco Gutierrez:835-365-1284:454 Easy Street, Decatur, IL 75732:2/28/53:123500 Ephram Hardy:293-259-5395:235 CarltonLane, Joliet, IL 73858:8/12/20:56700 James Ikeda:834-938-8376:23445 Aster Ave., Allentown, NJ 83745:12/1/38:45000 Barbara Kertz:385-573-8326:832 Ponce Drive, Gary, IN 83756:12/1/46:268500 Lesley Kirstin:408-456-1234:4 Harvard Square, Boston, MA 02133:4/22/62:52600 William Kopf:846-836-2837:6937 Ware Road, Milton, PA 93756:9/21/46:43500 Sir Lancelot:837-835-8257:474 Camelot Boulevard, Bath, WY 28356:5/13/69:24500 Jesse Neal:408-233-8971:45 Rose Terrace, San Francisco, CA 92303:2/3/36:25000 Zippy Pinhead:834-823-8319:2356 Bizarro Ave., Farmount, IL 84357:1/1/67:89500 Arthur Putie:923-835-8745:23 Wimp Lane, Kensington, DL 38758:8/31/69:126000 Popeye Sailor:156-454-3322:945 Bluto Street, Anywhere, USA 29358:3/19/35:22350 Jose Santiago:385-898-8357:38 Fife Way, Abilene, TX 39673:1/5/58:95600 Tommy Savage:408-724-0140:1222 Oxbow Court, Sunnyvale, CA 94087:5/19/66:34200 Yukio Takeshida:387-827-1095:13 Uno Lane, Ashville, NC 23556:7/1/29:57000 Vinh Tranh:438-910-7449:8235 Maple Street, Wilmington, VM 29085:9/23/63:68900 打印所有包含字符串 San 的行\ngrep 'San' databook 打印所有以 J 开头的行\ngrep '^J' databook 打印所有以 700 结尾的行\ngrep '700$' databook 打印所有不包含 834 的行\ngrep -v '834' databook 打印所有生日在 December 的行\ngrep ':12/' databook 打印所有电话号码区号为 408 的行\ngrep ':408-' databook 打印所有包含一个大写字母，后跟四个小写字母，一个逗号，一个空格和一个大写字母的行\ngrep '[[:upper:]][[:lower:]]\\{4\\}, [[:upper:]]' databook 打印所有最后一个名字以 K 或 k 开始的行\ngrep '^[A-Za-z]* [Kk]' databook 打印所有薪水为 6 位数的行，前导是一个行号\ngrep -n ':[0-9]\\{6\\}$' databook 打印包含 Lincoln 或 lincoln （注意，grep 不区分大小写）的行\ngrep '[Ll]incoln' databook ","date":"2012 November 3","permalink":"/posts/2012/11/03/","section":"Posts","summary":"数据文件：","title":"《Unix Shell 范例精解》第四章 grep 习题"},{"content":"一些选项 # -e script ：添加一套命令，可通过该选项添加多个处理命令 -n ：只打印通过 p 命令匹配到的行 -i ：将修改结果写入文件 -f scriptfile ：使用脚本文件 常用命令 # ! ：对所选行以为的行进行操作 p ：打印 d ：删除 s ：替换 g ：行内全局替换 w ：将行写入文件 c\\ ：用命令后面的文本替换当前的行 a\\ ：在当前行后添加文本 GNU对正则表达式的扩展 # \\n : 产生或匹配一个换行符（ASCII 10） \\r : 产生或匹配一个回车符（ASCII 13） \\t : 产生或匹配一个制表符（ASCII 9） \\v : 产生或匹配一个垂直制表符（ASCII 11） 指定地址范围 #打印第一行到第十行：\nsed -n -e '1,10p' filename 打印最后一行：\nsed -n -e '$p' filename 用正则表达式匹配行，\t打印从以 root 开头的行到以 mail 开头的行：\nsed -n -e '/^root/,/^mail/p' filename 大小写转换 #\\U \\u ：转换为大写\n\\L \\l ：转换为小写\nsed -e 's/[a-z]/\\U\u0026amp;/g' filename sed -e 's/[A-Z]/\\L\u0026amp;/g' filename \u0026amp; 表示前面的模式所匹配到的字符\n文本转换 #DOS/Windows格式的文本的每一行末尾是一个回车（CR）和一个换行符（LF），而Unix风格的文本只有一个换行符。\nUnix转DOS，$ 匹配到每行的末尾，\\r 表示回车符，这样就会在每行的末尾前添加一个回车符：\nsed -e 's/$/\\r/' filename \u0026gt; filename.txt DOS转Unix，将行尾前的一个字符（回车）替换为空即可：\nsed -e 's/.$//' filename.txt \u0026gt; filename ","date":"2012 November 2","permalink":"/posts/2012/11/02/","section":"Posts","summary":"一些选项 # -e script ：添加一套命令，可通过该选项添加多个处理命令 -n ：只打印通过 p 命令匹配到的行 -i ：将修改结果写入文件 -f scriptfile ：使用脚本文件 常用命令 # !","title":"sed 学习笔记"},{"content":"测试文件 file 的内容如下：\nMike Harrington:(510) 548-1278:250💯175 Christian Dobbins:(408) 538-2358:155:90:201 Susan Dalsass:(206) 654-6279:250:60:50 Archie McNichol:(206) 548-1348:250💯175 Jody Savage:(206) 548-1278:15:188:150 Guy Quigley:(916) 343-6410:250💯175 Dan Savage:(406) 298-7744:450:300:275 Nancy McNeil:(206) 548-1278:250:80:75 John Goldenrod:(916) 348-4278:250💯175 Chet Main:(510) 548-5258:50:95:135 Tom Savage:(408) 926-3456:250:168:200 Elizabeth Stachelin:(916) 440-1763:175:75:300 该文件依次显示的是姓名，电话号码，过去三个月的捐款额。\n显示所有的电话号码\nawk -F \u0026quot;:\u0026quot; '{print $2}' file 显示 Dan 的电话号码\nawk -F \u0026quot;:\u0026quot; '$1 ~ /^Dan / {print $2}' file 显示所有以 D 开头的姓\nawk -F \u0026quot;[ :]\u0026quot; '$2 ~ /^D/ {print $2}' file 显示所有以 C 或 E 开头的名\nawk -F \u0026quot;[ :]\u0026quot; '$1 ~ /^[CE]/ {print $1}' file 显示只有四个字符的名\nawk -F \u0026quot;[ :]\u0026quot; '{if(length($1) == 4) print $1}' file 显示所有区号为 916 的人名\nawk -F \u0026quot;:\u0026quot; '$2 ~ /(916)/ {print $1}' file 显示 Mike 的捐款，每笔捐款以 $ 开头\nawk -F \u0026quot;:\u0026quot; '$1 ~ /^Mike / {printf(\u0026quot;$%s,$%s,$%s\\n\u0026quot;,$3,$4,$5)}' file 将所有信息输出为如下格式：\n*** CAMPAIGN 1998 CONTRIBUTIONS *** ---------------------------------------------------------------------------- NAME PHONE Jan | Feb | Mar | Total Donated ---------------------------------------------------------------------------- Mike Harrington (510) 548-1278 250.00 100.00 175.00 525.00 Christian Dobbins (408) 538-2358 155.00 90.00 201.00 446.00 Susan Dalsass (206) 654-6279 250.00 60.00 50.00 360.00 Archie McNichol (206) 548-1348 250.00 100.00 175.00 525.00 Jody Savage (206) 548-1278 15.00 188.00 150.00 353.00 Guy Quigley (916) 343-6410 250.00 100.00 175.00 525.00 Dan Savage (406) 298-7744 450.00 300.00 275.00 1025.00 Nancy McNeil (206) 548-1278 250.00 80.00 75.00 405.00 John Goldenrod (916) 348-4278 250.00 100.00 175.00 525.00 Chet Main (510) 548-5258 50.00 95.00 135.00 280.00 Tom Savage (408) 926-3456 250.00 168.00 200.00 618.00 Elizabeth Stachelin (916) 440-1763 175.00 75.00 300.00 550.00 --------------------------------------------------------------------------- SUMMARY --------------------------------------------------------------------------- The campaign received a total of $6137.00 for this quarter The average donation for the 12 contributors was $511.42 The highest contribution was $450.00 The lowest contributino was $15.00 脚本文件 script 如下：\nBEGIN { FS=\u0026quot;:\u0026quot; sum=0 max=0 min=0 printf(\u0026quot; *** CAMPAIGN 1998 CONTRIBUTIONS ***\\n\u0026quot;) printf(\u0026quot;----------------------------------------------------------------------------\\n\u0026quot;) printf(\u0026quot;%19s%17s%10s%10s%10s%19s\\n\u0026quot;,\u0026quot;NAME\u0026quot;,\u0026quot;PHONE\u0026quot;,\u0026quot;Jan\u0026quot;,\u0026quot;| Feb\u0026quot;,\u0026quot;| Mar\u0026quot;,\u0026quot;| Total Donated\u0026quot;) printf(\u0026quot;----------------------------------------------------------------------------\\n\u0026quot;) } { printf(\u0026quot;%19s%17s%10.2f%10.2f%10.2f\u0026quot;,$1,$2,$3,$4,$5) total=$3+$4+$5 printf(\u0026quot;%12.2f\\n\u0026quot;,total) sum+=total\tif(NR==1) { min=$3 max=$3 } for(i=3;i\u0026lt;6;i++) { if(min\u0026gt;$i) min=$i if(max\u0026lt;$i) max=$i } } END { ave=sum/NR printf(\u0026quot;---------------------------------------------------------------------------\\n\u0026quot;) printf(\u0026quot; SUMMARY\\n\u0026quot;) printf(\u0026quot;---------------------------------------------------------------------------\\n\u0026quot;) printf(\u0026quot;The campaign received a total of $%.2f for this quarter\\n\u0026quot;,sum); printf(\u0026quot;The average donation for the 12 contributors was $%.2f\\n\u0026quot;,ave); printf(\u0026quot;The highest contribution was $%.2f\\n\u0026quot;,max) printf(\u0026quot;The lowest contributino was $%.2f\\n\u0026quot;,min) } 执行：\nawk -f script file ","date":"2012 October 28","permalink":"/posts/2012/10/28/","section":"Posts","summary":"测试文件 file 的内容如下：","title":"awk 实例练习"},{"content":"原文： Wireless Operating Modes\nTranslated by Bob\n2012-10-27\nEmail：gexbob@gmail.com\nBlog：http://shaocheng.li\n一个 WNIC （Wireless Network Interface Controller，无线网络接口控制器）总是运行在如下几种模式之一。这些模式设定了无线连接的主要功能。有时也可能同时运行在两种模式。\nStation (STA) 基本模式 #任何无线驱动都能运行在这种模式。因此它被称作默认模式。两个 STA 模式的 WNIC 无法相互连接。它们需要第三个 AP 模式的 WNIC 来管理无线网络！STA 模式的 WNIC 通过发送管理数据帧来连接 AP 模式的 WNIC 。这个过程叫做认证（authentication）和关联（association）。当 AP 发送关联成功的回复后，这个 STA 就成为了无线网络的一部分。\nAccessPoint (AP) 基本模式 #在一个已经被管理的无线网络中，Access Point 是作为主设备存在的。它通过管理和维护 STA 列表来聚合网络。它还管理安全策略。这个网络就以 AP 的 MAC 地址命名。同时还会为 AP 设置一个可读的名字 SSID 。\nLinux 下使用 AP 模式需要用到 hostapd ，当前至少是 0.6 版本，最好通过 git 获得。http://wireless.erley.org\nMonitor (MON) 模式 #Monitor 模式是一个被动模式，不会传输数据帧。所有的输入包都交给主机处理，不会进行任何过滤。这个模式被用来监视网络。\n对于 mac80211 ，除了常规设备，它可能还有一个处于 Monitor 模式的网络设备，用于检测和使用网络。可是，不是所有的硬件都支持这个功能，因为不是所有的硬件都能配置为在其他模式下显示所有的数据包。Monitor 模式接口总是工作在“尽可能(best effort)”的基础上。\n对于 mac80211 ，也可以在 Monitor 模式下发送数据包，这叫做数据包注入。用于想在用户空间实施 MLME 工作的应用程序，例如支持 IEEE 802.11 的非标准 MAC 扩展。\nAd-Hoc (IBSS) 模式 #Ad-Hoc 模式也叫 IBBS (Independent Basic Service Set) 模式，用于创建无需 AP 的无线网络。IBSS 网络中的每个节点都管理自己的网络。 Ad-Hoc 用于在没有可用 AP 的情况下使两台或更多的电脑相互连接。\nWireless Distribution System (WDS) 模式 #分发系统 (Distribution System) 是通过有线连接到 AP 。无线分发系统 (Wireless Distribution System) 是通过无线的方式完成相同的工作。WDS 作为多个关联 AP 之间的共同途径，可被用于替代综合布线。阅读 iw WDS 文档可以详细了解怎样使能这个模式，也要重新理解使用 4-address mode 。\nMesh #Mesh 接口被用于允许多个设备之间通过动态的建立智能路由来相互沟通。\n查看 Wikipedia\u0026rsquo;s entry on 802.11s 和 Wireless mesh network(WMN)。\n为了实现 mesh 的 portal 功能，可以为常规网口桥接一个 mesh 接口。\n","date":"2012 October 27","permalink":"/posts/2012/10/27/","section":"Posts","summary":"原文： Wireless Operating Modes","title":"Linux Wireless —— 无线操作模式"},{"content":"现在的 linux 内核支持三种电源管理模式,可以在 /sys/power/state 文件中查看：\ncat /sys/power/state standby mem disk 向该文件写入模式的名称即可实现待机，休眠等，例如：\necho standby \u0026gt; /sys/power/state 下面对各模式详细说明。\n1. standby #ACPI state: S1\n该模式会关闭显示器和键盘等输入设备， CPU 依然在工作，所有的操作状态都不会丢失。\n在该模式下按一下计算机的开关键，系统会在1~2秒内恢复到之前的状态。\n2. mem #ACPI state: S3\n该模式相当于 Windows 下的待机。计算机将进入一个低供电状态，只有内存保持供电，并处于自刷新模式，以便保存内容。\n此时，系统和设备的状态都存储在内存中。所有设备电源都进入 D3 状态，即全部断电。多数情况下，外围设备总线也全部断电。\n在该模式下按一下计算机的开关键，系统会在3~5秒内恢复到之前的状态。\n3. disk #ACPI state: S4\n该模式类似 mem 模式，但是最后多了一个步骤：将内存的内容写入硬盘（通常是写入 swap 分区）。在恢复时，再将其读出，并重新写入暂停前的工作状态。这样做的好处是，即使在该模式下计算机断电，也不会丢失数据，依然可以恢复到以前的工作状态。\n从该模式恢复需要大约30秒。\n在 disk 模式中，将内存内容写入硬盘的 swap 分区使用的是 swsusp 机制。关于该机制的详情在内核源码的 Documentation/power/swsusp.txt 文件中。\n","date":"2012 October 23","permalink":"/posts/2012/10/23/","section":"Posts","summary":"现在的 linux 内核支持三种电源管理模式,可以在 /sys/power/state 文件中查看：","title":"Linux 系统的电源管理"},{"content":"简介 #官方 : http://www.sublimetext.com/\n参考了非官方文档 : http://docs.sublimetext.info/en/latest/index.html\n视频简介 : http://v.youku.com/v_show/id_XMzU5NzQ5ODgw.html\n1.基本编辑 #1.1.操作文件 # Ctrl+n :新建文件。 Ctrl+s :保存文件。 Ctrl+w :关闭当前文件，没有文件时会关闭窗口。 Ctrl+tab :在多个打开的文件之间切换 在 View-\u0026gt;Syntax 中可以选择当前文件的语法。 1.2.选择文本 # Ctrl+l :选择当前行 Shift+鼠标右键 :按列选择文本。 反复按下 Ctrl+d 可以将全文中与光标所在处相同的单词逐一加入选择，直接按 Alt+F3 可以一次选择全部相同的单词。 1.3.跳转 # 用 Ctrl+P 可以快速跳转到当前项目中的任意文件，可进行关键词匹配。 用 Ctrl+P 后 @ (或是Ctrl+R)可以快速列出/跳转到某个函数（很爽的是在 markdown 当中是匹配到标题，而且还是带缩进的！）。 用 Ctrl+P 后 # 可以在当前文件中进行搜索。 用 Ctrl+P 后 : (或是Ctrl+G)加上数字可以跳转到相应的行。 而更酷的是你可以用 Ctrl+P 加上一些关键词跳转到某个文件同时加上 @ 来列出/跳转到目标文件中的某个函数，或是同时加上 # 来在目标文件中进行搜索，或是同时加上 : 和数字来跳转到目标文件中相应的行。 1.4.注释 # Ctrl+/ :快速注释一行，会根据当前文件的语法选择注释字符。 Ctrl+Shift+/ :注释一块代码。 2.常用设置 #Sublime Text 的各项特性都是用配置文件来设置的。例如用 Preferences-\u0026gt;Settings-User 可打开针对当前用户的配置文件，文件中每行设置一个特性，以逗号结尾，最后一个行末尾不可以写逗号，例如:\n{ \u0026quot;font_face\u0026quot;: \u0026quot;DejaVu Sans Mono\u0026quot;, \u0026quot;font_size\u0026quot;: 12 } 2.1.设置字体 #点击菜单上的 Preferences-\u0026gt;Settings-User ，在打开的用户配置文件中输入:\n\u0026quot;font_face\u0026quot;: \u0026quot;DejaVu Sans Mono\u0026quot;, \u0026quot;font_size\u0026quot;: 12, 也可以选择 Preferences-\u0026gt;Settings-Default，在默认配置文件中的相同字段中设置默认字体。\n2.2.设置缩进 #在 Preferences-\u0026gt;Settings-Default 中可以看到默认缩进为4个空格的宽度，并且 Tab 不会转换为空格，相应的字段为:\n\u0026quot;tab_size\u0026quot;: 4, \u0026quot;translate_tabs_to_spaces\u0026quot;: false, 还可以针对相应的语法设置特定的缩进格式。先在 View-\u0026gt;Syntax 中选择语法，然后点击 Preferences-\u0026gt;Settings-More-\u0026gt;Syntax Specific-User,在打开的文件中设置。\n2.3.设置文件的保存格式 #我们希望根据当前的语法将文件保存为相应的格式，例如Markdown文件保存为后缀为 .md 的文件。设置方法如下:\n新建一个文件，设置 View-\u0026gt;Syntax 为 Markdown 。\n选择 preferences-\u0026gt;Setting-more-\u0026gt;Syntax Specific-User ，在打开的 Markdown.sublime-settings 文件中输入:\n{ \u0026quot;extensions\u0026quot;: [ \u0026quot;md\u0026quot; ] } 然后保存。\n保存之前新建的文件，后缀就会是 .md 。\n2.4.设置为Vim模式 #点击 Preferences-\u0026gt;Setting-user ，在打开的配置文件中添加：\n\u0026quot;ignored_packages\u0026quot;: [], 然后保存。\n在 Vim 的 insert 模式下也可以用正常 Sublime Text 的方式编辑文件。\n3.安装插件 #只需将下载的插件解压到 Packages 目录即可，打开 Packages 目录的方法是点击 Preferences-\u0026gt;Browse Packages\u0026hellip; 。\n也可以通过 Sublime Package Control 插件来搜索、下载、安装源中的插件，方法如下：\n用 Ctrl+· 打开 console ，输入如下命令:\nimport urllib2,os; pf='Package Control.sublime-package'; ipp=sublime.installed_packages_path(); os.makedirs(ipp) if not os.path.exists(ipp) else None; urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler())); open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read()); print 'Please restart Sublime Text to finish installation' 该命令会创建一个 Installed Packages Text 文件夹，然后下载 Package Control.sublime-package 到他下面。\n然后重启 Sublime Text 。在菜单 Preferences 下可以看到多出了 Package Control 条目。\n按下 Ctrl+Shift+p ，打开命令面板。输入 install 调出 Package Control: Install Package 后按回车，在列表中选择需要安装的插件，就会自动安装，重启后生效。\n3.1.一些有用的插件 # GBK Encoding Support : Sublime Text 目前只支持 UTF-8 编码的文件，该插件可以使 Sublime Text 支持 GBK 编码文件。启用后载入文件的速度变慢，还有一个Bug就是标签上的文件名乱码，根据某网友的方法对该插件的 sublime_gbk.py 文件的进行修改后解决，修改后的代码如下，用 # 注释的是源代码，用 #new line 标记的是新加的代码。\nexcept: gbk = file(view.file_name()).read() text = gbk.decode('gbk') file_name = view.file_name().encode('utf-8') #tmp_file_name = urllib.quote_plus(os.path.basename(file_name)) + SEPERATOR + urllib.quote_\tplus(file_name) #tmp_file = os.path.join(TEMP_PATH, tmp_file_name) #f = file(tmp_file, 'w') f = file(view.file_name(),'w') #new line f.write(text.encode('utf8')) f.close() window = sublime.active_window() #v = window.find_open_file(tmp_file) v = window.find_open_file(file_name) #new line if(not v): #window.open_file(tmp_file) window.open_file(file_name) #new ConvertToUTF8 : 功能与 GBK Encoding Support 类似，且没有 Bug 。\nMarkdown Build : 用于将 Markdown 文件转换为 Html ，并用浏览器打开。快捷键是 Ctlr+b 。\nTag : 格式化 Html 和 CSS 语句，选中一段语句，安装组合键 ctrl+alt+f 即可。\nJSFormat : 格式化 Javascript 文件\n安装后重启 sublime text 就能使用js格式化插件\n使用方法：\n1.快捷键：ctrl+alt+f\n2.先用快捷键打开命令面板 “ctrl + shift + p”, 再输入 “Format: Javascript” 就可以使用格式化命令\nSublimeCodeIntel : 代码补全提示，支持多种语言。\nSoda : 一个主题，比默认的漂亮一些。安装后，打开配置文件Preferences -\u0026gt; Settings - User，加上一行\u0026quot;theme\u0026quot;: \u0026ldquo;Soda Light.sublime-theme\u0026quot;或者 \u0026ldquo;theme\u0026rdquo;: \u0026ldquo;Soda Dark.sublime-theme\u0026rdquo;。前面一个是亮色主题，后面一个是暗色主题。\n3.2.用 Sublime Text 编辑 Markdown 文件 # 配置 Markdown 语法高亮\n下载 Made of code 配色文件，放在 Preferences-\u0026gt;Browse Package\u0026hellip; 所打开的目录下即可。\n在 Preferences-\u0026gt;Color Scheme 中选择 Made of code ，在 View-\u0026gt;Syntax 中选择 Markdown 。\n安装 Markdown Build 插件。\n在 Tool 菜单里点击 Build，快捷键是 Ctrl+b ，会调用 Markdown Build 生成 Html 文件并用默认的浏览器打开。\n4.一些问题 #最近发现打开文件时，会多出一个带 dump 后缀的文件。最后发现是 GBK Encoding Support 插件的问题，卸载后解决，然后换上了 ConvertToUTF8 。\n","date":"2012 September 16","permalink":"/posts/2012/09/16/","section":"Posts","summary":"简介 #官方 : http://www.","title":"Sublime Text"},{"content":"1.代码和语法高亮 #除了 Markdown 语法的缩进方式，在 Octopress 中还多种方式可以在文章中嵌入代码并显示语法高亮：\n反引号代码块 语法\n``` [language] [title] [url] [link text] code snippet ``` 嵌入 Gist Gist 是 Github 提供的一个代码管理功能。在 Gist 中新建的代码文件会获得一个 gist_id ，用下面的语法就可以在文章中嵌入相应的代码：\n{ % gist gist_id [filename] % } filename 是可选的，如果一个 gist_id 下有多个文件，可以依次嵌入。\ninclude_code include_code 用于在文章中导入代码文件。可以在 _config.yml 的 code_dir 设置文件路径，默认是 source/downloads/code 。\n语法：\n{ % include_code [title] [lang:language] path/to/file % } 例如，导入 source/downloads/code/test.js ：\n{ % include_code test.js % } 2.插入图片 #github 提供的空间有限，图片最好使用外链。\nOctopress 提供的插入图片的语法如下：\n{ % img [class names] /path/to/image [width] [height] [title text [alt text]] % } 如果只输入图片的路径 (/path/to/image) ，图片会以左对齐的方式显示，其他可选参数可以控制图片的宽高和显示位置 (class names) 。\n3.添加导航 #以添加一个 About 页面为例：\n执行： rake new_page[blog/about] 在 source/blog/ 目录先生成 about 目录和 about/index.markdown 文件，默认的布局方式是 layout: page 。\n在 source/_includes/custom/navigation.html 文件中添加一行：\n\u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ root_url }}/blog/about\u0026#34;\u0026gt;About\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; 4.布局 #所有的页面布局文件都位于 source/_layouts 目录下，例如 post.html 是发布文章时默认的布局。\n可以从已有的布局文件复制，然后修改，例如从 page.html 复制一份 about.html ，并修改，然后就可以在上面新建的 about/index.markdown 中设置 layout: about 。\n5.侧边栏 #Octopress 提供的侧边栏都位于 source/_includes/asides 目录下，例如：显示最近发表的 recent_posts.html ，显示 github 版本库的 github.html。我们新增的侧边栏最好放在 source/_includes/custom/asides 下。\n假设我们新建了一个显示发布许可证的侧边栏:license.html，要将其显示在所有的页面需要修改 _config.yml 文件：\ndefault_asides: [custom/asides/license.html] default_asides 中添加的侧边栏会显示在所有布局的页面中，如果想要根据页面的布局显示不同的侧边栏，Octopress 提供了三个默认布局的设置变量：\nblog_index_asides # blog 主页上显示的侧边栏 post_asides # post 布局页面显示的侧边栏 page_asides # page 布局页面显示的侧边栏 只要在相应的变量中添加侧边栏即可。\n如果要新建了其他布局，如 about.html，只需在 _config.yml 文件中添加 about_asides 。\n6.评论 #Octproess 已经包含了支持 Disqus 的插件，只需做简单的设置即可使用：\n首先确保你已经注册了一个 Disqus 的账户，并将你的 Blog 的 URL 添加到 Disqus 。\n然后在 _config.yml 中设置 Disqus 账户的 short name , 并将其使能：\n# Disqus Comments disqus_short_name: exbob disqus_show_comment_count: true 最后在每个 post 的头部设置允许评论：\ncomments: true 7.分享 #添加分享按钮的方式有很多，这里用的是 百度分享：\n首先在百度分享中选择分享按钮的样式，并生成代码，例如： \u0026lt;!-- Baidu Button BEGIN --\u0026gt; \u0026lt;div id=\u0026#34;bdshare\u0026#34; class=\u0026#34;bdshare_t bds_tools get-codes-bdshare\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;bds_qzone\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;a class=\u0026#34;bds_tsina\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;a class=\u0026#34;bds_tqq\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;a class=\u0026#34;bds_renren\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;span class=\u0026#34;bds_more\u0026#34;\u0026gt;更多\u0026lt;/span\u0026gt; \u0026lt;a class=\u0026#34;shareCount\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; id=\u0026#34;bdshare_js\u0026#34; data=\u0026#34;type=tools\u0026amp;amp;uid=949520\u0026#34; \u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; id=\u0026#34;bdshell_js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; document.getElementById(\u0026#34;bdshell_js\u0026#34;).src = \u0026#34;http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=\u0026#34; + new Date().getHours(); \u0026lt;/script\u0026gt; \u0026lt;!-- Baidu Button END --\u0026gt; 将上面的代码添加到 source/_includes/post/sharing.html 文件的中： \u0026lt;div class=\u0026#34;sharing\u0026#34;\u0026gt; { % if site.baidushare % } \u0026lt;!-- Baidu Button BEGIN --\u0026gt; \u0026lt;div id=\u0026#34;bdshare\u0026#34; class=\u0026#34;bdshare_t bds_tools get-codes-bdshare\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;bds_qzone\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;a class=\u0026#34;bds_tsina\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;a class=\u0026#34;bds_tqq\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;a class=\u0026#34;bds_renren\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;span class=\u0026#34;bds_more\u0026#34;\u0026gt;更多\u0026lt;/span\u0026gt; \u0026lt;a class=\u0026#34;shareCount\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; id=\u0026#34;bdshare_js\u0026#34; data=\u0026#34;type=tools\u0026amp;amp;uid=949520\u0026#34; \u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; id=\u0026#34;bdshell_js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; document.getElementById(\u0026#34;bdshell_js\u0026#34;).src = \u0026#34;http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=\u0026#34; + new Date().getHours(); \u0026lt;/script\u0026gt; \u0026lt;!-- Baidu Button END --\u0026gt; { % endif % } \u0026lt;/div\u0026gt; 最后，在 _config.yml 文件中添加 baidushare : # baidu share baidushare: true ","date":"2012 September 15","permalink":"/posts/2012/09/15/","section":"Posts","summary":"1.代码和语法高亮 #除了 Markdown 语法的缩进方式，在 Octopress 中还多种方式可以在文章中嵌入代码并显示语法高亮：","title":"Octopress 使用笔记"},{"content":"1.准备 # 安装 git\nsudo yum install git 配置：\ngit config --global user.name \u0026quot;your name\u0026quot; git config --global user.email \u0026quot;your email\u0026quot; 用 RVM 安装 Ruby 1.9.3：\ncurl -L https://get.rvm.io | bash -s stable --ruby 根据提示执行：\nsource ~/.rvm/scripts/rvm 再安装 ruby 1.9.3：\nrvm install 1.9.3 rvm use 1.9.3 rvm rubygems latest 安装结束后运行 ruby \u0026ndash;version 查看 ruby 版本。\n安装 Octopress\ngit clone git://github.com/imathis/octopress.git octopress cd octopress # 首次进入该目录时会询问是否信任 .rvmrc 文件，选择 yes ruby --version # 应该是 Ruby 1.9.3 再安装一些依赖文件：\ngem install bundler bundle install 安装默认的主题：\nrake install 2.部署到 Github Pages #先在 github 上新建一个名为 username.github.com (username 替换为你的用户名) 的版本库。然后执行：\nrake setup_github_pages 这里会询问你的 Github Pages 版本库的 URL ，应该输入 git@github.com:username/username.github.com.git 。这条命令还会做以下几件事：\n将 Github Pages 版本库作为默认的 origin remote 将活动分支从 master 切换到 source 根据版本库设置博客的 URL 在 _deploy 目录下设置一个 master 分支用于部署博客。 然后执行：\nrake generate rake deploy 会在 _deploy 目录下生成博客，并把该目录下的文件发布到 github 版本库的 master 分支。十分钟以后就可以通过 username.github.com 访问你的博客了。\nOctopress 的源文件也应该提交到 github 保存：\ngit add . git commit git push origin source 3.配置 #Octopress 的配置文件有四个：\n_config.yml #主配置文件（jekyll的设置） Rakefile #关于部署的配置 config.rb config.ru 通常只需要修改 _config.yml 和 Rakefile 。\n_config.yml 文件中的配置分为三个部分：\nMain Configs 主要的设置有：\nurl: # 用于 RSS 的 URL title: # 博客的标题，会显示在博客和浏览器标签上。 subtitle: # 博客的副标题 author: # 名字, 用于 RSS, Copyright, Metadata simple_search: # 搜素栏所用的网址 description: # 默认的关于本站点的描述 date_format: # Format dates using Ruby's date strftime syntax subscribe_rss: # 用于 rss 订阅的 URL, 默认用 /atom.xml subscribe_email: # Url to subscribe by email (service required) category_feeds: # Enable per category RSS feeds (defaults to false in 2.1) email: # Email address for the RSS feed if you want it. Jekyll \u0026amp; Plugin\n用于 Jekyll 及其插件的设置，主要有：\nroot: # 相对根目录，默认是 / ，如果博客要发布在一个子目录下（例如 site.com/project），要设为 /project permalink: # 博客文章的存放结构 source: # 源文件的目录 destination: # 生成的文件存放的目录 plugins: # Jekyll 插件的目录 code_dir: # 代码片段文件的存放目录 (用于 include_code 插件) category_dir: # Directory for generated blog category pages pygments: # Toggle python pygments syntax highlighting paginate: # Posts per page on the blog index pagination_dir: # Directory base for pagination URLs eg. /blog/page/2/ recent_posts: # Number of recent posts to appear in the sidebar default_asides: # Configure what shows up in the sidebar and in what order blog_index_asides: # Optional sidebar config for blog index page post_asides: # Optional sidebar config for post layout page_asides: # Optional sidebar config for page layout 3rd Party Setting\n这些第三方工具已经安装，只要简单的设置就可以使用。\n4.写博客 #发表文章\n所有要发表的博文都存放在 source/_posts 目录下，并遵循 Jekyll 的命名方式：YYYY-MM-DD-post-title.markdown 。可以将写好的文章按照这种方式命名，并在文件中添加下面讲到的头部，然后复制到该目录习下。也可以用 Octopress 提供的命令生成，语法如下：\nrake new_post[\u0026quot;tiltle\u0026quot;] 这样生成的文件默认是 markdown 格式，可以在 Rakefile 中修改默认的格式。\n打开文件会发现有一个头部，类似：\n--- layout: post title: \u0026quot;tiltle\u0026quot; date: 2012-09-03 15:59 comments: true external-url: categories: --- layout: post 表示使用 source/_layouts/post.html 布局方式。 comment: true 表示允许评论，也可设为 off 关闭评论。如果有其他作者，可以添加 author: your name ，默认会使用 _config.yml 中的设置。如果要保存为草稿，添加 published: false ，这样在生成博客时就不会被发表。categories 用于设置标签，如果只有一个标签，可以用如下格式：\ncategories: Sass 如果有多个标签：\n# Multiple categories example 1 categories: [CSS3, Sass, Media Queries] # Multiple categories example 2 categories: - CSS3 - Sass - Media Queries 默认情况下，post 的全部内容将显示在 index 页面。可以在文章中插入 \u0026lt;!\u0026ndash; more \u0026ndash;\u0026gt; ，index 页面只会显示该标记之前的内容，点击 “Continue-\u0026gt;” 按钮后会完全显示。\n添加页面\n可以在 source 目录下添加页面，添加的文件的路径与最终生成的博客的 URL 是直接对应的，例如 about.markdown 就对应 site.com/about.html 。如果想要 site.com/about ，就要在 source 下添加 about/index.markdown 。可以用 rake 命令添加页面：\nrake new_page[super-awesome] # 生成 source/super-awesome/index.markdown rake new_page[super-awesome/page.html] # 生成 source/super-awesome/page.html 默认添加的文件的格式是 markdown ，也可以在 Rakefile 中修改。文件的内容与 post 类似：\n--- layout: page title: \u0026quot;Super Awesome\u0026quot; date: 2011-07-03 5:59 comments: true sharing: true footer: true --- 生成和预览\n执行：\nrake generate 在 _site 目录下生成博客的静态页面。\n然后执行：\nrake preview # Watches, and mounts a webserver at 在浏览器中访问 http://localhost:4000 即可预览博客。\n最后用 rake deploy 发布。\n","date":"2012 September 9","permalink":"/posts/2012/09/09/","section":"Posts","summary":"1.准备 # 安装 git","title":"用 Octopress 在 github 上部署博客"},{"content":"Qt Embedded 直接依赖 Framebuffer，无需 X-Window。所以要开启 Linux 系统的 Framebuffer 。开启方法是通过 BootLoader 向内核传递参数：\n对于 grub，在 grub.conf 文件的kernel 命令后面添加 vga=0x311 fb:on 。 对于 lilo，在 lilo.conf 文件中添加 vga=0x311。0x311 表示分辨率为 640*480，16dpp。 编译安装 #首先下载 Qt/E-4.4.0 的源码，然后解压在 root 目录：\ncd /root tar -xvjf qt-embedded-linux-opensource-src-4.4.0.tar.bz2 cd qt-embedded-linux-opensource-src-4.4.0 源码中包含了文档、例程。这些会占用很多空间和编译时间，如果不需要的话就修改 configure ，把它去掉：\nQT_DEFAULT_BUILD_PARTS=\u0026quot;libs tools examples demos doc\u0026quot; 改为 QT_DEFAULT_BUILD_PARTS=\u0026quot;libs tools\u0026quot; 通过 configure 的选项可以关闭很多不需要的模块，用 ./configure -help 查看详情。\n针对嵌入式版本，还可以用 -no-feature-\u0026lt;feature\u0026gt; 关闭相应的特性，默认情况下会编译全部的特性。可用的 feature 在 src/corelib/global/qfeatures.txt 文件中有完整描述。但是这个方法不方便，通常是通过 -qconfig 参数指定一个配置文件，在 src/corelib/global/ 目录下有几个典型的配置文件：\nqconfig-large.h #包含了大多数特性。 qconfig-small.h #关闭了很多特性。 qconfig-minimal.h #最小配置，几乎关闭了所有特性。 可以手动编辑修改配置。但是各种特性之间的依赖很复杂，所有Qt提供了一个图形工具 qconfig 来帮助生成配置。这个工具需要编译，安装 Qt/E 后再介绍。\n执行：\n./configure -prefix /usr/qt -release -no-largefile -no-qt3support -no-xmlpatterns -no-phonon -no-svg -no-webkit -no-mmx -no-3dnow -no-sse -no-sse2 -no-gif -no-libtiff -no-libmng -qt-libpng -qt-libjpeg -no-openssl -no-nis -no-cups -no-iconv -no-opengl -no-dbus -qt-freetype -depths 16 -embedded x86 -qt-decoration-default -qt-gfx-linuxfb -qt-kbd-tty -qt-kbd-usb -qt-mouse-pc -qt-mouse-bus -no-glib -qconfig src/corelib/global/qconfig-small.h make make install 编译工程需要几个小时，所有文件都会被安装到 /usr/qt/ 目录下。现在配置环境变量： 在 /etc/profile 文件中添加：\nPATH=$PATH:/usr/qt/bin 在 /etc/ld.so.conf 文件中添加：\n/usr/qt/lib 然后执行 ldconf -v\n重启系统后，Qt/E 就可以使用了。\n测试 #demo.cpp\n#include \u0026lt;QApplication\u0026gt; #include \u0026lt;QPushButton\u0026gt; #include \u0026lt;QFont\u0026gt; #include \u0026lt;QTextCodec\u0026gt; int main(int argc, char *argv[]) { QApplication app(argc, argv); QTextCodec *codec = QTextCodec::codecForName(\u0026quot;GB18030\u0026quot;); QTextCodec::setCodecForLocale(codec); QTextCodec::setCodecForCStrings(codec); QTextCodec::setCodecForTr(codec); QPushButton hello(\u0026quot;Hello 世界!\u0026quot;); hello.show(); return app.exec(); } 编译：\nqmake -project qmake make 编译生成了 demo 程序，运行：\n./demo -qws -fn wenquanyi 用qconfig工具配置qconfig-local.h文件 #进入qconfig的源码目录编译生成 qconfig ：\ncd tools/qconfig/ qmake make 执行qconfig：\n./qconfig -qws 首次打开时可能出现如下界面，需要导入 feature.txt 文件：\n选择 src/corelib/global/feature.txt 文件，然后点击 Open ，就会导入所有可配置的特性：\n在左侧的树状列表中选择需要编译的特性，然后通过 File 菜单的 Save As 保存为qconfig-local.h文件即可。 也可以通过 File -\u0026gt; Open 打开已有的配置文件，例如 qconfig-small.h，进行修改。\n","date":"2012 June 1","permalink":"/posts/2012/06/01/","section":"Posts","summary":"Qt Embedded 直接依赖 Framebuffer，无需 X-Window。所以要开启 Linux 系统的 Framebuffer 。开启方法是通过 BootLoader 向内核传递参数：","title":"在 Redhat9 文本系统上安装 Qt/E 4.4.0"},{"content":"原文：\nThe Vim/Cscope tutorial\nhttp://cscope.sourceforge.net/cscope_vim_tutorial.html\nTranslated by Bob\n2012-4-27\nEmail： gexbob@gmail.com\nBlog：http://shaocheng.li\nCscope 是一个非常方便的工具, 它会为你的编辑器（即 Vim ）带来很好的舒适性. 幸运的是, Cscope 已经被 Vim 在内部集成.\n这个教程向你介绍了 Vim 内建的 Cscope 支持，以及一套让搜索更方便的方法.\n假设你知道使用 vi 风格编辑器的基本知识, 但是不需要任何关于Vim的特定知识 (会简单介绍一些用得到的 Vim 特有功能——如多窗口). 你也无需知道任何关于Cscope的知识: 我们会逐步介绍一些基本的东西.\n简而言之，Vim 的 Cscope 支持很像你用过的 Vim 的 ctags 功能。但是因为 Cscope 的搜索类型比 ctags 更多，所以会有些不同。\n这是一个实践教程, 所以要启动一个 shell , 然后跟着下面的步骤做:\n如果你的电脑还没有Cscope，先下载并安装。理想状态下, 你的 Vim 应该是 6.x 版本, 但是用 Vim 5 以上的版本都可以获得大部分功能 (无法使用垂直分割, 但是通过修改相关文件可以使用水平分割).\n注意: 如果你的 Vim 版本在编译时没有指定 \u0026lsquo;\u0026ndash;enable-cscope\u0026rsquo; 选项, 你需要重新编译和配置 Vim 。 大部分随 Linux 发行版安装的 Vim 二进制文件都使能了 Cscope 插件。\n下载 cscope_maps.vim 文件, 让 Vim 在启动时读取它. 如果你用的是 Vim 6.x, 把它复制到 $HOME/.vim/plugin 目录下即可 (或者其他插件子目录). 如果你用的是 Vim 5.x, 只能把 cscope_maps 文件的内容复制到 $HOME/.vimrc 文件中, 或者黏贴 \u0026ldquo;source cscope_maps.vim\u0026rdquo; 一行到 .vimrc 文件.\n进入一个有C代码文件的目录, 执行 \u0026lsquo;cscope -R\u0026rsquo; ( \u0026lsquo;-R\u0026rsquo; 会让 Cscope 遍历所有子目录, 否则只会检测当前目录). 由于没有使用 \u0026lsquo;-b\u0026rsquo; 选项 (它告诉 Cscope 只建立数据库后就退出), Cscope 会打开一个基于 curses 的 GUI 界面. 在这里尝试一些搜索 (提示: 使用方向键可以在搜索类型之间移动, 用 \u0026rsquo;tab\u0026rsquo; 键来在搜索类型和搜索结果之间做出选择). 在搜索结果的左边敲入数字, Cscope 就会在 Vim 中打开它的位置. (除非你把 EDITOR 环境变量设为了 Vim 之外的东西). 关闭 Vim, 就会返回到离开 Cscope GUI 时的位置. 有趣。\nCscope 接口有个大问题； 每次要执行新的搜索时都要关闭 Vim. 这就是 Vim 插件. 用 CTRL-D 关闭 Cscope.\n启动 Vim. 如果你愿意, 可以在启动时带一个C语言的标识符 (入: \u0026lsquo;vim -t main\u0026rsquo;), 然后就会跳到代码中该标识符定义的地方.\n把光标移到一个在程序中多次使用的标识符上. 键入 \u0026ldquo;CTRL-\\ s\u0026rdquo; (先敲CTRL-, 然后敲 \u0026rsquo;s\u0026rsquo;) , 应该会在 Vim 窗口的底部看到一个菜单，显示了程序中所有用到这个标识符的地方. 选择其中的一个然后点回车, 就会跳到那里. 类似 ctags, 可以点击 \u0026ldquo;CTRL-t\u0026rdquo; 调回搜索之前的位置 (也可以多搜索几个，然后用 CTRL-t 依次释放).\n助记符: \u0026lsquo;'键在\u0026rsquo;]\u0026lsquo;键的右边, 用于 ctags 搜索.\n尝试同样的搜索, 但是这次用 \u0026ldquo;CTRL-spacebar s\u0026rdquo; 组合键. 这一次，Vim 窗口会水平分割为两个, Cscope 的搜索结果将在新的窗口上显示.[如果你从来没用过 Vim 的多窗口: 用 \u0026lsquo;CTRL-W w\u0026rsquo; (或 CTRL-W 和方向键, 或 CTRL-W 和 h/j/k/l )在窗口之间移动, 用 \u0026lsquo;CTRL-W c\u0026rsquo; (或 \u0026lsquo;:q\u0026rsquo;)关闭一个窗口, 用 \u0026lsquo;CTRL-W o\u0026rsquo;只显示当前窗口, 用 \u0026lsquo;CTRL-W s\u0026rsquo; (或 \u0026lsquo;CTRL-W v\u0026rsquo; 垂直分割)将窗口分割为两个, 用 \u0026lsquo;:spl[it] filename]\u0026rsquo; 在分割的新窗口打开文件。\nMnemonic: 在两个分割的窗口之间会有一条空白的间隔.\n现在用 \u0026ldquo;CTRL-spacebar CTRL-spacebar s\u0026rdquo;(只需按住CTRL连按两次空格)进行同样的搜索. 如果你无法快速的按键, 就打开 cscope_maps.vim 脚本，将 Vim 的超时设置改为注释 [事实上，我通常关闭 Vim 的超时]. 这一次 Vim 的窗口会被垂直分割 (注意: 在 Vim 5.x 上是无法实现的).\n到目前为止，我们只用到了\u0026rsquo;cscope_maps.vim\u0026rsquo;的热键,所有的搜索都与 Vim 中的光标有关. Cscope 搜索有一个老办法 (用 Vim 的内建 Cscope), 用 \u0026ldquo;:cscope find symbol foo\u0026quot;命令 (或者简单点，\u0026quot;:cs f s foo\u0026rdquo;). 对于可水平分割的版本,可以用\u0026quot;:scscope\u0026quot; (或\u0026quot;:scs\u0026quot;) . 如果要搜索的词就在光标下，用热键更简单, 命令行的方式可以让你搜索任何标识符，所以要根据实际情况选择.\n到目前为止，我们只用了一种搜索方法：‘s\u0026rsquo;，查找标识符的使用情况。试一下 Cscope 的其他用法: \u0026lsquo;g\u0026rsquo; ，查找全局定义的标识符；\u0026lsquo;c\u0026rsquo;，查找一个函数的所有调用；\u0026lsquo;f\u0026rsquo; 打开光标所指的文件名 (注意: 因为 Cscope 默认从 /usr/include 查找头文件, 可以用这个功能打开大部分标准头文件). 这些都是我最常用的, 但是还有其他的 (在 cscope_maps.vim 文件可以找到所有的用法，也可以看 Cscope 的 man 手册).\n虽然 Cscope 最初只支持 C 语言, 实际上它是个非常灵活的工具，可以支持类似 C++ 和 Java 这样的语言. 你可以把它想象成一个通用的\u0026rsquo;grep\u0026rsquo;数据库, 它的作用是分析函数调用和变量定义等类似的结构. Cscope 默认只能解析当前目录(用‘-R’选项可以包括子目录)下的 C, lex, 和 yacc 文件 (.c, .h, .l, .y) , 目前还无法修改文件扩展列表 (我们应该改变这个现状). 所以你必须做一个要解析的文件列表, 命名为\u0026rsquo;cscope.files\u0026rsquo;(如果用 \u0026lsquo;cscope -i foofile\u0026rsquo;命令，就可以随意命名). 有一个简单（而且十分灵活）的方法是通过 Unix 的\u0026rsquo;find\u0026rsquo;命令:\nfind . -name '*.java' \u0026gt; cscope.files 然后执行 \u0026lsquo;cscope -b\u0026rsquo; 重新构建数据库(‘-b’会让 Cscope 只构建数据库而不启动 GUI), 你就可以浏览 Java 文件中的所有标识符. 很多人用 Cscope 来浏览和编辑大量的文档文件, 说明 Cscope 解析器是非常灵活的。\n对于大的项目,你可能需要用 -q 选项, 并且使用更复杂的 \u0026lsquo;find\u0026rsquo; 命令. 在 tutorial on using Cscope with large projects 可以得到更多信息.\n尝试通过设置 $CSCOPE_DB 环境变量来指定一个你创建的 Cscope 数据库, 这样就不用总是在数据库的目录下启动 Vim. 这种用法多用于代码分别放在多个子目录的项目。注意: 这种情况下, 应该用绝对路径来构建数据库: cd to / ,然后：\nfind /my/project/dir -name '*.c' -o -name '*.h' \u0026gt; /foo/cscope.files 然后在 cscope.files 的目录下运行 Cscope (或者用 \u0026lsquo;cscope -i /foo/cscope.files\u0026rsquo;), 然后设置并到处 $CSCOPE_DB 变量, 让它指向 cscope.out 文件):\ncd /foo cscope -b CSCOPE_DB=/foo/cscope.out; export CSCOPE_DB (上面最后一条命令是针对 Bourne/Korn/Bash 的: 我已经忘了在基于 csh 的 shell 中如何导出变量, 因为我不喜欢它).\n现在应该可以在任何目录下运行 \u0026lsquo;vim -t foo\u0026rsquo; ，并且会准确的跳到定义 \u0026lsquo;foo\u0026rsquo; 的地方. 我通常会为不同的项目写一个小的 shell 脚本 (仅用于定义和导出 CSCOPE_DB) , 以后只需用一个 \u0026lsquo;source projectA\u0026rsquo; 命令来选择它们.\nBUG: 在 Cscope V15.4 之前的版本, 有一个愚蠢的Bug，当执行上面的命令时，可能会导致Vim 停止工作，除非你调用你的数据库是不用默认的‘cscope.out\u0026rsquo;：用’-f foo\u0026rsquo;命名为‘foo.out\u0026rsquo;。\n就是这样！如果有什么问题的话就用\u0026quot;:help cscope\u0026quot; (Vim) 或 \u0026ldquo;man cscope\u0026rdquo; (根据你的 shell) , 还可以学习细微之处.\nCscope support added to Vim by Andy Kahn\nTutorial and cscope_maps.vim by Jason Duell\nCscope art by Petr Sorfa\n","date":"2012 April 29","permalink":"/posts/2012/04/29/","section":"Posts","summary":"原文：","title":"Vim/Cscope 教程"},{"content":"原文：\nUsing Cscope on large projects (example: the Linux kernel)\nhttp://cscope.sourceforge.net/large_projects.html\nTranslated by Bob\n2012-4-28\nEmail： gexbob@gmail.com\nBlog：http://shaocheng.li\n如果你要涉及一个大的代码库，Cscope 会是一个非常有用的工具. 它可以通过快速、有目的的搜索为你节省很多时间，而不是像 grep 那样随机的对源文件手动搜索(对于大的代码库，grep 需要一段时间才能启动).\n在这个教程中，你将学会如何针对一个大项目来设置 Cscope. 我们用到的例子是 Linux 内核源代码, 基本的步骤和其他大项目是一样的, 包括 C++ 和 JAVA 项目.\n1.获取源代码. 首先要获取源代码. 可以从 http://www.kernel.org 下载内核源代码. 本教程中假设你下载的是 Linux 2.4.18 并且安装在 /home/jru/linux-2.4.18.\n注意: 确保你有足够的磁盘空间: 内核压缩包只有 30 MB, 解压后会的源代码是 150 MB , 生成的 Cscope 数据库会占用额外的 20-100+ MB (这取决于你想要数据库包含多少内核代码). 有必要的话，可以把源代码和 Cscope 数据库放在两个不同的磁盘分区 .\n2.弄清楚你想要把 Cscope 数据库文件放在哪里. 我假设你会在 /home/jru/cscope 存放数据库和关联文件.\n3.生成一个带有浏览文件列表的 cscope.files . 对于某些项目, 你可能想要在 Cscope 数据库中包含项目目录中的所有 C 源文件. 这种情况下可以跳过这一步, 只需在项目的顶层目录上执行 \u0026lsquo;cscope -R\u0026rsquo; 来构建你的 Cscope 数据库. 但是如果有些代码你不想包含, 或者你的项目包含 C++ 或 JAVA 源代码 (Cscope 默认只能解析 .c, .h, .y, 或 .l 文件), 就要生成一个 cscope.files 文件, 其中包含了想要 Cscope 扫描的所有文件名 (每个文件名占一行).\n你有可能用到绝对路径 (至少在编辑器里使用 Cscope 数据库时需要), 这样就可以在你创建的目录之外使用数据库. 我展示的命令会先进入根目录, 这样就可以用 find 打印出绝对路径.\n对于很多项目, find 命令可以这样用:\ncd / find /my/project/dir -name '*.java' \u0026gt;/my/cscope/dir/cscope.files 对于 Linux 内核, 就有点棘手, 因为我们想要排除文档和脚本目录下的代码, 还有除 Intel x86 外的所有芯片和体系结构的汇编代码(我想你的体系结构是 X86). 另外, 本例中我会排除所有的内核驱动代码 (这些代码超过要解析的代码总量的两倍, 会导致 Cscope 数据库膨胀, 并且包含了很多重复的定义, 通常更难搜素. 如果你对驱动代码感兴趣, 可以省略下面相关的行, 或者修改为只输出你感兴趣的驱动文件):\nLNX=/home/jru/linux-2.4.18 cd / find $LNX \\ -path \u0026quot;$LNX/arch/*\u0026quot; ! -path \u0026quot;$LNX/arch/i386*\u0026quot; -prune -o \\ -path \u0026quot;$LNX/include/asm-*\u0026quot; ! -path \u0026quot;$LNX/include/asm-i386*\u0026quot; -prune -o \\ -path \u0026quot;$LNX/tmp*\u0026quot; -prune -o \\ -path \u0026quot;$LNX/Documentation*\u0026quot; -prune -o \\ -path \u0026quot;$LNX/scripts*\u0026quot; -prune -o \\ -path \u0026quot;$LNX/drivers*\u0026quot; -prune -o \\ -name \u0026quot;*.[chxsS]\u0026quot; -print \u0026gt;/home/jru/cscope/cscope.files 这里用到了 find 命令, 在大项目中，这样做比手动编辑一个文件列表容易多了, 也可以从其他地方复制一个.\n4.生成 Cscope 数据库. 到了生成 Cscope 数据库的时候了:\ncd /home/jru/cscope # the directory with 'cscope.files' cscope -b -q -k -b 选项告诉 Cscope 只要构建数据库，无需启动 Cscope GUI. -q 会导致一个额外的\u0026rsquo;inverted index\u0026rsquo; 文件被创建, 它会使大数据库的搜索更快. 最后, -k 设置 Cscope 为 \u0026lsquo;kernel\u0026rsquo; 模式——这样它就不会去 /usr/include 下搜索源文件中包含的头文件 (这是在操作系统或 C 源码库中使用 Cscope 时的主要作用).\n在我的 900 MHz Pentium III 系统上 (带一个标准的 IDE 硬盘), 解析这样的 Linux 源码只用了 12 秒, 输出的 3 个文件 (cscope.out, cscope.in.out, 和 cscope.po.out) 总共占用了 25 MB.\n5.使用数据库. 如果你喜欢用 vim 或 emacs/xemacs, 我建议你先学习怎样在这些编辑器中使用 Cscope, 这样才能让你在编辑器中轻松的运行搜索. 我们有一份 tutorial for Vim, emacs 用户当然是足够聪明的，可以根据 cscope/contrib/xcscope 目录下的宝贵意见来解决所有问题.\n否则, 你可以用独立的基于 curses 的 Cscope GUI 来运行搜索, 然后启动你喜欢的编辑器(无论 $EDITOR 设为什么,或默认是vi) 来打开搜索结果中的行.\n如果你用独立的 Cscope 浏览器, 确保这样调用它:\ncscope -d 这样 Cscope 就不会重新生成数据库. 否则你就不得不 Cscope 检测修改过的文件, 在大项目中会花很多时间, 即使没有文件被修改过. 如果偶然没有带任何参数就运行了 \u0026lsquo;cscope\u0026rsquo;, 也会导致重新创建没有快速索引和内核模式的数据库, 那就要重新运行之前的 cscope 命令了.\n6.源码改变时重新生成数据库. 如果项目中有了新文件, 就再运行 \u0026lsquo;find\u0026rsquo; 命令来更新 cscope.files (如果正在使用它).\n像初始生成数据那样，用同样的方法调用 cscope (并且在相同的目录下) (即, cscope -b -q -k).\nTutorial by Jason Duell\n","date":"2012 April 28","permalink":"/posts/2012/04/28/","section":"Posts","summary":"原文：","title":"在大项目中使用 Cscope"},{"content":"原文：\nBuilding a custom kernel\nhttps://fedoraproject.org/wiki/Building_a_custom_kernel\nTranslated By Bob\n2012-3-31\nEmail： gexbob@gmail.com\nBlog：http://shaocheng.li\n1. 从源码RPM包建立一个内核 # 注意：下面的说明只对 Fedora12 和之后版本有效\n这份文档为那些想要重新建立内核的高级用户提供说明。但是，重新建立的内核无法得到 Fedora 内核团队的支持。但是，您是高级用户，您可以自己处理，对吗？无论如何，高级用户建立定制内核的原因有如下几项：\n测试他们编写的或从其他地方得到的补丁。 重新配置已经存在的内核。 学习内核或内核开发。 这些说明也可以用于简单的准备内核源码树。\n开始之前，确认系统已经安装了必要的软件包：\nrpmdevtools yum-utils yum-utils 是一个默认的包。用如下命令安装：\nsu -c 'yum install rpmdevtools yum-utils' 如果您要用 make xconfig，安装如下软件是必要的：\nqt3-devle libXi-devel gcc-c++ 对于 Fedora 15，用如下命令：\nsu -c 'yum install qt3-devel libXi-devel' 1.1. 获得源码 # 不要用 root 建立软件包,用 root 建立软件包是很危险且没有必要的，即使对于内核。下面的指令允许任何普通用户从源码包开始建立和安装内核.\n1.在您的用户主目录下准备一个建立RPM包的环境，运行如下命令：\nrpmdev-setuptree 这个命令新建了几个不同的目录 ${HOME}/rpmbuild/SOURCES， ${HOME}/rpmbuild/SPECS和${HOME}/rpmbuild/BUILD 。${HOME} 是您的用户主目录。\n2.下载 kernel-\u0026lt;version\u0026gt;.src.rpm 文件。用\u0026ndash;enablerepo选项使能适当的源码库。（yumdownloader \u0026ndash;enablerepo=repo_to_enable \u0026ndash;source kernel)\nyumdownloader --source kernel 3.用 yum-builddep 命令为内核源码安装编译依赖。\nsu -c 'yum-builddep kernel-\u0026lt;version\u0026gt;.src.rpm' 4.用如下命令安装 kernel-\u0026lt;version\u0026gt;.src.rpm\nrpm -Uvh kernel-\u0026lt;version\u0026gt;.src.rpm 这个命令把RPM目录写入了 ${HOME}/repbuild/SOURCES和${HOME}/rpmbuild/SPECS ，${HOME} 是您的用户主目录。可以忽略像下面这样的信息：\nwarning: user kojibuilder does not exist - using root warning: group kojibuilder does not exist - using root 空间需求:完全的内部编译过程需要若干 GB 的额外空间。\n1.2. 准备内核源码树 #这一步扩大为整个内核源码文件。这对于查看代码、编辑代码和生成补丁是必需的。\n用如下命令准备内核源码树：\ncd ~/rpmbuild/SPECS rpmbuild -bp --target=$(uname -m) kernel.spec 现在，内核源码树就位于 ~/rpmbuild/BUILD/kernel-\u0026lt;version\u0026gt;/linux-\u0026lt;version\u0026gt;.\u0026lt;arch\u0026gt; 目录。\n1.3. 复制源码树和生成一个补丁 #这一步是为了对内核源码使用一个补丁。如果不需要这个补丁，直接跳到“配置内核选项”。\n高级用户： 有些工具，例如“quilt”，允许您避免复制源码树。对应高级用户，这样的工具可以使您在下面的步骤中节省很多时间。\n复制源码树是为了保留修改前的原始代码。\nexport arch=x86_64 # replace x86_64 with your arch export ver=3.1 # replace 3.1 with your kernel version export fedver=fc16 # replace fc16 with your fedora version cp -r ~/rpmbuild/BUILD/kernel-$ver.$fedver/linux-$ver.$arch ~/rpmbuild/BUILD/kernel-$ver.$fedver.orig cp -al ~/rpmbuild/BUILD/kernel-$ver.$fedver.orig ~/rpmbuild/BUILD/kernel-$ver.$fedver.new 第二个 cp 命令在 .orig 和 .new 树之间建立了硬连接，这样可以使 diff 运行的更快。大部分文本编辑者都知道怎样正确的破坏硬连接来避免问题。\n在 FC14 上使用 vim 时，它会把上面的硬连接当做硬连接来处理，从而导致上面的技术失败。有必要将原始代码完全复制到 .new 目录。但是这样将使用双倍的空间。\n直接更改 .new 源码树中的代码，或者复制到一个副本文件。这个文件可以来自于一个要求测试的开发者，上游内核源码，或者另一个发行版本。\n修改 .new 源码树之后，生成一个补丁。要生成一个补丁，用下面命令对整个 .new 和 .orig 源码树运行 diff 。\ncd ~/rpmbuild/BUILD diff -uNrp kernel-$ver.$fedver.orig kernel-$ver.$fedver.new \u0026gt; ../SOURCES/linux-$ver.$fedver-mynewpatch.patch 用新补丁的名字替换 \u0026rsquo;linux-$ver.$fedver-mynewpatch.patch\u0026rsquo; 。在 FC14 上必须把前面的补丁名字复制到 ~/rpmbuild/SOURCES 中的 linux-$ver.$fedver-mynewpatch.patch ，以便 rpmbuild 找到它。\n更多关于补丁的信息请看 diff(1) 和 patch(1) 的 man 手册\n1.4. 配置内核选项 #这一步是为了修改内核的选项。这一步是可选的。如果没有需要修改的配置，可以跳到“准备建立文件”。\n小变化: 如果您只是想要做一点小的修改，可以在config-local文件中根据需要直接设置选项。这样会找到并覆盖其余的config-*文件，避免很多不必要的工作。如果您使用config-local就可以跳过下面的步骤。*\n1.改变内核源码树目录：\ncd ~/rpmbuild/BUILD/kernel-$ver.$fedver/linux-$ver.$arch/ 如果您只是对默认的 fedora 内核做小的修改，跳到第四步，从两个配置工作中选择一个，将这些修改编辑到默认的配置文件。\n2.从 ~/rpmbuild/BUILD/kernel-$ver.$fedver/linux-$ver.$arch/configs 选择所需的配置文件。复制所需的 config 文件到 ~/rpmbuild/BUILD/kernel-$ver.$fedver/linux-$ver.$arch/.config:\ncp configs/\u0026lt;desired-config-file\u0026gt; .config 3.运行下面命令：\nmake oldconfig 4.运行下面命令，在文本界面上选择并保持所需的内核选项\nmake menuconfig 运行图形界面的话用这个命令：\nmake xconfig 5.在顶层 config 文件中添加一行，该文件包含了内核支持的硬件架构（uname -i的输出）。这一行以 # 开头。例如，x86_64 设备应该在顶层 config 文件中添加下面这行：\n# x86_64 6.复制 config 文件到 ~/rpmbuild/SOURCES/:\ncp .config ~/rpmbuild/SOURCES/config-`uname -m`-generic 32-bit x86 内核\n32-bit PAE 内核使用 config-i686-PAE 配置文件。如果您正在建立一个 PAE 内核，需要复制您的 config 文件到 ~/rpmbuild/SOURCES/:\ncp .config ~/rpmbuild/SOURCES/config-i686-PAE 如果您正在建立一个非 PAE 内核，需要复制您的 config 文件到：\ncp .config ~/rpmbuild/SOURCES/config-x86-32-generic 再次鼓励使用 config-local，除非您正在修改大量的配置。\n1.5. 准备建立文件 #这一步将对 kernel.spec 文件做必要的修改。只是建立定制内核所需的。\n1.进入~/rpmbuild/SPECS目录：\ncd ~/rpmbuild/SPECS 2.用编辑器打开kernel.spec文件。\n3.为内核起一个唯一的名字。这对于确保定制内核不与其他内核混淆是很重要的。通过修改 ‘buildid’ 一行，为内核名字添加一个唯一的字符串。可以把 “.local” 改为您的名字缩写，一个 bug 号，日期，或其它任何唯一的字符串。\n修改这一行：\n#% define buildid .local 改为（注意，# 号和额外的空格都被删除了）：\n%define buildid .\u0026lt;custom_text\u0026gt; 4.如果您生成了一个补丁，最后把它添加到 kernel.spec 文件中所有已存在的补丁的后面，并且添加详细的注释。\n# cputime accounting is broken, revert to 2.6.22 version Patch2220: linux-2.6-cputime-fix-accounting.patch Patch9999: linux-2.6-samfw-test.patch 然后，需要将补丁应用到spec文件的application段，放在所有已存在的补丁应用的后面，并添加详细的注释。\nApplyPatch linux-2.6-cputime-fix-accounting.patch ApplyPatch linux-2.6-samfw-test.patch 1.6. 建立新内核 #这一步实际是要生成一个内核 RPM 文件。只是建立定制内核所需的。对于 Fedora10 或 11 ，大多数场合下，这是建立内核（包括固件）的最简单的方法（看最后一部分）。\n用 rpmbuild 工具建立新内核：\n1.建立所有内核配置：\nrpmbuild -bb --target='uname -m' kernel.spec 2.关闭指定的内核配置（为了更快的建立）：\nrpmbuild -bb --without \u0026lt;option\u0026gt; --target='uname -m' kernel.spec 其中 “option” 的有效值包括 xen、smp、up、pae、kdump、debug 和 debuginfo 。指定 \u0026ndash;without debug 会剔除内核中的调试代码，指定 \u0026ndash;without debuginfo 会禁止建立 kernel-debuginfo 包。\n3.只建立一个特定的内核：\nrpmbuild -bb --with \u0026lt;option\u0026gt; --target='uname -m' kernel-spec “option” 的有效值包括 xenonly、smponly 和 beseonly。\n4.例如，只建立 kernel 和 kernel-devel 包的命令是：\nrpmbuild -bb --with baseonly --without debuginfo --target='uname -m' kernel.spec 5.建立时包含固件，用如下命令：\nrpmbuild -bb --with baseonly --with firmware --without debuginfo --target=`uname -m` kernel.spec 建立的过程需要很长时间。会在屏幕上打印大量的信息。这些信息可以被忽略，除非建立过程因为一个error而停止。如果成功完成建立过程，一个新的内核包会出现在~/rpmbuild/RPMS目录。\n应该添加一个故障排除的部分。\n####1.6.1. 以下是通用教程\n大部分关于 Linux 内核开发的教程，例子和教科书都假设内核源码被安装在/usr/src/linux目录下。如果您想下面这样做一个符号链接，您就可以使用那些Fedora包的学习材料了。安装合适的内核源码，然后运行下面命令：\nsu -c 'ln -s /usr/src/kernels/\u0026lt;version\u0026gt;.\u0026lt;release\u0026gt;-\u0026lt;arch\u0026gt; /usr/src/linux' 根据提示输入 root 密码。\n1.7. 安装新内核 #这一步将把新内核安装到运行中的系统。\n要安装新内核，用 rpm -ivh 命令，不要带 -U 或 \u0026ndash;upgrade 选项：\nsu -c \u0026quot;rpm -ivh --force $HOME/rpmbuild/RPMS/\u0026lt;arch\u0026gt;/kernel-\u0026lt;version\u0026gt;.\u0026lt;arch\u0026gt;.rpm\u0026quot; 如果您根据需要修改了内核的名字，您的固件和内核头文件将无法匹配。最简单的解决方法是用前面描述的方法建立新的固件，然后：\nsu -c \u0026quot;rpm -ivh $HOME/rpmbuild/RPMS/\u0026lt;arch\u0026gt;/kernel-\u0026lt;version\u0026gt;.\u0026lt;arch\u0026gt;.rpm \\ $HOME/rpmbuild/RPMS/\u0026lt;arch\u0026gt;/kernel-firmware-\u0026lt;version\u0026gt;.\u0026lt;arch\u0026gt;.rpm \\ $HOME/rpmbuild/RPMS/\u0026lt;arch\u0026gt;/kernel-headers-\u0026lt;version\u0026gt;.\u0026lt;arch\u0026gt;.rpm \\ $HOME/rpmbuild/RPMS/\u0026lt;arch\u0026gt;/kernel-devel-\u0026lt;version\u0026gt;.\u0026lt;arch\u0026gt;.rpm\u0026quot; 这些命令会把您的内核安装到 /boot目录，创建一个新的 initramfs，并且自动把新内核添加到 grub 的 “menu.list” 中。然后，您就可以重启并使用您的新内核了。\n2. 只建立内核模块（kernel modules） #本段需要更新和充实\n这一段针对那些只想在内核模块上工作的用户，他们并不想建立一个完整的内核。只要就没必要下载和重新建立整个内核。要为当前运行的内核建立一个模块，只需要相匹配的 kernel-devel 包。运行下面命令安装 kernel-devel 包：\nsu -c 'yum install kernel-devel' 如果您用的是 PAE 内核，可能要安装 “kernel-PAE-devel” 。\n只要您安装了相应版本的 kernel 或 kernel-devel 包，就可以建立任何内核版本。本段的其余部分假设您正在使用当前运行的内核。如果不是，用指定的版本号代替 ‘uname -r’。\nkernel-doc 包包含了官方的 Kbuild 文档。在 Documentation/kbuild 目录下查看，尤其是 modules.txt 文件。\n一个简单的例子，从 foo.c 建立 foo.ko 模块，在 foo.c 所在的目录下创建下面这样的 Makefile：\nobj-m := foo.o KDIR := /lib/modules/$(shell uname -r)/build PWD := $(shell pwd) default: [TAB]$(MAKE) -C $(KDIR) M=$(PWD) modules [TAB] 表示 makefile 中包含命令的一行必须以一个 tab 字符开头。\n然后，执行 make 命令建立 foo.ko 模块。\n上面是是通过一个本地 Makefile 包装调用 kbuild。通常您可以简单一点，想下面这样来建立那些目标。\n# make -C /lib/modules/`uname -r`/build M=`pwd` modules # make -C /lib/modules/`uname -r`/build M=`pwd` clean # make -C /lib/modules/`uname -r`/build M=`pwd` modules_install ","date":"2012 April 1","permalink":"/posts/2012/04/01/","section":"Posts","summary":"原文：","title":"建立一个定制内核"},{"content":"Goagent 的项目主页在 googlecode：http://code.google.com/p/goagent/\n首页有 Windows 系统中的部署教程，Linux 系统中的部署方法有些复杂，记录如下:\n申请一个Google Appengine：http://code.google.com/intl/zh-CN/appengine/，并且创建一个 appid。 下载 Python 版的 Google App Engine SDK，下载页面：http://code.google.com/intl/zh-CN/appengine/downloads.html#Google_App_Engine_SDK_for_Python，要选择 Linux 平台。下载后解压为一个 google_appengine 文件夹。 下载 goagent 稳定版，在项目主页的顶部就有下载链接，当前的版本是 goagent 1.7.10。下载后解压到 google_appengine/goagent 文件夹。 修改 local/proxy.ini 文件中的 [gae] 下的 appid=你的appid ，多个 appid 可以用 | 隔开。 上传。在 google_appengine 目录下执行：python appcfg.py update goagent/server/python。上传需要一些时间。 chrome 浏览器请安装 SwitchySharp 插件：https://chrome.google.com/webstore/detail/dpplabbmogkhghncfbfdeeokoefdjegm，安装后导入这个设置：http://goagent.googlecode.com/files/SwitchyOptions.bak。 使用时在 goagent/local 下执行 python proxy.py ，然后打开 chrome 即可。 ","date":"2012 March 23","permalink":"/posts/2012/03/23/","section":"Posts","summary":"Goagent 的项目主页在 googlecode：http://code.","title":"在 Linux 系统中部署 goagent"},{"content":"也许你还不知道 AA 是什么，但只看那牛逼哄哄的名字，就该知道它绝非善类。\n没错。进入这个项目的主页：http://aa-project.sourceforge.net/，就能看到它的三个宏伟目标：\n将所有的重要软件移植到AA-lib 将AA-lib移植到所有的可用平台 迫使IBM重新制造MDA卡 注：MDA（Monochrome Display Adapter ），单色字符显示适配卡，与单色字符显示器配接，它只支持字符显示功能，无图形功能，是一种相当古老的显卡。\n如果你对技术不感兴趣，可用点击这里 http://v.youku.com/v_show/id_XMzYwNTIyODY4.html，观看利用 AA 制作的一段动画,制作方法和源代码在文档的最后一节。\n简单的说，它可用实现下面的效果，就是将图片转换为 ASCII 文本。\n这个略显粗糙，如果将字体调小，增大分辨率，可显示更加逼真的图片，例如：\n其实，这是一个由ASCII字符的狂热爱好者们开发的项目，最初的发起人叫 Jan Hubicka ，目的是将计算机上的一切都用 ASCII 字符来表现，包括图形和视频。\n该项目提供了一个库—— AA-lib ，这是一个低级图形库，与其他的库的区别是它不需要图形设备，完全用 ASCII 字符描绘图形，它的 API 被设计得与其他库类似。还提提供一个演示程序—— BB（这个名字更显另类），播放了一段完全由 ASCII 字符绘制的动画，其中有文字，图像，分形几何，还有一个 3D 效果。\n下面在 fedora12 中安装它们。\n1. 安装 AA-lib #下载 aalib-1.2：\nhttp://prdownloads.sourceforge.net/aa-project/aalib-1.2.tar.gz\n最新版本是 1.4，但是 BB 是基于 1.2 的，所有先安装1.2。\n解压、编译、安装：\ntar xvzf aalib-1.2.tar.gz cd aalib-1.2 ./configure make make install 默认安装在 /usr/local 下\n2. 安装 bb #下载 bb-1.2：\nhttp://prdownloads.sourceforge.net/aa-project/bb-1.2.tar.gz\n编译前需要设置一个环境变量，否则会找不到 aa-lib：\nexport CFLAGS=-I/usr/local/include 解压：\ntar xvzf bb-1.2.tar.gz cd aalib-1.2 编译时会报 textform.c 文件的错误，是因为该文件内定义的某些字符串太长，换行时没有用反斜杠，可以在后面加上反斜杠\t，或直接注释掉。然后编译：\n./configure make 编译生成了可执行文件 bb，直接执行即可看到一段演示。最好在文本模式下执行，否则可能会报错。\n这段演示还可以添加音乐，在源码的 mikunix 目录下有音频的程序，直接 make ，然后执行 strip ../bb_snd_\tserver。但是我一直没有弄出声音，也许是虚拟机的问题。\n3. 安装 aview #aview 的作用是将 pnm 格式的图片转换为 ASCII 文本，并显示。aview只支持 pnm、pgm、pbm 和 ppm 格式的图片，所以需要将其他格式的图片转换，它提供了一个 asciiview 的脚本，利用 convert 转换图片格式，然后再传递给 aview。\naview 依赖于 aalib-1.4，所有要先用 1.4 替换之前安装的 1.2，安装方法与 1.2 相同。安装后下载 aview：http://prdownloads.sourceforge.net/aa-project/aview-1.3.0rc1.tar.gz\n解压、编译、安装：\ntar xvzf aview-1.3.0rc1.tar.gz cd aview-1.3.0 ./configure make make install 编译生成的 aview 程序可以将 pbm、pgm 或 pnm 图片用 ASCII 字符显示。但是不支持 JPEG 图片，所以它提供了一个 shell 脚本 ascii\tview，先调用 convert 将 JPEG 图片转换为 pgm 图片，然后再用 aview 显示。\nfedora12 中没有 convert 命令，先用下面的命令安装：\nyum install ImageMagick 准备一张图片，例如 1.jpg，用下面的命令就可以把它转换为 ASCII文本：\nasciiview 1.jpg 4. Bad Apple #下面参考 aview 的源码，编写了一个程序，在 Linux 的终端下播放一段由 ASCII 字符绘制的动画：Bad Apple。原理比较\t简单，就是将视频逐帧截图，然后用程序按一定的时间间隔将图片依次转换为ASCII文本在终端上显示。动画视频在这里：http://v.youku.com/v_show/id_XMzYwNTIyODY4.html，动画中的卡顿是屏幕录像软件的问题，AA-lib本身是很流畅的。\n制作步骤：\n准备 apple.flv，用 kmplayer 做每 50 毫秒截图，截图为 jpeg 格式，把它们都复制到 /root/aa/img 目录下。\n用下面 shell 脚本将 jpeg 图片转化为 pgm 格式，共 3202 张，文件名为 1.pgm 到 3202.pgm ，全部放在 pgm 文件夹下。\n#!/bin/sh ls -l *.jpg \u0026gt; sort i=1 while [ $i -le 3202 ] do filename=`sed -n ''$i'p' sort | awk '{print $8}'` echo $filename convert $filename ./pgm/$i.pgm i=`expr $i + 1` done 在 pgm 文件夹下执行程序：\n./aviewdemo -contrast 20 -extended 1.pgm 程序源码在这里：http://download.csdn.net/detail/exbob/4112093\n动画视频在这里：http://v.youku.com/v_show/id_XMzYwNTIyODY4.html\n","date":"2012 March 5","permalink":"/posts/2012/03/05/","section":"Posts","summary":"也许你还不知道 AA 是什么，但只看那牛逼哄哄的名字，就该知道它绝非善类。","title":"牛逼的AA"},{"content":"原文：\nX Window System Architecture Overview HOWTO\nhttp://www.linuxdoc.org/HOWTO/XWindow-Overview-HOWTO/index.html\nDaniel Manrique\nroadmr@entropia.com.mx\nTranslated By Bob\nEmail： gexbob@gmail.com\nBlog：http://shaocheng.li\n修订历史\nRevision 1.0.1 2001-05-22 Revised by: dm 一些语法修正，由Bill Staehle指出。\nRevision 1.0 2001-05-20 Revised by: dm 初始发行。\n本文档描述了X Window的架构，给出了对于X Window设计的更好理解, 包括X的组件，这些组件结合起来构成的可运行图形环境，这些组件作为窗口管理器该怎样选择，工具包和构件库，桌面环境。\n1. 序言 #这个文档的目的是提供一个 X-Window 系统架构的概述，希望人们更好的理解它为什么要这样设计，X 的组件是怎样组合起来形成一个可工作的图形环境，怎样选择这些组件。\n我们探讨一些经常被提到的概念，如果没有相关的技术背景，这些概念可能被混淆，例如部件（widgets）和工具包（toolkits），窗口管理器（window managers）和桌面环境（desktop environments）。还提供了一些例子，展示了这些组件在日常使用的应用程序中如何相互作用。\n这个文档故意写得不太偏重技术，它基于作者的经验知识，以非技术方式引入，它可以从各种意见中吸取营养，包括更深入的例子和解释，以及技术上的更正。作者欢迎所有关于这个文档的问题和意见，Email： roadmr@entropia.com.mx 。\n2. 简介 #回到UNIX还是新鲜事物的时代，大约是1970年，图形用户接口还是一个奇怪的东西，只被一个实验室（Xerox\u0026rsquo;s PARC）使用。可是今天，任何操作系统只要想拥有竞争力，就必须有一个GUI子系统。GUI界面提供了良好的易用性。这不是UNIX所关心的，UNIX 有它的传统，某种程度来讲，多功能比易用性更好。但是，有几个原因使得 UNIX 系统需要有一个GUI。例如，UNIX 的多任务特性，在给定的时间内要运行多个程序。GUI 提供了多种控制方式，可以在同一时间在屏幕上显示多个运行的程序。所以，某些类型的信息更适合在图形界面上显示（有些甚至只能在图形界面上显示，例如pr0n和其他图形数据）。\n历史上，UNIX有很多学术上的改进。一个好的例子是，70年代末加入了 BSD 网络代码，这是加州大学伯克利分校的工作成果。事实证明，X Window 系统也是一个学术项目的结果，即 MIT 的雅典娜项目，它成为了现代 UNIX（类UNIX系统）中大部分GUI子系统的基础，包括 Linux 和 BSD。\n从一开始，UNIX就是一个多用户、多任务的分时操作系统。随着网络技术的加入，它还允许用户远程连接和执行任务。以前，这是通过串行终端或网络连接（telnet）完成的。\n当开发UNIX下的GUI系统的时候，这些概念都被加入到了设计中。事实上，X是一个相当复杂的设计，这是经常被提到的一个缺点。可是，正因如此，它才是一个真正多功能的系统，当我们解释GUI的各个部分在UNIX下是怎样结合的时候，这些都会变的很清晰。\n介绍X的架构之前，简单介绍一下它的历史，还有它是如果进入Linux系统的。\nX是由雅典娜项目开发，在1984年发行。1988年，一个叫做“X Consortium ”的实体接手X，之后开始处理它的开发和发布。X规范是自由提供的，这个聪明的举动使X得到了很大程度的普及。下面介绍XFree86是什么。XFree86是我们在Linux系统上使用的X实体，XFree86也可以工作在其他操作系统上，例如BSD系列、OS/2和其他。尽管它的名字中带有86，它依然支持其他CPU架构。\n3. X Window系统架构：概览 #X被设计为客户端—服务器的架构（client-server）。应用软件作为客户端，他们通过服务器进行沟通和发布请求，当然也可以从服务器接受信息。\nX server维护一个独立的显示控制器和处理来自client的请求。从这一点上来看，使用这种模式的优点是显而易见的。应用程序（client）只需要知道怎样同server沟通，而不需要关注实际图像显示设备的细节。最基本的，client会告诉server一些这样的东西：“画一条从这里到那里的线”，或者“显示一个文本字符串，使用这个字体，在屏幕的这个位置”。\n这与只用图形库写应用没什么不同。但是，X模式更进一步。它不限制client和server在同处一台电脑。使用这个协议可以让client和server通过网络进行沟通，事实上，“进程间通信机制提供了可靠的字节流”。当然，更好的方法是使用TCP/IP协议。可以看到，X的模式是很强大的。一个经典的例子是，在Cray计算机上运行一个处理器密集阵应用程序，在Solaris 服务器上运行一个数据库监视器，在小型BSD邮件服务器上运行一个E-mail应用，在SGI服务器上运行一个可视化应用，然后，将以上这些都显示在我的Linux平台的屏幕上。\n目前为止，我们已经看到X server是一个处理实际图形显示的东西。由于X server是运行在用户使用的实际计算机上，它的职责是处理所有与用户的交互。这包括监听鼠标和键盘。所有这些信息都要传达给client，还有对它进行响应。\nX提供了一个库，称作Xlib，负责处理所有低级的client-server通信任务。很显然，client调用Xlib中的函数进行工作。\n这样看来，一切都工作的很好。我们有一个server负责虚拟输出和数据输入，客户端应用程序，两者之间可以通过一种方法互相通信。假设client和server之间有一个互动，client可以让server在屏幕上分配一指定的矩形区域。作为client，我并不关心我被现实在屏幕的哪个位置，我只是告诉server“给我一个X乘以Y像素大小的区域”，然后调用函数执行类似“画一条从这里到那里的线”，“用户是否在我的屏幕范围内移动鼠标”等等。\n4. 窗口管理器 #可是，我们没有提到X server怎样处理client在屏幕现实范围内的操作（调用窗口）。显然，对于任何使用GUI的用户，对需要对“client windows”进行控制。通常情况下，你可以对窗口进行移动和排列；改变大小；最大化或最小化。那么，X server是怎样处理这些任务呢？答案是：不能。\nX的设计原则之一就是“只提供机制，不提供策略”。所以，X server提供了一个操作窗口的方法（机制），并没有说怎样表现这种机制（策略）。\n这些机制和策略可以归结为：有一个程序的责任是管理屏幕空间。这个程序决定了窗口的位置，为用户提供了控制窗口外观、位置和大小的机制，通常还会提供一些“装饰”，例如标题、边框和按钮，这些是我们对窗口本身的控制。这个控制窗口的程序称作“窗口管理器”。\n“窗口管理器只是X的一个客户端程序——它不是X window系统的一部分，尽管它享有一些特权——所以，窗口管理器不是唯一的，而是有很多，它们提供了不同的用户与窗口的交互方式和不同的窗口布局、修饰、键盘和色调的风格。”\nX的架构提供了用于窗口管理器执行这些窗口操作的方法，但确实没有提供一个窗口管理器。\n另外，由于窗口管理器是一个外部元件，可以很容易的根据你的参数设定窗口，例如，你希望它看起来是什么样子，你想要它怎样执行，你想要它出现在哪里，等等。有些窗口管理器比较简单和丑陋（例如twm）；还有一些是华而不实的；还有介于两者之间的；fvwm, amiwm, icewm, windowmaker, afterstep, sawfish, kwm, 还有数不清的其他窗口管理器。每一种口味都有对应的窗口管理器。\n窗口管理器是一个“meta-client”，最基本的使命是管理其他客户端程序。大部分窗口管理器会提供一些额外的设施（有些会提供很多）。 可是，有个功能是大部分窗口管理器都有的——启动应用程序的方法。有些窗口管理器会提供一个命令盒子，你可以在这里写标准命令（用于启动应用程序）。还有一些窗口管理器会提供某种类型的应用程序启动菜单。这些不是标准配置。由于X没有制度关于如何启动应用程序的策略，这项功能在客户端程序中实施。那么，通常情况下，窗口管理器所负责的这个功能（个体之间会由差异），它的唯一使命就是如果启动客户端应用程序，就像一个程序启动平台。当然，人们已经写了大量的“启动程序”的应用。\n5. 客户端应用 #下面让我们关注一些客户端程序。假设你想要从头开始写一个客户端程序，并且只用X提供的设施。你很快就会发现，Xlib是漂亮的斯巴达，想要在屏幕上放一个按钮、文本，或是为用户提供的漂亮空间（滚动条，单选框），这些事竟是令人恐怖的复杂。\n幸运的是，有人为我们提供了一个库，可以解决这些控件的编程问题。这些控件通常称作“部件”（widget library ），所以，这个库称作“部件库”。我只需从库中调用一个带参数的函数就可以在屏幕上显示一个按钮。这些部件包括菜单、按钮、单选按钮、滚动条和画布。\n“canvas”（画布）是一个有趣的部件，它是客户端上的一个子空间，我能在里面话一些东西。可以理解，我不能直接使用Xlib，那样会干扰部件库，这个库本身提供了在画布内画任意图像的方法。\n由于部件库确实可以在屏幕上画各种元素，以及解释用户的输入动作，这个库要对每个客户端的外观和行为负责。从开发者的角度来看，部件库也有一些API（设置函数），定义了我想要用到的部件。\n6. 部件库和工具包 #原始的部件库是为雅典娜项目开发的，理所当然应该是雅典娜部件库，也被称作雅典娜部件。它非常基础，非常简陋，安装现在的标准来看，它的使用方便并不直观（例如，要移动一个滚动条或滑块，你不能拖动，你要点击右边的按钮让它向上滑，或者点击左边的按钮让它向下滑），正因如此，现在几乎没有被使用了。\n像窗口管理器一样，考虑到不同的设计目的，工具包（toolkit）也有很多种。最早的工具包之一是著名的Motif，这是开发软件基金会（OSF）的Motif图像环境的一部分，由一个窗口管理器和一个匹配工具包组成。OSF的历史超出了本文档的讨论范围。Motif工具包优于雅典娜部件，在80年代和90年代初使用广泛。\n这些年，Motif不是一个受欢迎的选择。它不是免费的，如果你想要一个开发许可证（即用它编译你自己的程序），你需要向OSF Motif缴费，尽管可以发布一个针对Motif的二进制连接。至少对于Linux用户来说，最知名的Motif应用可能就是Netscape Navigator/Communicator。\n有一段时间，Motif是唯一正常可用的工具包。有很多软件围绕着Motif。于是人们开始开发替代品，产生了丰富的工具包，例如XForms, FLTK等等。\n已经有些时间没有听到Motif了，特别是在自由软件世界。原因是：就许可、性能（Motif被普遍认为像一头猪）和功能而言已经有了更好的替代品。\n有一个知名并广泛使用的工具包是Gtk，它是GIMP项目专门设计用来替代Motif的。Gtk现在非常流行，因为它相对较轻，功能丰富，可扩展，而且完全免费。GIMP的0.6发行版的更新日志里包含了“Bloatif has been zorched ”，这句话是给Motif的臃肿的遗嘱。\n另一个目前很流行的工具包是Qt。直到KDE项目的出现，它才开始出名，KDE利用了Qt的所有GUI元素。当然，我们不会深入Qt的许可问题和KDE/GNOME的分离性。Gtk说来话长，因为它的历史伴随着Motif的替换而变的很有趣。Qt没什么可说的，因为它真的很流行。\n最后，另一个值得一提的替代品是LessTif，这个名字是对于Motif的双关语，LessTif的目标是成为免费的，兼容Motif API的替代品。并不清楚LessTif的目标已经达到了怎样的程度，倒不如帮助那些使用Motif代码的应用，在它们想要移植到其他的工具包时，有个一个免费的替代品。\n7. 目前为止我们所拥有的 #现在，我们已经知道，X有一个client-server架构，我们的应用程序就是client。在这个client-server架构的图形系统下，有多种可选的窗口管理器，它管理着我们的屏幕空间。client是我们真正完成工作的地方，而且，可以使用不同的工具包进行客户端编程。\n困境就从这里产生了。各种窗口管理器使用各自不同的方法管理客户端，它们的功能和外观各不相同。同样的，由于每个客户端使用不同的工具包，它们的外观和性能也会不同。由于没有人说作者必须用同一个工具包写应用程序，下面这种情况很可能在用户运行程序是出现，比方说，六个不同的应用，都使用不同的工具包，那么它们的外观和性能也不同。这是由于应用之间的功能不一致而造成的困境。如果你一直使用一个用雅典娜组件写的程序，你会注意到，它和用Gtk所写的程序不太一样。通过使用这些外观和体验差别很大的应用，会让你记住是一个困境。这基本上否定了一个GUI环境的优势。\n从技术角度来看，使用多种不同的工具包会增加对资源的占用。现代操作系统都支持动态链接库。这意味着，如果我有两三个使用Gtk的应用程序，还有一个Gtk动态链接库，那么这几个应用程序将共享这个Gtk。这样就节省了资源。另一方面，如果我有一个Gtk应用，一个Qt应用，一些基于雅典娜的程序，一个基于Motif的程序（例如Netscape），一个使用FLTK的程序，还有其他一些使用XForms，那我就要在内存中加载六个不同的库，每个库还要有一个不同的工具包。请记住，这些工具包提供的功能基本相同。\n还用另外一些问题。每一种窗口管理器的启动程序的方式是不同的。有些窗口管理器有漂亮的启动程序菜单；有些则没有，它们希望我们打开一个程序启动箱，或者使用一个组合键，要不就是打开一个xterm，然后调用命令启动你的程序。所有，困境就是因为没有一个标准。\n最后，我们的计划没有覆盖到一些GUI环境的细节。例如有效的配置，或者“控制面板”；还有图形文件管理器。当然，这些可以写成客户端应用。在典型的自由软件时尚中，有数百种文件管理器，数百种系统配置程序，可以想象，处理这些不同的软件组件将是更大的困境。\n8. 桌面环境的救赎 #先说一下桌面环境的概念是怎么来的。一个桌面环境应该提供一套设施和指导，用于规范我们之前提到的所有东西，以便我们前面提到的问题最小化。\n桌面环境的概念对于Linux来说是新的东西，但是这些东西在其他操作系统（例如Windows和Mac OS）中本来就存在。例如，MacOS，它是最早的图形用户接口之一，为整个计算机会话提供了一个非常一致的感观。再例如，操作系统提供了很多我们前面提到的细节：它提供了一个默认的文件管理器，一个全系统控制面板，还有一个所有应用都使用的独立工具包（所以它们看起来都差不多）。应用窗口由系统（严格的将是窗口管理器）负责管理。最后，还有一套指南告诉开发者应该怎么表现他们的应用，如何设计外观和布局，以及根据系统中的其他应用设计外观。所有这些都是为了保证应用程序的一致性和易用性。\n这引出了一个问题，“为什么X的开发者没有将桌面环境的事情放在首位？”。这是有道理的；毕竟，这样就可以避免前面提到的所有问题。答案就是，在X的设计过程中，它的设计者选择将它设计得尽可能的灵活。比如说，MacOS提供了大多数机制/策略规范，但是他们不鼓励人们玩弄这些东西，结果就是失去了多功能性，如果我不喜欢MacOS管理窗口的方式，或者工具包没有提供我需要的功能，我只能怪自己倒霉。X下就不会发生这样的事，灵活的代价就是更大的复杂性。\n在Linux/Unix和X下，一切都归结于统一和坚持。以KDE为例，KDE包含一个单一的窗口管理器（kwm），负责管理和控制窗口的行为。它用了一个特定的图形工具包（Qt），以至于KDE应用的控制和外观都差不多。KDE提供了一套桌面环境库，这是Qt的扩展，用来完成一些常见的编程工作，例如创建菜单、“关于”框，编写工具栏，程序间通信，打印，选择文件，等等。这使得程序员的工作更加简单，并且标准化。KDE还为程序员提供了一套设计和行为指南，如果每个人都按照指南来做，那么KDE程序的外观和操作就会很相似。最后，KDE还为桌面环境提供一些组件，一个启动器面板（kpanel），一个标准的文件管理器，还有一个配置程序（控制面板），通过它可以全方位的控制计算机环境，比如设置桌面背景和标题栏的颜色。\nKDE面板相当于Windows操作系统的任务栏。在这上面可以启动应用程序，还可以在上面显示将小程序（applets）。它还提供了大多数用户都离不开的实时时钟。\n9. 特定桌面环境 #我们以KDE为例，但它不是Unix系统上最早的桌面环境。最早的可能是CDE（Common Desktop Environment），OSF的另一个兄弟。根据CDE FAQ：“Common Desktop Environment是Unix的标准桌面，为最终用户、系统管理员和应用开发者提供一贯的跨平台服务。”可是，CDE没有足够丰富的功能和易用性。除了Motif，CDE几乎在自由软件世界消失了，最终被更好的平台替代。\n在Linux下，最流行的桌面环境是KDE和GNOME，但是不止这两个。在网上可以轻易的搜索到半打桌面环境：GNUStep、ROX、GTK+XFce、UDE。它们都提供前面提到的基础功能。GNOME和KDE拥有来自社区和业界的最广泛的支持，所以它们是最优秀的之一，为用户和应用程序提供大量的服务。\n我们提过在KDE下有很多提供特定服务的组件。作为一个好的桌面环境，GNOME在这方面也一样。最明显的差别是GNOME并不要求使用特定的窗口管理器（这方面KDE有kwm）。GNOME一直试图做到与窗口管理器无关，但是要承认，大多数用户与他们的窗口管理器联系紧密，而强迫他们使用不同的窗口管理器会损害他们的观众。GNOME原本青睐Enlightenment窗口管理器，现在它们更喜欢用Sawfish，但是GNOME控制面板一直有一个窗口管理器选择框。\n除此以外，GNOME使用Gtk工具包，并且通过gnome-lib提供了一套高级功能和工具。GNOME有它自己的一套编程方法，可以确保兼容的应用之间行为一致；它提供了一个面板，一个文件管理器（gmc）和一个控制面板（gnome控制中心）。\n10. 怎样把它们组合到一起 #每个用户都可以自由的选择感觉最好的桌面环境。最终的结果是，如果你使用纯kde或纯gnome系统，整个环境的感观就非常一致；并且应用程序之间的沟通会更好。我们不可能在一个应用程序中使用多种不同的工具包。现代Linux桌面环境提供的设备还使用了一些其他的小技术，例如组件架构（KDE有Kparts，GNOME用Bonobo），它允许你在文字处理文档中嵌入表格或图表；还有整体打印设备，就像是Windows中的印刷背景；还有脚本语言，可以让更多的高级用户编写程序将多个应用结合到一起，让它们用有趣的方式进行协作。\n在Unix的桌面环境概念中，一个程序可以在多个环境中运行。我可以想象在GNOME中用Konqueror，在KDE中用Gnumeric。它们只是程序而已。当然，一个桌面环境的整体理念是一致的，所以，坚持使用那些你喜欢的环境中的应用是有道理的。但是，如果你想要处理掉一个不太合适的应用，并且不影响环境中的其他部分，你完全可以自由的去做。\n11. X系统中的一天 #下面是一个例子，在Linux系统的桌面环境中，一个典型的GNOME会话是怎样运行的。假设它们工作在X之上。\n当Linux系统启动X时，X server启动并初始化图形设备，然后等待客户端的应答。首先启动gnome-sessiong，并且设置工作会话。一个会话包括我同意打开的应用，它们在屏幕上的位置，等等。然后启动面板。面板通常出现在屏幕的底部，有点像桌面环境的仪表盘。我们可以用它来启动程序，看到正在运行的程序，还可以控制工作环境。然后，窗口管理器会启动。因为我们正在使用GNOME，无法确定是哪种窗口管理器，这里假设是Sawfish。最后，文件管理器启动。文件管理器负责处理桌面图标。至此，我的GNOME环境就完全准备好了。\n到目前为止，所有启动的程序都是客户端，都连接到了X server。现在我们看到的X server和client是在同一台计算机上，但是就像我们前面看到的，这不是必须的。\n现在，我们可以打开一个xterm来执行一些命令。当我们点击xterm图标时，面板会启动xterm程序。它是一个X client应用，所以，当它启动时会连接X server并显示它的界面。当X server为xterm分配屏幕空间时，它会让窗口管理器（Sawfish）为窗口装饰一个漂亮的标题栏，并决定它显示的位置。\n让我们用一下浏览器。点击面板上的Netscape图标，启动一个浏览器。这个浏览器可不是GNOME的设备，它用的是Gtk工具包。所以，它和桌面环境中的其它部分不是特别协调。\n接着打开“File”菜单。Motif在屏幕上提供了一个控制器，所以，Motif库的工作就是适当的调用相关的Xlib，为显示菜单在屏幕上绘制必要的元素，并且让我选择“exit”选项来关闭应用。\n现在我们打开一个Gnumeric电子表格。有些时候我需要用到xterm，所以我点击它。Sawfish检测到了我的动作，然后对现有的窗口做些改变，将xterm放在了最上层，并且将焦点移动到xterm上面，这样我就可以在它上面工作了。\n之后，我回到电子表格，想要打印这个文档。Gnumeric是一个GNOME应用，所以它可以使用GNOME环境提供的设备。当我打印时，Gnumeric调用gnome-print库，连接打印机并且打印。\n12. 版权和许可 #Copyright (c) 2001 by Daniel Manrique\n在自由软件社区发行的GNU Free Documentation License，Version1.1或之后版本的条款下（不包含不变章节、封面文字和封底文字），授予复制、发布和修改该文档的权限。在这里可以找到许可协议的衣服拷贝。\n","date":"2012 February 27","permalink":"/posts/2012/02/27/","section":"Posts","summary":"原文：","title":"X Window 架构概述"},{"content":"今天是年前最后一天上班，要在 Fedora7 下安装一款 USB 无线网卡—— TP-Link 的 WN321G+，该网卡使用的是 rt73 芯片，属于 Ralink 芯片组，安装过程中遇到了一下问题，最后总算成功了，记录一下。\n插上usb网卡，用 lsusb 命令就可以看到设备：\nBus 004 Drvice 003： ID 148f:2573 Ralink Technology,Corp fedora7 已经带了 rt73 的驱动，用如下命令即可加载：\nmodprobe rt73usb 可是加载了驱动后，网卡还是不能用，用 iwconfig 命令也没有看到无线网卡，用 dmesg 命令看到一条错误信息：\nError-connt read firmware 无法读取固件，原因不明。\n无奈只能下载在一个新的驱动，编译安装，驱动名称是：\nrt73-k2wrlz-3.0.3-3 下载地址： http://homepages.tu-darmstadt.de/~p_larbig/wlan/rt73-k2wrlz-3.0.3.tar.bz2\n下载后解压，按照README文件的描述进行编译安装：\ntar -xvf rt73-k2wrlz-3.0.3-3.tar.bz2 cd rt73-k2wrlz-3.0.3-3/Module make make install modprobe rt73 ifname=wlan0 安装成功。\n用 iwconfig 可以看到 wlan0 的相关信息，\n在 /etc/sysconfig/network-scripts 目录下添加 ifcfg-wlan0 文件，添加如下内容：\nDEVICE=wlan0 ONBOOT=yes ROOTPROTO=dhcp 保存，退出，用 ifup wlan0 命令启动网卡。\n用 iwlist wlan0 scan 可以看到可用的无线路由器。 用 iwconfig wlan0 ap [mac] 命令连接到可用的无线路由器的MAC地址。\n工作完成，开心回家。\nP.S.:\nmake 后可能会报 warning：Module file much too big，用 strip 压缩即可：\nstrip --strip-debug rt73.ko 原来 2.7M 的驱动文件压缩后只有200KB。\n最近发现该驱动不太稳定，经常会连不上无线路由，最终更换为芯片厂商 Ralink 提供的驱动。\n下载地址：http://www.ralinktech.com/en/04_support/support.php?sn=501\n文件名：2011_0210_RT73_Linux_STA_Drv1.1.0.5.bz2\n安装方法参考Readme文件。\n参考：\nWireless Setup：https://wiki.archlinux.org/index.php/Wireless_Setup\nrt73-k2wrlz-3.0.3-3：http://aur.archlinux.org/packages.php?ID=15377\nRt2x00 beta driver：https://wiki.archlinux.org/index.php/Using_the_new_rt2x00_beta_driver\n","date":"2012 January 17","permalink":"/posts/2012/01/17/","section":"Posts","summary":"今天是年前最后一天上班，要在 Fedora7 下安装一款 USB 无线网卡—— TP-Link 的 WN321G+，该网卡使用的是 rt73 芯片，属于 Ralink 芯片组，安装过程中遇到了一下问题，最后总算成功了，记录一下。","title":"在Fedora7下安装USB无线网卡TL-WN321G"},{"content":"环境：Redhat9.02\n启动级别：3\n1. 配置内核： #首先要再编译内核是选中如下几项：\nCode maturity level options ---\u0026gt;[*] Prompt for development and/or incomplete code/drivers Processor type and features ---\u0026gt;[*] MTRR (Memory Type Range Register) support Block Devices -\u0026gt;[*] Loopback device support [*] RAM disk support (4096) Default RAM disk size [*] Initial RAM disk (initrd) support Console Drivers -\u0026gt;[*] VGA text console [*] Videomode selection support Console Drivers -\u0026gt; Frame-buffer support -\u0026gt;[*] Support for frame buffer devices [*] VESA VGA graphics console [*] Use splash screen instead of boot logo 2. 配置Bootloader # Grub 修改/etc/grub.conf，在kernel项的最后添加vga参数和fb，例如：\nkernel /boot/vmlinuz-2.4.20-8 ro root=LABEL=/ vga=0x311 fb:on LILO\n修改/etc/lilo.conf，添加vga参数，例如：\nvga=0x311 修改后执行lilo命令，写入bootloader。\nvga参数的可选值如下：\n修改后重启系统，会在右上角看到一个Linux的企鹅Logo。\n","date":"2011 December 14","permalink":"/posts/2011/12/14/","section":"Posts","summary":"环境：Redhat9.02","title":"怎样设置Framebuffer"},{"content":"原文：\nHow To Create a GNU Autoconf / Automake Based Configure Script for Your Application\nhttp://www3.fh-swf.de/fbin/roth/download/prg3.howto_autoconfmake.pdf\nby Prof.Dr. Walter Roth\nUniversity of Applied Science Suedwestfalen, Germany\nTranslated by Bob\n2011-11-18\nEmail： gexbob@gmail.com\nBlog：http://shaocheng.li\n1. 本文档的基本信息 #1.1. 印刷 #有些字体比较难认，所以用下面这个表给出一些字符的图像，这对命令很重要。本文档用 Times New Roman 的 12 号字体写普通文本，用 Courier 的 11 号字体写命令行和源代码。注意：双线可能会画成一个比较长的单线\n1.2. 名词定义 #应用（Application）是指你开发的程序。\n目标系统（target system）是用于安装你的程序的计算机。\n开发系统（development system）是指开发程序所用计算机\n2. 为什么使用GNU AutoXXX Tools？ #使用 Autoconf 和 Automake 是唯一的（合理的）为你的应用创建 Makefile 的方法，只要你的应用工作在任何有 GNU 工具的系统上。GNU 工具可用于所有的 Unix、Windows（Cywin）和 MacOS 系统\n3. 它是如何工作的？ #GNU Autoconf 由多个程序组成，最终由它们为你的应用创建 Makefile。它会为源码的每个子目录创建一个 Makefile。由于Makefile 是针对特定的用户机器的（目标系统），也就是你的程序运行的系统，所以必须在用户机器上创建。目标系统的所有信息对于这个机器都是可用的。Makefile 是由冗长的脚步程序“configure”创建的，这个脚本必须随你的源代码一起提供。在目标系统上，configure 是根据它运行的一些测试结果来创建 Makefile 的，这些结果已经事先写在了 Makefile.am文件。Makefile 支持很多不同的目标，第一个就是“all”。make all 会为你的程序创建二进制文件。install 目标会安装这些二进制文件，uninstall 用于卸载。这样的话，用户就可以很方便的使用你的程序，只需应用的顶层目录上，运行如下三条命令即可：\n./configure make make install 第二条命令就相当于 make all，因为 all 是第一个目标。当然，目标系统必须有可用 make 工具和一个编译器。但是，这要用 configure 检查，如果 configure 没有找到所有它需要的程序，它会停止并返回错误信息。 可是，必须在你的系统上创建 configure 脚本，这是个非常复杂的任务。\n4. 你需要什么？ #首先，需要你的源码。确保处在顶层目录，并且包含了所有的文件，编译时不会报错。\n你可能要添加一些新文件，为你的应用提供一些必要的文档。下面这些文件是必须存在于顶层目录的：\nINSTALL：安装描述。你可以从其他基于automake的应用中拷贝一个标准的INSTALL文件，然后添加一些针对你的应用的信息。 README：用户应该知道的一些关于本应用的信息。最好在文件的开始处简单描述一些这个应用的目的 AUTHORS：作者列表。 NEWS：关于本应用的最新的新闻 ChangLog：本应用的修订历史 这些文件可以不包含任何内容，因此，第一次运行时，你可以只创建一些空文件。但是，这些文档对用户是很重要的。你应该花点时间好好的写了它们。README 文件是最重要的一个。让它尽可能的保护一些有用的信息。\n然后，当然是需要GNU工具。幸运的是，现在所有的Linux发行版都包含了GNU工具。你可以验证一些它们是否已经安装。要检查的话，只需键入：\nwhich automake 它会产生类似下面的结果：\n/usr/bin/automake 如果返回的是空行，很可能没有安装GNU工具。\n5. 一步一步为“Hello World”创建配置脚本 #5.1. 简评 #下面内容中的命令都用 Courier 字体。所有的命令都可以在普通用户中使用，无需变成 root 。例子中使用的应用叫做 myapplication，版本是 1.0。该应用只有一个文件夹“myapplication”，单一源文件 main.c。你要自己编辑源代码、文档、configure.ac 和 makefile.am 文件。其他的都可以自动生成。\n5.2. 准备源码 #进入应用的顶层目录。\ncd myapplication 建立前面提到的那些空文档文件，稍后再填写它们。\ntouch INSTALL README AUTHORS NEWS ChangeLog 5.3. 新建makefile.am #####5.3.1. 构建应用\nmakefile.am 包含了关于应用的信息，配置脚本需要这些信息来创建最终的 Makefile。必须建立一个 makefile.am，它的内容包括目标、源代码和应用的子目录。下面是 myapplication 的 makefile.am，没有子目录：\n##Process this file with automake to create Makefile.in bin_PROGRAMS = myapplication myapplication_SOURCES=main.c 第一行是默认的内容，每个 makefile.am 都可以使用。第二行列出了要建立和安装到目标系统的二进制程序文件。本例中只有一个 myapplication，它将被安装到 SuSe9.0 系统的 /usr/bin 目录下，这是一个默认目录。如果你要构建多于一个的程序，或要安装到其他目录，请查看第7章的 Automake 文档。\n第三行列出了该应用的所有源文件。第一个词是由应用名称和_SOURCES组成的。\n####5.3.2. 安装文件\nmakefile.am 不仅仅管理应用的构建过程，还定义了要安装到目标系统的文件的目标路径。automake已经提前定义了标准的安装目录，其中最重要的几个目录是：\nprefix ：安装目录树的顶层，标准是/usr/local(KDE是/opt/kde) binary ：二进制程序的目录 libexecdir ：程序的库的目录 还有更多的提前定义的目录，请阅读“The GNU Coding Startding”的目录变量（5）。安装到这些目录的文件会像下面这样被列出了：\nbin_PROGRAMS=myapplication myapplication文件将被放到一个bin目录下。\n如果你需要将某些文件安装到非标准目录下，就要自己定义。名字必须以dir作为后缀。例如：\nhtmldir=$(prefix)/html html 目录就会处于 prefix 之下。在 makefile.am 定义要安装的文件，如下：\nhtml_DATA=usermanual.html 除了标准目录,automake 还为个别包定义了目录：pkglibdir、pkgincludedir 和 pkgdatadir，可以用它们将你的文件安装到标准的bin、lib或data目录下的独立子目录。这些安装目录会用包的名字命名。\n并不是所有文件都要被最终安装。例如，图标（或图标），它们被编译到可执行文件后就不再需要了。但它们并不是真正的源文件。由于它们必须包含在最终的发布中，所有要把它们作为EXTRA_dist文件列出了。\n5.4. 新建configure.ac #注意：在比较早的 automake 和 autoconf 版本中，configure.ac 被叫做 configure.in。autoscan 工具会扫描你的源代码，然后创建一个默认的 configure.ac 初始文件。因此，你可以在源代码的顶层目录执行 autoscan，生成一个 configure.scan 文件作为 configure.ac 的模板。\nautoscan autoscan的执行结果大概是这样：\n# -*- Autoconf -*- # Process this file with autoconf to produce a configure script. AC_PREREQ(2.59) AC_INIT(FULL-PACKAGE-NAME, VERSION, BUG-REPORT-ADDRESS) AC_CONFIG_SRCDIR([config.h.in]) AC_CONFIG_HEADER([config.h]) # Checks for programs. AC_PROG_CXX AC_PROG_CC AC_PROG_CPP AC_PROG_INSTALL AC_PROG_LN_S AC_PROG_MAKE_SET AC_PROG_RANLIB # Checks for libraries. # Checks for header files. # Checks for typedefs, structures, and compiler characteristics. AC_HEADER_STDBOOL AC_C_CONST # Checks for library functions. AC_CONFIG_FILES([Makefile src/Makefile]) AC_OUTPUT 编辑 configure.scan 文件，修改下面这几行：\nAC_INIT(FULL-PACKAGE-NAME, VERSION, BUG-REPORT-ADDRESS) 用你的应用的名字替换 FULL-PACKAGE-NAME ，VERSION 就是它的版本号。BUG-REPORT-ADDRESS 应该设一个 Email 地址，以便报告 Bug。例如：\nAC_INIT(myapplication,1.0) 接下来添加一行，来调用 automake。\nAM_INIT_AUTOMAKE(@PACKAGE_NAME@, @PACKAGE_VERSION@) 这一行使用 PACKAGE_NAME 和 PACKAGE_VERSION变量，它们都是 AC_INIT 中定义过的，最终会传递给 automake。@ 表示它包含字符串的是一个变量标识符。没有用 @ 的字符串直接按字面传递，结果包含在 PACKAGE_NAME_PACKAGE_VERSION 。\nAC_CONFIG_SRCDIR 用于检测源代码目录下的 config.h 文件。AC_CONFIG_HEADER 表示你想要使用一个配置头文件。\n下面的宏用于检测构建应用所需的各种程序，把你需要用在目标系统上的程序都添加到这里。\n在 typedefs 这一组，你可以检测目标机器上的系统的特殊属性。AC_HEADER_STDBOOL 是 autoscan 为本例添加的，用于检测 stdbool.h 的可用性和 C99 的 bool 类型是否存在。AC_C_CONST 用于检测例程所需的常量机制。\n最后，你可以在 AC_CONFIG_FILES 中指定所有你想要配置生成的 makefile 文件，这些文件将由 AC_OUTPUT 输出，通常将它卸载文件的最后一行。\n5.5. 新建config.h.in #运行 autoheader 可以根据 configure.ac 文件创建一个 config.h.in。如果你想要指定 config.h 中包含 #define，必须在 configure.ac 中定义。查看 autoconf 文档中的 AC_CONFIG_HEADER。\nautoheader 这样就会建立 config.h 文件，文件的内容是用预处理描述应用程序的代码。下面这段文本是例程的 config.h.in 文件的一部分。\n/* config.h.in. Generated from configure.in by autoheader. */ * Define to 1 if stdbool.h conforms to C99. */ #undef HAVE_STDBOOL_H /* Define to 1 if the system has the type `_Bool'. */ #undef HAVE__BOOL /* Name of package */ #undef PACKAGE /* Define to the address where bug reports for this package should be sent. */ #undef PACKAGE_BUGREPORT /* Define to the full name of this package. */ #undef PACKAGE_NAME /* Define to the full name and version of this package. */ #undef PACKAGE_STRING /* Define to the one symbol short name of this package. */ #undef PACKAGE_TARNAME /* Define to the version of this package. */ #undef PACKAGE_VERSION /* Define to 1 if you have the ANSI C header files. */ #undef STDC_HEADERS /* Version number of package */ #undef VERSION /* Define to empty if `const' does not conform to ANSI C. */ #undef const 5.6. 新建aclocal.m4 #很幸运有一个程序可以完成这个工作。只需执行：\naclocal 这样就创建了 aclocal.m4 文件。文件中包含了 autoconf 的宏，它们可以用在你的机器上。文件包含了宏的完整源代码，所以很长。如果没有在你的机器上找到所有的宏，可以尝试从 autoconf 的宏档案（www.gnu.org/software/ac-archive）中找一找。这里有很多宏，可以解决你遇到的大部分问题。另外，还有 BNV_HVE_QT 用于检测 Qt 库，MDL_HAVE_OPENGL 用于检测 OpenGL。\n如果没有找到你所需的宏，就不得不自己去写了。“Goat book”（1）会告诉你怎么做。\n5.7. 新建configure #现在，autoconf 就可以用 autoconfig.ac 和 aclocal.m4 创建一个配置脚本了。只需运行：\nautoconf 这样会产生一个配置脚本，对于一个GUI应用，可能超过2000行。\n5.8. 新建makefile.in #makefile.in 包含很多从 makefile.am 自动添加的信息。makefile.in 是配置脚本最终创建 Makefile 所必须的。很幸运的是，automake 程序可以为你完成这个工作。可是，一些应用程序发布包所必须的文件还没有添加到应用的顶层目录。如果你运行下面的命令，automake 将从GNU工具中拷贝这些文件，然后创建 makefile.in：\nautomake -a 或\nautomake --add-missing 5.9. 测试包 #现在，配置脚本已经准备好了，可以在任何 GNU 支持系统上创建 Makefile。configure 接受很多命令行参数。运行 ./configure 可以得到一个概述。最重要的参数可能是 \u0026ndash;enable-FEATURE ，这里的 FEATURE 有很多选择。对于程序开发而言，经常要用到 \u0026ndash;enabl-debug=full 来选择调试。对于用户，\u0026ndash;prefix 和 \u0026ndash;with-LIBRARY-dir 可以控制很多安装路径。先试一下不用任何参数运行 configure。会在源码的顶层目录产生一个 Makefile ，prefix 设为 /usr/local。只需键入：\n./configure 你将看到很多 check\u0026hellip; 信息，最后结束时会出现在类似下面的信息：\nconfigure: creating ./config.status config.status: creating makefile config.status: creating config.h config.status: config.h is unchanged config.status: executing depfiles commands 然后，测试一下新的 makefile：\nmake 应该会没有任何错误的编译应用。注意，不要用 root 用户运行 make install，否则会将程序安装到默认的 prefix 下，那很可能是一个错误的地址。运行如下命令就能将应用安装到默认的 prefix：\nmake install 只要你不是 root，将看到很多错误信息，这是因为没有写的权限。用普通用户运行 make install 的话，对于寻找安装的文件会很有用。\n你的 Makefile 支持所有的标准的目标，例如 clean、dist、uninstall 等等。 要得到一个程序的开发版本，需要重新运行 configure，生成一个支持调试的 makefile。\n./configure --enable-debug=full 然后运行：\nmake 这样，编译的程序就包含了调试信息。因此，可执行文件也会比之前编译的大很多。现在你就可以在调试器中运行你的程序了。\n6. 比较复杂的应用 #6.1. 带有子目录的应用 #你需要在顶层目录（myapplication）和每个子目录（src、doc、img）都有一个makefile.am。像myapplication/CVS这样的子目录不算发布包的一部分，必须跳过。相应目录的直接子目录必须像下面这样在 makefile.am 中列出了：\nSUBDIRS = subdir1 subdir2 subdir3 不需要在SUBDIRS中指定子目录下的目录。每个子目录下的makefile.am只需指定本目录下的直接子目录。\n例如，顶层目录是myapplication，CVS子目录用于管理CVS，src是源码，doc是文档，img是图片，myapplication 目录下的顶级 makefile.am 就应该是这样：\n##Process this file with automake to create Makefile.in SUBDIRS = src doc img 提供一个好主意，为大多数 autoXXX 工具创建和使用的文件使用用一个叫做 admin 的单独目录。这会使顶层目录更具可读性。你要做的就是在AC_INIT后面直接添加：\nAC_CONFIG_AUX_DIR(admin) 然后在手动创建一个 admin 目录，它就可以被 automake 使用了。\nmkdir admin 源文件通常被列在 myapplication_SOURCES 列表。但是，这次的源文件在 src 目录下，所以要把它们列在 myapplication/src/makefile.am 文件中。二进制文件列表 bin_PROGRAMS 也在这个文件中指定。如下：\n##Process this file with automake to create Makefile.in bin_PROGRAMS = myapplication myapplication_SOURCES = main.c 对于其他的非源代码文件，如果想将它们包含在发布包中，就必须作为 EXTRA_DIST 文件列出。如果 doc 目录中包含一个 index.html 文件，你必须将它添加到 myapplication/doc/makefile.am 文件的 EXTRA_DIST 列表中：\n##Process this file with automake to create Makefile.in EXTRA_DIST = index.html page1.html 下面是 myapplication/img 目录下的 makefile.am 文件：\n##Process this file with automake to create Makefile.in EXTRA_DIST = image1.png image2.bmp 运行 autoscan，并按照3.3节描述的那样编辑 configure.scan 文件。在文件末尾的 AC_CONFIG_FILES 宏中为每个要包含在发布包的子目录列一个 makefile 文件。在顶层目录（myapplication）下运行：\naclocal autoconf autoheader automake -a 那么，automake 将为每个 makefile.in 创建一个 makefile.am。\n6.2. 库的应用 #####6.2.1. 静态库\n静态库的构建很像应用，可是，目标要用 _LIBRARIES 变量指定。mylib 库可以用下面的这些方式指定：\n如果它要被安装在全局库目录下（默认：/usr/lib）：\nlib_LIBRARIES = mylib.a 如果它要被安装在应用的lib目录下（默认：/usr/myapplication/lib）：\npkglib_LIBRARIES = mylib.a 如果它只是在构建的过程中使用，不需要安装：\n[python] view plaincopy noinst_LIBRARIES = mylib.a ####6.2.2. 共享库\n构建共享库是一个比较复杂的问题，你最好参考一下 automake 和 libtool 的文档。这里介绍一种简单情况下工作方式：对于用 libtool 构建的库使用 _LTLIBRARIES 宏。库的名字要以 lib 开头并以 .la 结尾（例如libmylib.la）。使用 _SOURCES宏 时，la 前面的点(.)必须用下划线(_)代替。对于要安装到 lib 目录下的 mylib 库来说，它的宏可以这样写：\nlib_LTLIBRARIES = libmylib.la libmylib_la_SOURCES = mylib.c 在 configure.ac 文件中的 AC_PROG_CC 后面添加 AC_PROG_LIBTOOL 宏。这样的话，autoconf 就会为 configure 脚本增加 libtool 支持。\n运行 automake 之前，先运行 libtoolize，会添加一些 automake 所需的文件。\n7. 参考文献 # Gary Vaughan, Ben Elliston, Tom Tromey, Ian Taylor: “GNU Autoconf, Automake and Libtool”, New Riders Publishing, 2000, also available online at http://www.gnu.org GNU Automake:http://www.gnu.org/software/automake/manual/automake.html GNU Autoconf:http://www.gnu.org/software/autoconf/manual/autoconf-2.57/autoconf.html Libtool The GNU Coding Standards:http://www.gnu.org/prep/standards/standards.html\u0026gt; ","date":"2011 November 21","permalink":"/posts/2011/11/21/","section":"Posts","summary":"原文：","title":"使用GNU Autoconf/Automake创建Makefile"},{"content":"原文：\nGuide for pkg-config:http://people.freedesktop.org/~dbn/pkg-config-guide.html\nDan Nicholson\nTranslated By Bob\n2011-11-13\nEmail: gexbob@gmail.com\nBlog:http://shaocheng.li\n概述 #这个文档的目的是从用户和开发者的角度给一个 pkg-config 工具的使用概述。本文复习一些 pkg-config 背后的概念，怎样写 pkg-config 文件来支持你的项目，以及怎样用 pkg-config 集成第三方项目。\n关于 pkg-config 的更多信息可以在 web 站点和 pkg-config 的 man 手册中找到。\n本文档假的 pkg-config 在类UNIX操作系统中使用，例如 Linux。其他平台可能在一些细节上的存在差别。\n为什么？ #现代计算机系统使用了很多分层组件为用户提供应用。其中一个困难就是如何正确的整合这些组件。pkg-config 会收集系统中安装的库的数据，然后提供给用户。\n如果没有 pkg-config 这样的数据系统，定位计算机提供的服务和获取它们的细节会很困难。对于开发者，安装软件包的 pkg-config 文件极大的简化了对 API 的获取。\n一些概念 #使用 pkg-config 的初级阶段是为编译和链接程序时提供必要的细节。数据存储在 pkg-config 文件中。这些文件有一个 .pc 的后缀，放在一个特定的、pkg-config 工具所知道的位置。我们会在后面描述更多的细节。\n这个文件的格式包括预定义的关键字和自由形式的变量。例如：\nprefix=/usr/local exec_prefix=${prefix} includedir=${prefix}/include libdir=${exec_prefix}/lib Name: foo Description: The foo library Version: 1.0.0 Cflags: -I${includedir}/foo Libs: -L${libdir} -lfoo 以预定义关键字 Name：为例，以关键字开头，后面跟一个冒号和一个值。变量是一个字符串和一个值，例如 prefix= ，用等号分开。关键字是由 pkg-config 定义和输出的。变量不是必须的，但可以被关键字用来定位和存储 pkg-config 没有覆盖的数据。\n这里只是简单的描述一下关键字。更深入的描述和怎样有效的使用它们将在“写pkg-config文件”段中给出。\n**Name：**一个人们可读的链接库或软件包的名称，这不影响pkg-config的使用，它用的是.pc文件的名称。\n**Description：**关于软件包的简单描述。\n**URL：**一个URL，可以在那里获得更多的信息，并且下载这个软件包。\n**Version：**软件包的版本。\n**Requires：**这个软件包所需的包的列表。这些包的版本可能用一写运算符来指定：=、\u0026gt;、\u0026lt;、\u0026gt;=、\u0026lt;=。\n**Requires.private：**这个软件包所需的私有包的列表，不会暴露给应用。版本的指定规则与Requires相同。\n**Conflicts：**可选，描述了会与这个软件包产生冲突的包。版本的指定规则与Requires相同。这个域会提供同一个包的多个实例，例如：Conflicts: bar \u0026lt; 1.2.3, bar \u0026gt;= 1.3.0。\n**Cflags：**为这个软件包指定编译器选项，以及pkg-config不支持的必要的库。如果所需的库支持pkg-config，应该将它们添加到Requires和Requires.private。\n**Libs：**为这个软件包指定的链接选项，以及pkg-config不支持的必要的库。与Cflags的规则相同。\n**Libs.private：**这个软件包所需的私有库的链接选项，不会暴露给应用。规则与Cflags相同。\n写pkg-config文件 #为一个软件包创建 pkg-config 时，首先要确定怎样描述它。一个文件最好只用于描述一个库，所以，每个软件包至少需要像它所需的链接库那么多的 pkg-config 文件。\n软件包的名字是由 pkg-config 数据文件的名字确定的。就是文件名去掉 .pc 后缀的那一部分。通常都用库的名字命名 .pc 文件。例如，一个安装 libfoo.so 的包会有一个相应的 libfoo.c 文件来包含 pkg-config 数据。这不是必须的，.pc 文件仅仅是一个对你的库的唯一标识符。所以，foo.pc 或 foolib.pc 也能正常工作。\nName、Description 和 URL 的值是纯粹的信息，容易填写。Version 比较棘手，它要确保这个包可以被用户使用。pkg-config 使用 RPM 算法来进行版本比较。Version 最好是用点分开的十进制数字，例如 1.2.3，因为字母可能引起意外的结果。数字应该是单调递增的，并且要竟可能具体的描述这个库。通常使用包的版本号即可，这样可以方便使用者跟踪。\n在描述更多的有用的关键字之前，有必要展示一下变量的定义。最常见的用法是定义安装路径，这样就不会使其他字段显得杂乱。因为变量是扩大递归的，在结合 autoconf 派生路径时，这会很有用。\nprefix=/usr/local includedir=${prefix}/include Cflags: -I${includedir}/foo 最重要的 pkg-config 数据字段是 Requires，Requires.private，Cflags，Libs 和 Libs.private 。它们定义的数据被外部项目用来编译和链接库。\nRequires 和 Requires.private 定义了库所需的其他模块。通常首选 Requires.private，以便避免程序链接到一些不必要的库。如果一个程序不使用所需库的符号，它就不应该直接链接到这个库。可以在 overlinking 的讨论中看到更多详细的解释。\n由于 pkg-config 通常会公开 Requires 库的链接标识，这些模块会变成程序的直接依赖。另外，Requires.private 中的库只有在静态链接是才会被包含。正因如此，pkg-config 通常只会适当的从 Requires 中的同一个包中添加模块。\nLibs 包含了使用库是所必须的链接标识。此外，Libs 和 Libs.private 还包含了 pkg-config 不支持的库的链接标识。与 Requires 类似，首选将外部库的链接标识添加到 Libs.private，这样，程序就不会获得额外的直接依赖。\n最后，Cflags 包含了所用的库的编译标识。与 Libs 不同，Cflags 没有私有变种。这是因为，数据类型和宏定义在任何链接情况下都是需要的。\n使用pkg-config文件 #假设系统中已经安装了 .pc 文件，pkg-config 工具就被用来提取其中的数据。执行 pkg-config \u0026ndash;help 命令可以看到一些关于命令选项的简单描述。深入的描述可以在 pkg-config（1）的 man 手册页中找到。本地将对一些常见的用法进行简单的描述。\n假设系统中已经有了两个模块：foo和bar。它们的.pc文件可能像下面这样：\nfoo.pc: prefix=/usr exec_prefix=${prefix} includedir=${prefix}/include libdir=${exec_prefix}/lib Name: foo Description: The foo library Version: 1.0.0 Cflags: -I${includedir}/foo Libs: -L${libdir} -lfoo bar.pc: prefix=/usr exec_prefix=${prefix} includedir=${prefix}/include libdir=${exec_prefix}/lib Name: bar Description: The bar library Version: 2.1.2 Requires.private: foo \u0026gt;= 0.7 Cflags: -I${includedir} Libs: -L${libdir} -lbar 模块的版本可以用 \u0026ndash;modversion 选项获得。\n$ pkg-config --modversion foo 1.0.0 $ pkg-config --modversion bar 2.1.2 要打印模块的链接标识，就用 \u0026ndash;libs 选项。\n$ pkg-config --libs foo -lfoo $ pkg-config --libs bar -lbar 请注意，pkg-config 压缩了两个模块 Libs 字段。这是因为 pkg-config 对 -L 标识有特殊处理，它知道 ${libdir} 目录 /usr/lib 是系统链接器搜素路径的一部分。也就是 pkg-config 受到了链接器选项的影响。\n还有就是，虽然 foo 是 bar 所需要的，但是没有输出 foo 的链接标识。这是因为，只使用 bar 库的应用并不直接需要 foo。对应静态链接 bar 的应用，我们需要两个链接标识:\n$ pkg-config --libs --static bar -lbar -lfoo 这种情况下，pkg-config就要输出两个链接标识，这样才能保证静态链接的应用可以找到所有必须的符号。另一方面，它会输出所有的Cflags字段。\n$ pkg-config --cflags bar -I/usr/include/foo $ pkg-config --cflags --static bar -I/usr/include/foo 还有一个有用的选项，\u0026ndash;exists，可以用来测试模块的可用性。\n$ pkg-config --exists foo $ echo $? 0 最值得注意的 pkg-config 特性是它所提供的版本检测，可以用来确定某个版本是否可用。\n$ pkg-config --exists foo $ echo $? 0 有些命令在结合 \u0026ndash;print-errors 选项使用时可以输出更详细的信息。\n$ pkg-config --exists --print-errors xoxo Package xoxo was not found in the pkg-config search path. Perhaps you should add the directory containing `xoxo.pc' to the PKG_CONFIG_PATH environment variable No package 'xoxo' found 上面的信息出现了 PKG_CONFIG_PATH 环境变量。这个变量用来配置 pkg-config 的搜索路径。在类 Unix 操作系统中，会搜索 /usr/lib/pkconfig 和 /usr/share/pkgconfig 目录。这通常已经覆盖了系统已经安装的模块。但是，有些本地模块可能安装在了其他路径，例如 /usr/local 。这种情况下，需要指定搜索路径，以便 pkg-config 可以定位 .pc 文件。\n$ pkg-config --modversion hello Package hello was not found in the pkg-config search path. Perhaps you should add the directory containing `hello.pc' to the PKG_CONFIG_PATH environment variable No package 'hello' found $ export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig $ pkg-config --modversion hello 1.0.0 autoconf也提供了一些宏，可以将pkg-config集成到项目中。\nPKG_PROG_PKG_CONFIG([MIN-VERSION])：定位系统中的 pkg-config 工具，并检测版本兼容性。 PKG_CHECK_EXISTS(MODULES,[ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])：检测指定的模块是否存在。 PKG_CHECK_MODULES(VARIABLE-PREFIX,MODULES, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND]):：检测指定的模块是否存在，如果存在，就根据 pkg-config \u0026ndash;cflags 和 pkg-config \u0026ndash;libs 的输出设置 \u0026lt;VARIABLE-PREFIX\u0026gt;_CFLAGS and \u0026lt;VARIABLE-PREFIX\u0026gt;_LIBS。 常见问题 # 我的程序使用了x库，我该怎么做？ pkg-config 的输出可以在编译命令中使用，假设 x 库已经有了一个叫做 x.pc 的 pkg-config 文件：\ncc `pkg-config --cflags --libs x` -o myapp myapp.c 将 pkg-config 集成到 autoconf 和 automake 中使用会更强大。但是，用 PKG_CONFIG_PATH 宏可以很容易的在建立过程中访问元数据。\nconfigure.ac: PKG_CHECK_MODULES(\\[X], [x]) Makefile.am: myapp_CFLAGS = $(X_CFLAGS) myapp_LDADD = $(X_LIBS) 如果找到了 x 模块，宏会填充和替代 X_CFLAGS和X_LIBS变量。如果没有找到，会产生错误。配置 PKG_CHECK_MODULES 的第3、4个参数，可以控制没有找到模块时的动作。\n我的 z 库安装了保护 libx 头的头文件。我应该在 z.pc 中添加什么？\n如果 x 库支持 pkg-config，将它添加到 Requires.private 字段。如果不支持，就配置 Cflags 字段，添加一些使用 libx 头时所需的编译器标识。在这两种情况下，无论是否使用了\u0026ndash;static，pkg-config 都会输出编译器标识。\n我的 z 库内部使用了 libx，但是不能再公开 API 中暴露libx的数据类型。我应该在 z.pc 中添加什么？\n同样的，如果 x 支持 pkg-config，就把它添加到 Requires.private 。这种情况下，就没必要发出编译器标识，但是在今天链接时要确保有链接器标识。如果 libx 不支持pkg-config ，就将必要的链接器标识添加到 Libs.private。\nDan Nicholson \u0026lt;dbn.lists (at) gmail (dot) com\u0026gt;\nCopyright (C) 2010 Dan Nicholson.\nThis document is licensed under the GNU General Public License, Version 2 or any later version.\n","date":"2011 November 19","permalink":"/posts/2011/11/19/","section":"Posts","summary":"原文：","title":"pkg-config指南"},{"content":"概述 #最近要将 Redhat9.02 移植到一块嵌入式 586 的主板上，空间有限，还要有图形环境，支持中文。所以，要建立一个精简的图像环境，先选择 TinyX+GTK 的方式进行研究。TinyX 是 XFree86 针对嵌入式的编译选项，体积小，启动速度快。 本文使用虚拟机 vmware 安装 Redhat-9.02 文本系统，然后用 XFree86-4.3.0 编译 TinyX ，最后编译 GTK+-2.0。\n1. 安装Redhat-9.02 #在 vmware 上新建一个虚拟机，硬盘空间为 4GB，内存 512MB。开始安装 Redhat-9.02，选择 linux text 模式，中文安装语言，swap 分区为 512MB，其余空间都挂载到根目录下。bootloader 用 Grub，自定义安装软件包，选择的软件包如下：\nAdministration tools Development Tools Editors Ftp Server Kernel Development NetWork Server Printing Support Server Configuration Tools Sound and Video System Tool 选择系统支持的语言为 Chinese+English。\n安装后将 /etc/sysconfig/ 下的 i18n 文件修改如下：\nLC_CTYPE=\u0026quot;zh_CN.GB2312\u0026quot; SUPPORTED=\u0026quot;zh_CN.GB2312:en_US.UTF-8:en_US:en\u0026quot; SYSFONT=\u0026quot;latercyrheb-sun16\u0026quot; SYSFONTACM=\u0026quot;iso01\u0026quot; 2. 编译libpng-1.2.16 #编译 TinyX 时需要 png.h 文件，所以要重新安装 libpng。先删除原有的 libpng：\nrm -rf /usr/lib/libpng* 下载 libpng-1.2.16.tar.bz2 ，复制到 /root 目录下解压：\ntar -xvjf libpng-1.2.16.tar.bz2 源码包中的 README 和 INSTALL 文件有关于 libpng 的详细信息和编译安装方法，用如下命令编译安装：\ncd /root/libpng-1.2.16 ./configure make make install 默认安装在 /usr/local/ 目录下，支持 pkg-config，pkg-config 文件放在 /usr/lib/pkg-config/ 目录下。如果想卸载 libpng，执行：make uninstall。\n3.编译freetype-2.2.1 #删除原有的 freetype：\nrm -rf /usr/lib/libfreetype* 下载 freetype-2.2.1.tar.gz：http://download.savannah.gnu.org/releases/freetype/\n复制到 /root/ 目录下解压：\ntar -xvzf freetype-2.2.1.tar.gz 编译、安装：\ncd /root/freetype-2.2.1 ./configure make make install 默认安装到 /usr/local/ 目录下，支持 pkg-config。\n4.编译TinyX #先删除原系统的 X-window：\nrm -rf /usr/X11R6 rm -rf /etc/X11 下载XFree86-4.3.0：ftp://ftp.xfree86.org/pub/XFree86/4.3.0/，共下载7个软件包：\nX430src-1.tgz X430src-2.tgz X430src-3.tgz X430src-4.tgz X430src-5.tgz X430src-6.tgz X430src-7.tgz 全部复制到 /root 下解压，解压后的源码都会放在 /root/xc 目录下。\n先编译一个 lndir 工具：\ncd /root/xc/config/util make -f Makefile.ini lndir cd ../../../ 用 lndir 制作一个源文件的符号链接目录：\nmkdir build cd build ../xc/config/util/lndir ../xc 用 TinyX.cf 的配置安装：\ncd config/cf cp -arf TinyX.cf host.def 修改 host.def 为：\n#define KDriveXServer YES #define TinyXServer YES #define XfbdevServer YES #define BuildLBX YES #define BuildFonts YES #define BuildAppgroup NO #define BuildDBE NO #define BuildXCSecurity YES #define FontServerAccess NO #undef BuildXF86RushExt #define BuildXF86RushExt NO #undef BuildRender #define BuildRender YES #define UseRgbTxt YES #define BuildFontServer NO 然后：\ncd ../../ touch xf86Date.h touch xf86Version.h make World make install 主要的库、头文件、可执行文件和配置文件等都安装了在 /etc/X11 和 /usr/X11R6 下。\nTinyX 依赖于 framebuffer，要打开 framebuffer。修改 /etc/grub.conf 文件，在 kernel 一行添加：\nvga=0x311 fb：on 0x311为640x480，16bpp。 然后重启系统，启动时，屏幕左上方会出现一个企鹅 Logo。\n重启后运行 /usr/X11R6/bin/Xfbdev，即可启动 Xserver，可以看到灰色背景上有一个 X 形的鼠标。 为 Xfbdev 建立一个符号链接：\nln -s Xfbdev X 这样就可以用startx命令启动 X-window。用Ctrl+Alt+Backspace组合键退出X-window。\n这里可能出现加载链接库的错误，查看 /etc/ld.so.conf 文件中是否有 /usr/X11R6/lib，然后执行 ldconfig -v。\n5.设置pkg-config #在 /root/.bashrc 文件中添加 PKG_CONFIG_PATH 环境变量：\nexport PKG\\_CONFIG\\_PATH=/usr/local/lib/pkgconfig:/usr/X11R6/lib/pkgconfig 6.编译Glib-2.0 #先删除原有的 glib：\nrm -rf /usr/lib/libglib* rm -rf /usr/lib/libgmoudle* rm -rf /usr/lib/libgobject* rm -rf /usr/lib/gthread* 下载 glib-2.0.0.tar.bz2：http://ftp.gnome.org/pub/gnome/sources/glib/2.0/\n复制到/root/目录下解压：\ntar -xvjf glib-2.0.0.tar.bz2 编译、安装：\ncd /root/glib-2.0.0 ./configure make make install 默认安装到/usr/local/目录下，支持pkg-config。\n7.编译atk-1.0.0 #删除原有的 atk：\nrm -rf /usr/lib/libatk* 修改 /etc/ld.so.conf 文件，添加：\n/usr/local/lib 下载 atk-1.0.0.tar.bz2：http://ftp.gnome.org/pub/gnome/sources/atk/1.0/\n复制到/root/目录下解压：\ntar -xvjf atk-1.0.0.tar.bz2 编译、安装：\ncd /root/atk-1.0.0 ./configure make make install 默认安装到 /usr/local/ 目录下，支持 pkg-config。\n8.编译pango-1.0.0 #删除原有的pango：\nrm -rf /usr/lib/libpango* rm -rf /usr/lib/pango 下载pango-1.0.0.tar.bz2：http://ftp.gnome.org/pub/gnome/sources/pango/1.0/\n复制到 /root/ 目录下解压：\ntar -xvjf pango-1.0.0.tar.bz2 编译、安装：\ncd /root/pango-1.0.0 ./configure make make install 默认安装到 /usr/local/ 目录下，支持 pkg-config。\n9.编译libjpeg-6b #删除原有的 libjpeg：\nrm -rf /usr/lib/libjpeg* 下载libjpeg-6b.tar.gz：http://jaist.dl.sourceforge.net/project/cross-stuff/cross-stuff/1.0/libjpeg-6b.tar.gz\n复制到 /root/ 目录下解压：\ntar -xvzf libjpeg-6b.tar.gz 编译、安装：\ncd /root/libjpeg-6b ./configure --enable-shared make make install 默认安装到/usr/local/目录下。\n10.编译gtk+-2.0 #删除原有的gtk:\nrm -rf /etc/gtk* rm -rf /etc/gnome rm -rf /usr/bin/*gtk* rm -rf /usr/lib/libgtk* rm -rf /usr/lib/gtk* 下载gtk+-2.0.0.tar.bz2：http://ftp.gnome.org/pub/gnome/sources/gtk+/2.0/\n复制到/root/目录下解压：\ntar -xvjf gtk+-2.0.0.tar.bz2 编译、安装：\ncd /root/gtk+-2.0.0 ./configure --without-libtiff make make install 默认安装到/usr/local/目录下，支持pkg-config。\n11.测试 #运行 startx，可以启动 X-window。 然后运行gtk-demo，可以启动 gtk-demo 程序。 编写 demo.c 文件：\n#include \u0026lt;gtk/gtk.h\u0026gt; char *_(char *c) { return(g_locale_to_utf8(c,-1,0,0,0)); } int main(int argc,char *argv[]) { GtkWidget *window; gtk_init(\u0026amp;argc,\u0026amp;argv); window = gtk_window_new(GTK_WINDOW_TOPLEVEL); gtk_window_set_title(GTK_WINDOW(window),_(\u0026quot;中文窗口\u0026quot;)); //定义窗口的标题 gtk_window_set_default_size(GTK_WINDOW(window),200,200); //设置窗口的大小 gtk_window_set_position(GTK_WINDOW(window),GTK_WIN_POS_MOUSE); //设置窗口显示的位置为鼠标的位置 gtk_widget_show(window); gtk_main(); return 1; } 编译：\ngcc -Wall -o demo demo.c `pkg-config --cflags --libs gtk+-2.0` 执行：\n./demo 效果：\n","date":"2011 November 15","permalink":"/posts/2011/11/15/","section":"Posts","summary":"\u003ch2 id=\"概述\" class=\"relative group\"\u003e概述 \u003cspan class=\"absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100\"\u003e\u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\" style=\"text-decoration-line: none !important;\" href=\"#%e6%a6%82%e8%bf%b0\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e\u003c/h2\u003e\u003cp\u003e最近要将 Redhat9.02 移植到一块嵌入式 586 的主板上，空间有限，还要有图形环境，支持中文。所以，要建立一个精简的图像环境，先选择 TinyX+GTK 的方式进行研究。TinyX 是 XFree86 针对嵌入式的编译选项，体积小，启动速度快。\n本文使用虚拟机 vmware 安装 Redhat-9.02 文本系统，然后用 XFree86-4.3.0 编译 TinyX ，最后编译 GTK+-2.0。\u003c/p\u003e","title":"在Redhat9下构建TinyX+GTK图形环境"},{"content":"原文：\nBuilding XFree86 from a Source Distribution\nhttp://www.xfree86.org/4.3.0/BUILD.html\n26 February 2003\nTranslated By Bob\nEmail： gexbob@gmail.com\nBlog：http://shaocheng.li\n这个文档描述了怎样从源代码发行版构建XFree86，要结合特定操作系统的README文件来使用它。\n注：构建XFree86之前，最好参考特定操作系统的README文件，这些文件包含了在你的操作系统下成功构建XFree86所需的详细信息。\n我们强烈推荐使用GCC构建XFree86，但是通常也可以使用各个平台的本地编译器。\n1. 怎样得到XFree86 4.3.0 的源码 #推荐的方法是从 XFree86 的 CVS 库中获取 XFree86 4.3.0 的源码。有多种途径可以做到这一点，可以在我们的 CVS 页面找到 xf-4.3.0 发行版的标签。\n另一个途径是在 XFree86 的 FTP 站点下载 4.3.0 的 tar 格式源码包。步骤如下：\nXFree86 4.3.0的源码包含在 X430src-1.tgz, X430src-2.tgz, X430src-3.tgz, X430src-4.tgz,X430src-5.tgz, X430src-6.tgz 和 X430src-7.tgz 中。这些文件可以在 ftp://ftp.xfree86.org/pub/XFree86/4.3.0/source/ 或 XFree86 站点的类似地址中找到。X430src-4.tgz 和 X430src-5.tgz包含了字体，X430src-6.tgz 和 X430src-7.tgz 包含了文档。X430src-1.tgz, X430src-2.tgz 和 X430src-3.tgz 包含了其他所有的东西。如果你不需要字体和文档，可以只下载 X430src-1.tgz, X430src-2.tgz 和 X430src-3.tgz。\n运行下面的命令解压每个文件，确保足够的空间，全部源码大约需要305M，还要一些空间编译二进制文件。\ngzip -d \u0026lt; X430src-1.tgz | tar vxf - gzip -d \u0026lt; X430src-2.tgz | tar vxf - gzip -d \u0026lt; X430src-3.tgz | tar vxf - gzip -d \u0026lt; X430src-4.tgz | tar vxf - gzip -d \u0026lt; X430src-5.tgz | tar vxf - gzip -d \u0026lt; X430src-6.tgz | tar vxf - gzip -d \u0026lt; X430src-7.tgz | tar vxf - 如果你已经有了一份 XFree86 4.2.0 源码的拷贝，可以从 ftp://ftp.xfree86.org/pub/XFree86/4.3.0/patches/ 下载补丁来升级到 4.3.0 。补丁的下载和使用信息可以在这个发行版的R EDAME 文件的 “How to get XFree86” 段找到。 所有的方法都将产生一个主源码目录，叫做 xc 。\n2. 构建之前先配置源码 #在大多数情况下，没有必要做任何配置。\n如果你确实想要改变配置，建议你先进入 xc/config/cf 目录，复制 xf86site.def 为 host.def。然后通过阅读 host.def 文件，根据你的配置设置你想要的参数。你也可以通过查看 .cf 文件，找出针对你的操作系统的默认设置。\n通常遵循的规则是，只修改你理解的选项，并且有好的修改原因。修改默认配置容易产生一些问题。很多配置选项记录在 xc/config/cf/README。\n如果你只使用源代码的 x430src-1.tgz,x430src-2.tgz 和 x430src-3.tgx 部分，你需要定义 BuildFonts 为 NO。\n3. 使用符号链接的目录来构建 #推荐的做法是，用一个符号链接的目录来构建 XFree86。这样可以保证源代码目录在构建过程中不被修改，还有以下好处：\n当使用 CVS 维护源码树的更新时，更新进程不会被非 CVS 控制的文件所干扰。 可以用同样的源码为不同的操作系统或架构构建 XFree86 ，用只读的 NFS 共享。 可以用不同的配置构建 XFree86，只需要在每一个构建树中放一个 host.def 的拷贝，并且分别定义。 用下面步骤建立一个符号链接目录：\n在构建树的顶层创建目录，通常新建在xc目录的同层，但不是强制性的。\ncd [xc目录] mkdir build 用“lndir”命令创建影子树：\nlndir ../xc 注：如果需要的话，最好使用xc目录的绝对路径。\n如果你的系统没有安装 lndir ，你可以用下面的命令从 XFree86 的源码安装它：\ncd xc/config/util make -f Makefile.ini lndir cp lndir [some directory in your PATH] 随着时间的推移，可能在构建树中产生一些陈旧的链接，例如，当源码中的文件被删除或重命名。可以在构建目录中运行“cleanlinks”脚本来清除。很少会因为一些变化而要从头开始重新创建构建树。如果有这样的情况，那可能是构建过程中问题。最好的方法是删除构建树，然后按上面的步骤重新构建。\n4. 构建和安装 #构建之前，读一下 xc/programs/Xserver/hw/xfree86/doc 中与你相关的特定操作系统的 README 。一旦特定操作系统的详情已经有了描述，就可以到你的构建目录（xc目录或之前建立的影子树），运行“make World”，如果有必要，就带上 README 中描述的 BOOTSTRAPCFLAGS 设置，但是 XFree86 支持大多数操作系统已经不需要 BOOTSTRAPCFLAGS。一个明智的做法是将 stdout 和 stderr 重定向到 World.log，以便追踪构建过程中可能产生的问题。\n在类 Bourne 的 shell(Bash,Korn shell,zsh,等)中使用如下的命令：\nmake World \u0026gt; World.log 2\u0026gt;\u0026amp;1 C-shell(csh,tcsh,等)中使用：\nmake World \u0026gt;\u0026amp; World.log 你可以根据构建的进展运行：\ntail -f World.log 构建完成后，如果有什么问题，你需要检查 World.log 文件。如果没有问题，你就可以安装二进制文件了。默认的“make World” 过程会忽略错误，以便尽可能的构建成功。如果在这一步中有无法解决的问题，安装过程将会失败。解决问题后重新开始构建时，只需要运行 “make” 。如果在解决问题的过程中改变了 Imakefile 或其它构建配置，需要重新运行 “make World” 或 “make Everything”。\n如果你想要 “make World” 在第一个错误是结束，用下面的命令来替换前面所讲的:\n在类Bourne的shell中：\nmake WORLDOPTS= World \u0026gt; World.log 2\u0026gt;\u0026amp;1 在C-shell中：\nmake WORLDOPTS= World \u0026gt;\u0026amp; World.log 对于安装，运行“make install”和“make install.man”。确保 /usr/X11R6 中有足够的空间用于安装。如果你想要安装在 /usr 之外的文件系统，需要在新建一个指向 /usr/X11R6 的符号连接。\n5. 重新配置服务器 #为服务器构建不同的设置，或带有不同驱动设置的服务器。\n确保新的驱动源码在正确的位置（例如，驱动源码应该在 xc/programs/Xserver/hw/xfree86/drivers 下的一个子目录）。\n修改host.def（你要构建的服务器）中定义的服务器设置，也可以根据你的需要修改驱动列表。\n在xc/programs/Xserver中运行：\nmake Makefile make Makefiles make includes make depend make 6. 其他有用的make目标 #下面是一些在 XFree86 的 Makefile 中定义的其他有用的目标：\nEverything make Worle之后，make Everything 会做任何 make World 可以做的，除了清理树。这是一个为源码打补丁后、快速重新构建树的方法。但它并不是100%可靠的。最好是用 make World 做一次完整的构建。\nclean 用于对源码树进行局部清理。删除目标文件和生成的手册页，但是保留 Makefile 和生成的依赖文件。执行 make clean 后，你需要重新运行以下命令来重新构建 XFree86 ：\nmake include make depend make disclean 对源码树进行完全清理，删除所有的生产文件。make disclean后，只能用make World重新构建XFree86。\nincludes 生产所有的可生成头文件和构建所需的符号链接。make clean时，这些文件会被删除。\ndepend 重新计算 Makefile 中各个目标的依赖关系。根据操作系统，依赖关系储存在 Makefile ，或一个独立的文件中，叫做 .depend。这目标需要用到 make includes 生产的头文件。VerifyOS 显示检测到的操作系统的版本。如版本号与你的系统不匹配，你可能要在 host.def 中设置并且向 XFree86@XFree86.org 报告这个问题\n","date":"2011 November 8","permalink":"/posts/2011/11/08/","section":"Posts","summary":"原文：","title":"从源码建立XFree86"},{"content":"使用递归：\nint strlen(char * str) { if(*str) return strlen(str+1)+1; else return 0; } ","date":"2011 October 18","permalink":"/posts/2011/10/18/","section":"Posts","summary":"使用递归：","title":"不用任何变量，实现strlen函数"},{"content":"Linux系统文本模式下截屏要用到/dev目录下的vcs设备：\nls /dev/vcs* /dev/vcs /dev/vcs1 /dev/vcs2 /dev/vcs3 /dev/vcs4 /dev/vcs5 /dev/vcs6 其中，/dev/vcs 是当前的虚拟控制台的内容，/dev/vcs1 是tty1的内容。\n截取当前控制台的内容：\ncat /dev/vcs \u0026gt; filename 得到的文件 filename 是一个文本文件，直接用编辑器即可查看。\n如果要截取 tty1 的内容，就执行：\ncat /dev/vcs1 \u0026gt; filename ","date":"2011 July 29","permalink":"/posts/2011/07/29/","section":"Posts","summary":"Linux系统文本模式下截屏要用到/dev目录下的vcs设备：","title":"Linux系统文本模式下的截屏"},{"content":"dd的作用是转换和拷贝文件，我们可以利用它来分割文件，相关的选项如下：\nif=filename：输入的文件名\nof=finename：输出的文件名\nbs=bytes：一次读写的字节数，默认是512bytes\nskip=blocks:拷贝前，跳过的输入文件的前blocks块，块的大小有bs决定\ncount=blocks：只拷贝输入文件的前blocks块\n例如，现在有一个文件file，大小为116616字节：\n[root]# du -b file 116616 file 将其分割为两文件file1和file2，那我们就设置每块为1024字节，将file的前60块放入file1，余下的放入file2：\n[root]# dd if=file bs=1024 count=60 skip=0 of=file1 [root]# dd if=file bs=1024 count=60 skip=60 of=file2 然后用cat将两个文件合并为file.bak，要注意文件的顺序：\n[root]# cat file1 file2 \u0026gt; file.bak 可以用md5sum验证一下file和file.bak：\n[root]# md5sum file 3ff53f7c30421ace632eefff36148a70 file [root]# md5sum file.bak 3ff53f7c30421ace632eefff36148a70 file.bak 可以证明两个文件时完全相同的。\n为了方便分割、合并文件，我写了两个脚本：\nddf.sh\n#ddf.sh：分割文件，分割后的文件以数字结尾，例如file分割为两个文件：file1和file2 #!/bin/sh #使用脚本是第一参数是要分割的文件名 Filename=$1 Filesize=0 Path=`pwd` #验证文件名是否正确，然后计算文件的大小 if [ -z $Filename ];then echo \u0026quot;Error:The file name can not be empty\u0026quot; exit fi if [ -e $Filename ];then Filesize=`du -b $Filename | awk '{print $1}'` if [ $Filesize == 0 ];then echo \u0026quot;Error:The File size is zero!\u0026quot; exit fi echo \u0026quot;The file size is $Filesize Byte\u0026quot; echo \u0026quot;Plese enter the subfile size(KB):\u0026quot; else echo \u0026quot;Error:$Filename does not exist!\u0026quot; exit fi #输入分割后每个文件的大小，单位是KB read Subfilesize if [ -z $Subfilesize ];then echo \u0026quot;Error:Input can not be empty\u0026quot; exit fi echo $Subfilesize | grep '^[0-9]\\+$' \u0026gt;\u0026gt; /dev/null if [ $? -ne 0 ];then echo \u0026quot;Error:The Input is not a number!\u0026quot; exit elif [ $Subfilesize -eq 0 ];then echo \u0026quot;Error:The Subfile size is zero!\u0026quot; exit fi #计算需要分割为几个文件 SubfileByte=`expr $Subfilesize \\* 1024` Subfilenum=`expr $Filesize / $SubfileByte` if [ `expr $Filesize % $Subfilesize` -ne 0 ];then Subfilenum=`expr $Subfilenum + 1` fi #将文件分割 echo \u0026quot;$Filename will be divided into $Subfilenum\u0026quot; i=1 skipnum=0 while [ $i -le $Subfilenum ] do echo \u0026quot;$Filename$i\u0026quot; dd if=$Filename of=\u0026quot;$Path/$Filename$i\u0026quot; bs=1024 count=$Subfilesize skip=$skipnum i=`expr $i + 1` skipnum=`expr $skipnum + $Subfilesize` done echo \u0026quot;$Filename has been divided into $Subfilenum\u0026quot; echo \u0026quot;Done !\u0026quot; caf.sh\n#caf.sh:合并文件，需要合并的文件要放在一个文件夹里 # 文件名分为两个部分，第一部分都相同，第二部分必须是从1开始的连续数字，例如file1，file2，file3 # 合并后的文件名为file.bak #!/bin/sh #输入文件名的第一部分 echo \u0026quot;Please enter file name:\u0026quot; read Filename if [ -z $Filename ];then echo \u0026quot;Error:File name can not be empty\u0026quot; exit fi #输入待合并文件的个数 echo \u0026quot;Please enter the number of subfiles:\u0026quot; read Subfilenum if [ -z $Subfilenum ];then echo \u0026quot;Error:The number of subfiles can not be empty\u0026quot; exit fi echo $Subfilenum | grep '^[0-9]\\+$' \u0026gt; /dev/null if [ $? -ne 0 ];then echo \u0026quot;Error:Input must be a number\u0026quot; exit fi if [ $Subfilenum -eq 0 ];then echo \u0026quot;Error:The number of subfiles can not be zero\u0026quot; exit fi #合并文件 i=1 Newfile=$Filename\\.bak while [ $i -le $Subfilenum ] do Subfilename=$Filename$i if [ -e $Subfilename ];then echo \u0026quot;$Subfilename done!\u0026quot; cat $Subfilename \u0026gt;\u0026gt; $Newfile i=`expr $i + 1` else echo \u0026quot;Error:$Subfilename does not exist\u0026quot; rm -rf $Newfile exit fi done echo \u0026quot;Subfiles be merged into $Newfile\u0026quot; echo \u0026quot;Success!\u0026quot; 用这两个脚本完成对file的分割、合并：\n[root]# ./ddf.sh file The file size is 116616 Byte Plese enter the subfile size(KB): 60 file will be divided into 2 file1 记录了60+0 的读入 记录了60+0 的写出 61440字节(61 kB)已复制，0.0352612 秒，1.7 MB/秒 file2 记录了53+1 的读入 记录了53+1 的写出 55176字节(55 kB)已复制，0.0316272 秒，1.7 MB/秒 file has been divided into 2 Done ! [root]# ls caf.sh ddf.sh file file1 file2 [root]# ./caf.sh Please enter file name: file Please enter the number of subfiles: 2 file1 done! file2 done! Subfiles be merged into file.bak Success! [root]# ls caf.sh ddf.sh file file1 file2 file.bak ","date":"2011 July 26","permalink":"/posts/2011/07/26/","section":"Posts","summary":"dd的作用是转换和拷贝文件，我们可以利用它来分割文件，相关的选项如下：","title":"Linux下分割、合并文件——dd和cat"},{"content":"原文：\n《Linux Ramdisk mini-HOWTO》\nBy Van Emery\nhttp://www.vanemery.com/Linux/Ramdisk/ramdisk.html\nTranslate By Bob\nFriday, July 25, 2011\nEmail： gexbob@gmail.com\nBlog：http://shaocheng.li\n简介 #什么是RamDisk？RamDisk就是将内存（Ram）的一部分当做硬盘（Disk）来使用。RamDisk有固定的大小，可以像正常硬盘分区那样去使用。 就操作时间来讲，RamDisk比真实的物理硬盘快很多，当系统关闭或断电时，保存在RamDisk中的数据会全部丢失。RamDisk可以成为一个存放临时数据的好地方。\nLinux的2.4内核已经内建支持RamDisk。RamDisk在很多情况下是很有用的，包括：\n使用加密文件中的未加密数据； 某些类型的网页内容服务； 挂载loopback文件系统（例如，从软盘或CD运行） 我为什么要写这个文档？因为我需要设置一个16M的RamDisk来查看、创建加密文件。我不想让未加密的文件写入我的工作平台的任何物理介质。我还发现一个有趣的地方，可以轻易的在Ram中创建一个比我的第一个物理硬盘（20M）还大的虚拟硬盘，当时，我根本无法想象怎样填满这个虚拟硬盘。\n这个文档将会带你一步步地经历创建和使用RamDisk的过程。\n平台 #我使用Red Hat 9进行测试，但是这应该适用于其他的 2.4 内核的Linux系统，我还假设你的Linux系统已经将RamDisk支持编译到了内核。我的计算机使用 Pentium 4 处理器，256M内存，确切的内核版本是：2.4.20-20.9\n1. 查看你的系统已经创建了什么 #RedHat默认创建16个RamDisk，虽然它们没有激活或使用任何Ram。系统列出的设备是ram0~ram19，但是只有ram0~ram15是默认可用的。使用下面的命令可用检出这些块设备：\n[root]# ls -l /dev/ram* lrwxrwxrwx 1 root root 4 Jun 12 00:31 /dev/ram -\u0026gt; ram1 brw-rw---- 1 root disk 1, 0 Jan 30 2003 /dev/ram0 brw-rw---- 1 root disk 1, 1 Jan 30 2003 /dev/ram1 brw-rw---- 1 root disk 1, 10 Jan 30 2003 /dev/ram10 brw-rw---- 1 root disk 1, 11 Jan 30 2003 /dev/ram11 brw-rw---- 1 root disk 1, 12 Jan 30 2003 /dev/ram12 brw-rw---- 1 root disk 1, 13 Jan 30 2003 /dev/ram13 brw-rw---- 1 root disk 1, 14 Jan 30 2003 /dev/ram14 brw-rw---- 1 root disk 1, 15 Jan 30 2003 /dev/ram15 brw-rw---- 1 root disk 1, 16 Jan 30 2003 /dev/ram16 brw-rw---- 1 root disk 1, 17 Jan 30 2003 /dev/ram17 brw-rw---- 1 root disk 1, 18 Jan 30 2003 /dev/ram18 brw-rw---- 1 root disk 1, 19 Jan 30 2003 /dev/ram19 brw-rw---- 1 root disk 1, 2 Jan 30 2003 /dev/ram2 brw-rw---- 1 root disk 1, 3 Jan 30 2003 /dev/ram3 brw-rw---- 1 root disk 1, 4 Jan 30 2003 /dev/ram4 brw-rw---- 1 root disk 1, 5 Jan 30 2003 /dev/ram5 brw-rw---- 1 root disk 1, 6 Jan 30 2003 /dev/ram6 brw-rw---- 1 root disk 1, 7 Jan 30 2003 /dev/ram7 brw-rw---- 1 root disk 1, 8 Jan 30 2003 /dev/ram8 brw-rw---- 1 root disk 1, 9 Jan 30 2003 /dev/ram9 lrwxrwxrwx 1 root root 4 Jun 12 00:31 /dev/ramdisk -\u0026gt; ram0 现在，用grep在dmesg的输出中找出RamDisk的大小\n[root]# dmesg | grep RAMDISK RAMDISK driver initialized: 16 RAM disks of 4096K size 1024 blocksize RAMDISK: Compressed image found at block 0 你可用看到，RamDisk 默认只有 4MB。我想要一个 16MB 的 RamDisk，所以，下一步要配置 Linux，使得在启动过程中使用一个更大的 RamDisk 。\n2. 增加RamDisk的大小 #RamDisk 的大小是被一个命令行选项控制的，这个选项会在系统启动时传给内核。由于 RedHat9 的默认 bootloader 是 GRUB，我将用新的选项修改 /etc/grub.conf，RamDisk 大小的内核选项是：ramdisk_size=xxxxx ，xxxxx 是指大小为 1024-Byte 的块的个数。下面是我要添加到 /etc/grub.conf 的内容，它将 RamDisk 配置为16MB：\ngurb.conf\n# grub.conf generated by anaconda # # Note that you do not have to rerun grub after making changes to this file # NOTICE: You have a /boot partition. This means that # all kernel and initrd paths are relative to /boot/, eg. # root (hd0,0) # kernel /vmlinuz-version ro root=/dev/hda5 # initrd /initrd-version.img #boot=/dev/hda default=0 timeout=10 splashimage=(hd0,0)/grub/splash.xpm.gz title Red Hat Linux (2.4.20-20.9) root (hd0,0) kernel /vmlinuz-2.4.20-20.9 ro root=LABEL=/ hdc=ide-scsi ramdisk_size=16000 initrd /initrd-2.4.20-20.9.img 将文件保存后，你需要重启系统。重启后，通过查看dmesg的输出来确认修改已经生效：\n[root]# dmesg | grep RAMDISK RAMDISK driver initialized: 16 RAM disks of 16000K size 1024 blocksize RAMDISK: Compressed image found at block 0 3. 格式化RamDisk #无需将 RamDisk 格式化为日志文件系统，我们将使用 EXT2 文件系统。我只想使用一个 RamDisk ，所以我只格式化 ram0。\n[root]# mke2fs -m 0 /dev/ram0 mke2fs 1.32 (09-Nov-2002) Filesystem label= OS type: Linux Block size=1024 (log=0) Fragment size=1024 (log=0) 4000 inodes, 16000 blocks 0 blocks (0.00%) reserved for the super user First data block=1 2 block groups 8192 blocks per group, 8192 fragments per group 2000 inodes per group Superblock backups stored on blocks: 8193 Writing inode tables: done Writing superblocks and filesystem accounting information: done This filesystem will be automatically checked every 22 mounts or 180 days, whichever comes first. Use tune2fs -c or -i to override. -m 0选项指定了文件系统上root用户保留区块的比例为0，这是默认的特性。我希望普通用户可以使用所有的RamDisk空间。\n4. 新建一个挂载点并挂载RamDisk #你已经格式化了RamDisk，现在要为它新建一个挂载点。然后就可以挂载你的RamDisk并使用它。我们将会使用/mnt/rd文件夹。\n[root]# mkdir /mnt/rd [root]# mount /dev/ram0 /mnt/rd 检测新挂载的RamDisk\n[root]# mount | grep ram0 /dev/ram0 on /mnt/rd type ext2 (rw) [root]# df -h | grep ram0 /dev/ram0 16M 13K 16M 1% /mnt/rd 你可以用tune2fs命令查看新RamDisk的详细信息\n[root]# tune2fs -l /dev/ram0 tune2fs 1.32 (09-Nov-2002) Filesystem volume name: none Last mounted on: not available Filesystem UUID: fbb80e9a-8e7c-4bd4-b3d9-37c29813a5f5 Filesystem magic number: 0xEF53 Filesystem revision #: 1 (dynamic) Filesystem features: filetype sparse_super Default mount options: (none) Filesystem state: not clean Errors behavior: Continue Filesystem OS type: Linux Inode count: 4000 Block count: 16000 Reserved block count: 0 Free blocks: 15478 Free inodes: 3989 First block: 1 Block size: 1024 Fragment size: 1024 Blocks per group: 8192 Fragments per group: 8192 Inodes per group: 2000 Inode blocks per group: 250 Filesystem created: Mon Dec 8 14:33:57 2003 Last mount time: Mon Dec 8 14:35:39 2003 Last write time: Mon Dec 8 14:35:39 2003 Mount count: 1 Maximum mount count: 22 Last checked: Mon Dec 8 14:33:57 2003 Check interval: 15552000 (6 months) Next check after: Sat Jun 5 14:33:57 2004 Reserved blocks uid: 0 (user root) Reserved blocks gid: 0 (group root) First inode: 11 Inode size: 128 在我的系统中，我需要\u0026rsquo;var\u0026rsquo;用户能够读写RamDisk，所以必须修改/mnt/rd文件夹的所有者和权限。\n[root]# chown van:root /mnt/rd [root]# chmod 0770 /mnt/rd [root]# ls -ald /mnt/rd drwxrwx--- 2 van root 4096 Dec 8 11:09 /mnt/rd RamDisk挂载点的所有者和权限要根据你的特定情况进行修改。\n5. 使用RamDisk #RamDisk已经创建成功，现在，你可以像在物理硬盘分区那样，在RamDisk上复制、移动、删除、编辑或列出文件。这是一个查看加密的GPG或OpenSSL文件的好地方，也是一个创建加密文件的好地方。你的主机关闭后，所有在RamDisk上创建的文件都会消失。\n用下面的命令可以轻易的卸载RamDisk：\n[root]# umount -v /mnt/rd /dev/ram0 umounted **Note：**如果你卸载了RamDisk，你的数据依然会保存在那里。一旦内存被分配给了RamDisk，它就会被标记，之后内核就不会试图重用这块内存。因此，使用了RamDisk后，就不能回收那块内存。正因如此，你要考虑清楚，不要给RamDisk分配太多的内存。在我的系统里，我分配了小于10%的物理内存。你要根据自己的需要确定RamDisk的大小。当然，也可以重启后释放空间。\n自动创建RamDisk #如果你需要每次系统启动后创建和挂载RamDisk，可以通过在/etc/rc.local启动脚本里添加命令来自动执行这个进程。 下面是我添加的命令：\n# Formats, mounts, and sets permissions on my 16MB ramdisk /sbin/mke2fs -q -m 0 /dev/ram0 /bin/mount /dev/ram0 /mnt/rd /bin/chown van:root /mnt/rd /bin/chmod 0750 /mnt/rd 结语 #现在你可以尝试在你的UNIX/Linux系统上创建和使用RamDisk。希望这些信息对你有用。\n参考 # /usr/src/linux-2.4/Documentation/ramdisk.txt /usr/src/linux-2.4/drivers/block/rd.c man mke2fs Ramdisk article by Mark Nielsen for Red Hat 6.0 ","date":"2011 July 25","permalink":"/posts/2011/07/25/","section":"Posts","summary":"原文：","title":"如何在Linux系统下制作RamDisk"},{"content":"原文：\n《Remote Serial Console HOWTO》：http://www.linux.com/learn/docs/ldp/714-Remote-Serial-Console-HOWTO\nTranslate By Bob\nFriday, July 15, 2011\nEmail： gexbob@gmail.com\nBlog：http://shaocheng.li\n根据我的环境（Redhat 9，Grub 0.93），翻译了我需要的部分。原文还有针对Lilo和Syslinux的配置说明。\n1. 准备工作 #1.1. 关于serial console #Console是一个输出系统管理信息的文本输出设备，这些信息来自于内核，系统启动和系统用户，serial console就是串口作为输出终端设备，是这些信息可以通过串口在远程的终端上显示。\n配置一个serial console大致包括五项内容：\n配置BIOS使用serial console（可选）； 配置Bootloader使用serial console（可选）； 配置内核使用serial console 在系统启动时运行一个支持serial console登录的程序 一些其他系统配置，使这些功能支持serial console，或者防止它们扰乱serial console 1.2. 串口线 #使用RS232方式的DB9串口线，信号连接如下：\nSignal ground ------------------ Signal ground Receive data ------------------ Transmit data Transmit data ------------------ Receive data Ready to send ------------------ Clear to send Clear to send ------------------ Ready to send ata terminal ready -------------+--- Data carrier detect | +--- Data set ready Data carrier detect ----+---------------- Data terminal ready | Data set ready ----+ 1.3. 串口参数的设置 #选择的串口是COM1，设备名为ttyS0，波特率为9600,8位数据位，无奇偶校验，1位停止位。\n2. 配置BIOS #有些BIOS支持serial console，可以在serial console显示BIOS启动信息，这需要在BIOS中配置。\n3. 配置Bootloader #LILO、GRUB和SYSLINUX都支持serial console。\n3.1. GRUB的配置 #GRUB的配置文件是/boot/grub目录下的grub.conf，在配置文件的开始处添加：\nserial --unit=0 --speed=9600 --word=8 --parity=no --stop=1 terminal --timeout=10 serial console Serial命令用于设置串口的参数：\n--unit：串口设备，0就表示ttyS0，如果是ttyS1就要设为1； --speed：波特率； --work：数据位； --parity：奇偶校验位； --stop：停止位。 Terminal命令用于设置终端的类型 --timeout：等待时间，单位是秒 4. 配置Kernel #Kernel的console类型可以通过console参数选择，console配置的语法如下：\nconsole=ttyS\u0026lt;serial_port\u0026gt;[,\u0026lt;mode\u0026gt;] console=tty\u0026lt;virtual_terminal\u0026gt; console=lp\u0026lt;parallel_port\u0026gt; console=ttyUSB[\u0026lt;usb_port\u0026gt;[,\u0026lt;mode\u0026gt;] 其中的ttyS就是串口设备，mode表示串口的参数；tty表示虚拟终端。\n每个console类型指南设置一个设备，例如，可以设置为console=tty0 console=lp0 console=ttyS0，但是设为 console=ttyS0 console=ttyS1就是错误的。\n如果没有设置console参数，内核默认使用虚拟终端，即tty0，使用组合键 Ctrl+Alt+F1 可以切换到 tty0。如果你的电脑有显示设备，最好将它设为 console，即 console=tty0。\n根据我的设备情况可以设置为：\nconsole=tty0 console=ttyS0,9600n8 Console参数需要用bootloader在内核启动时传递给内核，对于GRUB，需要修改grub.conf文件，将参数添加到kernel命令后面即可，例如；\ngrub.conf\ntitle Red Hat Linux (2.4.9-21) root (hd0,0) kernel /vmlinuz-2.4.9-21 ro root=/dev/hda6 console=tty0 console=ttyS0,9600n8 initrd /initrd-2.4.9-21.img 5. 配置getty #getty会监控和等待一个连接，然后配置串口连接，发送/etc/issue的内容，并且要求输入登录名和密码，然后开始登录，如果登录失败，getty会返回等待状态。\ngetty的另一项工作是设置TERM变量的值，以指定所连接的终端的类型。\n常用的getty有四个版本：\n*getty：*传统的getty，需要配置文件/etc/gettydefs *agetty：*无需配置文件，直接通过命令行传递参数 *mgetty：*支持modem的getty，需要配置文件 *minigetty：*精简版的getty，不支持serial console\nRedHat9自带agetty和mgetty，在/etc/inittab文件中默认使用mgetty，在该文件中添加：\nco：2345：respawn：/sbin/agetty -h -t 60 ttyS0 9600 vt102 -t 60 : 60秒内无操作，agetty将会返回等待状态。\n-h ： 使用硬件流控制（CTS/RTS握手）\n6. 其他配置 #6.1. 让root可以通过serial console登录 #配置文件/etc/securetty用于管理root用户可以登录的设备，将serial console的设备名添加到该文件，即可使root用户通过serial console登录。\n为了安全性，我们通常root用户在远程登录，而是用普通用户登录，然后用su或sudo命令切换到root。\n6.2. 将启动基本改为文本方式 #这个只针对在没有屏幕的服务器上运行X-Window系统，编辑/etc/inittab文件中包含initdefault的那一行，例如：\nid:5:initdefault: 改为\nid:3:initdefault: 如果连接了键盘和显示器，可以用start命令启动X-Window。\n####6.2.1. 配置为运行X\n有时，一台有serial console却没有连接显示器的电脑依然需要运行X-Window，例如，这台电脑连接有X终端。\n这种情况下，计算机还是需要运行在第5级，但是不能为显示器运行X-server。修改/etc/X11/xdm/Xservers,删除所有以冒号开头的行，例如：\n:0 local /usr/X11R6/bin/X 如果操作系统使用的是GNOME，那就要修改它的配置文件/etc/X11/gdm/gdm.conf，删除[servers] 段中的所有本地X-Server的条目，例如：\n[servers] 0=/usr/bin/X11/X 6.3. 删除已有的console设置 #/etc/ioctl.save包含了单用户模式中使用的串口和终端的特性，这些特性通常是有getty来设置的——在没用getty运行的单用户模式下，这个文件的内容被用来设置串口和终端。\n因为我们已经改变了console，已有的设置已经不正确了，所以要删除这个文件：\nrm -f /etc/ioctl.save 一旦我们可以从serial console登录，我们会重建这个文件。\n6.4. serial console不是/dev/modem #很多Linux会将/dev/modem链接到一个包含可用modem的串口设备。\n虽然serial console是一个带有modem的串口，但是我们真的不希望它被用作一个呼叫设备。\n检查/dev/modem是否指向了那个用做console的串口，如果是，将它删除。\nbash$ ls -l /dev/modem lrwxrwxrwx 1 root root 10 Jan 01 00:00 /dev/modem -\u0026gt; /dev/ttyS0 bash# rm /dev/modem 6.5. 更改/dev/systty的目标 #很多Linux将/dev/systty链接到了键盘和显示器所使用的那个终端设备。\n如果计算机没有连接键盘和显示器，或者不想给键盘和显示器提供一个文本终端，那就修改/dev/systty，使它指向serial console。\n相对于修改链接，修改MAKEDEV使用的配置文件更好，这样会重建链接。配置文件位于/dev/makedev.d目录下，默认配置指向第一个虚拟终端：\nl systty tty0 修改它，使systty指向用作console的串口：\nbash# cd /etc/makedev.d bash# fgrep systty * linux-2.4.x:l systty tty0 bash# vi linux-2.4.x 将systty那一行改为：\nl systty ttyS0 然后根据新定义重建/dev/systty:\nbash# cd /dev bash# rm systty bash# ./MAKEDEV systty 6.6. 配置可拔插认证模块 #可拔插认证模块系统被用于向用户提供通过console登录系统的特权，它使得设备像软盘那样可以由console用户挂载，通常情况下，挂载磁盘需要超级用户权限。\nPAM配置文件/etc/security/console.perms包含\u0026lt;console\u0026gt;变量，对于连接了键盘显示器的系统，默认的\u0026lt;console\u0026gt;变量为：\n\u0026lt;console\u0026gt;=tty[0-9][0-9]* vc/[0-9][0-9]* :[0-9]\\.[0-9] :[0-9] 在该文件的后面部分，console用户被赋予了使用一些设备的权限，设备权限的修改会在登录或退出后生效。 console.perms文件中默认的设备列表如下：\nconsole.perms\n\u0026lt;console\u0026gt; 0660 \u0026lt;floppy\u0026gt; 0660 root.floppy \u0026lt;console\u0026gt; 0600 \u0026lt;sound\u0026gt; 0600 root \u0026lt;console\u0026gt; 0600 \u0026lt;cdrom\u0026gt; 0660 root.disk \u0026lt;console\u0026gt; 0600 \u0026lt;pilot\u0026gt; 0660 root.uucp \u0026lt;console\u0026gt; 0600 \u0026lt;jaz\u0026gt; 0660 root.disk \u0026lt;console\u0026gt; 0600 \u0026lt;zip\u0026gt; 0660 root.disk \u0026lt;console\u0026gt; 0600 \u0026lt;ls120\u0026gt; 0660 root.disk \u0026lt;console\u0026gt; 0600 \u0026lt;scanner\u0026gt; 0600 root \u0026lt;console\u0026gt; 0600 \u0026lt;camera\u0026gt; 0600 root \u0026lt;console\u0026gt; 0600 \u0026lt;memstick\u0026gt; 0600 root \u0026lt;console\u0026gt; 0600 \u0026lt;flash\u0026gt; 0600 root \u0026lt;console\u0026gt; 0600 \u0026lt;fb\u0026gt; 0600 root \u0026lt;console\u0026gt; 0600 \u0026lt;kbd\u0026gt; 0600 root \u0026lt;console\u0026gt; 0600 \u0026lt;joystick\u0026gt; 0600 root \u0026lt;console\u0026gt; 0600 \u0026lt;v4l\u0026gt; 0600 root \u0026lt;console\u0026gt; 0700 \u0026lt;gpm\u0026gt; 0700 root \u0026lt;console\u0026gt; 0600 \u0026lt;mainboard\u0026gt; 0600 root \u0026lt;console\u0026gt; 0600 \u0026lt;rio500\u0026gt; 0600 root 以上被列出的设备分为两种：一些设备需要来自键盘和显示器的连接，而另一些设备可以方便的连接，这个配置文件无法区分逻辑console和物理console，可通过修改文件来区分二者。\n需要键盘和显示器连接的设备如下：\n\u0026lt;console\u0026gt; 0600 \u0026lt;fb\u0026gt; 0600 root \u0026lt;console\u0026gt; 0600 \u0026lt;kbd\u0026gt; 0600 root \u0026lt;console\u0026gt; 0600 \u0026lt;joystick\u0026gt; 0600 root \u0026lt;console\u0026gt; 0600 \u0026lt;v4l\u0026gt; 0600 root \u0026lt;console\u0026gt; 0700 \u0026lt;gpm\u0026gt; 0700 root 其余的设备要修改为通过serial console来控制。例如，我们不想要一个处于托管位置的非特权用户去挂载软盘。为serial console定义一个新的console类型，叫做\u0026lt;sconsole\u0026gt;，将它添加到console.perms：\n\u0026lt;sconsole\u0026gt;=ttyS0 然后将其他设备的 \u0026lt;console\u0026gt; 改为 \u0026lt;sconsole\u0026gt;,使它们指向serial console:\n\u0026lt;sconsole\u0026gt; 0660 \u0026lt;floppy\u0026gt; 0660 root.floppy \u0026lt;sconsole\u0026gt; 0600 \u0026lt;sound\u0026gt; 0600 root \u0026lt;sconsole\u0026gt; 0600 \u0026lt;cdrom\u0026gt; 0660 root.disk \u0026lt;sconsole\u0026gt; 0600 \u0026lt;pilot\u0026gt; 0660 root.uucp \u0026lt;sconsole\u0026gt; 0600 \u0026lt;jaz\u0026gt; 0660 root.disk \u0026lt;sconsole\u0026gt; 0600 \u0026lt;zip\u0026gt; 0660 root.disk \u0026lt;sconsole\u0026gt; 0600 \u0026lt;ls120\u0026gt; 0660 root.disk \u0026lt;sconsole\u0026gt; 0600 \u0026lt;scanner\u0026gt; 0600 root \u0026lt;sconsole\u0026gt; 0600 \u0026lt;camera\u0026gt; 0600 root \u0026lt;sconsole\u0026gt; 0600 \u0026lt;memstick\u0026gt; 0600 root \u0026lt;sconsole\u0026gt; 0600 \u0026lt;flash\u0026gt; 0600 root \u0026lt;sconsole\u0026gt; 0600 \u0026lt;mainboard\u0026gt; 0600 root \u0026lt;sconsole\u0026gt; 0600 \u0026lt;rio500\u0026gt; 0600 root 6.7. 针对RedHat的配置 #RedHat将一些系统初始化所需的参数存放在 /etc/sysconfig/init。\n修改BOOTUP参数，使用独立终端命令写OK、PASSED和FAULT信息，这些信息将不再显示为绿色、黄色或红色。/etc/sysconfig/init 文件的注释说，除了color，还可以设置其他的值，但是，BOOTUP 必须被设为 serial。\n修改PROMPT参数，禁止交互启动。\n对 /etc/sysconfig/init 的修改如下：\nBOOTUP=serial PROMPT=no RedHat会运行一个用于发现硬件设备的程序，叫做 kudzu。当发现一个串口时，kudzu会将其复位，这将停止 serial console。kudzu 的配置文件是 /etc/sysconfig/kudzu。\n将配置文件中的 SAFE 设为 yes，就会阻止 kudzu 复位设备。\n修改 /etc/sysconfig/kudzu:\nSAFE=yes 7. 重启测试 #7.1. 验证console操作 #有可能的话，在串口上接一个串口接线盒。在重启的过程中，DTR信号会被激活，出现console信息时，数据指示灯会闪烁。在里一台电脑上配置好终端，重启计算机。\n重启过程中，在终端界面可以看到bootloader的启动信息，然后是kernel启动，系统初始化输出，最后会显示/etc/issue的内容，并且getty要求你登录。\n如果没有看到login信息，可能会提示按下Return或Enter键。\n7.2. 重建console设置 #用root用户登录serial console。前面我们删除了/etc/ioctl.save，现在要重新配置console，波特率为9600,8位数据位，无奇偶校验，1位停止位。\nremote.example.edu.au ttyS0 login: root Password: … sh# rm -f /etc/ioctl.save bash# telinit 1 …Telling INIT to go to single user mode. INIT: Going single user INIT: Sending processes the TERM signal sh# stty sane -parenb cs8 crtscts brkint -istrip -ixoff -ixon 结束单用户模式返回正常运行级别后，serial console的终端配置会保存到/etc/ioctl.save。\nsh# exit ... bash# ls -l /etc/ioctl.save -rw------- 1 root root 60 Jan 1 00:00 /etc/ioctl.save 当系统以单用户模式启动后，会使用/etc/ioctl.save。\n附录： #我的平台：\n两台PC，一个安装Redhat 9，bootlloader为Grub 0.93，另一个安装WindowsXP,用超级终端作为serial console显示设备，用DB9头的串口通信线将二者COM1相连，只将两端的TX和RX信号交叉相连，其他信号都直连。\n操作步骤：\n修改/boot/grub/grub.conf\n添加：\nserial --unit=0 --speed=9600 --word=8 --parity=no --stop=1 terminal --timeout=10 serial console 在kernel后面添加参数：\nconsole=tty0 console=ttyS0,9600n8 修改/etc/inittab\n添加：\nco：2345：respawn：/sbin/agetty -t 60 ttyS0 9600 vt100 在XP系统上打开超级终端，波特率为9600，8位数据位，1位停止位，无奇偶校验，无数据流控制。然后重启Redhat9，在超级终端上即可看到内核和文件系统的启动信息，最后可以用普通用户登录，登录后可以用su root命令切换到root用户。这里有个问题还未解决，文件系统的信息只能在超级终端上显示，在Redhat9的屏幕上显示完内核启动信息后就暂停输出了，最后直接显示登录信息，待解决。\n如果想让root用户通过serial console登录，需要修改/etc/securetty，在该文件的最后一行添加ttyS0，重启后即可在超级终端用root用户登录。\n其他设置暂未测试。\n","date":"2011 July 22","permalink":"/posts/2011/07/22/","section":"Posts","summary":"原文：","title":"为Linux系统配置serial console"},{"content":"原理 #现在有一个文件file1，通过修改file1得到了文件file2，然后用diff工具比较file1和file2的差异，得到一个补丁文件file.patch，它记录了两个文件的不同之处，patch工具就可以根据这个补丁文件修改file1，从而得到file2。\n相关工具 #diff diff [options] 源文件 目标文件 diff用于列出两个文件的不同之处，指示如何由源文件变为目标文件，可以用重定向生成补丁文件，注意：diff只能用于比较文本文件。常用选项：\n-c，输出一个基于上下文的diff，即提供每处修改的前后机会内容，这样patch命令可以在打补丁前验证上下文是否匹配，而补丁文件也更容易阅读。\n-b，忽略空格引起的变化\n-B，忽略插入/删除空行引起的变化\n-i，忽略大小写\n-N，在比较目录时，如果一个文件只在其中一个目录中找到，那它被视为在第二个目录中是一个空文件\n-r，在比较目录时，递归比较所有子目录\n-u，使用统一的输出格式\npatch patch [options] 源文件 补丁文件 patch用于根据补丁文件修改源文件，它会直接改动源文件，打补丁前请注意备份。常用选项：\n-R，反向补丁，将已经打了补丁的文件恢复到原来的样子\n-p[num]，忽略前几层目录，目录的层数由num指定\n例1：比较两个文件 #file1:\nthis is line1 this is line2 this is line3 this is line4 file2：\nthis is line1 this is line2 hello this is line3 this is line4 this is line5 执行：\ndiff file1 file2 \u0026gt; file.patch 生成补丁文件file.patch：\n2c2 \u0026lt; this is line2 --- \u0026gt; this is line2 hello 4a5 \u0026gt; this is line5 对file1打补丁：\npatch file1 file.patch file1的内容就变成了file2，如果想把file1变为原来的样子，执行：\npatch -R file1 file.patch 例2：比较两个目录 #在工作路径下有两个目录：doc1和doc2。\n执行diff命令，生成补丁文件patch：\ndiff -Nur doc1 doc2 \u0026gt; doc.patch 用patch工具为doc1打补丁：\ncd doc1 patch -p1 \u0026lt; ../doc.patch 参考： #用Diff和Patch工具维护源码： https://www.ibm.com/developerworks/cn/linux/l-diffp/\n","date":"2011 July 15","permalink":"/posts/2011/07/15/","section":"Posts","summary":"原理 #现在有一个文件file1，通过修改file1得到了文件file2，然后用diff工具比较file1和file2的差异，得到一个补丁文件file.","title":"补丁的制作和使用"},{"content":"下面这段代码会输出什么结果？\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026quot;%d\\n\u0026quot;,( (i-sizeof(int)) \u0026gt;\u0026gt;32)); return 0; } 答案是 0\n将代码修改如下：\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026quot;%d\\n\u0026quot;,( (i-((int)sizeof(int))) \u0026gt;\u0026gt;32)); return 0; } 结果输出 -1\n解析：\nsizeof是一个操作符，它返回的结果是unsigned int。\n对于无符号数：右移后，高位补0；\n对于有符号数：正数，右移后高位补0；负数，右移后高位补1。\n建议只对无符号数做位运行，减少出错的可能。\n注意：移动的位数要小于做操作数的总位数，否则结果是undefined（虽然有时也会得到正确的结果）。\n","date":"2011 July 8","permalink":"/posts/2011/07/08/","section":"Posts","summary":"下面这段代码会输出什么结果？","title":"关于C语言的位移操作"},{"content":"先做一道题目：\n#include \u0026lt;stdio.h\u0026gt; int f(int *p) { static int i = 5; p=\u0026amp;i; return 0; } int main(void) { int *p; f(p); printf(\u0026quot;p = %d/n\u0026quot;,*p); return 0; } 该程序的输出结果是多少？\n有人会认为输出的是“p = 5”，其实应该是一个不确定的数。\n为了弄清为什么，先看下一个例子：\n#include \u0026lt;stdio.h\u0026gt; int main(void) { int i=0x01; int *p=\u0026amp;i; printf(\u0026quot;\u0026amp;i = %x/n\u0026quot;,\u0026amp;i); //i的地址 printf(\u0026quot;p = %x/n\u0026quot;,p); printf(\u0026quot;*p = %x/n\u0026quot;,*p); printf(\u0026quot;\u0026amp;p = %x/n\u0026quot;,\u0026amp;p); return 0; } 执行结果：\n\u0026amp;i = bfffe924 p = bfffe924 *p = 1 \u0026amp;p = bfffe920 解析：\n指针占4Byte，存放着它所指向的数据的地址。P是一个指向int型变量i的指针，所以p表示该指针的内容，也就是i的地址；*p表示p指向的内容，就是i；\u0026amp;p代表指针p本身的地址。\n再看第一道题，main函数里的p和f函数的参数p都是指向int型的指针，当 main 函数调用f函数时：f(p),传递给f函数的是main函数中的p的内容，因为p没有初始化，所以它的内容是一个不确定的地址，所以，f函数中的p指向了这个不确定地址。\n怎样才能让 main 函数中的p指向f函数中的静态变量i呢？\n将程序做如下修改即可：\n#include \u0026lt;stdio.h\u0026gt; int f(int **p) { static int i = 5; *p=\u0026amp;i; return 0; } int main(void) { int i=0x01; int *p=\u0026amp;i; f(\u0026amp;p); printf(\u0026quot;p = %d/n\u0026quot;,*p); return 0; } ","date":"2011 July 1","permalink":"/posts/2011/07/01/","section":"Posts","summary":"先做一道题目：","title":"关于函数的指针参数"},{"content":"下面是一个排序算法，用shell实现的：\nsleepsort.sh\n#!/bin/bash function f() { sleep \u0026quot;$1\u0026quot; echo \u0026quot;$1\u0026quot; } while [ -n \u0026quot;$1\u0026quot; ] do f \u0026quot;$1\u0026quot; \u0026amp; shift done wait 用法：\n./sleepsort.sh 5 3 6 3 6 3 1 4 7 这个算法太NB、太BT、太搞笑了！\n神马冒泡、插入、归并\u0026hellip; 全是浮云啊！\n膜拜吧！\n详情可见酷壳原文：http://coolshell.cn/articles/4883.html\n佩服之余，我在linux下用C语言实现了一把：\nsleepsort.c\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; void *f(void *opt) { sleep((*((int *)opt))); printf(\u0026quot;%d,\u0026quot;,(*((int *)opt))); pthread_exit(0); } int main() { const int len=5; pthread_t a_thread[5]; int array[5]={3,5,2,4,1}; int i=0; while(i\u0026lt;len) { pthread_create(\u0026amp;(a_thread[i]),NULL,f,\u0026amp;(array[i])); i++; } i=0; while(i\u0026lt;len) { pthread_join(a_thread[i],0); i++; } printf(\u0026quot;/n\u0026quot;); return 0; } 编译：\ngcc -Wall -o sleepsort sleepsort.c -lpthread 执行：\n./sleepsort 1,2,3,4,5, ","date":"2011 June 28","permalink":"/posts/2011/06/28/","section":"Posts","summary":"下面是一个排序算法，用shell实现的：","title":"神级排序算法"},{"content":"对于unicode编码的字符，可以先将unicode编码转换为GBK编码，然后利用GBK点阵字库（gbk.bin)显示字符。一个比较好的编码转换方法是，制作一个按照unicode编码顺序排列的GBK编码表，直接根据unicode编码就可以查到对应的GBK编码，具体的制作方法如下：\n1.生成一个unicode字符文件 #上以篇文章中已经制作了一个GBK编码的全字符文件gbk.txt，用记事本打开gbk.txt，然后以unicode编码另存为unicode.txt文件。\n这样的话，所有的GBK编码字符都用unicode编码保存在unicode.txt中了，可以用winhex打开unicode.txt，会发现前两个字节是FFFE，这是unicode编码的标识，要注意后面的unicode编码是小端存储。\n2.制作unicode转gbk的文件 #这里要用程序制作一个unicode与gbk编码相对应的文件，该文件每四个字节为一组，其中前两个字节为unicode编码，后两个字节是对应的gbk编码，两种编码都以小端存储，数据结构如下：\nunion code { unsigned int unigbk; unsigned short int uni_gbk[2]; unsigned char buffer[4]; }; 这个数据结构是以gbk编码的顺序存放在文件uni2gbk.txt中，文件大小为128764Byte。程序如下：\n//由unicode.txt和gbk.txt生成uni2gbk.txt #include \u0026lt;stdio.h\u0026gt; int main(void) { unsigned char buffer[2]; int count=0; FILE *fup=0; FILE *fgp=0; FILE *fwp=0; fup=fopen(\u0026quot;unicode.txt\u0026quot;,\u0026quot;rb\u0026quot;); fgp=fopen(\u0026quot;gbk.txt\u0026quot;,\u0026quot;rb\u0026quot;); fwp=fopen(\u0026quot;uni2gbk.txt\u0026quot;,\u0026quot;wb\u0026quot;); fgetc(fup); fgetc(fup); while(1) { //读取unicode编码，写入uni2gbk.txt buffer[0]=fgetc(fup); buffer[1]=fgetc(fup); fputc(buffer[0],fwp); fputc(buffer[1],fwp); //读取gbk编码，写入uni2gbk.txt buffer[0]=fgetc(fgp); buffer[1]=fgetc(fgp); fputc(buffer[1],fwp); fputc(buffer[0],fwp); count+=2; if(count==0xfb7c) printf(\u0026quot;xxxxxxxxx/n\u0026quot;); if(buffer[0]==0xfe \u0026amp;\u0026amp; buffer[1]==0xfe) { printf(\u0026quot;count = %x/n\u0026quot;,count); fclose(fup); fclose(fgp); fclose(fwp); return; } } return 0； } 3.将uni2gbk.txt排序 #用程序将uni2gbk.txt文件中的union code数据结构按照unicode编码的顺序从小到大排序，程序如下：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MAXSIZE (0x7DBF) //union code的个数 union code { unsigned int unigbk; unsigned short int uni_gbk[2]; unsigned char buffer[4]; }; int main(void) { unsigned char flag=1; unsigned int i=0; unsigned int j=0; union code pdata; union code ndata; FILE *fp=0; fp = fopen(\u0026quot;uni2gbk.txt\u0026quot;,\u0026quot;rb+\u0026quot;); for(i=1; i\u0026lt;MAXSIZE \u0026amp;\u0026amp; flag==1; i++) { flag=0; for(j=0; j\u0026lt;(MAXSIZE-i); j++) { fseek(fp,j*4,0); fread(pdata.buffer,1,4,fp); fseek(fp,j*4+4,0); fread(ndata.buffer,1,4,fp); if(pdata.uni_gbk[0]\u0026gt;ndata.uni_gbk[0]) { flag=1; fseek(fp,j*4,0); fwrite(ndata.buffer,4,1,fp); fseek(fp,j*4+4,0); fwrite(pdata.buffer,4,1,fp); } } printf(\u0026quot;i=%d/n\u0026quot;,i); } fclose(fp); } 排序后，为了与没有排序的uni2gbk.txt区分，将文件名改为uni2gbkp.txt。\n4.删除无用的编码 #用winhex打开uni2gbkp.txt，可以发现，从0到第0x80EB个字节中的unicode编码都是0x0020或0x003F，这些都是无用的编码，它们所对应的gbk编码也是无用的，都可以删除。\n删除后，uni2gbkp.txt文件中的union code数据结构的unicode编码就是从0x00A4开始，以0xFFE5结束。但是这些unicode编码不是连续的，例如0x00A4之后就是0x00A7，为了方便查找，需要在不连续的编码中间用union code填充，对应的gbk编码部分用0x0000填充，然后将union code中的unicode编码全部删除。最后生成uni2gbk.bin文件。程序如下：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; union code { unsigned int unigbk; unsigned short int uni_gbk[2]; unsigned char buffer[4]; }; int main() { unsigned short int count=0x00A4; //从unicode的0x00A4开始 union code temp; FILE *frp=0; FILE *fwp=0; frp=fopen(\u0026quot;uni2gbkp.txt\u0026quot;,\u0026quot;rb\u0026quot;); fwp=fopen(\u0026quot;uni2gbk.bin\u0026quot;,\u0026quot;wb\u0026quot;); fseek(frp,0x80EC,SEEK_SET); //舍弃uni2gbkp.txt文件的前0x80EC个字节 fread(temp.buffer,1,4,frp); while(count\u0026lt;=0xffe5) //以unicode的0xffe5结束 { if(temp.uni_gbk[0]==count) //判断unicode编码是否连续 { fputc(temp.buffer[2],fwp); //将对应的gbk编码写入uni2gbk.bin fputc(temp.buffer[3],fwp); fread(temp.buffer,1,4,frp); } else //不连续的地方填充0 { fputc(0x00,fwp); fputc(0x00,fwp); } count++; } fclose(frp); fclose(fwp); return 0; } 生成的uni2gbk.bin文件中都是gbk编码，这些gbk编码都是按照对应的unicode编码（0x00A4到0xFFE5）的顺序排列的。\n5.uni2gbk.bin的使用 #假设一个字符的unicode编码为X，那么它对应的gbk编码在uni2gbk.bin文件中的位置就是：\n（X-0x00A4）*2\n从这个位置读取一个unsigned short int数据，就是它的gbk码。然后利用GBK点阵字库（gbk.bin）即可显示。\n例如，以Linux的终端模拟点阵屏幕，程序如下：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;curses.h\u0026gt; #define START 0x8140 #define DATANUM 0x20 int displaychar(FILE *fp,unsigned short int dispch,char fillch,char start_x,char start_y); int main(void) { FILE * fp=0; unsigned short int testch = 0x7231; //汉字'爱‘的unicode码 unsigned short int gbkch=0; //存放testch的gbk编码 //将unicode转换为gbk fp = fopen(\u0026quot;uni2gbk.bin\u0026quot;,\u0026quot;rb\u0026quot;); fseek(fp,(testch-0x00A4)*((unsigned int)2),SEEK_SET); gbkch = fgetc(fp); gbkch = (fgetc(fp)\u0026lt;\u0026lt;8) + gbkch; fclose(fp); fp = fopen(\u0026quot;gbk.bin\u0026quot;,\u0026quot;rb\u0026quot;); initscr(); displaychar(fp,gbkch,'*',0,0); refresh(); while(1); endwin(); fclose(fp); return 0; } /* * fp指向点阵字库二进制文件 * 以点阵方式显示一个GBK字符 * dispch是要显示的字符，fillch是填充点阵的字符 * start_x,start_y是显示的起始坐标 */ int displaychar(FILE *fp,unsigned short int dispch,char fillch,char start_x,char start_y) { char x=start_x; char y=start_y; unsigned int location=(dispch-START)*DATANUM; int i=0; int j=0; char buf=0; fseek(fp,location,SEEK_SET); for(i=0;i\u0026lt;DATANUM;i++) { buf=fgetc(fp); //显示一个字节 for(j=0;j\u0026lt;8;j++) { move(y+j,x); if( buf \u0026amp; (0x01\u0026lt;\u0026lt;j) ) { addch(fillch); } } if(x == (start_x+15)) { x=start_x; y=start_y+8; } else x++; } return 0; } 下载： #unicode点阵字库文件：http://download.csdn.net/source/3362591\n","date":"2011 June 13","permalink":"/posts/2011/06/13/","section":"Posts","summary":"对于unicode编码的字符，可以先将unicode编码转换为GBK编码，然后利用GBK点阵字库（gbk.bin)显示字符。一个比较好的编码转换方法是，制作一个按照unicode编码顺序排列的GBK编码表，直接根据unicode编码就可以查到对应的GBK编码，具体的制作方法如下：","title":"Unicode编码字符的点阵显示"},{"content":"GBK编码共收录汉字21003个、符号883个，并提供1894个造字码位，简、繁体字融于一库。以两个字节表示一个汉字，编码范围是0x8140~0xfefe，兼容GB2318，并覆盖了unicode中的所有汉字。Win7记事本默认以GBK保存汉字。\n关于GBK的详细信息：http://baike.baidu.com/view/25421.htm\n开发环境:\nWin7、Eclipse、MinGW\n1.生成GBK全字符文件 #运行下面这段代码，生成GBK全字符文件gbk.txt,编码范围0x8140~0xfefe。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { FILE *fp=0; char ch=0; unsigned short int start=0x8140; unsigned char part1=0; unsigned char part2=0; fp=fopen(\u0026quot;gbk.txt\u0026quot;,\u0026quot;wb\u0026quot;); if(fp==NULL) { perror(\u0026quot;Cann't open gbk.txt\u0026quot;); return -1; } else printf(\u0026quot;Creat file gbk.txt/n\u0026quot;); while(start \u0026lt; 0xfeff) { part1=start\u0026gt;\u0026gt;8; part2=start; fputc(part1,fp); fputc(part2,fp); start++; } fclose(fp); printf(\u0026quot;success!\u0026quot;); return 0; } 运行后，用记事本打开gbk.txt文件，可以看到其中的字符。\n2.生成字模二进制文件 #用“牧码字模”软件打开gbk.txt文件，选择字体为宋体，字重为1，点阵大小16*16，对齐方式为左下，取模方式为“纵向取模、高位在下”。输出格式选择bin。然后点击输出，会生成一个temp.bin文件，改名为gbk.bin。\ngbk.bin文件就是GBK编码字符的点阵字库文件，每32个字节可以绘制一个字符，例如第一个字符‘丂’的显示如下：\n取模的数据为：\n0x02, 0x02, 0x02, 0xc2, 0xb2, 0x8e, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x80, 0x40, 0x3f, 0x00, 0x00, 0x00, 0x00,\n3.使用字库文件 #gbk.bin文件中按GBK编码的大小排列，每32个字节可以显示一个字符，假设一个字符的GBK编码为NUM，那么它的点阵数据第一个字节的位置就是：\n（NUM-0x8240）*32\n从这个字节开始，读取32个字节，将其按按照取模方式显示即可。\n例如：用Linux的终端模拟点阵屏幕，每个字符位置就是一个点，程序如下：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;curses.h\u0026gt; #define START 0x8140 #define DATANUM 0x20 int displaychar(FILE *fp,unsigned short int dispch,char fillch,char start_x,char start_y); int main(void) { FILE * fp=0; unsigned short int testch = 0xb0ae; //汉字'爱‘的gbk码 fp = fopen(\u0026quot;gbk.bin\u0026quot;,\u0026quot;rb\u0026quot;); initscr(); displaychar(fp,testch,'*',0,0); refresh(); while(1); endwin(); fclose(fp); return 0; } /* * fp指向点阵字库二进制文件 * 以点阵方式显示一个GBK字符 * dispch是要显示的字符，fillch是填充点阵的字符 * start_x,start_y是显示的起始坐标 */ int displaychar(FILE *fp,unsigned short int dispch,char fillch,char start_x,char start_y) { char x=start_x; char y=start_y; unsigned int location=(dispch-START)*DATANUM; int i=0; int j=0; char buf=0; fseek(fp,location,SEEK_SET); for(i=0;i\u0026lt;DATANUM;i++) { buf=fgetc(fp); //显示一个字节 for(j=0;j\u0026lt;8;j++) { move(y+j,x); if( buf \u0026amp; (0x01\u0026lt;\u0026lt;j) ) { addch(fillch); } } if(x == (start_x+15)) { x=start_x; y=start_y+8; } else x++; } return 0; } 显示效果如下：\n下载： #字库文件：http://download.csdn.net/source/3359198 字模提取软件：http://download.csdn.net/source/3358791\n","date":"2011 June 12","permalink":"/posts/2011/06/12/","section":"Posts","summary":"GBK编码共收录汉字21003个、符号883个，并提供1894个造字码位，简、繁体字融于一库。以两个字节表示一个汉字，编码范围是0x8140~0xfefe，兼容GB2318，并覆盖了unicode中的所有汉字。Win7记事本默认以GBK保存汉字。","title":"GBK点阵显示字库的制作和使用"},{"content":"开发环境：\nWin7，Eclipse，MinGW\n#1.生成ASCII字符文件\nASCII编码的可打印字符是0x20~0x7E,先用运行下面这段代码，生成一个包含全部可打印字符的txt文件：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(int argc,char *argv[]) { FILE * fp; unsigned char i = 0; fp = fopen(\u0026quot;ascii.txt\u0026quot;,\u0026quot;w\u0026quot;); if(fp == 0) { perror(\u0026quot;open\u0026quot;); return -1; } for(i=0x20;i\u0026lt;0x7F;i++) { fputc(i,fp); } return 0; } 运行后，用记事本打开ascii.txt文件，会看到如下文本：\n#2.生成字模数据\n使用字模提取V2.1软件，设置字体为宋体、12，纵向取模，字节倒序（即高位在下）。这些设置可以根据实际情况设置。用C51格式生成字模，大小是8*16，每个字符用16个字节表示。如字符A的显示如下：\n取模数据为：\n0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20,\n然后将所有的字模数据复制到一个文本文件，删除其中的空行，换行，注释等与字模数据无关的内容，并将文件最后的一个逗号改为ASCII字符的句号，得到一个纯字模数据文件ascii_zk.txt\n#3.将字模数据文件转换为二进制文件\n将ascii_zk.txt文件中的每个字模数据转换为占一个字节的数，将所有的数据填充为一个二进制文件ascii_zk.bin。这样，按照ASCII码的顺序，ascii_zk.bin中每16个字节就可以绘制一个字符。文件转换的程序如下：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; /* *将一个ascii字符转换为数 */ unsigned char c2x(char ch) { unsigned char temp=0; if(ch\u0026gt;=0x30 \u0026amp;\u0026amp; ch\u0026lt;=0x39) temp = ch-0x30; else if(ch\u0026gt;=0x41 \u0026amp;\u0026amp; ch\u0026lt;=0x46) temp = 0x0a+(ch-0x41); else if(ch\u0026gt;=0x61 \u0026amp;\u0026amp; ch\u0026lt;=0x66) temp = 0x0a+(ch-0x61); else temp =0xff; return temp; } //将ascii_zk.txt转换为二进制文件 int main(void) { char buffer[5]; unsigned char ch=0; int i=0; FILE *frp=0; FILE *fwp=0; for(i=0; i\u0026lt;5; i++) buffer[i] = 0; frp=fopen(\u0026quot;ascii_zk.txt\u0026quot;,\u0026quot;r\u0026quot;); fwp=fopen(\u0026quot;ascii_zk.bin\u0026quot;,\u0026quot;w\u0026quot;); while(buffer[4] != 0x2e) //全部数据以句号结尾 { for(i=0; i\u0026lt;5; i++) buffer[i]=fgetc(frp); ch = c2x(buffer[2]); ch = ch*16; ch = ch+c2x(buffer[3]); fputc(ch,fwp); } fclose(frp); fclose(fwp); return 0; } 字库文件制作完毕。\n#4.字库文件ascii_zk.bin的使用\nascii_zk.bin文件从ASCII码的空格（0x20）开始，每16个字节表示一个字符的点阵字模。以字母A为例，它的ASCII码是0x41，那么，它的字模数据的开始位置就是：\n（0x41-0x20）*16\n从这个位置开始依次读取16个字节，就是字母A的字模数据，将其显示即可。\n例：用Linux的终端模拟显示点阵字符，终端屏幕中的每个字符位置就是一个点，程序如下。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;curses.h\u0026gt; #define START 0x20 #define DATANUM 0x10 int displaychar(FILE *fp,char dispch,char fillch,char start_x,char start_y); int main(void) { FILE* fp=0; int i = 0; const char * teststring=\u0026quot;I love Julia\u0026quot;; fp=fopen(\u0026quot;ascii_zk.bin\u0026quot;,\u0026quot;r\u0026quot;); initscr(); for(i=0;(teststring[i]!=0);i++) { displaychar(fp,teststring[i],'*',0+(i*8),0); } refresh(); while(1); endwin(); fclose(fp); return 0; } /* * 以点阵方式显示一个ASCII字符 * dispch是要显示的字符，fillch是填充点阵的字符 * start_x,start_y是显示的起始坐标 */ int displaychar(FILE *fp,char dispch,char fillch,char start_x,char start_y) { int location = ((dispch-START) * DATANUM); char x=start_x; char y=start_y; int i=0; int j=0; char buf=0; //将文件流指针移到到dispch字符点阵数据的起始位置 fseek(fp,location,SEEK_SET); for(i=0;i\u0026lt;DATANUM;i++) { buf = fgetc(fp); //显示一个字节 for(j=0;j\u0026lt;8;j++) { move(y+j,x); if(buf \u0026amp; (0x01\u0026lt;\u0026lt;j)) addch(fillch); } if(x == (start_x+7)) { x = start_x; y = (start_y+8); } else { x++; } } return 0; } 该程序在Fedora12的终端中运行，效果如下：\n#下载：\nASCII点阵字库文件\n","date":"2011 June 8","permalink":"/posts/2011/06/08/","section":"Posts","summary":"开发环境：","title":"ASCII字符点阵字库的制作和使用"},{"content":"环境：Fedora12 Gcc4.4.2\n在C语言中，main函数的声明如下：\nint main（int argc，char *argv[]); argc是指程序参数的个数，包括程序名本身，如果程序不带参数，argc为1；\nargv的每个数组元素存放一个程序参数，程序名存放在argv[0];\n例如：\n$ ls -l 此时，argc为2，argv[0]是ls，argv[1]是-l。\n程序的参数可以分为三种：选项，选项的关联值，非选项参数。例如：\n$gcc hello.c -o hello hello.c是非选项参数，-o是选项，hello是-o选项的关联值。\n根据Linux的惯例，程序的选项应该以一个短横线开头，后面包含单个字母或数字，选项分为两种：带关联值的和不带关联值的，例如：\n$gcc hello.c -o hello 选项-o必须带一个关联值。\n$ls -l 选项-l无需带参数。\n不带关联值的选项应该可以在一个短横线后合并使用，例如：\n$ls -la Linux系统提供了getopt函数，它用来按照上述规则处理程序的参数，相关定义如下：\n#include \u0026lt;unistd.h\u0026gt; int getopt(int argc,char *const argv[],const char *optstring); extern char *optarg; extern int optind,opterr,optopt; getopt 使用 main 函数的 argc 和 argv 作为前两个参数，optsting 是一个字符列表，每个字符代表一个单字符选项，如果一个字符后面紧跟以冒号（：），表示该字符有一个关联值作为下一个参数；\ngetopt的返回值是argv数组中的下一个选项参数，由optind记录argv数组的下标,如果选项参数处理完毕，函数返回-1；\n如果遇到一个无法识别的选项，返回问号（？），并保存在optopt中；\n如果一个选项需要一个关联值，而程序执行时没有提供，返回一个问号（？）,如果将optstring的第一个字符设为冒号（:),这种情况下，函数会返回冒号而不是问号。\n选项参数处理完毕后，optind 会指向 argv 数组尾部的其他非选项参数。实际上，getopt 在执行过程中会重排 argv 数组，将非选项参数移到数组的尾部。\n例：\n下面这个程序需要提供两个无关联值的选项：-v，-g；一个需要关联值的选项：-t；一个非选项参数。\n//getopttest.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main(int argc,char *argv[]) { int opt=0; int i=0; const char *optstring=\u0026quot;:vgt:\u0026quot;; //非选项参数的个数 const int num=1; //调用getopt前打印argv数组 for(i=0;i\u0026lt;argc;i++) printf(\u0026quot;%d:%s/n\u0026quot;,i,argv[i]); //处理选项参数 while((opt=getopt(argc,argv,optstring)) != -1) { switch(opt) { case 'v': case 'g': printf(\u0026quot;option：%c/n\u0026quot;,opt); break; case 't': printf(\u0026quot;option:%c = %s/n\u0026quot;,opt,optarg); break; case ':': printf(\u0026quot;the option need a value/n\u0026quot;); break; case '?': printf(\u0026quot;unknow option：%c/n\u0026quot;,optopt); break; } } //处理非选项参数 for(i=0;optind\u0026lt;argc;i++,optind++) { if(i\u0026lt;num) printf(\u0026quot;argument:%s/n\u0026quot;,argv[optind]); else printf(\u0026quot;excess argument:%s/n\u0026quot;,argv[optind]); } //调用getopt后打印argv数组 for(i=0;i\u0026lt;argc;i++) printf(\u0026quot;%d:%s/n\u0026quot;,i,argv[i]); return 0; } 编译：\ngcc -Wall getopttest.c -o getopttest 执行：\n$./getopttest arg1 -vg -t value -x arg2 0:./getopttest 1:arg1 2:-vg 3:-t 4:value 5:-x 6:arg2 option：v option：g option:t = value unknow option：x argument:arg1 excess argument:arg2 0:./getopttest 1:-vg 2:-t 3:value 4:-x 5:arg1 6:arg2 从执行结果可以看出，getopt 函数重排了 argv 数组，将非选项参数 arg1 排到了数组尾部。\n","date":"2011 May 28","permalink":"/posts/2011/05/28/","section":"Posts","summary":"环境：Fedora12 Gcc4.","title":"用getopt处理main函数的参数"},{"content":"环境：fedora12，gcc4.4.4\nC语言参数个数可变的函数，叫做VA函数（variable argument function），例如printf()函数。要实现VA函数需要包含stdarg.h:\n#include \u0026lt;stdarg.h\u0026gt; 主要使用下面三个宏定义：\nva_start(ap, A) va_arg(ap, T) va_end(ap) ap 是类型是 va_list ，va_list 的定义如下：\ntypedef char *va_list; 它用来指向函数的参数。\nA是函数的最后一个固定参数，一个VA函数必须有至少一个固定参数。\nT是参数的类型，例如int，char\u0026hellip;,等等。\nva_start(ap,A)：初始化函数参数指针ap，使ap指向A的右边的第一个参数，即函数可变参数中的第一个； va_arg(ap,T）：返回ap指向的参数的值，参数的类型用T确定，然后将ap指向下一个参数； va_end（ap）：释放ap。 下面的例子定义了一个va函数，作用是依次打印传递给函数的int型参数。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; int va_function(const char *start,...) { int n=1; va_list arg; va_start(arg,start); printf(\u0026quot;%s/n\u0026quot;,start); while(n != 0) { n=va_arg(arg,int); printf(\u0026quot;%d/n\u0026quot;,n); } va_end(arg); return 0; } int main(void) { va_function(\u0026quot;start\u0026quot;,1,2,3,-1,-2,0); return 0; } 注意：\nVA函数的可变参数类型必须在函数中自行确定，编译器无法自动识别。 必须在VA函数中定义可变参数的结束标志，如果没有结束标志，va_arg会依次返回内存中的值，直到访问到非法内存而出错退出。 这几个宏在不同的编译器中有不同的定义，但是功能是一样的，在linux的内核源码中也用定义，可以参考。在内核源码的 /include/acpi/platform/acenv.h 文件内：\ntypedef char *va_list; /* Storage alignment properties */ #define _AUPBND (sizeof (acpi_native_uint) - 1) #define _ADNBND (sizeof (acpi_native_uint) - 1) /* Variable argument list macro definitions */ #define _bnd(X, bnd) (((sizeof (X)) + (bnd)) \u0026amp; (~(bnd))) #define va_arg(ap, T) (*(T *)(((ap) += (_bnd (T, _AUPBND))) - (_bnd (T,_ADNBND)))) #define va_end(ap) (void) 0 #define va_start(ap, A) (void) ((ap) = (((char *) \u0026amp;(A)) + (_bnd (A,_AUPBND)))) 参考：\n深入浅出VA函数\nlinux kernel中的变长参数宏\n《The Open Group Base Specifications Issue 6》\n","date":"2011 May 17","permalink":"/posts/2011/05/17/","section":"Posts","summary":"环境：fedora12，gcc4.4.4","title":"C语言的参数可变函数"},{"content":"**Esc **：escape\n**Tab **：table\n**Caps Lock **：Capital Lock\n**Shift **：shift\n**Ctrl **：control\n**Alt **：alternative\n**Enter **： enter\n**F1~12 **：functions\n**~ **：tilde\n**! **：exclamation\n**@ **：at\n**# **：pound ，hash\n**$ **：dollar\n**% **：percent\n**^ **：caret\n**\u0026amp; **：ampersand\n*** **：star\n**( **：opening parenthesis\n**) **：closing parenthesis\n**_ **：underscore\n**+ **：plus\n**- **：Minus\n**= **：equals\n**` **：backquote\n**{ **：opening brace\n**} **：closing brace\n**[ **：opening bracket\n**] **：closing bracket\n**| **：pipe\n**\\ **：backslash\n**: **：colon\n**; **：semicolon\n**“ **：double quote\n**‘ **：single quote\n**\u0026lt; **：less than\n**, **：comma\n**\u0026gt; **：great than\n**. **：dot\n**? **：question mark\n**/ **：slash\n","date":"2011 April 10","permalink":"/posts/2011/04/10/","section":"Posts","summary":"**Esc **：escape","title":"键盘上各个按键的英文名"},{"content":"test.sh :\n#!/bin/bash pid=`ps -ef | grep -v grep | grep -v \u0026quot;test.sh\u0026quot; | grep $1 | sed -n '1P' | awk '{print $2}'` if [ -z $pid ] ; then echo \u0026quot;no this process\u0026quot; else echo $pid fi 例：\n查询是否存在hello进程\n#./test.sh hello 如果存在 hello 进程，会输出 PID ; 不存在会输出 no this process\n","date":"2011 March 4","permalink":"/posts/2011/03/04/","section":"Posts","summary":"test.sh :","title":"判断进程是否存在的脚本"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"}]