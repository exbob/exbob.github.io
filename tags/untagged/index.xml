<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>untagged on Shaocheng.Li</title><link>https://shaocheng.li/tags/untagged/</link><description>Recent content in untagged on Shaocheng.Li</description><generator>Hugo -- gohugo.io</generator><copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright><lastBuildDate>Sat, 06 Mar 2021 21:19:11 +0800</lastBuildDate><atom:link href="https://shaocheng.li/tags/untagged/index.xml" rel="self" type="application/rss+xml"/><item><title>Systemd 中实现自动登录和程序自启动</title><link>https://shaocheng.li/posts/2021/03/06/</link><pubDate>Sat, 06 Mar 2021 21:19:11 +0800</pubDate><guid>https://shaocheng.li/posts/2021/03/06/</guid><description>以 NXP 的 Yocto Linux 4.9.88 为例。
Systemd 管理系统资源的基本单元是 Unit ，分为 12 种：
Service unit：系统服务 Target unit：多个 Unit 构成的一个组 Device Unit：硬件设备 Mount Unit：文件系统的挂载点 Automount Unit：自动挂载点 Path Unit：文件或路径 Scope Unit：不是由 Systemd 启动的外部进程 Slice Unit：进程组 Snapshot Unit：Systemd 快照，可以切回某个快照 Socket Unit：进程间通信的 socket Swap Unit：swap 文件 Timer Unit：定时器 我们可以使用 systemd-analyze 命令来分析系统启动的过程：
# 查看启动耗时 $ systemd-analyze # 查看每个服务的启动耗时 $ systemd-analyze blame # 显示瀑布状的启动过程流 $ systemd-analyze critical-chain # 显示指定服务的启动流 $ systemd-analyze critical-chain atd.service # 将系统启动流程输出为 svg 格式，可以通过浏览器查看 systemd-analyze plot &amp;gt; .</description></item><item><title>在 i.MX 6ULL 上学习 Yocto</title><link>https://shaocheng.li/posts/2020/12/12/</link><pubDate>Sat, 12 Dec 2020 18:40:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/12/12/</guid><description>1. 概述 NXP 为官方评估板 i.MX6ULL EVK 提供了完整的 Yocto 项目源码和文档 ，板卡的外观和接口如图：
特性：
参考板是 iMX6ULL EVK ：https://www.nxp.com/design/development-boards/i-mx-evaluation-and-development-boards/evaluation-kit-for-the-i-mx-6ull-and-6ulz-applications-processor:MCIMX6ULL-EVK 芯片是 NXP 的 iMX6ULL : https://www.nxp.com/products/processors-and-microcontrollers/arm-processors/i-mx-applications-processors/i-mx-6-processors:IMX6X_SERIES 软件使用最新的 Linux 5.4.47_2.2.0 : https://www.nxp.com/design/software/embedded-software/i-mx-software/embedded-linux-for-i-mx-applications-processors:IMXLINUX 2. 构建系统 我们先为这个板卡编译一个可以运行的系统。
2.1. 准备宿主机 使用 Ubuntu 20.04 （至少要用 18.04 ，低版本系统会遇到很多问题），安装必要的开发包：
$ sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib \ build-essential chrpath socat cpio python python3 python3-pip python3-pexpect \ xz-utils debianutils iputils-ping python3-git python3-jinja2 libegl1-mesa libsdl1.2-dev \ pylint3 xterm 安装 repo :</description></item><item><title>使用 Docker 学习 Redis</title><link>https://shaocheng.li/posts/2020/09/01/</link><pubDate>Tue, 01 Sep 2020 09:53:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/09/01/</guid><description># 1. 安装 Docker 的安装比较简单，访问 ，按照指引安装相应系统的版本即可。安装完毕后，我们先拉取 Redis 的镜像：
$ docker pull redis 这个命令默认是拉取 Redis 官方的 Docker 镜像最新版，也可以在后面指定具体的版本：
$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE docker101tutorial latest 8e9d20f8bd52 38 hours ago 27.3MB nginx alpine 6f715d38cfe0 2 weeks ago 22.1MB nginx latest 4bb46517cac3 2 weeks ago 133MB python alpine 44fceb565b2a 2 weeks ago 42.7MB redis latest 1319b1eaa0b7 3 weeks ago 104MB node 12-alpine 18f4bc975732 4 weeks ago 89.3MB 然后启动这个进行容器:</description></item><item><title>epoll 学习笔记</title><link>https://shaocheng.li/posts/2020/08/30/</link><pubDate>Sun, 30 Aug 2020 11:53:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/08/30/</guid><description>1. 工作原理 epoll 是 Linux 独有的 I/O 多路复用机制，核心概念就是 epoll 实例，它是一个内核里的数据结构，从用户角度来看它可以简单的看做包含了两个队列：
interest list（或者叫epoll set），用户注册的感兴趣的描述符集合。 ready list，就绪的描述符集合，当有 I/O 就绪时，内核会自动将就绪的描述符加到 ready list 中。 在用户端的工作流程就是：
向 interest list 注册感兴趣的文件描述符的 I/O 事件。 等待已注册的文件描述符就绪。 处理所有已经就绪的文件描述符。 2. 使用方法 使用 epoll 时，需要包括头文件：
#include &amp;lt;sys/epoll.h&amp;gt; 2.1 新建一个 epoll 实例 int epoll_create(int size); epoll_create() 函数会新建一个 epoll 实例，然后返回一个文件描述符，作为 epoll 操作的句柄。从 Linux 2.6.8 开始， 参数 size 可以忽略，但是必须大于 0 。当不在需要这个描述符时，应该调用 close() 函数将其关闭。
调用失败时，会返回一个负数。
2.2 操作 epoll 实例 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 这是操作 epoll 实例的接口函数，用于添加、删除和修改 interest list 中监控的文件描述符。如果调用成功，会返回 0 ，如果失败，会返回一个负数，并设置 errno 。参数的含义：</description></item><item><title>uthash 学习笔记</title><link>https://shaocheng.li/posts/2020/08/29/</link><pubDate>Sat, 29 Aug 2020 11:23:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/08/29/</guid><description>uthash 是一个 C 语言的哈希表函数库，支持哈希表的各种操作，包括添加，删除，查找，排序等。你可以在 github 上下载到它的源码：
源码：https://github.com/troydhanson/uthash 文档：https://troydhanson.github.io/uthash/userguide.html 这个函数库在使用时只需要包含 uthash.h 头文件即可，没有二进制的库文件。
1. 数据结构 uthash 的哈希表是由多个结构体组成的双向链表实现的，一个结构体就是一个键值对，例如：
#include &amp;#34;uthash.h&amp;#34; struct my_struct { int id; /* key */ char name[10]; UT_hash_handle hh; /* makes this structure hashable */ }; id 就是键（key），名称和数据类型没有限制； name 就是值（value），也可以是任何数据类型； hh 是内部使用的 hash 处理句柄，UT_hash_handle 字段必须存在于你的结构中。它用于内部记录，使哈希表正常工作，它不需要初始化。可以被命名为任何标识符； 哈希句柄在 32 位系统中每个元素消耗约 32 个字节，在 64 位系统中每个元素消耗 56 个字节。其他的开销成本&amp;ndash;桶和表&amp;ndash;相比之下可以忽略不计。你可以使用 HASH_OVERHEAD 来获取哈希表的开销大小，单位是字节。
2. 基本操作 完整的例子可以在源码下的 tests/exapmle.c 文件中找到，可以执行 make example 进行编译。
2.1 声明 定义一个结构体类型的空指针，即声明了一个哈希表：</description></item><item><title>libubox 学习笔记</title><link>https://shaocheng.li/posts/2020/07/16/</link><pubDate>Thu, 16 Jul 2020 21:23:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/07/16/</guid><description>编译安装 首先要安装一些依赖的软件：
apt-get install pkg-config apt-get install lua5.1 apt-get install liblua5.1-dev apt-get install cmake apt-get install libjson-c-dev 然后要编译安装 libubox ：
git clone https://git.openwrt.org/project/libubox.git cd libubox cmake . make make install ulog 头文件 ulog.h 提供了打印日志的方法。使用时，先调用 ulog_open() 函数初始化一些 ulog 需要的变量：
void ulog_open(int channels, int facility, const char *ident); channels 用于设置日志消息的输出目标，取值：
ULOG_KMSG，内核日志，输出到了 /dev/kmsg 文件。 ULOG_SYSLOG，系统日志，调用了 vsyslog() 产生系统日志。 ULOG_STDIO，标准输出，输出到了 stderr 。 facility 用于设置记录日志的程序的类型，只有当 channels 的值为 ULOG_SYSLOG 时，这个参数有效。取值与 openlog() 的第三个参数一致，它们是定义在 &amp;lt;syslog.h&amp;gt; 中的宏：</description></item><item><title>CMake 学习笔记</title><link>https://shaocheng.li/posts/2020/06/29/</link><pubDate>Mon, 29 Jun 2020 22:25:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/06/29/</guid><description>本教程提供了一个渐进式的指导，参考的是官方教程 CMake Tutorial ，然后加入学习过程的笔记。涵盖了使用 CMake 构建一个工程时经常遇到的问题 。通过一个示例项目，展示各种功能是如何一起工作的，这对理解 CMake 非常有用。
1. 最简单的工程 最简单工程是从源码文件直接编译生成一个可执行的问题，最简单的解决方案只需要在 CMakeLists.txt 文件中添加三行。
新建一个工程目录，在目录下新建一个源文件 Tutorial.c ：
#include &amp;lt;stdio.h&amp;gt; int main (int argc, char *argv[]) { printf(&amp;#34;Hello World!\n&amp;#34;); return 0; } 新建一个 CMakeLists.txt ：
cmake_minimum_required(VERSION 3.1)project(Tutorial)add_executable(Tutorial Tutorial.c) CMakeLists.txt 是 cmake 生成 Makefile 所依赖的描述性文件，文件内容由一行一行的命令组成，命令不区分大小写。
cmake_minimum_required 表示该项目对 CMake 的最低版本要求。 project 用于设置项目名称。 add_executable 添加了一个生成的可执行文件，和依赖的源码。 这样的话，执行 cmake . 生成 Makefile ，再执行 make 开始编译，就可以使用 Tutorial.c 生成的可执行文件 Tutorial 。
cmake 执行过程中会生成大量的缓存文件，又没有提供类似 cmake clean 的命令来清除生成的文件，有一个简单的方法可以解决这个问题。在工程目录下新建一个名为 build 的子目录，进入这个子目录中执行 cmake .</description></item><item><title>Markdown Syntax Guide</title><link>https://shaocheng.li/posts/2020/01/15/</link><pubDate>Wed, 15 Jan 2020 14:31:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/01/15/</guid><description>This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.
Headings The following HTML &amp;lt;h1&amp;gt;—&amp;lt;h6&amp;gt; elements represent six levels of section headings. &amp;lt;h1&amp;gt; is the highest section level while &amp;lt;h6&amp;gt; is the lowest.
H1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo.</description></item></channel></rss>