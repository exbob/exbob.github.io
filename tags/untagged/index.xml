<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>untagged on Shaocheng.Li</title><link>https://shaocheng.li/tags/untagged/</link><description>Recent content in untagged on Shaocheng.Li</description><generator>Hugo -- gohugo.io</generator><copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright><lastBuildDate>Sun, 30 Aug 2020 11:53:11 +0800</lastBuildDate><atom:link href="https://shaocheng.li/tags/untagged/index.xml" rel="self" type="application/rss+xml"/><item><title>epoll 学习笔记</title><link>https://shaocheng.li/posts/2020/08/30/</link><pubDate>Sun, 30 Aug 2020 11:53:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/08/30/</guid><description>1. 工作原理 epoll 是 Linux 独有的 I/O 多路复用机制，核心概念就是 epoll 实例，它是一个内核里的数据结构，从用户角度来看它可以简单的看做包含了两个队列：
interest list（或者叫epoll set），用户注册的感兴趣的描述符集合。 ready list，就绪的描述符集合，当有 I/O 就绪时，内核会自动将就绪的描述符加到 ready list 中。 在用户端的工作流程就是：
向 interest list 注册感兴趣的文件描述符的 I/O 事件。 等待已注册的文件描述符就绪。 处理所有已经就绪的文件描述符。 2. 使用方法 使用 epoll 时，需要包括头文件：
#include &amp;lt;sys/epoll.h&amp;gt; 2.1 新建一个 epoll 实例 int epoll_create(int size); epoll_create() 函数会新建一个 epoll 实例，然后返回一个文件描述符，作为 epoll 操作的句柄。从 Linux 2.6.8 开始， 参数 size 可以忽略，但是必须大于 0 。当不在需要这个描述符时，应该调用 close() 函数将其关闭。
调用失败时，会返回一个负数。
2.2 操作 epoll 实例 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 这是操作 epoll 实例的接口函数，用于添加、删除和修改 interest list 中监控的文件描述符。如果调用成功，会返回 0 ，如果失败，会返回一个负数，并设置 errno 。参数的含义：</description></item><item><title>uthash 学习笔记</title><link>https://shaocheng.li/posts/2020/08/29/</link><pubDate>Sat, 29 Aug 2020 11:23:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/08/29/</guid><description>uthash 是一个 C 语言的哈希表函数库，支持哈希表的各种操作，包括添加，删除，查找，排序等。你可以在 github 上下载到它的源码：
源码：https://github.com/troydhanson/uthash 文档：https://troydhanson.github.io/uthash/userguide.html 这个函数库在使用时只需要包含 uthash.h 头文件即可，没有二进制的库文件。
1. 数据结构 uthash 的哈希表是由多个结构体组成的双向链表实现的，一个结构体就是一个键值对，例如：
#include &amp;#34;uthash.h&amp;#34; struct my_struct { int id; /* key */ char name[10]; UT_hash_handle hh; /* makes this structure hashable */ }; id 就是键（key），名称和数据类型没有限制； name 就是值（value），也可以是任何数据类型； hh 是内部使用的 hash 处理句柄，UT_hash_handle 字段必须存在于你的结构中。它用于内部记录，使哈希表正常工作，它不需要初始化。可以被命名为任何标识符； 哈希句柄在 32 位系统中每个元素消耗约 32 个字节，在 64 位系统中每个元素消耗 56 个字节。其他的开销成本&amp;ndash;桶和表&amp;ndash;相比之下可以忽略不计。你可以使用 HASH_OVERHEAD 来获取哈希表的开销大小，单位是字节。
2. 基本操作 完整的例子可以在源码下的 tests/exapmle.c 文件中找到，可以执行 make example 进行编译。
2.1 声明 定义一个结构体类型的空指针，即声明了一个哈希表：</description></item><item><title>libubox 学习笔记</title><link>https://shaocheng.li/posts/2020/07/16/</link><pubDate>Thu, 16 Jul 2020 21:23:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/07/16/</guid><description>编译安装 首先要安装一些依赖的软件：
apt-get install pkg-config apt-get install lua5.1 apt-get install liblua5.1-dev apt-get install cmake apt-get install libjson-c-dev 然后要编译安装 libubox ：
git clone https://git.openwrt.org/project/libubox.git cd libubox cmake . make make install ulog 头文件 ulog.h 提供了打印日志的方法。使用时，先调用 ulog_open() 函数初始化一些 ulog 需要的变量：
void ulog_open(int channels, int facility, const char *ident); channels 用于设置日志消息的输出目标，取值：
ULOG_KMSG，内核日志，输出到了 /dev/kmsg 文件。 ULOG_SYSLOG，系统日志，调用了 vsyslog() 产生系统日志。 ULOG_STDIO，标准输出，输出到了 stderr 。 facility 用于设置记录日志的程序的类型，只有当 channels 的值为 ULOG_SYSLOG 时，这个参数有效。取值与 openlog() 的第三个参数一致，它们是定义在 &amp;lt;syslog.h&amp;gt; 中的宏：</description></item><item><title>CMake 学习笔记</title><link>https://shaocheng.li/posts/2020/06/29/</link><pubDate>Mon, 29 Jun 2020 22:25:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/06/29/</guid><description>本教程提供了一个渐进式的指导，参考的是官方教程 CMake Tutorial ，然后加入学习过程的笔记。涵盖了使用 CMake 构建一个工程时经常遇到的问题 。通过一个示例项目，展示各种功能是如何一起工作的，这对理解 CMake 非常有用。
1. 最简单的工程 最简单工程是从源码文件直接编译生成一个可执行的问题，最简单的解决方案只需要在 CMakeLists.txt 文件中添加三行。
新建一个工程目录，在目录下新建一个源文件 Tutorial.c ：
#include &amp;lt;stdio.h&amp;gt; int main (int argc, char *argv[]) { printf(&amp;#34;Hello World!\n&amp;#34;); return 0; } 新建一个 CMakeLists.txt ：
cmake_minimum_required(VERSION 3.1)project(Tutorial)add_executable(Tutorial Tutorial.c) CMakeLists.txt 是 cmake 生成 Makefile 所依赖的描述性文件，文件内容由一行一行的命令组成，命令不区分大小写。
cmake_minimum_required 表示该项目对 CMake 的最低版本要求。 project 用于设置项目名称。 add_executable 添加了一个生成的可执行文件，和依赖的源码。 这样的话，执行 cmake . 生成 Makefile ，再执行 make 开始编译，就可以使用 Tutorial.c 生成的可执行文件 Tutorial 。
cmake 执行过程中会生成大量的缓存文件，又没有提供类似 cmake clean 的命令来清除生成的文件，有一个简单的方法可以解决这个问题。在工程目录下新建一个名为 build 的子目录，进入这个子目录中执行 cmake .</description></item><item><title>使用 pm2 管理进程</title><link>https://shaocheng.li/posts/2020/03/24/</link><pubDate>Tue, 24 Mar 2020 21:15:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/03/24/</guid><description>PM2 是基于 nodejs 的进程管理工具，需要用 npm 安装，通常用于管理 node 进程，也可以管理其他语言编写的软件，官网是 https://pm2.keymetrics.io/ ，具有如下特性：</description></item><item><title>Markdown Syntax Guide</title><link>https://shaocheng.li/posts/2020/01/15/</link><pubDate>Wed, 15 Jan 2020 14:31:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/01/15/</guid><description>This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.
Headings The following HTML &amp;lt;h1&amp;gt;—&amp;lt;h6&amp;gt; elements represent six levels of section headings. &amp;lt;h1&amp;gt; is the highest section level while &amp;lt;h6&amp;gt; is the lowest.
H1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo.</description></item></channel></rss>