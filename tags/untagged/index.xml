<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>untagged on Shaocheng.Li</title><link>https://shaocheng.li/tags/untagged/</link><description>Recent content in untagged on Shaocheng.Li</description><generator>Hugo -- gohugo.io</generator><copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright><lastBuildDate>Fri, 07 May 2021 20:49:11 +0800</lastBuildDate><atom:link href="https://shaocheng.li/tags/untagged/index.xml" rel="self" type="application/rss+xml"/><item><title>如何修改 ARM Linux 系统的启动画面</title><link>https://shaocheng.li/posts/2021/05/07/</link><pubDate>Fri, 07 May 2021 20:49:11 +0800</pubDate><guid>https://shaocheng.li/posts/2021/05/07/</guid><description>以 NXP 的 iMX Yocto 4.9.88 系统版本为例，启动分为三个阶段：U-Boot ，内核，根文件系统，每个阶段都可以设置自己的显示画面。
U-Boot 的启动画面 u-boot 阶段的运行时很短，一般不用修改。待补充。
内核的启动画面 PPM 图片格式 如果开启了 FrameBuffer ，Linux 内核启动时会在屏幕左上角显示企鹅图标，图标的数量等于 CPU 的核心数量。这个图标来自于内核源码的 driver/video/logo/ 目录下的 ppm 格式图片：
$ ls drivers/video/logo/ clut_vga16.ppm logo_linux_mono.pbm logo_sun_clut224.ppm Kconfig logo_linux_vga16.ppm logo_superh_clut224.ppm logo_blackfin_clut224.ppm logo_m32r_clut224.ppm logo_superh_mono.pbm logo_blackfin_vga16.ppm logo_mac_clut224.ppm logo_superh_vga16.ppm logo.c logo_parisc_clut224.ppm Makefile logo_dec_clut224.ppm logo_sgi_clut224.ppm logo_linux_clut224.ppm logo_spe_clut224.ppm 这里的 ppm 格式是一种 ASCII 编码的图片文件格式，可以用文本编辑器打开，以 logo_linux_clut224.ppm 为例 ：
P3 # Standard 224-color Linux logo 80 80 255 0 0 0 0 0 0 0 0 0 0 0 0 井号 # 开头的是注释，忽略注释后，前三行文本是文件头：</description></item><item><title>Linux 系统的 SPI 设备编程</title><link>https://shaocheng.li/posts/2021/04/10/</link><pubDate>Sat, 10 Apr 2021 21:19:11 +0800</pubDate><guid>https://shaocheng.li/posts/2021/04/10/</guid><description>SPI 通信协议 SPI 的全称是 Serial Peripheral Interface，是一个带时钟同步的全双工串行链接，使用主/从结构，用于连接微控制器和传感器、存储器和外设。常见的连接结构如下：
通信时需要四个信号：
SCLK，Serial Clock，时钟信号，SPI 的时钟频率通常可以达到 10MHz，实际情况还依赖从机能够支持的时钟频率。 MISO，Master In Slave Out，从机向主机发出的数据。 MOSI，Master Out Slave In，主机向从机发出的数据。 SS，Slave Select，从机选择，也叫做片选信号。一条 SPI 总线可以连接多个从设备，SCLK、MISO 和 MOSI 是共用的，每个从机需要一个独立的片选信号，当从机的 SS 信号拉低时，表示从机被选中，才开始接收总线上的信号。 在一个SPI时钟周期内，收发是同时进行的：
主机通过 MOSI 线发送 1bit 数据，从机通过该线读取这 1bit 数据； 从机通过 MISO 线发送 1bit 数据，主机通过该线读取这 1bit 数据。 这个过程是 SPI 设备内的移位寄存器实现的，当寄存器中的内容全部移出时，相当于完成了两个寄存器内容的交换，如下图所示。
下面是一个典型的主机模型的通信时序，描述了主机的 0xD2 的数据被移出，从 MISO 信号移入了 0x66 ：
SCLK 、MOSI 和 SS 信号由主机产生，MISO 是从机发出的信号，主机从这个信号读取从机的数据。通信开始前，SCLK 为低电平，当 SS 拉低后，从机被选中，通信开始，MOSI 和 MISO 信号在 SCLK 的上升沿发生变化，MISO 信号在 SCLK 的下降沿被采样锁存，通信结束后，SS 信号拉高，SCLK 信号重回低电平，一次通信发出的 bit 数为一个 word ，也叫字长。这只是一种情况，在 SCLK 下降沿和上升沿所做的事情由 CPOL 和 CPHA 的值决定，可以在 SPI 设备内的寄存器配置：</description></item><item><title>Systemd 中实现自动登录和程序自启动</title><link>https://shaocheng.li/posts/2021/03/06/</link><pubDate>Sat, 06 Mar 2021 21:19:11 +0800</pubDate><guid>https://shaocheng.li/posts/2021/03/06/</guid><description>以 NXP 的 Yocto Linux 4.9.88 为例。
Systemd 管理系统资源的基本单元是 Unit ，分为 12 种：
Service unit：系统服务 Target unit：多个 Unit 构成的一个组 Device Unit：硬件设备 Mount Unit：文件系统的挂载点 Automount Unit：自动挂载点 Path Unit：文件或路径 Scope Unit：不是由 Systemd 启动的外部进程 Slice Unit：进程组 Snapshot Unit：Systemd 快照，可以切回某个快照 Socket Unit：进程间通信的 socket Swap Unit：swap 文件 Timer Unit：定时器 我们可以使用 systemd-analyze 命令来分析系统启动的过程：
# 查看启动耗时 $ systemd-analyze # 查看每个服务的启动耗时 $ systemd-analyze blame # 显示瀑布状的启动过程流 $ systemd-analyze critical-chain # 显示指定服务的启动流 $ systemd-analyze critical-chain atd.service # 将系统启动流程输出为 svg 格式，可以通过浏览器查看 systemd-analyze plot &amp;gt; .</description></item><item><title>在 i.MX 6ULL 上学习 Yocto</title><link>https://shaocheng.li/posts/2020/12/12/</link><pubDate>Sat, 12 Dec 2020 18:40:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/12/12/</guid><description>1. 概述 NXP 为官方评估板 i.MX6ULL EVK 提供了完整的 Yocto 项目源码和文档 ，板卡的外观和接口如图：
特性：
参考板是 iMX6ULL EVK ：https://www.nxp.com/design/development-boards/i-mx-evaluation-and-development-boards/evaluation-kit-for-the-i-mx-6ull-and-6ulz-applications-processor:MCIMX6ULL-EVK 芯片是 NXP 的 iMX6ULL : https://www.nxp.com/products/processors-and-microcontrollers/arm-processors/i-mx-applications-processors/i-mx-6-processors:IMX6X_SERIES 软件使用最新的 Linux 5.4.47_2.2.0 : https://www.nxp.com/design/software/embedded-software/i-mx-software/embedded-linux-for-i-mx-applications-processors:IMXLINUX 2. 构建系统 我们先为这个板卡编译一个可以运行的系统。
2.1. 准备宿主机 使用 Ubuntu 20.04 （至少要用 18.04 ，低版本系统会遇到很多问题），安装必要的开发包：
$ sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib \ build-essential chrpath socat cpio python python3 python3-pip python3-pexpect \ xz-utils debianutils iputils-ping python3-git python3-jinja2 libegl1-mesa libsdl1.2-dev \ pylint3 xterm 安装 repo :</description></item><item><title>使用 Docker 学习 Redis</title><link>https://shaocheng.li/posts/2020/09/01/</link><pubDate>Tue, 01 Sep 2020 09:53:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/09/01/</guid><description># 1. 安装 Docker 的安装比较简单，访问 ，按照指引安装相应系统的版本即可。安装完毕后，我们先拉取 Redis 的镜像：
$ docker pull redis 这个命令默认是拉取 Redis 官方的 Docker 镜像最新版，也可以在后面指定具体的版本：
$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE docker101tutorial latest 8e9d20f8bd52 38 hours ago 27.3MB nginx alpine 6f715d38cfe0 2 weeks ago 22.1MB nginx latest 4bb46517cac3 2 weeks ago 133MB python alpine 44fceb565b2a 2 weeks ago 42.7MB redis latest 1319b1eaa0b7 3 weeks ago 104MB node 12-alpine 18f4bc975732 4 weeks ago 89.3MB 然后启动这个进行容器:</description></item><item><title>epoll 学习笔记</title><link>https://shaocheng.li/posts/2020/08/30/</link><pubDate>Sun, 30 Aug 2020 11:53:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/08/30/</guid><description>1. 工作原理 epoll 是 Linux 独有的 I/O 多路复用机制，核心概念就是 epoll 实例，它是一个内核里的数据结构，从用户角度来看它可以简单的看做包含了两个队列：
interest list（或者叫epoll set），用户注册的感兴趣的描述符集合。 ready list，就绪的描述符集合，当有 I/O 就绪时，内核会自动将就绪的描述符加到 ready list 中。 在用户端的工作流程就是：
向 interest list 注册感兴趣的文件描述符的 I/O 事件。 等待已注册的文件描述符就绪。 处理所有已经就绪的文件描述符。 2. 使用方法 使用 epoll 时，需要包括头文件：
#include &amp;lt;sys/epoll.h&amp;gt; 2.1 新建一个 epoll 实例 int epoll_create(int size); epoll_create() 函数会新建一个 epoll 实例，然后返回一个文件描述符，作为 epoll 操作的句柄。从 Linux 2.6.8 开始， 参数 size 可以忽略，但是必须大于 0 。当不在需要这个描述符时，应该调用 close() 函数将其关闭。
调用失败时，会返回一个负数。
2.2 操作 epoll 实例 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 这是操作 epoll 实例的接口函数，用于添加、删除和修改 interest list 中监控的文件描述符。如果调用成功，会返回 0 ，如果失败，会返回一个负数，并设置 errno 。参数的含义：</description></item><item><title>uthash 学习笔记</title><link>https://shaocheng.li/posts/2020/08/29/</link><pubDate>Sat, 29 Aug 2020 11:23:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/08/29/</guid><description>uthash 是一个 C 语言的哈希表函数库，支持哈希表的各种操作，包括添加，删除，查找，排序等。你可以在 github 上下载到它的源码：
源码：https://github.com/troydhanson/uthash 文档：https://troydhanson.github.io/uthash/userguide.html 这个函数库在使用时只需要包含 uthash.h 头文件即可，没有二进制的库文件。
1. 数据结构 uthash 的哈希表是由多个结构体组成的双向链表实现的，一个结构体就是一个键值对，例如：
#include &amp;#34;uthash.h&amp;#34; struct my_struct { int id; /* key */ char name[10]; UT_hash_handle hh; /* makes this structure hashable */ }; id 就是键（key），名称和数据类型没有限制； name 就是值（value），也可以是任何数据类型； hh 是内部使用的 hash 处理句柄，UT_hash_handle 字段必须存在于你的结构中。它用于内部记录，使哈希表正常工作，它不需要初始化。可以被命名为任何标识符； 哈希句柄在 32 位系统中每个元素消耗约 32 个字节，在 64 位系统中每个元素消耗 56 个字节。其他的开销成本&amp;ndash;桶和表&amp;ndash;相比之下可以忽略不计。你可以使用 HASH_OVERHEAD 来获取哈希表的开销大小，单位是字节。
2. 基本操作 完整的例子可以在源码下的 tests/exapmle.c 文件中找到，可以执行 make example 进行编译。
2.1 声明 定义一个结构体类型的空指针，即声明了一个哈希表：</description></item><item><title>libubox 学习笔记</title><link>https://shaocheng.li/posts/2020/07/16/</link><pubDate>Thu, 16 Jul 2020 21:23:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/07/16/</guid><description>编译安装 首先要安装一些依赖的软件：
apt-get install pkg-config apt-get install lua5.1 apt-get install liblua5.1-dev apt-get install cmake apt-get install libjson-c-dev 然后要编译安装 libubox ：
git clone https://git.openwrt.org/project/libubox.git cd libubox cmake . make make install ulog 头文件 ulog.h 提供了打印日志的方法。使用时，先调用 ulog_open() 函数初始化一些 ulog 需要的变量：
void ulog_open(int channels, int facility, const char *ident); channels 用于设置日志消息的输出目标，取值：
ULOG_KMSG，内核日志，输出到了 /dev/kmsg 文件。 ULOG_SYSLOG，系统日志，调用了 vsyslog() 产生系统日志。 ULOG_STDIO，标准输出，输出到了 stderr 。 facility 用于设置记录日志的程序的类型，只有当 channels 的值为 ULOG_SYSLOG 时，这个参数有效。取值与 openlog() 的第三个参数一致，它们是定义在 &amp;lt;syslog.h&amp;gt; 中的宏：</description></item><item><title>CMake 学习笔记</title><link>https://shaocheng.li/posts/2020/06/29/</link><pubDate>Mon, 29 Jun 2020 22:25:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/06/29/</guid><description>本教程提供了一个渐进式的指导，参考的是官方教程 CMake Tutorial ，然后加入学习过程的笔记。涵盖了使用 CMake 构建一个工程时经常遇到的问题 。通过一个示例项目，展示各种功能是如何一起工作的，这对理解 CMake 非常有用。
1. 最简单的工程 最简单工程是从源码文件直接编译生成一个可执行的问题，最简单的解决方案只需要在 CMakeLists.txt 文件中添加三行。
新建一个工程目录，在目录下新建一个源文件 Tutorial.c ：
#include &amp;lt;stdio.h&amp;gt; int main (int argc, char *argv[]) { printf(&amp;#34;Hello World!\n&amp;#34;); return 0; } 新建一个 CMakeLists.txt ：
cmake_minimum_required(VERSION 3.1)project(Tutorial)add_executable(Tutorial Tutorial.c) CMakeLists.txt 是 cmake 生成 Makefile 所依赖的描述性文件，文件内容由一行一行的命令组成，命令不区分大小写。
cmake_minimum_required 表示该项目对 CMake 的最低版本要求。 project 用于设置项目名称。 add_executable 添加了一个生成的可执行文件，和依赖的源码。 这样的话，执行 cmake . 生成 Makefile ，再执行 make 开始编译，就可以使用 Tutorial.c 生成的可执行文件 Tutorial 。
cmake 执行过程中会生成大量的缓存文件，又没有提供类似 cmake clean 的命令来清除生成的文件，有一个简单的方法可以解决这个问题。在工程目录下新建一个名为 build 的子目录，进入这个子目录中执行 cmake .</description></item><item><title>tcpdump 使用笔记</title><link>https://shaocheng.li/posts/2020/04/12/</link><pubDate>Sun, 12 Apr 2020 22:25:11 +0800</pubDate><guid>https://shaocheng.li/posts/2020/04/12/</guid><description>tcpdump 是一个帮助用户捕获、筛选和解析 TCP/IP 协议数据包的命令行工具。
1. 基本用法 下面展示了 tcpdump 的常用的选项：
:~$ tcpdump -nn -s0 -v -i en0 port 80 -i ：指定需要监听的网卡，可以是物理网卡，也可以是虚拟网卡。途径该网卡的数据包都会被捕获，然后用过滤器的规则进行筛选。如果没有指定，默认会监听本机的所有网卡。 port ：这是一个过滤器规则，表示只显示使用该端口收发的数据。 -nn ：默认情况下，tcpdump 会将 ip 和端口号解析为字符串的形式，例如 80 端口会显示为 http 。可以用 -n 表示不解析主机名，-nn 表示不解析主机名和端口号，这样可以加快速度，也方便查看。 -s0 ：设置要捕获的数据包的大小，s0 表示不限制大小。 -v ：表示粗略显示数据包的内容，-vv 可以增加显示数据包的细节。 1.1 显示控制 使用 -A 选项可以将数据包的内容以 ASCII 字符形式显示，方便阅读，另一个选项 -X 可以让数据包的内容同时以 16 进制和 ASCII 字符形式显示，例如：
:~$ tcpdump -nn -s0 -v -i en0 port 80 -X tcpdump: listening on en0, link-type EN10MB (Ethernet), capture size 262144 bytes 08:51:01.</description></item></channel></rss>